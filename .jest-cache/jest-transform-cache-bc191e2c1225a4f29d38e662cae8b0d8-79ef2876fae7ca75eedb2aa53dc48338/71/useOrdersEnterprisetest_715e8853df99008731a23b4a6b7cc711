9cff16bec85e5ae8c3105b2b468bd304
// ===================================
// PINTEYA E-COMMERCE - USE ORDERS ENTERPRISE HOOK TESTS
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useOrdersEnterprise = require("../../hooks/useOrdersEnterprise");
const _ordersmocks = require("../setup/orders-mocks.js");
// ===================================
// SETUP MOCKS
// ===================================
const mockFetch = (0, _ordersmocks.createMockFetch)();
global.fetch = mockFetch;
// ===================================
// TESTS BÁSICOS useOrdersEnterprise
// ===================================
describe('useOrdersEnterprise', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should initialize with default state', async ()=>{
        // Arrange & Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Assert initial state
        expect(result.current.orders).toEqual([]);
        expect(result.current.loading).toBe(true);
        expect(result.current.error).toBe(null);
        expect(result.current.filters).toEqual({
            page: 1,
            limit: 20,
            sort_by: 'created_at',
            sort_order: 'desc'
        });
    });
    test('should fetch orders on mount', async ()=>{
        // Arrange & Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/api/admin/orders'));
        expect(result.current.orders).toEqual(_ordersmocks.mockOrders);
        expect(result.current.error).toBe(null);
    });
    test('should handle fetch errors', async ()=>{
        // Arrange
        mockFetch.mockImplementationOnce(()=>Promise.resolve({
                ok: false,
                status: 500,
                json: ()=>Promise.resolve({
                        error: 'Server error'
                    })
            }));
        // Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert
        expect(result.current.error).toBe('Error al cargar órdenes');
        expect(result.current.orders).toEqual([]);
    });
    test('should accept initial filters', async ()=>{
        // Arrange
        const initialFilters = {
            status: 'pending',
            page: 2,
            limit: 10
        };
        // Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)(initialFilters));
        // Assert
        expect(result.current.filters).toEqual({
            page: 2,
            limit: 10,
            sort_by: 'created_at',
            sort_order: 'desc',
            status: 'pending'
        });
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('status=pending'));
        });
    });
});
// ===================================
// TESTS DE FILTROS
// ===================================
describe('useOrdersEnterprise - Filters', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should update search filter', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setSearch('test search');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('search=test'));
    });
    test('should update status filter', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setStatus('pending');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('status=pending'));
    });
    test('should update payment status filter', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setPaymentStatus('paid');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('payment_status=paid'));
    });
    test('should update sorting', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setSorting('total_amount', 'asc');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('sort_by=total_amount'));
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('sort_order=asc'));
    });
    test('should update date range', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setDateRange('2024-01-01', '2024-01-31');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('date_from=2024-01-01'));
    });
    test('should clear all filters', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)({
                status: 'pending',
                search: 'test',
                page: 3
            }));
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.clearFilters();
        });
        // Assert - Verificar que se llamó a fetch con filtros limpiados
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/api/admin/orders'));
    });
});
// ===================================
// TESTS DE PAGINACIÓN
// ===================================
describe('useOrdersEnterprise - Pagination', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should handle page changes', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setPage(2);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('page=2'));
    });
    test('should provide pagination helpers', async ()=>{
        // Arrange
        mockFetch.mockImplementationOnce(()=>Promise.resolve({
                ok: true,
                status: 200,
                json: ()=>Promise.resolve({
                        data: {
                            orders: _ordersmocks.mockOrders,
                            pagination: {
                                page: 2,
                                limit: 20,
                                total: 50,
                                totalPages: 3,
                                hasNextPage: true,
                                hasPreviousPage: true
                            },
                            filters: {}
                        },
                        success: true,
                        error: null
                    })
            }));
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert pagination helpers
        expect(result.current.hasNextPage).toBe(true);
        expect(result.current.hasPreviousPage).toBe(true);
        expect(result.current.totalOrders).toBe(50);
        expect(result.current.currentPage).toBe(2);
        expect(result.current.totalPages).toBe(3);
    });
});
// ===================================
// TESTS DE OPERACIONES CRUD
// ===================================
describe('useOrdersEnterprise - CRUD Operations', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should create order', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const orderData = {
            user_id: 'test-user-id',
            items: [
                {
                    product_id: 1,
                    quantity: 1,
                    unit_price: 15000
                }
            ]
        };
        // Act
        let createdOrder;
        await (0, _react.act)(async ()=>{
            createdOrder = await result.current.createOrder(orderData);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders', expect.objectContaining({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(orderData)
        }));
        expect(createdOrder).toBeDefined();
    });
    test('should update order', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const updateData = {
            notes: 'Updated notes'
        };
        // Act
        let updatedOrder;
        await (0, _react.act)(async ()=>{
            updatedOrder = await result.current.updateOrder('order-1', updateData);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/order-1', expect.objectContaining({
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateData)
        }));
        expect(updatedOrder).toBeDefined();
    });
    test('should change order status', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            await result.current.changeOrderStatus('order-1', 'confirmed', 'Payment confirmed');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/order-1/status', expect.objectContaining({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                status: 'confirmed',
                reason: 'Payment confirmed'
            })
        }));
    });
    test('should handle bulk status update', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const bulkData = {
            order_ids: [
                'order-1',
                'order-2'
            ],
            status: 'confirmed',
            reason: 'Bulk confirmation'
        };
        // Act
        let bulkResult;
        await (0, _react.act)(async ()=>{
            bulkResult = await result.current.bulkUpdateStatus(bulkData);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/bulk?operation=status_update', expect.objectContaining({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(bulkData)
        }));
        expect(bulkResult).toBeDefined();
    });
    test('should export orders', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        let exportResult;
        await (0, _react.act)(async ()=>{
            exportResult = await result.current.exportOrders('csv');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/bulk?operation=export', expect.objectContaining({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                format: 'csv',
                filters: result.current.filters,
                include_items: true
            })
        }));
        expect(exportResult).toBeDefined();
    });
});
// ===================================
// TESTS DE UTILIDADES
// ===================================
describe('useOrdersEnterprise - Utilities', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should get order by id', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        const order = result.current.getOrderById('order-1');
        // Assert
        expect(order).toEqual(_ordersmocks.mockOrders[0]);
    });
    test('should get orders by status', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        const pendingOrders = result.current.getOrdersByStatus('pending');
        // Assert
        expect(pendingOrders).toEqual(_ordersmocks.mockOrders.filter((order)=>order.status === 'pending'));
    });
    test('should calculate total revenue', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        const totalRevenue = result.current.getTotalRevenue();
        // Assert
        const expectedRevenue = _ordersmocks.mockOrders.filter((order)=>order.status !== 'cancelled').reduce((sum, order)=>sum + order.total_amount, 0);
        expect(totalRevenue).toBe(expectedRevenue);
    });
    test('should calculate average order value', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        const avgOrderValue = result.current.getAverageOrderValue();
        // Assert
        const validOrders = _ordersmocks.mockOrders.filter((order)=>order.status !== 'cancelled');
        const expectedAvg = validOrders.reduce((sum, order)=>sum + order.total_amount, 0) / validOrders.length;
        expect(avgOrderValue).toBe(expectedAvg);
    });
    test('should refresh data', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const initialCallCount = mockFetch.mock.calls.length;
        // Act
        await (0, _react.act)(async ()=>{
            result.current.refresh();
        });
        // Assert
        expect(mockFetch.mock.calls.length).toBe(initialCallCount + 1);
    });
});
// ===================================
// TESTS useOrderDetail
// ===================================
describe('useOrderDetail', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should fetch order detail', async ()=>{
        // Arrange
        mockFetch.mockImplementationOnce(()=>Promise.resolve({
                ok: true,
                status: 200,
                json: ()=>Promise.resolve({
                        data: {
                            order: _ordersmocks.mockOrders[0],
                            statusHistory: [],
                            notes: []
                        },
                        success: true,
                        error: null
                    })
            }));
        // Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrderDetail)('order-1'));
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/order-1');
        expect(result.current.order).toEqual(_ordersmocks.mockOrders[0]);
        expect(result.current.error).toBe(null);
    });
    test('should handle fetch error', async ()=>{
        // Arrange
        mockFetch.mockImplementationOnce(()=>Promise.resolve({
                ok: false,
                status: 404,
                json: ()=>Promise.resolve({
                        error: 'Order not found'
                    })
            }));
        // Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrderDetail)('order-1'));
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert
        expect(result.current.error).toBe('Order not found');
        expect(result.current.order).toBe(null);
    });
    test('should not fetch if no orderId provided', async ()=>{
        // Arrange & Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrderDetail)(''));
        // Wait a bit to ensure no fetch is made
        await new Promise((resolve)=>setTimeout(resolve, 100));
        // Assert
        expect(mockFetch).not.toHaveBeenCalled();
        expect(result.current.loading).toBe(true);
    });
    test('should refresh order detail', async ()=>{
        // Arrange
        mockFetch.mockImplementation(()=>Promise.resolve({
                ok: true,
                status: 200,
                json: ()=>Promise.resolve({
                        data: {
                            order: _ordersmocks.mockOrders[0],
                            statusHistory: [],
                            notes: []
                        },
                        success: true,
                        error: null
                    })
            }));
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrderDetail)('order-1'));
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const initialCallCount = mockFetch.mock.calls.length;
        // Act
        await (0, _react.act)(async ()=>{
            result.current.refresh();
        });
        // Assert
        expect(mockFetch.mock.calls.length).toBe(initialCallCount + 1);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlT3JkZXJzRW50ZXJwcmlzZS50ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBJTlRFWUEgRS1DT01NRVJDRSAtIFVTRSBPUkRFUlMgRU5URVJQUklTRSBIT09LIFRFU1RTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbXBvcnQgeyByZW5kZXJIb29rLCBhY3QsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcclxuaW1wb3J0IHsgdXNlT3JkZXJzRW50ZXJwcmlzZSwgdXNlT3JkZXJEZXRhaWwgfSBmcm9tICdAL2hvb2tzL3VzZU9yZGVyc0VudGVycHJpc2UnO1xyXG5pbXBvcnQgeyBcclxuICBtb2NrT3JkZXJzLCBcclxuICBjcmVhdGVNb2NrRmV0Y2gsIFxyXG4gIHJlc2V0QWxsTW9ja3MgXHJcbn0gZnJvbSAnLi4vc2V0dXAvb3JkZXJzLW1vY2tzJztcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFNFVFVQIE1PQ0tTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5jb25zdCBtb2NrRmV0Y2ggPSBjcmVhdGVNb2NrRmV0Y2goKTtcclxuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgQsOBU0lDT1MgdXNlT3JkZXJzRW50ZXJwcmlzZVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICByZXNldEFsbE1vY2tzKCk7XHJcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBpbml0aWFsaXplIHdpdGggZGVmYXVsdCBzdGF0ZScsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2UgJiBBY3RcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyc0VudGVycHJpc2UoKSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0IGluaXRpYWwgc3RhdGVcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5vcmRlcnMpLnRvRXF1YWwoW10pO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUodHJ1ZSk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmUobnVsbCk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZmlsdGVycykudG9FcXVhbCh7XHJcbiAgICAgIHBhZ2U6IDEsXHJcbiAgICAgIGxpbWl0OiAyMCxcclxuICAgICAgc29ydF9ieTogJ2NyZWF0ZWRfYXQnLFxyXG4gICAgICBzb3J0X29yZGVyOiAnZGVzYydcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgZmV0Y2ggb3JkZXJzIG9uIG1vdW50JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZSAmIEFjdFxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBmZXRjaCB0byBjb21wbGV0ZVxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCcvYXBpL2FkbWluL29yZGVycycpXHJcbiAgICApO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lm9yZGVycykudG9FcXVhbChtb2NrT3JkZXJzKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZShudWxsKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIGhhbmRsZSBmZXRjaCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiBcclxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICBvazogZmFsc2UsXHJcbiAgICAgICAgc3RhdHVzOiA1MDAsXHJcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZXJyb3I6ICdTZXJ2ZXIgZXJyb3InIH0pXHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBmZXRjaCB0byBjb21wbGV0ZVxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlKCdFcnJvciBhbCBjYXJnYXIgw7NyZGVuZXMnKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5vcmRlcnMpLnRvRXF1YWwoW10pO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgYWNjZXB0IGluaXRpYWwgZmlsdGVycycsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2VcclxuICAgIGNvbnN0IGluaXRpYWxGaWx0ZXJzID0ge1xyXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcclxuICAgICAgcGFnZTogMixcclxuICAgICAgbGltaXQ6IDEwXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZShpbml0aWFsRmlsdGVycykpO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmZpbHRlcnMpLnRvRXF1YWwoe1xyXG4gICAgICBwYWdlOiAyLFxyXG4gICAgICBsaW1pdDogMTAsXHJcbiAgICAgIHNvcnRfYnk6ICdjcmVhdGVkX2F0JyxcclxuICAgICAgc29ydF9vcmRlcjogJ2Rlc2MnLFxyXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJ1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgZmV0Y2ggdG8gY29tcGxldGVcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnc3RhdHVzPXBlbmRpbmcnKVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgRklMVFJPU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UgLSBGaWx0ZXJzJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgcmVzZXRBbGxNb2NrcygpO1xyXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgdXBkYXRlIHNlYXJjaCBmaWx0ZXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNldFNlYXJjaCgndGVzdCBzZWFyY2gnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdzZWFyY2g9dGVzdCcpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgdXBkYXRlIHN0YXR1cyBmaWx0ZXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNldFN0YXR1cygncGVuZGluZycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ3N0YXR1cz1wZW5kaW5nJylcclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCB1cGRhdGUgcGF5bWVudCBzdGF0dXMgZmlsdGVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBpbml0aWFsIGZldGNoXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWN0XHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZXN1bHQuY3VycmVudC5zZXRQYXltZW50U3RhdHVzKCdwYWlkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygncGF5bWVudF9zdGF0dXM9cGFpZCcpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgdXBkYXRlIHNvcnRpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNldFNvcnRpbmcoJ3RvdGFsX2Ftb3VudCcsICdhc2MnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdzb3J0X2J5PXRvdGFsX2Ftb3VudCcpXHJcbiAgICApO1xyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdzb3J0X29yZGVyPWFzYycpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgdXBkYXRlIGRhdGUgcmFuZ2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNldERhdGVSYW5nZSgnMjAyNC0wMS0wMScsICcyMDI0LTAxLTMxJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnZGF0ZV9mcm9tPTIwMjQtMDEtMDEnKVxyXG4gICAgKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIGNsZWFyIGFsbCBmaWx0ZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSh7XHJcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxyXG4gICAgICBzZWFyY2g6ICd0ZXN0JyxcclxuICAgICAgcGFnZTogM1xyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LmNsZWFyRmlsdGVycygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0IC0gVmVyaWZpY2FyIHF1ZSBzZSBsbGFtw7MgYSBmZXRjaCBjb24gZmlsdHJvcyBsaW1waWFkb3NcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnL2FwaS9hZG1pbi9vcmRlcnMnKVxyXG4gICAgKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBQQUdJTkFDScOTTlxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UgLSBQYWdpbmF0aW9uJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgcmVzZXRBbGxNb2NrcygpO1xyXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgaGFuZGxlIHBhZ2UgY2hhbmdlcycsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2VcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyc0VudGVycHJpc2UoKSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBmZXRjaFxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgcmVzdWx0LmN1cnJlbnQuc2V0UGFnZSgyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdwYWdlPTInKVxyXG4gICAgKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIHByb3ZpZGUgcGFnaW5hdGlvbiBoZWxwZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4gXHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgb3JkZXJzOiBtb2NrT3JkZXJzLFxyXG4gICAgICAgICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgcGFnZTogMixcclxuICAgICAgICAgICAgICBsaW1pdDogMjAsXHJcbiAgICAgICAgICAgICAgdG90YWw6IDUwLFxyXG4gICAgICAgICAgICAgIHRvdGFsUGFnZXM6IDMsXHJcbiAgICAgICAgICAgICAgaGFzTmV4dFBhZ2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgaGFzUHJldmlvdXNQYWdlOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZpbHRlcnM6IHt9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgIGVycm9yOiBudWxsXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBmZXRjaCB0byBjb21wbGV0ZVxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydCBwYWdpbmF0aW9uIGhlbHBlcnNcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNOZXh0UGFnZSkudG9CZSh0cnVlKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNQcmV2aW91c1BhZ2UpLnRvQmUodHJ1ZSk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQudG90YWxPcmRlcnMpLnRvQmUoNTApO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmN1cnJlbnRQYWdlKS50b0JlKDIpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnRvdGFsUGFnZXMpLnRvQmUoMyk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgT1BFUkFDSU9ORVMgQ1JVRFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UgLSBDUlVEIE9wZXJhdGlvbnMnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICByZXNldEFsbE1vY2tzKCk7XHJcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBjcmVhdGUgb3JkZXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBvcmRlckRhdGEgPSB7XHJcbiAgICAgIHVzZXJfaWQ6ICd0ZXN0LXVzZXItaWQnLFxyXG4gICAgICBpdGVtczogW3sgcHJvZHVjdF9pZDogMSwgcXVhbnRpdHk6IDEsIHVuaXRfcHJpY2U6IDE1MDAwIH1dXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgbGV0IGNyZWF0ZWRPcmRlcjtcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNyZWF0ZWRPcmRlciA9IGF3YWl0IHJlc3VsdC5jdXJyZW50LmNyZWF0ZU9yZGVyKG9yZGVyRGF0YSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAnL2FwaS9hZG1pbi9vcmRlcnMnLFxyXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkob3JkZXJEYXRhKVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICAgIGV4cGVjdChjcmVhdGVkT3JkZXIpLnRvQmVEZWZpbmVkKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCB1cGRhdGUgb3JkZXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0geyBub3RlczogJ1VwZGF0ZWQgbm90ZXMnIH07XHJcblxyXG4gICAgLy8gQWN0XHJcbiAgICBsZXQgdXBkYXRlZE9yZGVyO1xyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgdXBkYXRlZE9yZGVyID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQudXBkYXRlT3JkZXIoJ29yZGVyLTEnLCB1cGRhdGVEYXRhKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICcvYXBpL2FkbWluL29yZGVycy9vcmRlci0xJyxcclxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xyXG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICAgIGV4cGVjdCh1cGRhdGVkT3JkZXIpLnRvQmVEZWZpbmVkKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBjaGFuZ2Ugb3JkZXIgc3RhdHVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBpbml0aWFsIGZldGNoXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWN0XHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5jaGFuZ2VPcmRlclN0YXR1cygnb3JkZXItMScsICdjb25maXJtZWQnLCAnUGF5bWVudCBjb25maXJtZWQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICcvYXBpL2FkbWluL29yZGVycy9vcmRlci0xL3N0YXR1cycsXHJcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBzdGF0dXM6ICdjb25maXJtZWQnLFxyXG4gICAgICAgICAgcmVhc29uOiAnUGF5bWVudCBjb25maXJtZWQnXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBoYW5kbGUgYnVsayBzdGF0dXMgdXBkYXRlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBpbml0aWFsIGZldGNoXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgYnVsa0RhdGEgPSB7XHJcbiAgICAgIG9yZGVyX2lkczogWydvcmRlci0xJywgJ29yZGVyLTInXSxcclxuICAgICAgc3RhdHVzOiAnY29uZmlybWVkJyxcclxuICAgICAgcmVhc29uOiAnQnVsayBjb25maXJtYXRpb24nXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgbGV0IGJ1bGtSZXN1bHQ7XHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBidWxrUmVzdWx0ID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQuYnVsa1VwZGF0ZVN0YXR1cyhidWxrRGF0YSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAnL2FwaS9hZG1pbi9vcmRlcnMvYnVsaz9vcGVyYXRpb249c3RhdHVzX3VwZGF0ZScsXHJcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShidWxrRGF0YSlcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgICBleHBlY3QoYnVsa1Jlc3VsdCkudG9CZURlZmluZWQoKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIGV4cG9ydCBvcmRlcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGxldCBleHBvcnRSZXN1bHQ7XHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBleHBvcnRSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5leHBvcnRPcmRlcnMoJ2NzdicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgJy9hcGkvYWRtaW4vb3JkZXJzL2J1bGs/b3BlcmF0aW9uPWV4cG9ydCcsXHJcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBmb3JtYXQ6ICdjc3YnLFxyXG4gICAgICAgICAgZmlsdGVyczogcmVzdWx0LmN1cnJlbnQuZmlsdGVycyxcclxuICAgICAgICAgIGluY2x1ZGVfaXRlbXM6IHRydWVcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICAgIGV4cGVjdChleHBvcnRSZXN1bHQpLnRvQmVEZWZpbmVkKCk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgVVRJTElEQURFU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UgLSBVdGlsaXRpZXMnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICByZXNldEFsbE1vY2tzKCk7XHJcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBnZXQgb3JkZXIgYnkgaWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGNvbnN0IG9yZGVyID0gcmVzdWx0LmN1cnJlbnQuZ2V0T3JkZXJCeUlkKCdvcmRlci0xJyk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3Qob3JkZXIpLnRvRXF1YWwobW9ja09yZGVyc1swXSk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBnZXQgb3JkZXJzIGJ5IHN0YXR1cycsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2VcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyc0VudGVycHJpc2UoKSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBmZXRjaFxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgY29uc3QgcGVuZGluZ09yZGVycyA9IHJlc3VsdC5jdXJyZW50LmdldE9yZGVyc0J5U3RhdHVzKCdwZW5kaW5nJyk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QocGVuZGluZ09yZGVycykudG9FcXVhbChcclxuICAgICAgbW9ja09yZGVycy5maWx0ZXIob3JkZXIgPT4gb3JkZXIuc3RhdHVzID09PSAncGVuZGluZycpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgY2FsY3VsYXRlIHRvdGFsIHJldmVudWUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGNvbnN0IHRvdGFsUmV2ZW51ZSA9IHJlc3VsdC5jdXJyZW50LmdldFRvdGFsUmV2ZW51ZSgpO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgY29uc3QgZXhwZWN0ZWRSZXZlbnVlID0gbW9ja09yZGVyc1xyXG4gICAgICAuZmlsdGVyKG9yZGVyID0+IG9yZGVyLnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpXHJcbiAgICAgIC5yZWR1Y2UoKHN1bSwgb3JkZXIpID0+IHN1bSArIG9yZGVyLnRvdGFsX2Ftb3VudCwgMCk7XHJcbiAgICBleHBlY3QodG90YWxSZXZlbnVlKS50b0JlKGV4cGVjdGVkUmV2ZW51ZSk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBjYWxjdWxhdGUgYXZlcmFnZSBvcmRlciB2YWx1ZScsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2VcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyc0VudGVycHJpc2UoKSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBmZXRjaFxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgY29uc3QgYXZnT3JkZXJWYWx1ZSA9IHJlc3VsdC5jdXJyZW50LmdldEF2ZXJhZ2VPcmRlclZhbHVlKCk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBjb25zdCB2YWxpZE9yZGVycyA9IG1vY2tPcmRlcnMuZmlsdGVyKG9yZGVyID0+IG9yZGVyLnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRBdmcgPSB2YWxpZE9yZGVycy5yZWR1Y2UoKHN1bSwgb3JkZXIpID0+IHN1bSArIG9yZGVyLnRvdGFsX2Ftb3VudCwgMCkgLyB2YWxpZE9yZGVycy5sZW5ndGg7XHJcbiAgICBleHBlY3QoYXZnT3JkZXJWYWx1ZSkudG9CZShleHBlY3RlZEF2Zyk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCByZWZyZXNoIGRhdGEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsQ2FsbENvdW50ID0gbW9ja0ZldGNoLm1vY2suY2FsbHMubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgcmVzdWx0LmN1cnJlbnQucmVmcmVzaCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoLm1vY2suY2FsbHMubGVuZ3RoKS50b0JlKGluaXRpYWxDYWxsQ291bnQgKyAxKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyB1c2VPcmRlckRldGFpbFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyRGV0YWlsJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgcmVzZXRBbGxNb2NrcygpO1xyXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgZmV0Y2ggb3JkZXIgZGV0YWlsJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4gXHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgb3JkZXI6IG1vY2tPcmRlcnNbMF0sXHJcbiAgICAgICAgICAgIHN0YXR1c0hpc3Rvcnk6IFtdLFxyXG4gICAgICAgICAgICBub3RlczogW11cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyRGV0YWlsKCdvcmRlci0xJykpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGZldGNoIHRvIGNvbXBsZXRlXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9hZG1pbi9vcmRlcnMvb3JkZXItMScpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lm9yZGVyKS50b0VxdWFsKG1vY2tPcmRlcnNbMF0pO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlKG51bGwpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgaGFuZGxlIGZldGNoIGVycm9yJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4gXHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgb2s6IGZhbHNlLFxyXG4gICAgICAgIHN0YXR1czogNDA0LFxyXG4gICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IGVycm9yOiAnT3JkZXIgbm90IGZvdW5kJyB9KVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyRGV0YWlsKCdvcmRlci0xJykpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGZldGNoIHRvIGNvbXBsZXRlXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmUoJ09yZGVyIG5vdCBmb3VuZCcpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lm9yZGVyKS50b0JlKG51bGwpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgbm90IGZldGNoIGlmIG5vIG9yZGVySWQgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlICYgQWN0XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlckRldGFpbCgnJykpO1xyXG5cclxuICAgIC8vIFdhaXQgYSBiaXQgdG8gZW5zdXJlIG5vIGZldGNoIGlzIG1hZGVcclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZSh0cnVlKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIHJlZnJlc2ggb3JkZXIgZGV0YWlsJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBcclxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICBvcmRlcjogbW9ja09yZGVyc1swXSxcclxuICAgICAgICAgICAgc3RhdHVzSGlzdG9yeTogW10sXHJcbiAgICAgICAgICAgIG5vdGVzOiBbXVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICBlcnJvcjogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyRGV0YWlsKCdvcmRlci0xJykpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsQ2FsbENvdW50ID0gbW9ja0ZldGNoLm1vY2suY2FsbHMubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgcmVzdWx0LmN1cnJlbnQucmVmcmVzaCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoLm1vY2suY2FsbHMubGVuZ3RoKS50b0JlKGluaXRpYWxDYWxsQ291bnQgKyAxKTtcclxuICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJtb2NrRmV0Y2giLCJjcmVhdGVNb2NrRmV0Y2giLCJnbG9iYWwiLCJmZXRjaCIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsInJlc2V0QWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJ0ZXN0IiwicmVzdWx0IiwicmVuZGVySG9vayIsInVzZU9yZGVyc0VudGVycHJpc2UiLCJleHBlY3QiLCJjdXJyZW50Iiwib3JkZXJzIiwidG9FcXVhbCIsImxvYWRpbmciLCJ0b0JlIiwiZXJyb3IiLCJmaWx0ZXJzIiwicGFnZSIsImxpbWl0Iiwic29ydF9ieSIsInNvcnRfb3JkZXIiLCJ3YWl0Rm9yIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJzdHJpbmdDb250YWluaW5nIiwibW9ja09yZGVycyIsIm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9rIiwic3RhdHVzIiwianNvbiIsImluaXRpYWxGaWx0ZXJzIiwiYWN0Iiwic2V0U2VhcmNoIiwic2V0U3RhdHVzIiwic2V0UGF5bWVudFN0YXR1cyIsInNldFNvcnRpbmciLCJzZXREYXRlUmFuZ2UiLCJzZWFyY2giLCJjbGVhckZpbHRlcnMiLCJzZXRQYWdlIiwiZGF0YSIsInBhZ2luYXRpb24iLCJ0b3RhbCIsInRvdGFsUGFnZXMiLCJoYXNOZXh0UGFnZSIsImhhc1ByZXZpb3VzUGFnZSIsInN1Y2Nlc3MiLCJ0b3RhbE9yZGVycyIsImN1cnJlbnRQYWdlIiwib3JkZXJEYXRhIiwidXNlcl9pZCIsIml0ZW1zIiwicHJvZHVjdF9pZCIsInF1YW50aXR5IiwidW5pdF9wcmljZSIsImNyZWF0ZWRPcmRlciIsImNyZWF0ZU9yZGVyIiwib2JqZWN0Q29udGFpbmluZyIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInRvQmVEZWZpbmVkIiwidXBkYXRlRGF0YSIsIm5vdGVzIiwidXBkYXRlZE9yZGVyIiwidXBkYXRlT3JkZXIiLCJjaGFuZ2VPcmRlclN0YXR1cyIsInJlYXNvbiIsImJ1bGtEYXRhIiwib3JkZXJfaWRzIiwiYnVsa1Jlc3VsdCIsImJ1bGtVcGRhdGVTdGF0dXMiLCJleHBvcnRSZXN1bHQiLCJleHBvcnRPcmRlcnMiLCJmb3JtYXQiLCJpbmNsdWRlX2l0ZW1zIiwib3JkZXIiLCJnZXRPcmRlckJ5SWQiLCJwZW5kaW5nT3JkZXJzIiwiZ2V0T3JkZXJzQnlTdGF0dXMiLCJmaWx0ZXIiLCJ0b3RhbFJldmVudWUiLCJnZXRUb3RhbFJldmVudWUiLCJleHBlY3RlZFJldmVudWUiLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbF9hbW91bnQiLCJhdmdPcmRlclZhbHVlIiwiZ2V0QXZlcmFnZU9yZGVyVmFsdWUiLCJ2YWxpZE9yZGVycyIsImV4cGVjdGVkQXZnIiwibGVuZ3RoIiwiaW5pdGlhbENhbGxDb3VudCIsIm1vY2siLCJjYWxscyIsInJlZnJlc2giLCJzdGF0dXNIaXN0b3J5IiwidXNlT3JkZXJEZXRhaWwiLCJzZXRUaW1lb3V0Iiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsIm1vY2tJbXBsZW1lbnRhdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLHdEQUF3RDtBQUN4RCxzQ0FBc0M7Ozs7O3VCQUVHO3FDQUNXOzZCQUs3QztBQUVQLHNDQUFzQztBQUN0QyxjQUFjO0FBQ2Qsc0NBQXNDO0FBRXRDLE1BQU1BLFlBQVlDLElBQUFBLDRCQUFlO0FBQ2pDQyxPQUFPQyxLQUFLLEdBQUdIO0FBRWYsc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFFdENJLFNBQVMsdUJBQXVCO0lBQzlCQyxXQUFXO1FBQ1RDLElBQUFBLDBCQUFhO1FBQ2JOLFVBQVVPLFNBQVM7SUFDckI7SUFFQUMsS0FBSyx3Q0FBd0M7UUFDM0MsZ0JBQWdCO1FBQ2hCLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdDLElBQUFBLGlCQUFVLEVBQUMsSUFBTUMsSUFBQUEsd0NBQW1CO1FBRXZELHVCQUF1QjtRQUN2QkMsT0FBT0gsT0FBT0ksT0FBTyxDQUFDQyxNQUFNLEVBQUVDLE9BQU8sQ0FBQyxFQUFFO1FBQ3hDSCxP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