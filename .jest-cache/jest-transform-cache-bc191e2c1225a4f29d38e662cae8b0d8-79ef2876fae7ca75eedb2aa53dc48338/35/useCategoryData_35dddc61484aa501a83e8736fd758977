1dd97d37c0069ad0875816cfc7f6e44f
/**
 * useCategoryData Hook
 * Manages category data fetching, caching, and state
 * Pinteya E-commerce - Enterprise-ready implementation
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    clearCategoryCache: function() {
        return clearCategoryCache;
    },
    /**
 * Default export for convenience
 */ default: function() {
        return _default;
    },
    preloadCategoryImages: function() {
        return preloadCategoryImages;
    },
    useCategoryData: function() {
        return useCategoryData;
    }
});
const _react = require("react");
/**
 * In-memory cache for category data
 */ const categoryCache = new Map();
/**
 * Default categories data (fallback) - ELIMINADO
 * DATOS HARDCODEADOS ELIMINADOS - Ahora usa solo API real de Supabase
 * Las categorías se obtienen dinámicamente desde /api/categories
 */ const DEFAULT_CATEGORIES = [];
const useCategoryData = (options = {})=>{
    const { autoFetch = true, cacheDuration = 5 * 60 * 1000, enableBackgroundRefresh = true, refreshInterval = 30 * 60 * 1000, maxCategories = 20, enableAnalytics = true, fallbackCategories = [], apiEndpoint = '/api/categories' } = options;
    const [categories, setCategories] = (0, _react.useState)(fallbackCategories);
    const [loading, setLoading] = (0, _react.useState)(false);
    const [error, setError] = (0, _react.useState)(null);
    /**
   * Generate cache key based on options
   */ const cacheKey = (0, _react.useMemo)(()=>{
        return `categories_${maxCategories}_${apiEndpoint}`;
    }, [
        maxCategories,
        apiEndpoint
    ]);
    /**
   * Check if cached data is valid
   */ const isCacheValid = (0, _react.useCallback)((cache)=>{
        return Date.now() < cache.expiresAt;
    }, []);
    /**
   * Get data from cache if valid
   */ const getCachedData = (0, _react.useCallback)(()=>{
        const cached = categoryCache.get(cacheKey);
        if (cached && isCacheValid(cached)) {
            return cached.data;
        }
        return null;
    }, [
        cacheKey,
        isCacheValid
    ]);
    /**
   * Store data in cache
   */ const setCachedData = (0, _react.useCallback)((data)=>{
        const now = Date.now();
        categoryCache.set(cacheKey, {
            data,
            timestamp: now,
            expiresAt: now + cacheDuration
        });
    }, [
        cacheKey,
        cacheDuration
    ]);
    /**
   * Track analytics event
   */ const trackAnalytics = (0, _react.useCallback)((event, data)=>{
        if (!enableAnalytics) return;
        if (typeof window !== 'undefined' && window.gtag) {
            window.gtag('event', 'category_data', {
                event_category: 'data',
                event_label: event,
                custom_parameters: data
            });
        }
        if (process.env.NODE_ENV === 'development') {}
    }, [
        enableAnalytics
    ]);
    /**
   * Fetch categories from API
   */ const fetchCategories = (0, _react.useCallback)(async ()=>{
        try {
            const response = await fetch(apiEndpoint);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const result = await response.json();
            // Handle different API response formats
            let categoriesData;
            if (Array.isArray(result)) {
                categoriesData = result;
            } else if (result.data && Array.isArray(result.data)) {
                categoriesData = result.data;
            } else if (result.categories && Array.isArray(result.categories)) {
                categoriesData = result.categories;
            } else {
                throw new Error('Invalid API response format');
            }
            // Validate and transform data
            const validCategories = categoriesData.filter((cat)=>typeof cat === 'object' && cat !== null && (typeof cat.id === 'string' || typeof cat.id === 'number') && typeof cat.name === 'string').slice(0, maxCategories).map((cat)=>({
                    id: cat.slug || cat.id.toString(),
                    name: cat.name,
                    icon: cat.image_url || cat.icon || "/images/categories/placeholder.png",
                    description: cat.description || `Productos de ${cat.name.toLowerCase()}`,
                    isAvailable: cat.isAvailable ?? true,
                    // Keep additional API fields for compatibility
                    products_count: cat.products_count || 0,
                    slug: cat.slug,
                    parent_id: cat.parent_id,
                    image_url: cat.image_url,
                    created_at: cat.created_at,
                    updated_at: cat.updated_at
                }));
            trackAnalytics('fetch_success', {
                count: validCategories.length
            });
            return validCategories;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            trackAnalytics('fetch_error', {
                error: errorMessage
            });
            throw new Error(`Failed to fetch categories: ${errorMessage}`);
        }
    }, [
        apiEndpoint,
        maxCategories,
        trackAnalytics
    ]);
    /**
   * Refresh categories data
   */ const refresh = (0, _react.useCallback)(async ()=>{
        setLoading(true);
        setError(null);
        try {
            // Check cache first
            const cachedData = getCachedData();
            if (cachedData && !enableBackgroundRefresh) {
                setCategories(cachedData);
                setLoading(false);
                return;
            }
            // Fetch fresh data
            const freshData = await fetchCategories();
            // Update state and cache
            setCategories(freshData);
            setCachedData(freshData);
            setError(null);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Failed to load categories';
            setError(errorMessage);
            // Use cached data as fallback if available
            const cachedData = getCachedData();
            if (cachedData) {
                setCategories(cachedData);
            } else {
                setCategories(fallbackCategories);
            }
            console.error('Category data error:', error);
        } finally{
            setLoading(false);
        }
    }, [
        getCachedData,
        enableBackgroundRefresh,
        fetchCategories,
        setCachedData,
        fallbackCategories
    ]);
    /**
   * Get category by ID
   */ const getCategoryById = (0, _react.useCallback)((id)=>{
        return categories.find((cat)=>cat.id === id);
    }, [
        categories
    ]);
    /**
   * Initial data load
   */ (0, _react.useEffect)(()=>{
        if (autoFetch) {
            refresh();
        }
    }, [
        autoFetch
    ]); // Removed refresh dependency to prevent infinite loop
    /**
   * Background refresh interval
   */ (0, _react.useEffect)(()=>{
        if (!enableBackgroundRefresh || refreshInterval <= 0) return;
        const interval = setInterval(()=>{
            refresh();
        }, refreshInterval);
        return ()=>clearInterval(interval);
    }, [
        enableBackgroundRefresh,
        refreshInterval
    ]); // Removed refresh dependency to prevent infinite loop
    /**
   * Memoized return object for performance
   */ const returnValue = (0, _react.useMemo)(()=>({
            categories,
            loading,
            error,
            refresh,
            getCategoryById
        }), [
        categories,
        loading,
        error,
        refresh,
        getCategoryById
    ]);
    return returnValue;
};
const preloadCategoryImages = (categories)=>{
    if (typeof window === 'undefined') return;
    categories.forEach((category)=>{
        if (category.icon) {
            const img = new Image();
            img.src = category.icon;
        }
    });
};
const clearCategoryCache = ()=>{
    categoryCache.clear();
};
const _default = useCategoryData;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcaG9va3NcXHVzZUNhdGVnb3J5RGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHVzZUNhdGVnb3J5RGF0YSBIb29rXG4gKiBNYW5hZ2VzIGNhdGVnb3J5IGRhdGEgZmV0Y2hpbmcsIGNhY2hpbmcsIGFuZCBzdGF0ZVxuICogUGludGV5YSBFLWNvbW1lcmNlIC0gRW50ZXJwcmlzZS1yZWFkeSBpbXBsZW1lbnRhdGlvblxuICovXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBDYXRlZ29yeSwgVXNlQ2F0ZWdvcnlEYXRhUmV0dXJuIH0gZnJvbSAnQC90eXBlcy9jYXRlZ29yaWVzJztcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjYXRlZ29yeSBkYXRhIGhvb2tcbiAqL1xuaW50ZXJmYWNlIFVzZUNhdGVnb3J5RGF0YU9wdGlvbnMge1xuICAvKiogV2hldGhlciB0byBmZXRjaCBkYXRhIGltbWVkaWF0ZWx5IG9uIG1vdW50ICovXG4gIGF1dG9GZXRjaD86IGJvb2xlYW47XG4gIC8qKiBDYWNoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKi9cbiAgY2FjaGVEdXJhdGlvbj86IG51bWJlcjtcbiAgLyoqIFdoZXRoZXIgdG8gZW5hYmxlIGJhY2tncm91bmQgcmVmcmVzaCAqL1xuICBlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaD86IGJvb2xlYW47XG4gIC8qKiBSZWZyZXNoIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyAqL1xuICByZWZyZXNoSW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiBjYXRlZ29yaWVzIHRvIGZldGNoICovXG4gIG1heENhdGVnb3JpZXM/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIHRvIGVuYWJsZSBhbmFseXRpY3MgdHJhY2tpbmcgKi9cbiAgZW5hYmxlQW5hbHl0aWNzPzogYm9vbGVhbjtcbiAgLyoqIEZhbGxiYWNrIGNhdGVnb3JpZXMgaWYgQVBJIGZhaWxzICovXG4gIGZhbGxiYWNrQ2F0ZWdvcmllcz86IENhdGVnb3J5W107XG4gIC8qKiBBUEkgZW5kcG9pbnQgZm9yIGNhdGVnb3JpZXMgKi9cbiAgYXBpRW5kcG9pbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ2FjaGUgaW50ZXJmYWNlIGZvciBzdG9yaW5nIGNhdGVnb3J5IGRhdGFcbiAqL1xuaW50ZXJmYWNlIENhdGVnb3J5Q2FjaGUge1xuICBkYXRhOiBDYXRlZ29yeVtdO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgZXhwaXJlc0F0OiBudW1iZXI7XG59XG5cbi8qKlxuICogSW4tbWVtb3J5IGNhY2hlIGZvciBjYXRlZ29yeSBkYXRhXG4gKi9cbmNvbnN0IGNhdGVnb3J5Q2FjaGUgPSBuZXcgTWFwPHN0cmluZywgQ2F0ZWdvcnlDYWNoZT4oKTtcblxuLyoqXG4gKiBEZWZhdWx0IGNhdGVnb3JpZXMgZGF0YSAoZmFsbGJhY2spIC0gRUxJTUlOQURPXG4gKiBEQVRPUyBIQVJEQ09ERUFET1MgRUxJTUlOQURPUyAtIEFob3JhIHVzYSBzb2xvIEFQSSByZWFsIGRlIFN1cGFiYXNlXG4gKiBMYXMgY2F0ZWdvcsOtYXMgc2Ugb2J0aWVuZW4gZGluw6FtaWNhbWVudGUgZGVzZGUgL2FwaS9jYXRlZ29yaWVzXG4gKi9cbmNvbnN0IERFRkFVTFRfQ0FURUdPUklFUzogQ2F0ZWdvcnlbXSA9IFtdO1xuXG4vKipcbiAqIEN1c3RvbSBob29rIGZvciBtYW5hZ2luZyBjYXRlZ29yeSBkYXRhXG4gKiBcbiAqIEZlYXR1cmVzOlxuICogLSBEYXRhIGZldGNoaW5nIHdpdGggY2FjaGluZ1xuICogLSBCYWNrZ3JvdW5kIHJlZnJlc2hcbiAqIC0gRXJyb3IgaGFuZGxpbmcgYW5kIGZhbGxiYWNrc1xuICogLSBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAqIC0gQW5hbHl0aWNzIHRyYWNraW5nXG4gKiBcbiAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHJldHVybnMgQ2F0ZWdvcnkgZGF0YSBzdGF0ZSBhbmQgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgdXNlQ2F0ZWdvcnlEYXRhID0gKFxuICBvcHRpb25zOiBVc2VDYXRlZ29yeURhdGFPcHRpb25zID0ge31cbik6IFVzZUNhdGVnb3J5RGF0YVJldHVybiA9PiB7XG4gIGNvbnN0IHtcbiAgICBhdXRvRmV0Y2ggPSB0cnVlLFxuICAgIGNhY2hlRHVyYXRpb24gPSA1ICogNjAgKiAxMDAwLCAvLyA1IG1pbnV0ZXNcbiAgICBlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaCA9IHRydWUsXG4gICAgcmVmcmVzaEludGVydmFsID0gMzAgKiA2MCAqIDEwMDAsIC8vIDMwIG1pbnV0ZXNcbiAgICBtYXhDYXRlZ29yaWVzID0gMjAsXG4gICAgZW5hYmxlQW5hbHl0aWNzID0gdHJ1ZSxcbiAgICBmYWxsYmFja0NhdGVnb3JpZXMgPSBbXSwgLy8gU2luIGZhbGxiYWNrIC0gdXNhciBzb2xvIGRhdG9zIGRlIEFQSVxuICAgIGFwaUVuZHBvaW50ID0gJy9hcGkvY2F0ZWdvcmllcycsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IFtjYXRlZ29yaWVzLCBzZXRDYXRlZ29yaWVzXSA9IHVzZVN0YXRlPENhdGVnb3J5W10+KGZhbGxiYWNrQ2F0ZWdvcmllcyk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgY2FjaGUga2V5IGJhc2VkIG9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0IGNhY2hlS2V5ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGBjYXRlZ29yaWVzXyR7bWF4Q2F0ZWdvcmllc31fJHthcGlFbmRwb2ludH1gO1xuICB9LCBbbWF4Q2F0ZWdvcmllcywgYXBpRW5kcG9pbnRdKTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgY2FjaGVkIGRhdGEgaXMgdmFsaWRcbiAgICovXG4gIGNvbnN0IGlzQ2FjaGVWYWxpZCA9IHVzZUNhbGxiYWNrKChjYWNoZTogQ2F0ZWdvcnlDYWNoZSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBEYXRlLm5vdygpIDwgY2FjaGUuZXhwaXJlc0F0O1xuICB9LCBbXSk7XG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIGZyb20gY2FjaGUgaWYgdmFsaWRcbiAgICovXG4gIGNvbnN0IGdldENhY2hlZERhdGEgPSB1c2VDYWxsYmFjaygoKTogQ2F0ZWdvcnlbXSB8IG51bGwgPT4ge1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhdGVnb3J5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoY2FjaGVkICYmIGlzQ2FjaGVWYWxpZChjYWNoZWQpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LCBbY2FjaGVLZXksIGlzQ2FjaGVWYWxpZF0pO1xuXG4gIC8qKlxuICAgKiBTdG9yZSBkYXRhIGluIGNhY2hlXG4gICAqL1xuICBjb25zdCBzZXRDYWNoZWREYXRhID0gdXNlQ2FsbGJhY2soKGRhdGE6IENhdGVnb3J5W10pID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNhdGVnb3J5Q2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICBkYXRhLFxuICAgICAgdGltZXN0YW1wOiBub3csXG4gICAgICBleHBpcmVzQXQ6IG5vdyArIGNhY2hlRHVyYXRpb24sXG4gICAgfSk7XG4gIH0sIFtjYWNoZUtleSwgY2FjaGVEdXJhdGlvbl0pO1xuXG4gIC8qKlxuICAgKiBUcmFjayBhbmFseXRpY3MgZXZlbnRcbiAgICovXG4gIGNvbnN0IHRyYWNrQW5hbHl0aWNzID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBzdHJpbmcsIGRhdGE/OiBhbnkpID0+IHtcbiAgICBpZiAoIWVuYWJsZUFuYWx5dGljcykgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ndGFnKSB7XG4gICAgICB3aW5kb3cuZ3RhZygnZXZlbnQnLCAnY2F0ZWdvcnlfZGF0YScsIHtcbiAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdkYXRhJyxcbiAgICAgICAgZXZlbnRfbGFiZWw6IGV2ZW50LFxuICAgICAgICBjdXN0b21fcGFyYW1ldGVyczogZGF0YSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIH1cbiAgfSwgW2VuYWJsZUFuYWx5dGljc10pO1xuXG4gIC8qKlxuICAgKiBGZXRjaCBjYXRlZ29yaWVzIGZyb20gQVBJXG4gICAqL1xuICBjb25zdCBmZXRjaENhdGVnb3JpZXMgPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTxDYXRlZ29yeVtdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpRW5kcG9pbnQpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IEFQSSByZXNwb25zZSBmb3JtYXRzXG4gICAgICBsZXQgY2F0ZWdvcmllc0RhdGE6IENhdGVnb3J5W107XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgIGNhdGVnb3JpZXNEYXRhID0gcmVzdWx0O1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZGF0YSAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC5kYXRhKSkge1xuICAgICAgICBjYXRlZ29yaWVzRGF0YSA9IHJlc3VsdC5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY2F0ZWdvcmllcyAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC5jYXRlZ29yaWVzKSkge1xuICAgICAgICBjYXRlZ29yaWVzRGF0YSA9IHJlc3VsdC5jYXRlZ29yaWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFQSSByZXNwb25zZSBmb3JtYXQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgYW5kIHRyYW5zZm9ybSBkYXRhXG4gICAgICBjb25zdCB2YWxpZENhdGVnb3JpZXMgPSBjYXRlZ29yaWVzRGF0YVxuICAgICAgICAuZmlsdGVyKChjYXQpOiBjYXQgaXMgYW55ID0+XG4gICAgICAgICAgdHlwZW9mIGNhdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBjYXQgIT09IG51bGwgJiZcbiAgICAgICAgICAodHlwZW9mIGNhdC5pZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNhdC5pZCA9PT0gJ251bWJlcicpICYmXG4gICAgICAgICAgdHlwZW9mIGNhdC5uYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICApXG4gICAgICAgIC5zbGljZSgwLCBtYXhDYXRlZ29yaWVzKVxuICAgICAgICAubWFwKGNhdCA9PiAoe1xuICAgICAgICAgIGlkOiBjYXQuc2x1ZyB8fCBjYXQuaWQudG9TdHJpbmcoKSwgLy8gVXNlIHNsdWcgYXMgSUQsIGZhbGxiYWNrIHRvIHN0cmluZyBJRFxuICAgICAgICAgIG5hbWU6IGNhdC5uYW1lLFxuICAgICAgICAgIGljb246IGNhdC5pbWFnZV91cmwgfHwgY2F0Lmljb24gfHwgXCIvaW1hZ2VzL2NhdGVnb3JpZXMvcGxhY2Vob2xkZXIucG5nXCIsIC8vIE1hcCBpbWFnZV91cmwgdG8gaWNvblxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBjYXQuZGVzY3JpcHRpb24gfHwgYFByb2R1Y3RvcyBkZSAke2NhdC5uYW1lLnRvTG93ZXJDYXNlKCl9YCwgLy8gR2VuZXJhdGUgZGVzY3JpcHRpb24gaWYgbWlzc2luZ1xuICAgICAgICAgIGlzQXZhaWxhYmxlOiBjYXQuaXNBdmFpbGFibGUgPz8gdHJ1ZSxcbiAgICAgICAgICAvLyBLZWVwIGFkZGl0aW9uYWwgQVBJIGZpZWxkcyBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgIHByb2R1Y3RzX2NvdW50OiBjYXQucHJvZHVjdHNfY291bnQgfHwgMCxcbiAgICAgICAgICBzbHVnOiBjYXQuc2x1ZyxcbiAgICAgICAgICBwYXJlbnRfaWQ6IGNhdC5wYXJlbnRfaWQsXG4gICAgICAgICAgaW1hZ2VfdXJsOiBjYXQuaW1hZ2VfdXJsLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IGNhdC5jcmVhdGVkX2F0LFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IGNhdC51cGRhdGVkX2F0XG4gICAgICAgIH0pKTtcblxuICAgICAgdHJhY2tBbmFseXRpY3MoJ2ZldGNoX3N1Y2Nlc3MnLCB7IGNvdW50OiB2YWxpZENhdGVnb3JpZXMubGVuZ3RoIH0pO1xuICAgICAgcmV0dXJuIHZhbGlkQ2F0ZWdvcmllcztcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcbiAgICAgIHRyYWNrQW5hbHl0aWNzKCdmZXRjaF9lcnJvcicsIHsgZXJyb3I6IGVycm9yTWVzc2FnZSB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGNhdGVnb3JpZXM6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgIH1cbiAgfSwgW2FwaUVuZHBvaW50LCBtYXhDYXRlZ29yaWVzLCB0cmFja0FuYWx5dGljc10pO1xuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGNhdGVnb3JpZXMgZGF0YVxuICAgKi9cbiAgY29uc3QgcmVmcmVzaCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgICBjb25zdCBjYWNoZWREYXRhID0gZ2V0Q2FjaGVkRGF0YSgpO1xuICAgICAgaWYgKGNhY2hlZERhdGEgJiYgIWVuYWJsZUJhY2tncm91bmRSZWZyZXNoKSB7XG4gICAgICAgIHNldENhdGVnb3JpZXMoY2FjaGVkRGF0YSk7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZldGNoIGZyZXNoIGRhdGFcbiAgICAgIGNvbnN0IGZyZXNoRGF0YSA9IGF3YWl0IGZldGNoQ2F0ZWdvcmllcygpO1xuXG4gICAgICAvLyBVcGRhdGUgc3RhdGUgYW5kIGNhY2hlXG4gICAgICBzZXRDYXRlZ29yaWVzKGZyZXNoRGF0YSk7XG4gICAgICBzZXRDYWNoZWREYXRhKGZyZXNoRGF0YSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGYWlsZWQgdG8gbG9hZCBjYXRlZ29yaWVzJztcbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG5cbiAgICAgIC8vIFVzZSBjYWNoZWQgZGF0YSBhcyBmYWxsYmFjayBpZiBhdmFpbGFibGVcbiAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBnZXRDYWNoZWREYXRhKCk7XG4gICAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICBzZXRDYXRlZ29yaWVzKGNhY2hlZERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhmYWxsYmFja0NhdGVnb3JpZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmVycm9yKCdDYXRlZ29yeSBkYXRhIGVycm9yOicsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbXG4gICAgZ2V0Q2FjaGVkRGF0YSxcbiAgICBlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaCxcbiAgICBmZXRjaENhdGVnb3JpZXMsXG4gICAgc2V0Q2FjaGVkRGF0YSxcbiAgICBmYWxsYmFja0NhdGVnb3JpZXMsXG4gIF0pO1xuXG4gIC8qKlxuICAgKiBHZXQgY2F0ZWdvcnkgYnkgSURcbiAgICovXG4gIGNvbnN0IGdldENhdGVnb3J5QnlJZCA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKTogQ2F0ZWdvcnkgfCB1bmRlZmluZWQgPT4ge1xuICAgIHJldHVybiBjYXRlZ29yaWVzLmZpbmQoY2F0ID0+IGNhdC5pZCA9PT0gaWQpO1xuICB9LCBbY2F0ZWdvcmllc10pO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsIGRhdGEgbG9hZFxuICAgKi9cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYXV0b0ZldGNoKSB7XG4gICAgICByZWZyZXNoKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZldGNoXSk7IC8vIFJlbW92ZWQgcmVmcmVzaCBkZXBlbmRlbmN5IHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcFxuXG4gIC8qKlxuICAgKiBCYWNrZ3JvdW5kIHJlZnJlc2ggaW50ZXJ2YWxcbiAgICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaCB8fCByZWZyZXNoSW50ZXJ2YWwgPD0gMCkgcmV0dXJuO1xuXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICByZWZyZXNoKCk7XG4gICAgfSwgcmVmcmVzaEludGVydmFsKTtcblxuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSwgW2VuYWJsZUJhY2tncm91bmRSZWZyZXNoLCByZWZyZXNoSW50ZXJ2YWxdKTsgLy8gUmVtb3ZlZCByZWZyZXNoIGRlcGVuZGVuY3kgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wXG5cbiAgLyoqXG4gICAqIE1lbW9pemVkIHJldHVybiBvYmplY3QgZm9yIHBlcmZvcm1hbmNlXG4gICAqL1xuICBjb25zdCByZXR1cm5WYWx1ZSA9IHVzZU1lbW8oKCk6IFVzZUNhdGVnb3J5RGF0YVJldHVybiA9PiAoe1xuICAgIGNhdGVnb3JpZXMsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICByZWZyZXNoLFxuICAgIGdldENhdGVnb3J5QnlJZCxcbiAgfSksIFtjYXRlZ29yaWVzLCBsb2FkaW5nLCBlcnJvciwgcmVmcmVzaCwgZ2V0Q2F0ZWdvcnlCeUlkXSk7XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IHRvIHByZWxvYWQgY2F0ZWdvcnkgaW1hZ2VzXG4gKi9cbmV4cG9ydCBjb25zdCBwcmVsb2FkQ2F0ZWdvcnlJbWFnZXMgPSAoY2F0ZWdvcmllczogQ2F0ZWdvcnlbXSk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICBjYXRlZ29yaWVzLmZvckVhY2goY2F0ZWdvcnkgPT4ge1xuICAgIGlmIChjYXRlZ29yeS5pY29uKSB7XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltZy5zcmMgPSBjYXRlZ29yeS5pY29uO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgdG8gY2xlYXIgY2F0ZWdvcnkgY2FjaGVcbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFyQ2F0ZWdvcnlDYWNoZSA9ICgpOiB2b2lkID0+IHtcbiAgY2F0ZWdvcnlDYWNoZS5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGV4cG9ydCBmb3IgY29udmVuaWVuY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgdXNlQ2F0ZWdvcnlEYXRhO1xuIl0sIm5hbWVzIjpbImNsZWFyQ2F0ZWdvcnlDYWNoZSIsInByZWxvYWRDYXRlZ29yeUltYWdlcyIsInVzZUNhdGVnb3J5RGF0YSIsImNhdGVnb3J5Q2FjaGUiLCJNYXAiLCJERUZBVUxUX0NBVEVHT1JJRVMiLCJvcHRpb25zIiwiYXV0b0ZldGNoIiwiY2FjaGVEdXJhdGlvbiIsImVuYWJsZUJhY2tncm91bmRSZWZyZXNoIiwicmVmcmVzaEludGVydmFsIiwibWF4Q2F0ZWdvcmllcyIsImVuYWJsZUFuYWx5dGljcyIsImZhbGxiYWNrQ2F0ZWdvcmllcyIsImFwaUVuZHBvaW50IiwiY2F0ZWdvcmllcyIsInNldENhdGVnb3JpZXMiLCJ1c2VTdGF0ZSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImNhY2hlS2V5IiwidXNlTWVtbyIsImlzQ2FjaGVWYWxpZCIsInVzZUNhbGxiYWNrIiwiY2FjaGUiLCJEYXRlIiwibm93IiwiZXhwaXJlc0F0IiwiZ2V0Q2FjaGVkRGF0YSIsImNhY2hlZCIsImdldCIsImRhdGEiLCJzZXRDYWNoZWREYXRhIiwic2V0IiwidGltZXN0YW1wIiwidHJhY2tBbmFseXRpY3MiLCJldmVudCIsIndpbmRvdyIsImd0YWciLCJldmVudF9jYXRlZ29yeSIsImV2ZW50X2xhYmVsIiwiY3VzdG9tX3BhcmFtZXRlcnMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJmZXRjaENhdGVnb3JpZXMiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJyZXN1bHQiLCJqc29uIiwiY2F0ZWdvcmllc0RhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJ2YWxpZENhdGVnb3JpZXMiLCJmaWx0ZXIiLCJjYXQiLCJpZCIsIm5hbWUiLCJzbGljZSIsIm1hcCIsInNsdWciLCJ0b1N0cmluZyIsImljb24iLCJpbWFnZV91cmwiLCJkZXNjcmlwdGlvbiIsInRvTG93ZXJDYXNlIiwiaXNBdmFpbGFibGUiLCJwcm9kdWN0c19jb3VudCIsInBhcmVudF9pZCIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwiY291bnQiLCJsZW5ndGgiLCJlcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwicmVmcmVzaCIsImNhY2hlZERhdGEiLCJmcmVzaERhdGEiLCJjb25zb2xlIiwiZ2V0Q2F0ZWdvcnlCeUlkIiwiZmluZCIsInVzZUVmZmVjdCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwicmV0dXJuVmFsdWUiLCJmb3JFYWNoIiwiY2F0ZWdvcnkiLCJpbWciLCJJbWFnZSIsInNyYyIsImNsZWFyIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDOzs7Ozs7Ozs7OztJQTZTWUEsa0JBQWtCO2VBQWxCQTs7SUFJYjs7Q0FFQyxHQUNELE9BQStCO2VBQS9COztJQXJCYUMscUJBQXFCO2VBQXJCQTs7SUFsT0FDLGVBQWU7ZUFBZkE7Ozt1QkEzRDZDO0FBa0MxRDs7Q0FFQyxHQUNELE1BQU1DLGdCQUFnQixJQUFJQztBQUUxQjs7OztDQUlDLEdBQ0QsTUFBTUMscUJBQWlDLEVBQUU7QUFlbEMsTUFBTUgsa0JBQWtCLENBQzdCSSxVQUFrQyxDQUFDLENBQUM7SUFFcEMsTUFBTSxFQUNKQyxZQUFZLElBQUksRUFDaEJDLGdCQUFnQixJQUFJLEtBQUssSUFBSSxFQUM3QkMsMEJBQTBCLElBQUksRUFDOUJDLGtCQUFrQixLQUFLLEtBQUssSUFBSSxFQUNoQ0MsZ0JBQWdCLEVBQUUsRUFDbEJDLGtCQUFrQixJQUFJLEVBQ3RCQyxxQkFBcUIsRUFBRSxFQUN2QkMsY0FBYyxpQkFBaUIsRUFDaEMsR0FBR1I7SUFFSixNQUFNLENBQUNTLFlBQVlDLGNBQWMsR0FBR0MsSUFBQUEsZUFBUSxFQUFhSjtJQUN6RCxNQUFNLENBQUNLLFNBQVNDLFdBQVcsR0FBR0YsSUFBQUEsZUFBUSxFQUFDO0lBQ3ZDLE1BQU0sQ0FBQ0csT0FBT0MsU0FBUyxHQUFHSixJQUFBQSxlQUFRLEVBQWdCO0lBRWxEOztHQUVDLEdBQ0QsTUFBTUssV0FBV0MsSUFBQUEsY0FBTyxFQUFDO1FBQ3ZCLE9BQU8sQ0FBQyxXQUFXLEVBQUVaLGNBQWMsQ0FBQyxFQUFFRyxhQUFhO0lBQ3JELEdBQUc7UUFBQ0g7UUFBZUc7S0FBWTtJQUUvQjs7R0FFQyxHQUNELE1BQU1VLGVBQWVDLElBQUFBLGtCQUFXLEVBQUMsQ0FBQ0M7UUFDaEMsT0FBT0MsS0FBS0MsR0FBRyxLQUFLRixNQUFNRyxTQUFTO0lBQ3JDLEdBQUcsRUFBRTtJQUVMOztHQUVDLEdBQ0QsTUFBTUMsZ0JBQWdCTCxJQUFBQSxrQkFBVyxFQUFDO1FBQ2hDLE1BQU1NLFNBQVM1QixjQUFjNkIsR0FBRyxDQUFDVjtRQUNqQyxJQUFJUyxVQUFVUCxhQUFhTyxTQUFTO1lBQ2xDLE9BQU9BLE9BQU9FLElBQUk7UUFDcEI7UUFDQSxPQUFPO0lBQ1QsR0FBRztRQUFDWDtRQUFVRTtLQUFhO0lBRTNCOztHQUVDLEdBQ0QsTUFBTVUsZ0JBQWdCVCxJQUFBQSxrQkFBVyxFQUFDLENBQUNRO1FBQ2pDLE1BQU1MLE1BQU1ELEtBQUtDLEdBQUc7UUFDcEJ6QixjQUFjZ0MsR0FBRyxDQUFDYixVQUFVO1lBQzFCVztZQUNBRyxXQUFXUjtZQUNYQyxXQUFXRCxNQUFNcEI7UUFDbkI7SUFDRixHQUFHO1FBQUNjO1FBQVVkO0tBQWM7SUFFNUI7O0dBRUMsR0FDRCxNQUFNNkIsaUJBQWlCWixJQUFBQSxrQkFBVyxFQUFDLENBQUNhLE9BQWVMO1FBQ2pELElBQUksQ0FBQ3JCLGlCQUFpQjtRQUV0QixJQUFJLE9BQU8yQixXQUFXLGVBQWVBLE9BQU9DLElBQUksRUFBRTtZQUNoREQsT0FBT0MsSUFBSSxDQUFDLFNBQVMsaUJBQWlCO2dCQUNwQ0MsZ0JBQWdCO2dCQUNoQkMsYUFBYUo7Z0JBQ2JLLG1CQUFtQlY7WUFDckI7UUFDRjtRQUVBLElBQUlXLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLGVBQWUsQ0FDNUM7SUFDRixHQUFHO1FBQUNsQztLQUFnQjtJQUVwQjs7R0FFQyxHQUNELE1BQU1tQyxrQkFBa0J0QixJQUFBQSxrQkFBVyxFQUFDO1FBQ2xDLElBQUk7WUFDRixNQUFNdUIsV0FBVyxNQUFNQyxNQUFNbkM7WUFFN0IsSUFBSSxDQUFDa0MsU0FBU0UsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlDLE1BQU0sQ0FBQyxLQUFLLEVBQUVILFNBQVNJLE1BQU0sQ0FBQyxFQUFFLEVBQUVKLFNBQVNLLFVBQVUsRUFBRTtZQUNuRTtZQUVBLE1BQU1DLFNBQVMsTUFBTU4sU0FBU08sSUFBSTtZQUVsQyx3Q0FBd0M7WUFDeEMsSUFBSUM7WUFDSixJQUFJQyxNQUFNQyxPQUFPLENBQUNKLFNBQVM7Z0JBQ3pCRSxpQkFBaUJGO1lBQ25CLE9BQU8sSUFBSUEsT0FBT3JCLElBQUksSUFBSXdCLE1BQU1DLE9BQU8sQ0FBQ0osT0FBT3JCLElBQUksR0FBRztnQkFDcER1QixpQkFBaUJGLE9BQU9yQixJQUFJO1lBQzlCLE9BQU8sSUFBSXFCLE9BQU92QyxVQUFVLElBQUkwQyxNQUFNQyxPQUFPLENBQUNKLE9BQU92QyxVQUFVLEdBQUc7Z0JBQ2hFeUMsaUJBQWlCRixPQUFPdkMsVUFBVTtZQUNwQyxPQUFPO2dCQUNMLE1BQU0sSUFBSW9DLE1BQU07WUFDbEI7WUFFQSw4QkFBOEI7WUFDOUIsTUFBTVEsa0JBQWtCSCxlQUNyQkksTUFBTSxDQUFDLENBQUNDLE1BQ1AsT0FBT0EsUUFBUSxZQUNmQSxRQUFRLFFBQ1AsQ0FBQSxPQUFPQSxJQUFJQyxFQUFFLEtBQUssWUFBWSxPQUFPRCxJQUFJQyxFQUFFLEtBQUssUUFBTyxLQUN4RCxPQUFPRCxJQUFJRSxJQUFJLEtBQUssVUFFckJDLEtBQUssQ0FBQyxHQUFHckQsZUFDVHNELEdBQUcsQ0FBQ0osQ0FBQUEsTUFBUSxDQUFBO29CQUNYQyxJQUFJRCxJQUFJSyxJQUFJLElBQUlMLElBQUlDLEVBQUUsQ0FBQ0ssUUFBUTtvQkFDL0JKLE1BQU1GLElBQUlFLElBQUk7b0JBQ2RLLE1BQU1QLElBQUlRLFNBQVMsSUFBSVIsSUFBSU8sSUFBSSxJQUFJO29CQUNuQ0UsYUFBYVQsSUFBSVMsV0FBVyxJQUFJLENBQUMsYUFBYSxFQUFFVCxJQUFJRSxJQUFJLENBQUNRLFdBQVcsSUFBSTtvQkFDeEVDLGFBQWFYLElBQUlXLFdBQVcsSUFBSTtvQkFDaEMsK0NBQStDO29CQUMvQ0MsZ0JBQWdCWixJQUFJWSxjQUFjLElBQUk7b0JBQ3RDUCxNQUFNTCxJQUFJSyxJQUFJO29CQUNkUSxXQUFXYixJQUFJYSxTQUFTO29CQUN4QkwsV0FBV1IsSUFBSVEsU0FBUztvQkFDeEJNLFlBQVlkLElBQUljLFVBQVU7b0JBQzFCQyxZQUFZZixJQUFJZSxVQUFVO2dCQUM1QixDQUFBO1lBRUZ2QyxlQUFlLGlCQUFpQjtnQkFBRXdDLE9BQU9sQixnQkFBZ0JtQixNQUFNO1lBQUM7WUFDaEUsT0FBT25CO1FBRVQsRUFBRSxPQUFPdkMsT0FBTztZQUNkLE1BQU0yRCxlQUFlM0QsaUJBQWlCK0IsUUFBUS9CLE1BQU00RCxPQUFPLEdBQUc7WUFDOUQzQyxlQUFlLGVBQWU7Z0JBQUVqQixPQUFPMkQ7WUFBYTtZQUNwRCxNQUFNLElBQUk1QixNQUFNLENBQUMsNEJBQTRCLEVBQUU0QixjQUFjO1FBQy9EO0lBQ0YsR0FBRztRQUFDakU7UUFBYUg7UUFBZTBCO0tBQWU7SUFFL0M7O0dBRUMsR0FDRCxNQUFNNEMsVUFBVXhELElBQUFBLGtCQUFXLEVBQUM7UUFDMUJOLFdBQVc7UUFDWEUsU0FBUztRQUVULElBQUk7WUFDRixvQkFBb0I7WUFDcEIsTUFBTTZELGFBQWFwRDtZQUNuQixJQUFJb0QsY0FBYyxDQUFDekUseUJBQXlCO2dCQUMxQ08sY0FBY2tFO2dCQUNkL0QsV0FBVztnQkFDWDtZQUNGO1lBRUEsbUJBQW1CO1lBQ25CLE1BQU1nRSxZQUFZLE1BQU1wQztZQUV4Qix5QkFBeUI7WUFDekIvQixjQUFjbUU7WUFDZGpELGNBQWNpRDtZQUNkOUQsU0FBUztRQUVYLEVBQUUsT0FBT0QsT0FBTztZQUNkLE1BQU0yRCxlQUFlM0QsaUJBQWlCK0IsUUFBUS9CLE1BQU00RCxPQUFPLEdBQUc7WUFDOUQzRCxTQUFTMEQ7WUFFVCwyQ0FBMkM7WUFDM0MsTUFBTUcsYUFBYXBEO1lBQ25CLElBQUlvRCxZQUFZO2dCQUNkbEUsY0FBY2tFO1lBQ2hCLE9BQU87Z0JBQ0xsRSxjQUFjSDtZQUNoQjtZQUVBdUUsUUFBUWhFLEtBQUssQ0FBQyx3QkFBd0JBO1FBQ3hDLFNBQVU7WUFDUkQsV0FBVztRQUNiO0lBQ0YsR0FBRztRQUNEVztRQUNBckI7UUFDQXNDO1FBQ0FiO1FBQ0FyQjtLQUNEO0lBRUQ7O0dBRUMsR0FDRCxNQUFNd0Usa0JBQWtCNUQsSUFBQUEsa0JBQVcsRUFBQyxDQUFDcUM7UUFDbkMsT0FBTy9DLFdBQVd1RSxJQUFJLENBQUN6QixDQUFBQSxNQUFPQSxJQUFJQyxFQUFFLEtBQUtBO0lBQzNDLEdBQUc7UUFBQy9DO0tBQVc7SUFFZjs7R0FFQyxHQUNEd0UsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLElBQUloRixXQUFXO1lBQ2IwRTtRQUNGO0lBQ0YsR0FBRztRQUFDMUU7S0FBVSxHQUFHLHNEQUFzRDtJQUV2RTs7R0FFQyxHQUNEZ0YsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLElBQUksQ0FBQzlFLDJCQUEyQkMsbUJBQW1CLEdBQUc7UUFFdEQsTUFBTThFLFdBQVdDLFlBQVk7WUFDM0JSO1FBQ0YsR0FBR3ZFO1FBRUgsT0FBTyxJQUFNZ0YsY0FBY0Y7SUFDN0IsR0FBRztRQUFDL0U7UUFBeUJDO0tBQWdCLEdBQUcsc0RBQXNEO0lBRXRHOztHQUVDLEdBQ0QsTUFBTWlGLGNBQWNwRSxJQUFBQSxjQUFPLEVBQUMsSUFBOEIsQ0FBQTtZQUN4RFI7WUFDQUc7WUFDQUU7WUFDQTZEO1lBQ0FJO1FBQ0YsQ0FBQSxHQUFJO1FBQUN0RTtRQUFZRztRQUFTRTtRQUFPNkQ7UUFBU0k7S0FBZ0I7SUFFMUQsT0FBT007QUFDVDtBQUtPLE1BQU0xRix3QkFBd0IsQ0FBQ2M7SUFDcEMsSUFBSSxPQUFPd0IsV0FBVyxhQUFhO0lBRW5DeEIsV0FBVzZFLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDakIsSUFBSUEsU0FBU3pCLElBQUksRUFBRTtZQUNqQixNQUFNMEIsTUFBTSxJQUFJQztZQUNoQkQsSUFBSUUsR0FBRyxHQUFHSCxTQUFTekIsSUFBSTtRQUN6QjtJQUNGO0FBQ0Y7QUFLTyxNQUFNcEUscUJBQXFCO0lBQ2hDRyxjQUFjOEYsS0FBSztBQUNyQjtNQUtBLFdBQWUvRiJ9