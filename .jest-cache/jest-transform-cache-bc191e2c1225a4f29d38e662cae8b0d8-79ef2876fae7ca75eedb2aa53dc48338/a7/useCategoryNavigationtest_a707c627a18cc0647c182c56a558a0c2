2972a08a787760cf5ebf81ce833f29d1
/**
 * useCategoryNavigation Hook Tests
 * Enterprise-ready test suite for category navigation logic
 * Pinteya E-commerce
 */ "use strict";
// Mock Next.js navigation hooks
jest.mock('next/navigation', ()=>({
        useRouter: jest.fn(),
        useSearchParams: jest.fn(),
        usePathname: jest.fn(()=>'/')
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _navigation = require("next/navigation");
const _useCategoryNavigation = require("../../hooks/useCategoryNavigation");
// Mock analytics
const mockGtag = jest.fn();
Object.defineProperty(window, 'gtag', {
    value: mockGtag,
    writable: true
});
describe('useCategoryNavigation Hook', ()=>{
    const mockPush = jest.fn();
    const mockGet = jest.fn();
    const mockForEach = jest.fn();
    beforeEach(()=>{
        jest.clearAllMocks();
        // Setup router mock
        _navigation.useRouter.mockReturnValue({
            push: mockPush
        });
        // Setup search params mock
        _navigation.useSearchParams.mockReturnValue({
            get: mockGet,
            forEach: mockForEach
        });
        // Setup pathname mock
        _navigation.usePathname.mockReturnValue('/');
        // Reset analytics mock
        mockGtag.mockClear();
    });
    describe('Navigation Functions', ()=>{
        it('navigates to filtered view with categories', async ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    enableAnalytics: true
                }));
            const categories = [
                'cat1',
                'cat2'
            ];
            await (0, _react.act)(async ()=>{
                result.current.navigateToFiltered(categories);
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockPush).toHaveBeenCalledWith('/?categories=cat1%2Ccat2');
        });
        it('navigates to home (clears filters)', async ()=>{
            mockGet.mockReturnValue('cat1,cat2');
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    enableAnalytics: true
                }));
            await (0, _react.act)(async ()=>{
                result.current.navigateToHome();
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockPush).toHaveBeenCalledWith('/');
        });
        it('preserves other URL parameters when enabled', async ()=>{
            mockGet.mockImplementation((key)=>{
                if (key === 'categories') return null;
                if (key === 'search') return 'test';
                return null;
            });
            mockForEach.mockImplementation((callback)=>{
                callback('test', 'search');
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    preserveParams: true,
                    enableAnalytics: true
                }));
            const categories = [
                'cat1'
            ];
            await (0, _react.act)(async ()=>{
                result.current.navigateToFiltered(categories);
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockPush).toHaveBeenCalledWith('/?search=test&categories=cat1');
        });
        it('does not preserve other parameters when disabled', async ()=>{
            mockGet.mockImplementation((key)=>{
                if (key === 'categories') return null;
                if (key === 'search') return 'test';
                return null;
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    preserveParams: false,
                    enableAnalytics: true
                }));
            const categories = [
                'cat1'
            ];
            await (0, _react.act)(async ()=>{
                result.current.navigateToFiltered(categories);
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockPush).toHaveBeenCalledWith('/?categories=cat1');
        });
    });
    describe('URL Building', ()=>{
        it('builds correct URL with single category', ()=>{
            mockGet.mockReturnValue(null);
            mockForEach.mockImplementation(()=>{}); // No other params
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)());
            const url = result.current.getCurrentUrl();
            expect(url).toBe('/');
        });
        it('builds correct URL with multiple categories', ()=>{
            mockGet.mockReturnValue('cat1,cat2,cat3');
            mockForEach.mockImplementation(()=>{}); // No other params
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)());
            const url = result.current.getCurrentUrl();
            expect(url).toBe('/?categories=cat1%2Ccat2%2Ccat3');
        });
        it('handles empty categories correctly', ()=>{
            mockGet.mockReturnValue('');
            mockForEach.mockImplementation(()=>{}); // No other params
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)());
            const url = result.current.getCurrentUrl();
            expect(url).toBe('/');
        });
    });
    describe('Navigation State', ()=>{
        it('tracks navigation state correctly', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)());
            expect(result.current.isNavigating).toBe(false);
            (0, _react.act)(()=>{
                result.current.navigateToFiltered([
                    'cat1'
                ]);
            });
            expect(result.current.isNavigating).toBe(true);
            // Wait for navigation to complete
            await (0, _react.act)(async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, 500));
            });
            expect(result.current.isNavigating).toBe(false);
        });
    });
    describe('Analytics Tracking', ()=>{
        it('tracks navigation analytics when enabled', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    enableAnalytics: true
                }));
            await (0, _react.act)(async ()=>{
                result.current.navigateToFiltered([
                    'cat1',
                    'cat2'
                ]);
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockGtag).toHaveBeenCalledWith('event', 'category_navigation', expect.objectContaining({
                event_category: 'navigation',
                event_label: 'filter',
                value: 2
            }));
        });
        it('tracks clear navigation analytics', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    enableAnalytics: true
                }));
            await (0, _react.act)(async ()=>{
                result.current.navigateToHome();
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockGtag).toHaveBeenCalledWith('event', 'category_navigation', expect.objectContaining({
                event_category: 'navigation',
                event_label: 'clear',
                value: 0
            }));
        });
        it('does not track analytics when disabled', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    enableAnalytics: false
                }));
            await (0, _react.act)(async ()=>{
                result.current.navigateToFiltered([
                    'cat1'
                ]);
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockGtag).not.toHaveBeenCalled();
        });
    });
    describe('Configuration Options', ()=>{
        it('uses custom parameter name', async ()=>{
            mockGet.mockReturnValue(null);
            mockForEach.mockImplementation(()=>{}); // No other params
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    paramName: 'filters'
                }));
            await (0, _react.act)(async ()=>{
                result.current.navigateToFiltered([
                    'cat1'
                ]);
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockPush).toHaveBeenCalledWith('/?filters=cat1');
        });
        it('uses custom base path', async ()=>{
            mockGet.mockReturnValue(null);
            mockForEach.mockImplementation(()=>{}); // No other params
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    basePath: '/shop'
                }));
            await (0, _react.act)(async ()=>{
                result.current.navigateToFiltered([
                    'cat1'
                ]);
                // Wait for debounce
                await new Promise((resolve)=>setTimeout(resolve, 400));
            });
            expect(mockPush).toHaveBeenCalledWith('/shop?categories=cat1');
        });
        it('respects custom debounce delay', async ()=>{
            jest.useFakeTimers();
            mockGet.mockReturnValue(null);
            mockForEach.mockImplementation(()=>{}); // No other params
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)({
                    debounceDelay: 100
                }));
            (0, _react.act)(()=>{
                result.current.navigateToFiltered([
                    'cat1'
                ]);
            });
            expect(mockPush).not.toHaveBeenCalled();
            (0, _react.act)(()=>{
                jest.advanceTimersByTime(100);
            });
            expect(mockPush).toHaveBeenCalledWith('/?categories=cat1');
            jest.useRealTimers();
        });
    });
    describe('Error Handling', ()=>{
        it('handles navigation errors gracefully', ()=>{
            // Test that the hook doesn't crash when navigation fails
            mockPush.mockImplementation(()=>{
                throw new Error('Navigation failed');
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)());
            // Should not throw when navigation fails
            expect(()=>{
                result.current.navigateToFiltered([
                    'cat1'
                ]);
            }).not.toThrow();
        });
    });
    describe('Cleanup', ()=>{
        it('cleans up debounce timer on unmount', ()=>{
            // This test verifies that the hook cleans up properly
            // The actual cleanup is handled internally by the hook
            const { unmount } = (0, _react.renderHook)(()=>(0, _useCategoryNavigation.useCategoryNavigation)());
            // Should unmount without errors
            expect(()=>unmount()).not.toThrow();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIHVzZUNhdGVnb3J5TmF2aWdhdGlvbiBIb29rIFRlc3RzXHJcbiAqIEVudGVycHJpc2UtcmVhZHkgdGVzdCBzdWl0ZSBmb3IgY2F0ZWdvcnkgbmF2aWdhdGlvbiBsb2dpY1xyXG4gKiBQaW50ZXlhIEUtY29tbWVyY2VcclxuICovXHJcblxyXG5pbXBvcnQgeyByZW5kZXJIb29rLCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcclxuaW1wb3J0IHsgdXNlUm91dGVyLCB1c2VTZWFyY2hQYXJhbXMsIHVzZVBhdGhuYW1lIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcclxuaW1wb3J0IHsgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uIH0gZnJvbSAnQC9ob29rcy91c2VDYXRlZ29yeU5hdmlnYXRpb24nO1xyXG5cclxuLy8gTW9jayBOZXh0LmpzIG5hdmlnYXRpb24gaG9va3NcclxuamVzdC5tb2NrKCduZXh0L25hdmlnYXRpb24nLCAoKSA9PiAoe1xyXG4gIHVzZVJvdXRlcjogamVzdC5mbigpLFxyXG4gIHVzZVNlYXJjaFBhcmFtczogamVzdC5mbigpLFxyXG4gIHVzZVBhdGhuYW1lOiBqZXN0LmZuKCgpID0+ICcvJyksXHJcbn0pKTtcclxuXHJcbi8vIE1vY2sgYW5hbHl0aWNzXHJcbmNvbnN0IG1vY2tHdGFnID0gamVzdC5mbigpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnZ3RhZycsIHtcclxuICB2YWx1ZTogbW9ja0d0YWcsXHJcbiAgd3JpdGFibGU6IHRydWUsXHJcbn0pO1xyXG5cclxuZGVzY3JpYmUoJ3VzZUNhdGVnb3J5TmF2aWdhdGlvbiBIb29rJywgKCkgPT4ge1xyXG4gIGNvbnN0IG1vY2tQdXNoID0gamVzdC5mbigpO1xyXG4gIGNvbnN0IG1vY2tHZXQgPSBqZXN0LmZuKCk7XHJcbiAgY29uc3QgbW9ja0ZvckVhY2ggPSBqZXN0LmZuKCk7XHJcblxyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgICBcclxuICAgIC8vIFNldHVwIHJvdXRlciBtb2NrXHJcbiAgICAodXNlUm91dGVyIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKHtcclxuICAgICAgcHVzaDogbW9ja1B1c2gsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTZXR1cCBzZWFyY2ggcGFyYW1zIG1vY2tcclxuICAgICh1c2VTZWFyY2hQYXJhbXMgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoe1xyXG4gICAgICBnZXQ6IG1vY2tHZXQsXHJcbiAgICAgIGZvckVhY2g6IG1vY2tGb3JFYWNoLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU2V0dXAgcGF0aG5hbWUgbW9ja1xyXG4gICAgKHVzZVBhdGhuYW1lIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKCcvJyk7XHJcblxyXG4gICAgLy8gUmVzZXQgYW5hbHl0aWNzIG1vY2tcclxuICAgIG1vY2tHdGFnLm1vY2tDbGVhcigpO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnTmF2aWdhdGlvbiBGdW5jdGlvbnMnLCAoKSA9PiB7XHJcbiAgICBpdCgnbmF2aWdhdGVzIHRvIGZpbHRlcmVkIHZpZXcgd2l0aCBjYXRlZ29yaWVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxyXG4gICAgICAgIHVzZUNhdGVnb3J5TmF2aWdhdGlvbih7IGVuYWJsZUFuYWx5dGljczogdHJ1ZSB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IFsnY2F0MScsICdjYXQyJ107XHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm5hdmlnYXRlVG9GaWx0ZXJlZChjYXRlZ29yaWVzKTtcclxuICAgICAgICAvLyBXYWl0IGZvciBkZWJvdW5jZVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA0MDApKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja1B1c2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvP2NhdGVnb3JpZXM9Y2F0MSUyQ2NhdDInKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCduYXZpZ2F0ZXMgdG8gaG9tZSAoY2xlYXJzIGZpbHRlcnMpJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZSgnY2F0MSxjYXQyJyk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcclxuICAgICAgICB1c2VDYXRlZ29yeU5hdmlnYXRpb24oeyBlbmFibGVBbmFseXRpY3M6IHRydWUgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubmF2aWdhdGVUb0hvbWUoKTtcclxuICAgICAgICAvLyBXYWl0IGZvciBkZWJvdW5jZVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA0MDApKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja1B1c2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncHJlc2VydmVzIG90aGVyIFVSTCBwYXJhbWV0ZXJzIHdoZW4gZW5hYmxlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0dldC5tb2NrSW1wbGVtZW50YXRpb24oKGtleTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NhdGVnb3JpZXMnKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAoa2V5ID09PSAnc2VhcmNoJykgcmV0dXJuICd0ZXN0JztcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICBtb2NrRm9yRWFjaC5tb2NrSW1wbGVtZW50YXRpb24oKGNhbGxiYWNrOiAodmFsdWU6IHN0cmluZywga2V5OiBzdHJpbmcpID0+IHZvaWQpID0+IHtcclxuICAgICAgICBjYWxsYmFjaygndGVzdCcsICdzZWFyY2gnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcclxuICAgICAgICB1c2VDYXRlZ29yeU5hdmlnYXRpb24oeyBcclxuICAgICAgICAgIHByZXNlcnZlUGFyYW1zOiB0cnVlLFxyXG4gICAgICAgICAgZW5hYmxlQW5hbHl0aWNzOiB0cnVlIFxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBjYXRlZ29yaWVzID0gWydjYXQxJ107XHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm5hdmlnYXRlVG9GaWx0ZXJlZChjYXRlZ29yaWVzKTtcclxuICAgICAgICAvLyBXYWl0IGZvciBkZWJvdW5jZVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA0MDApKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja1B1c2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvP3NlYXJjaD10ZXN0JmNhdGVnb3JpZXM9Y2F0MScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RvZXMgbm90IHByZXNlcnZlIG90aGVyIHBhcmFtZXRlcnMgd2hlbiBkaXNhYmxlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0dldC5tb2NrSW1wbGVtZW50YXRpb24oKGtleTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NhdGVnb3JpZXMnKSByZXR1cm4gbnVsbDtcclxuICAgICAgICBpZiAoa2V5ID09PSAnc2VhcmNoJykgcmV0dXJuICd0ZXN0JztcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcclxuICAgICAgICB1c2VDYXRlZ29yeU5hdmlnYXRpb24oeyBcclxuICAgICAgICAgIHByZXNlcnZlUGFyYW1zOiBmYWxzZSxcclxuICAgICAgICAgIGVuYWJsZUFuYWx5dGljczogdHJ1ZSBcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IFsnY2F0MSddO1xyXG4gICAgICBcclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgICByZXN1bHQuY3VycmVudC5uYXZpZ2F0ZVRvRmlsdGVyZWQoY2F0ZWdvcmllcyk7XHJcbiAgICAgICAgLy8gV2FpdCBmb3IgZGVib3VuY2VcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNDAwKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tQdXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnLz9jYXRlZ29yaWVzPWNhdDEnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnVVJMIEJ1aWxkaW5nJywgKCkgPT4ge1xyXG4gICAgaXQoJ2J1aWxkcyBjb3JyZWN0IFVSTCB3aXRoIHNpbmdsZSBjYXRlZ29yeScsICgpID0+IHtcclxuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XHJcbiAgICAgIG1vY2tGb3JFYWNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7IC8vIE5vIG90aGVyIHBhcmFtc1xyXG5cclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cclxuICAgICAgICB1c2VDYXRlZ29yeU5hdmlnYXRpb24oKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgdXJsID0gcmVzdWx0LmN1cnJlbnQuZ2V0Q3VycmVudFVybCgpO1xyXG4gICAgICBleHBlY3QodXJsKS50b0JlKCcvJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnYnVpbGRzIGNvcnJlY3QgVVJMIHdpdGggbXVsdGlwbGUgY2F0ZWdvcmllcycsICgpID0+IHtcclxuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUoJ2NhdDEsY2F0MixjYXQzJyk7XHJcbiAgICAgIG1vY2tGb3JFYWNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7IC8vIE5vIG90aGVyIHBhcmFtc1xyXG5cclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cclxuICAgICAgICB1c2VDYXRlZ29yeU5hdmlnYXRpb24oKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgdXJsID0gcmVzdWx0LmN1cnJlbnQuZ2V0Q3VycmVudFVybCgpO1xyXG4gICAgICBleHBlY3QodXJsKS50b0JlKCcvP2NhdGVnb3JpZXM9Y2F0MSUyQ2NhdDIlMkNjYXQzJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnaGFuZGxlcyBlbXB0eSBjYXRlZ29yaWVzIGNvcnJlY3RseScsICgpID0+IHtcclxuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUoJycpO1xyXG4gICAgICBtb2NrRm9yRWFjaC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pOyAvLyBObyBvdGhlciBwYXJhbXNcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XHJcbiAgICAgICAgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IHVybCA9IHJlc3VsdC5jdXJyZW50LmdldEN1cnJlbnRVcmwoKTtcclxuICAgICAgZXhwZWN0KHVybCkudG9CZSgnLycpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdOYXZpZ2F0aW9uIFN0YXRlJywgKCkgPT4ge1xyXG4gICAgaXQoJ3RyYWNrcyBuYXZpZ2F0aW9uIHN0YXRlIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXHJcbiAgICAgICAgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc05hdmlnYXRpbmcpLnRvQmUoZmFsc2UpO1xyXG5cclxuICAgICAgYWN0KCgpID0+IHtcclxuICAgICAgICByZXN1bHQuY3VycmVudC5uYXZpZ2F0ZVRvRmlsdGVyZWQoWydjYXQxJ10pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc05hdmlnYXRpbmcpLnRvQmUodHJ1ZSk7XHJcblxyXG4gICAgICAvLyBXYWl0IGZvciBuYXZpZ2F0aW9uIHRvIGNvbXBsZXRlXHJcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc05hdmlnYXRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdBbmFseXRpY3MgVHJhY2tpbmcnLCAoKSA9PiB7XHJcbiAgICBpdCgndHJhY2tzIG5hdmlnYXRpb24gYW5hbHl0aWNzIHdoZW4gZW5hYmxlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXHJcbiAgICAgICAgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uKHsgZW5hYmxlQW5hbHl0aWNzOiB0cnVlIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm5hdmlnYXRlVG9GaWx0ZXJlZChbJ2NhdDEnLCAnY2F0MiddKTtcclxuICAgICAgICAvLyBXYWl0IGZvciBkZWJvdW5jZVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA0MDApKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0d0YWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAgICdldmVudCcsXHJcbiAgICAgICAgJ2NhdGVnb3J5X25hdmlnYXRpb24nLFxyXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnbmF2aWdhdGlvbicsXHJcbiAgICAgICAgICBldmVudF9sYWJlbDogJ2ZpbHRlcicsXHJcbiAgICAgICAgICB2YWx1ZTogMixcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3RyYWNrcyBjbGVhciBuYXZpZ2F0aW9uIGFuYWx5dGljcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXHJcbiAgICAgICAgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uKHsgZW5hYmxlQW5hbHl0aWNzOiB0cnVlIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm5hdmlnYXRlVG9Ib21lKCk7XHJcbiAgICAgICAgLy8gV2FpdCBmb3IgZGVib3VuY2VcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNDAwKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tHdGFnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgICAnZXZlbnQnLFxyXG4gICAgICAgICdjYXRlZ29yeV9uYXZpZ2F0aW9uJyxcclxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XHJcbiAgICAgICAgICBldmVudF9jYXRlZ29yeTogJ25hdmlnYXRpb24nLFxyXG4gICAgICAgICAgZXZlbnRfbGFiZWw6ICdjbGVhcicsXHJcbiAgICAgICAgICB2YWx1ZTogMCxcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RvZXMgbm90IHRyYWNrIGFuYWx5dGljcyB3aGVuIGRpc2FibGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcclxuICAgICAgICB1c2VDYXRlZ29yeU5hdmlnYXRpb24oeyBlbmFibGVBbmFseXRpY3M6IGZhbHNlIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm5hdmlnYXRlVG9GaWx0ZXJlZChbJ2NhdDEnXSk7XHJcbiAgICAgICAgLy8gV2FpdCBmb3IgZGVib3VuY2VcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNDAwKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tHdGFnKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdDb25maWd1cmF0aW9uIE9wdGlvbnMnLCAoKSA9PiB7XHJcbiAgICBpdCgndXNlcyBjdXN0b20gcGFyYW1ldGVyIG5hbWUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKG51bGwpO1xyXG4gICAgICBtb2NrRm9yRWFjaC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pOyAvLyBObyBvdGhlciBwYXJhbXNcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XHJcbiAgICAgICAgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uKHsgcGFyYW1OYW1lOiAnZmlsdGVycycgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubmF2aWdhdGVUb0ZpbHRlcmVkKFsnY2F0MSddKTtcclxuICAgICAgICAvLyBXYWl0IGZvciBkZWJvdW5jZVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA0MDApKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja1B1c2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvP2ZpbHRlcnM9Y2F0MScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3VzZXMgY3VzdG9tIGJhc2UgcGF0aCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XHJcbiAgICAgIG1vY2tGb3JFYWNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7IC8vIE5vIG90aGVyIHBhcmFtc1xyXG5cclxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cclxuICAgICAgICB1c2VDYXRlZ29yeU5hdmlnYXRpb24oeyBiYXNlUGF0aDogJy9zaG9wJyB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgICByZXN1bHQuY3VycmVudC5uYXZpZ2F0ZVRvRmlsdGVyZWQoWydjYXQxJ10pO1xyXG4gICAgICAgIC8vIFdhaXQgZm9yIGRlYm91bmNlXHJcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDQwMCkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGV4cGVjdChtb2NrUHVzaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9zaG9wP2NhdGVnb3JpZXM9Y2F0MScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Jlc3BlY3RzIGN1c3RvbSBkZWJvdW5jZSBkZWxheScsIGFzeW5jICgpID0+IHtcclxuICAgICAgamVzdC51c2VGYWtlVGltZXJzKCk7XHJcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKG51bGwpO1xyXG4gICAgICBtb2NrRm9yRWFjaC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pOyAvLyBObyBvdGhlciBwYXJhbXNcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XHJcbiAgICAgICAgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uKHsgZGVib3VuY2VEZWxheTogMTAwIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBhY3QoKCkgPT4ge1xyXG4gICAgICAgIHJlc3VsdC5jdXJyZW50Lm5hdmlnYXRlVG9GaWx0ZXJlZChbJ2NhdDEnXSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KG1vY2tQdXNoKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG5cclxuICAgICAgYWN0KCgpID0+IHtcclxuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja1B1c2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvP2NhdGVnb3JpZXM9Y2F0MScpO1xyXG5cclxuICAgICAgamVzdC51c2VSZWFsVGltZXJzKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xyXG4gICAgaXQoJ2hhbmRsZXMgbmF2aWdhdGlvbiBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcclxuICAgICAgLy8gVGVzdCB0aGF0IHRoZSBob29rIGRvZXNuJ3QgY3Jhc2ggd2hlbiBuYXZpZ2F0aW9uIGZhaWxzXHJcbiAgICAgIG1vY2tQdXNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXZpZ2F0aW9uIGZhaWxlZCcpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XHJcbiAgICAgICAgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgd2hlbiBuYXZpZ2F0aW9uIGZhaWxzXHJcbiAgICAgIGV4cGVjdCgoKSA9PiB7XHJcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQubmF2aWdhdGVUb0ZpbHRlcmVkKFsnY2F0MSddKTtcclxuICAgICAgfSkubm90LnRvVGhyb3coKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnQ2xlYW51cCcsICgpID0+IHtcclxuICAgIGl0KCdjbGVhbnMgdXAgZGVib3VuY2UgdGltZXIgb24gdW5tb3VudCcsICgpID0+IHtcclxuICAgICAgLy8gVGhpcyB0ZXN0IHZlcmlmaWVzIHRoYXQgdGhlIGhvb2sgY2xlYW5zIHVwIHByb3Blcmx5XHJcbiAgICAgIC8vIFRoZSBhY3R1YWwgY2xlYW51cCBpcyBoYW5kbGVkIGludGVybmFsbHkgYnkgdGhlIGhvb2tcclxuICAgICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXJIb29rKCgpID0+XHJcbiAgICAgICAgdXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uKClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIFNob3VsZCB1bm1vdW50IHdpdGhvdXQgZXJyb3JzXHJcbiAgICAgIGV4cGVjdCgoKSA9PiB1bm1vdW50KCkpLm5vdC50b1Rocm93KCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZVJvdXRlciIsImZuIiwidXNlU2VhcmNoUGFyYW1zIiwidXNlUGF0aG5hbWUiLCJtb2NrR3RhZyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93IiwidmFsdWUiLCJ3cml0YWJsZSIsImRlc2NyaWJlIiwibW9ja1B1c2giLCJtb2NrR2V0IiwibW9ja0ZvckVhY2giLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXR1cm5WYWx1ZSIsInB1c2giLCJnZXQiLCJmb3JFYWNoIiwibW9ja0NsZWFyIiwiaXQiLCJyZXN1bHQiLCJyZW5kZXJIb29rIiwidXNlQ2F0ZWdvcnlOYXZpZ2F0aW9uIiwiZW5hYmxlQW5hbHl0aWNzIiwiY2F0ZWdvcmllcyIsImFjdCIsImN1cnJlbnQiLCJuYXZpZ2F0ZVRvRmlsdGVyZWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm5hdmlnYXRlVG9Ib21lIiwibW9ja0ltcGxlbWVudGF0aW9uIiwia2V5IiwiY2FsbGJhY2siLCJwcmVzZXJ2ZVBhcmFtcyIsInVybCIsImdldEN1cnJlbnRVcmwiLCJ0b0JlIiwiaXNOYXZpZ2F0aW5nIiwib2JqZWN0Q29udGFpbmluZyIsImV2ZW50X2NhdGVnb3J5IiwiZXZlbnRfbGFiZWwiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwicGFyYW1OYW1lIiwiYmFzZVBhdGgiLCJ1c2VGYWtlVGltZXJzIiwiZGVib3VuY2VEZWxheSIsImFkdmFuY2VU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