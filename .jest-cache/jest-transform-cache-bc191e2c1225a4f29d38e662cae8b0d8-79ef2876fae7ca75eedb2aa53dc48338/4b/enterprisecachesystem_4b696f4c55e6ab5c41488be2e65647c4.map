{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\optimization\\enterprise-cache-system.ts"],"sourcesContent":["/**\n * Sistema Enterprise de Caché Inteligente\n * Extiende el cache manager existente con funcionalidades enterprise avanzadas\n */\n\nimport { cacheManager, CACHE_CONFIGS, type CacheConfig } from '@/lib/cache-manager';\nimport { redisCache } from '@/lib/redis';\nimport { enterpriseAuditSystem } from '@/lib/security/enterprise-audit-system';\nimport { metricsCollector } from '@/lib/rate-limiting/enterprise-rate-limiter';\nimport type { EnterpriseAuthContext } from '@/lib/auth/enterprise-auth-utils';\n\n// =====================================================\n// TIPOS Y INTERFACES ENTERPRISE\n// =====================================================\n\nexport interface EnterpriseCacheConfig extends CacheConfig {\n  // Configuraciones enterprise\n  enableAuditLogging?: boolean;\n  enableMetrics?: boolean;\n  enableInvalidation?: boolean;\n  enableWarmup?: boolean;\n  \n  // Configuraciones de invalidación\n  invalidationPatterns?: string[];\n  dependentKeys?: string[];\n  \n  // Configuraciones de warmup\n  warmupStrategy?: 'eager' | 'lazy' | 'scheduled';\n  warmupInterval?: number;\n  \n  // Configuraciones de seguridad\n  securityLevel?: 'basic' | 'standard' | 'high' | 'critical';\n  encryptData?: boolean;\n  \n  // Configuraciones de performance\n  compressionLevel?: number;\n  maxMemoryUsage?: number;\n  evictionPolicy?: 'lru' | 'lfu' | 'ttl' | 'random';\n}\n\nexport interface CacheMetrics {\n  hits: number;\n  misses: number;\n  hitRate: number;\n  avgResponseTime: number;\n  memoryUsage: number;\n  evictions: number;\n  errors: number;\n  lastAccess: string;\n}\n\nexport interface CacheInvalidationEvent {\n  pattern: string;\n  reason: 'manual' | 'ttl_expired' | 'dependency_changed' | 'memory_pressure';\n  affectedKeys: string[];\n  timestamp: string;\n  triggeredBy?: string;\n}\n\nexport interface CacheWarmupJob {\n  id: string;\n  pattern: string;\n  strategy: 'eager' | 'lazy' | 'scheduled';\n  interval?: number;\n  lastRun?: string;\n  nextRun?: string;\n  status: 'pending' | 'running' | 'completed' | 'failed';\n}\n\n// =====================================================\n// CONFIGURACIONES ENTERPRISE PREDEFINIDAS\n// =====================================================\n\nexport const ENTERPRISE_CACHE_CONFIGS: Record<string, EnterpriseCacheConfig> = {\n  // Cache crítico para datos de autenticación\n  AUTH_CRITICAL: {\n    ...CACHE_CONFIGS.SYSTEM_CONFIG,\n    ttl: 300, // 5 minutos\n    prefix: 'auth_critical',\n    enableAuditLogging: true,\n    enableMetrics: true,\n    enableInvalidation: true,\n    securityLevel: 'critical',\n    encryptData: true,\n    compressionLevel: 9,\n    evictionPolicy: 'ttl'\n  },\n\n  // Cache para datos de productos con invalidación inteligente\n  PRODUCTS_SMART: {\n    ...CACHE_CONFIGS.PRODUCT_DATA,\n    ttl: 1800, // 30 minutos\n    prefix: 'products_smart',\n    enableAuditLogging: false,\n    enableMetrics: true,\n    enableInvalidation: true,\n    enableWarmup: true,\n    invalidationPatterns: ['product:*', 'category:*', 'inventory:*'],\n    dependentKeys: ['categories', 'brands', 'pricing'],\n    warmupStrategy: 'scheduled',\n    warmupInterval: 3600, // 1 hora\n    securityLevel: 'standard',\n    compressionLevel: 6,\n    evictionPolicy: 'lru'\n  },\n\n  // Cache para APIs públicas con alta performance\n  PUBLIC_PERFORMANCE: {\n    ttl: 600, // 10 minutos\n    prefix: 'public_perf',\n    compress: true,\n    serialize: true,\n    enableAuditLogging: false,\n    enableMetrics: true,\n    enableInvalidation: true,\n    enableWarmup: true,\n    warmupStrategy: 'eager',\n    securityLevel: 'basic',\n    compressionLevel: 3,\n    maxMemoryUsage: 100 * 1024 * 1024, // 100MB\n    evictionPolicy: 'lfu'\n  },\n\n  // Cache para sesiones de usuario\n  USER_SESSIONS: {\n    ttl: 7200, // 2 horas\n    prefix: 'user_sessions',\n    compress: false,\n    serialize: true,\n    enableAuditLogging: true,\n    enableMetrics: true,\n    enableInvalidation: true,\n    securityLevel: 'high',\n    encryptData: true,\n    evictionPolicy: 'ttl'\n  },\n\n  // Cache para métricas y analytics\n  ANALYTICS_DATA: {\n    ttl: 900, // 15 minutos\n    prefix: 'analytics',\n    compress: true,\n    serialize: true,\n    enableAuditLogging: false,\n    enableMetrics: true,\n    enableInvalidation: true,\n    enableWarmup: true,\n    warmupStrategy: 'lazy',\n    securityLevel: 'standard',\n    compressionLevel: 8,\n    evictionPolicy: 'lru'\n  }\n};\n\n// =====================================================\n// SISTEMA ENTERPRISE DE CACHÉ\n// =====================================================\n\nexport class EnterpriseCacheSystem {\n  private static instance: EnterpriseCacheSystem;\n  private metrics: Map<string, CacheMetrics> = new Map();\n  private invalidationJobs: Map<string, CacheInvalidationEvent> = new Map();\n  private warmupJobs: Map<string, CacheWarmupJob> = new Map();\n  private isInitialized = false;\n\n  private constructor() {}\n\n  public static getInstance(): EnterpriseCacheSystem {\n    if (!EnterpriseCacheSystem.instance) {\n      EnterpriseCacheSystem.instance = new EnterpriseCacheSystem();\n    }\n    return EnterpriseCacheSystem.instance;\n  }\n\n  /**\n   * Inicializa el sistema enterprise de caché\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Inicializar jobs de warmup programados\n      await this.initializeWarmupJobs();\n      \n      // Inicializar limpieza automática\n      this.startCleanupScheduler();\n      \n      // Inicializar monitoreo de memoria\n      this.startMemoryMonitoring();\n      \n      this.isInitialized = true;\n      console.log('[ENTERPRISE_CACHE] Sistema inicializado correctamente');\n    } catch (error) {\n      console.error('[ENTERPRISE_CACHE] Error inicializando sistema:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtiene datos del caché con funcionalidades enterprise\n   */\n  async get<T>(\n    key: string, \n    config: EnterpriseCacheConfig,\n    context?: EnterpriseAuthContext\n  ): Promise<T | null> {\n    const startTime = Date.now();\n    const fullKey = this.generateKey(config, key);\n\n    try {\n      // Verificar permisos de acceso si es necesario\n      if (config.securityLevel === 'critical' && context) {\n        await this.verifyAccess(fullKey, context);\n      }\n\n      // Intentar obtener del caché\n      const result = await cacheManager.get<T>(key, config);\n      const responseTime = Date.now() - startTime;\n\n      // Actualizar métricas\n      if (config.enableMetrics) {\n        this.updateMetrics(fullKey, result !== null, responseTime);\n      }\n\n      // Registrar acceso si está habilitado\n      if (config.enableAuditLogging && context) {\n        await this.logCacheAccess('GET', fullKey, result !== null, context);\n      }\n\n      return result;\n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      \n      // Actualizar métricas de error\n      if (config.enableMetrics) {\n        this.updateErrorMetrics(fullKey, responseTime);\n      }\n\n      console.error('[ENTERPRISE_CACHE] Error en get:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Establece datos en el caché con funcionalidades enterprise\n   */\n  async set<T>(\n    key: string, \n    value: T, \n    config: EnterpriseCacheConfig,\n    context?: EnterpriseAuthContext\n  ): Promise<boolean> {\n    const startTime = Date.now();\n    const fullKey = this.generateKey(config, key);\n\n    try {\n      // Verificar permisos de escritura si es necesario\n      if (config.securityLevel === 'critical' && context) {\n        await this.verifyWriteAccess(fullKey, context);\n      }\n\n      // Encriptar datos si está configurado\n      let processedValue = value;\n      if (config.encryptData) {\n        processedValue = await this.encryptData(value) as T;\n      }\n\n      // Establecer en caché\n      const success = await cacheManager.set(key, processedValue, config);\n      const responseTime = Date.now() - startTime;\n\n      // Actualizar métricas\n      if (config.enableMetrics) {\n        this.updateSetMetrics(fullKey, success, responseTime);\n      }\n\n      // Registrar escritura si está habilitado\n      if (config.enableAuditLogging && context) {\n        await this.logCacheAccess('SET', fullKey, success, context);\n      }\n\n      // Programar invalidación de dependencias si es necesario\n      if (config.enableInvalidation && config.dependentKeys) {\n        await this.scheduleDependencyInvalidation(fullKey, config.dependentKeys);\n      }\n\n      return success;\n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      \n      // Actualizar métricas de error\n      if (config.enableMetrics) {\n        this.updateErrorMetrics(fullKey, responseTime);\n      }\n\n      console.error('[ENTERPRISE_CACHE] Error en set:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Invalidación inteligente de caché\n   */\n  async invalidate(\n    pattern: string, \n    reason: CacheInvalidationEvent['reason'] = 'manual',\n    context?: EnterpriseAuthContext\n  ): Promise<string[]> {\n    try {\n      const affectedKeys = await this.findKeysByPattern(pattern);\n      \n      // Eliminar claves del caché\n      const deletionPromises = affectedKeys.map(key => redisCache.del(key));\n      await Promise.all(deletionPromises);\n\n      // Registrar evento de invalidación\n      const invalidationEvent: CacheInvalidationEvent = {\n        pattern,\n        reason,\n        affectedKeys,\n        timestamp: new Date().toISOString(),\n        triggeredBy: context?.userId\n      };\n\n      this.invalidationJobs.set(\n        `inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        invalidationEvent\n      );\n\n      // Registrar en auditoría si hay contexto\n      if (context) {\n        await enterpriseAuditSystem.logEnterpriseEvent({\n          user_id: context.userId,\n          event_type: 'CACHE_INVALIDATION' as any,\n          event_category: 'system_operation',\n          severity: 'medium' as any,\n          description: `Cache invalidation: ${pattern}`,\n          metadata: {\n            pattern,\n            reason,\n            affected_keys_count: affectedKeys.length,\n            affected_keys: affectedKeys.slice(0, 10) // Primeras 10 para no saturar\n          },\n          ip_address: context.ipAddress,\n          user_agent: context.userAgent\n        }, context);\n      }\n\n      console.log(`[ENTERPRISE_CACHE] Invalidated ${affectedKeys.length} keys for pattern: ${pattern}`);\n      return affectedKeys;\n    } catch (error) {\n      console.error('[ENTERPRISE_CACHE] Error en invalidación:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Warmup inteligente de caché\n   */\n  async warmup(\n    keys: string[], \n    config: EnterpriseCacheConfig,\n    dataFetcher: (key: string) => Promise<any>\n  ): Promise<void> {\n    const jobId = `warmup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const warmupJob: CacheWarmupJob = {\n      id: jobId,\n      pattern: keys.join(','),\n      strategy: config.warmupStrategy || 'lazy',\n      interval: config.warmupInterval,\n      lastRun: new Date().toISOString(),\n      status: 'running'\n    };\n\n    this.warmupJobs.set(jobId, warmupJob);\n\n    try {\n      const warmupPromises = keys.map(async (key) => {\n        try {\n          // Verificar si ya existe en caché\n          const existing = await this.get(key, config);\n          if (existing !== null) {\n            return; // Ya está en caché\n          }\n\n          // Obtener datos y cachear\n          const data = await dataFetcher(key);\n          await this.set(key, data, config);\n        } catch (error) {\n          console.warn(`[ENTERPRISE_CACHE] Error warming up key ${key}:`, error);\n        }\n      });\n\n      await Promise.all(warmupPromises);\n      \n      // Actualizar estado del job\n      warmupJob.status = 'completed';\n      warmupJob.nextRun = config.warmupInterval ? \n        new Date(Date.now() + config.warmupInterval * 1000).toISOString() : \n        undefined;\n\n      console.log(`[ENTERPRISE_CACHE] Warmup completed for ${keys.length} keys`);\n    } catch (error) {\n      warmupJob.status = 'failed';\n      console.error('[ENTERPRISE_CACHE] Error en warmup:', error);\n    }\n  }\n\n  /**\n   * Obtiene métricas del sistema de caché\n   */\n  getMetrics(): Record<string, CacheMetrics> {\n    return Object.fromEntries(this.metrics);\n  }\n\n  /**\n   * Obtiene estadísticas de invalidación\n   */\n  getInvalidationStats(): CacheInvalidationEvent[] {\n    return Array.from(this.invalidationJobs.values());\n  }\n\n  /**\n   * Obtiene estadísticas de warmup\n   */\n  getWarmupStats(): CacheWarmupJob[] {\n    return Array.from(this.warmupJobs.values());\n  }\n\n  // =====================================================\n  // MÉTODOS PRIVADOS\n  // =====================================================\n\n  private generateKey(config: EnterpriseCacheConfig, key: string): string {\n    return `${config.prefix}:${key}`;\n  }\n\n  private async verifyAccess(key: string, context: EnterpriseAuthContext): Promise<void> {\n    // Verificar permisos de acceso para datos críticos\n    if (!context.permissions.includes('cache_access') && \n        !context.permissions.includes('admin_access')) {\n      throw new Error('Insufficient permissions for cache access');\n    }\n  }\n\n  private async verifyWriteAccess(key: string, context: EnterpriseAuthContext): Promise<void> {\n    // Verificar permisos de escritura para datos críticos\n    if (!context.permissions.includes('cache_write') && \n        !context.permissions.includes('admin_access')) {\n      throw new Error('Insufficient permissions for cache write');\n    }\n  }\n\n  private async encryptData(data: any): Promise<any> {\n    // Implementación básica de encriptación\n    // En producción, usar una librería de encriptación robusta\n    try {\n      const jsonString = JSON.stringify(data);\n      const encoded = Buffer.from(jsonString).toString('base64');\n      return { encrypted: true, data: encoded };\n    } catch (error) {\n      console.warn('[ENTERPRISE_CACHE] Error encriptando datos:', error);\n      return data;\n    }\n  }\n\n  private updateMetrics(key: string, hit: boolean, responseTime: number): void {\n    const existing = this.metrics.get(key) || {\n      hits: 0,\n      misses: 0,\n      hitRate: 0,\n      avgResponseTime: 0,\n      memoryUsage: 0,\n      evictions: 0,\n      errors: 0,\n      lastAccess: new Date().toISOString()\n    };\n\n    if (hit) {\n      existing.hits++;\n    } else {\n      existing.misses++;\n    }\n\n    const totalRequests = existing.hits + existing.misses;\n    existing.hitRate = totalRequests > 0 ? existing.hits / totalRequests : 0;\n    existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;\n    existing.lastAccess = new Date().toISOString();\n\n    this.metrics.set(key, existing);\n  }\n\n  private updateSetMetrics(key: string, success: boolean, responseTime: number): void {\n    const existing = this.metrics.get(key) || {\n      hits: 0,\n      misses: 0,\n      hitRate: 0,\n      avgResponseTime: 0,\n      memoryUsage: 0,\n      evictions: 0,\n      errors: 0,\n      lastAccess: new Date().toISOString()\n    };\n\n    existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;\n    existing.lastAccess = new Date().toISOString();\n\n    if (!success) {\n      existing.errors++;\n    }\n\n    this.metrics.set(key, existing);\n  }\n\n  private updateErrorMetrics(key: string, responseTime: number): void {\n    const existing = this.metrics.get(key) || {\n      hits: 0,\n      misses: 0,\n      hitRate: 0,\n      avgResponseTime: 0,\n      memoryUsage: 0,\n      evictions: 0,\n      errors: 0,\n      lastAccess: new Date().toISOString()\n    };\n\n    existing.errors++;\n    existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;\n    existing.lastAccess = new Date().toISOString();\n\n    this.metrics.set(key, existing);\n  }\n\n  private async logCacheAccess(\n    operation: 'GET' | 'SET',\n    key: string,\n    success: boolean,\n    context: EnterpriseAuthContext\n  ): Promise<void> {\n    try {\n      await enterpriseAuditSystem.logEnterpriseEvent({\n        user_id: context.userId,\n        event_type: 'CACHE_ACCESS' as any,\n        event_category: 'system_operation',\n        severity: 'low' as any,\n        description: `Cache ${operation}: ${key}`,\n        metadata: {\n          operation,\n          key,\n          success,\n          cache_system: 'enterprise'\n        },\n        ip_address: context.ipAddress,\n        user_agent: context.userAgent\n      }, context);\n    } catch (error) {\n      console.warn('[ENTERPRISE_CACHE] Error logging cache access:', error);\n    }\n  }\n\n  private async findKeysByPattern(pattern: string): Promise<string[]> {\n    try {\n      // Usar Redis SCAN para encontrar claves por patrón\n      const keys: string[] = [];\n      const client = redisCache['client']; // Acceder al cliente Redis interno\n      \n      if (client && typeof client.scanStream === 'function') {\n        const stream = client.scanStream({\n          match: pattern,\n          count: 100\n        });\n\n        return new Promise((resolve, reject) => {\n          stream.on('data', (resultKeys: string[]) => {\n            keys.push(...resultKeys);\n          });\n\n          stream.on('end', () => {\n            resolve(keys);\n          });\n\n          stream.on('error', (error: Error) => {\n            reject(error);\n          });\n        });\n      }\n\n      return keys;\n    } catch (error) {\n      console.error('[ENTERPRISE_CACHE] Error finding keys by pattern:', error);\n      return [];\n    }\n  }\n\n  private async scheduleDependencyInvalidation(key: string, dependentKeys: string[]): Promise<void> {\n    // Programar invalidación de claves dependientes\n    // Esto se podría implementar con un job queue como Bull o Agenda\n    setTimeout(async () => {\n      for (const depKey of dependentKeys) {\n        await this.invalidate(depKey, 'dependency_changed');\n      }\n    }, 1000); // 1 segundo de delay\n  }\n\n  private async initializeWarmupJobs(): Promise<void> {\n    // Inicializar jobs de warmup programados\n    // En una implementación real, esto se cargaría desde una base de datos\n    console.log('[ENTERPRISE_CACHE] Warmup jobs initialized');\n  }\n\n  private startCleanupScheduler(): void {\n    // Limpiar métricas antiguas cada hora\n    setInterval(() => {\n      const oneHourAgo = Date.now() - 60 * 60 * 1000;\n      \n      for (const [key, metrics] of this.metrics.entries()) {\n        const lastAccessTime = new Date(metrics.lastAccess).getTime();\n        if (lastAccessTime < oneHourAgo) {\n          this.metrics.delete(key);\n        }\n      }\n    }, 60 * 60 * 1000); // 1 hora\n  }\n\n  private startMemoryMonitoring(): void {\n    // Monitorear uso de memoria cada 5 minutos\n    setInterval(() => {\n      const memoryUsage = process.memoryUsage();\n      \n      if (memoryUsage.heapUsed > 500 * 1024 * 1024) { // 500MB\n        console.warn('[ENTERPRISE_CACHE] High memory usage detected:', memoryUsage);\n        // Aquí se podría implementar limpieza automática\n      }\n    }, 5 * 60 * 1000); // 5 minutos\n  }\n}\n\n// =====================================================\n// INSTANCIA SINGLETON Y UTILIDADES\n// =====================================================\n\nexport const enterpriseCacheSystem = EnterpriseCacheSystem.getInstance();\n\n/**\n * Funciones de utilidad para casos comunes\n */\nexport const EnterpriseCacheUtils = {\n  /**\n   * Cache para datos de autenticación críticos\n   */\n  async cacheAuthData<T>(key: string, fetcher: () => Promise<T>, context: EnterpriseAuthContext): Promise<T> {\n    const cached = await enterpriseCacheSystem.get<T>(key, ENTERPRISE_CACHE_CONFIGS.AUTH_CRITICAL, context);\n    if (cached !== null) return cached;\n\n    const data = await fetcher();\n    await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.AUTH_CRITICAL, context);\n    return data;\n  },\n\n  /**\n   * Cache inteligente para productos\n   */\n  async cacheProductData<T>(key: string, fetcher: () => Promise<T>): Promise<T> {\n    const cached = await enterpriseCacheSystem.get<T>(key, ENTERPRISE_CACHE_CONFIGS.PRODUCTS_SMART);\n    if (cached !== null) return cached;\n\n    const data = await fetcher();\n    await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.PRODUCTS_SMART);\n    return data;\n  },\n\n  /**\n   * Cache de alta performance para APIs públicas\n   */\n  async cachePublicData<T>(key: string, fetcher: () => Promise<T>): Promise<T> {\n    const cached = await enterpriseCacheSystem.get<T>(key, ENTERPRISE_CACHE_CONFIGS.PUBLIC_PERFORMANCE);\n    if (cached !== null) return cached;\n\n    const data = await fetcher();\n    await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.PUBLIC_PERFORMANCE);\n    return data;\n  },\n\n  /**\n   * Invalidación masiva por patrones\n   */\n  async invalidateByPatterns(patterns: string[], context?: EnterpriseAuthContext): Promise<void> {\n    const invalidationPromises = patterns.map(pattern => \n      enterpriseCacheSystem.invalidate(pattern, 'manual', context)\n    );\n    await Promise.all(invalidationPromises);\n  }\n};\n"],"names":["ENTERPRISE_CACHE_CONFIGS","EnterpriseCacheSystem","EnterpriseCacheUtils","enterpriseCacheSystem","AUTH_CRITICAL","CACHE_CONFIGS","SYSTEM_CONFIG","ttl","prefix","enableAuditLogging","enableMetrics","enableInvalidation","securityLevel","encryptData","compressionLevel","evictionPolicy","PRODUCTS_SMART","PRODUCT_DATA","enableWarmup","invalidationPatterns","dependentKeys","warmupStrategy","warmupInterval","PUBLIC_PERFORMANCE","compress","serialize","maxMemoryUsage","USER_SESSIONS","ANALYTICS_DATA","metrics","Map","invalidationJobs","warmupJobs","isInitialized","getInstance","instance","initialize","initializeWarmupJobs","startCleanupScheduler","startMemoryMonitoring","console","log","error","get","key","config","context","startTime","Date","now","fullKey","generateKey","verifyAccess","result","cacheManager","responseTime","updateMetrics","logCacheAccess","updateErrorMetrics","set","value","verifyWriteAccess","processedValue","success","updateSetMetrics","scheduleDependencyInvalidation","invalidate","pattern","reason","affectedKeys","findKeysByPattern","deletionPromises","map","redisCache","del","Promise","all","invalidationEvent","timestamp","toISOString","triggeredBy","userId","Math","random","toString","substr","enterpriseAuditSystem","logEnterpriseEvent","user_id","event_type","event_category","severity","description","metadata","affected_keys_count","length","affected_keys","slice","ip_address","ipAddress","user_agent","userAgent","warmup","keys","dataFetcher","jobId","warmupJob","id","join","strategy","interval","lastRun","status","warmupPromises","existing","data","warn","nextRun","undefined","getMetrics","Object","fromEntries","getInvalidationStats","Array","from","values","getWarmupStats","permissions","includes","Error","jsonString","JSON","stringify","encoded","Buffer","encrypted","hit","hits","misses","hitRate","avgResponseTime","memoryUsage","evictions","errors","lastAccess","totalRequests","operation","cache_system","client","scanStream","stream","match","count","resolve","reject","on","resultKeys","push","setTimeout","depKey","setInterval","oneHourAgo","entries","lastAccessTime","getTime","delete","process","heapUsed","cacheAuthData","fetcher","cached","cacheProductData","cachePublicData","invalidateByPatterns","patterns","invalidationPromises"],"mappings":"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"}