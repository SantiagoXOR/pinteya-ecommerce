15a4c105437b1f7fc4939ee799a2e8d0
"use strict";
// Mock dependencies
jest.mock('@clerk/nextjs/server');
jest.mock('@/lib/supabase');
jest.mock('@/lib/rate-limiter');
jest.mock('@/lib/metrics');
jest.mock('@/lib/logger');
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../../app/api/payments/reports/route");
const _server1 = require("@clerk/nextjs/server");
const mockAuth = _server1.auth;
describe('/api/payments/reports', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock environment variables
        process.env.MERCADOPAGO_ACCESS_TOKEN = 'APP_USR_test_token';
        process.env.NODE_ENV = 'test';
    });
    describe('GET', ()=>{
        it('should return 401 when user is not authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('No autorizado');
        });
        it('should return report data when user is authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                gte: jest.fn().mockReturnThis(),
                lte: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                in: jest.fn().mockResolvedValue({
                    data: [
                        {
                            id: 1,
                            total_amount: 1000,
                            status: 'completed',
                            payment_status: 'approved',
                            created_at: '2024-01-01T00:00:00Z',
                            updated_at: '2024-01-01T01:00:00Z',
                            order_items: [
                                {
                                    quantity: 2,
                                    unit_price: 500,
                                    products: {
                                        name: 'Test Product',
                                        category_id: 'cat_1'
                                    }
                                }
                            ]
                        }
                    ],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data).toBeDefined();
            expect(data.data.type).toBe('account_money');
            expect(data.data.records).toBeDefined();
            expect(Array.isArray(data.data.records)).toBe(true);
            expect(data.data.total_records).toBeDefined();
        });
        it('should handle different report types', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                gte: jest.fn().mockReturnThis(),
                lte: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                in: jest.fn().mockResolvedValue({
                    data: [],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            // Test released_money report
            const request1 = new _server.NextRequest('http://localhost:3000/api/payments/reports?type=released_money');
            const response1 = await (0, _route.GET)(request1);
            const data1 = await response1.json();
            expect(response1.status).toBe(200);
            expect(data1.data.type).toBe('released_money');
            // Test sales_report
            const request2 = new _server.NextRequest('http://localhost:3000/api/payments/reports?type=sales_report');
            const response2 = await (0, _route.GET)(request2);
            const data2 = await response2.json();
            expect(response2.status).toBe(200);
            expect(data2.data.type).toBe('sales_report');
        });
        it('should validate report type parameter', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports?type=invalid_type');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Tipo de reporte invÃ¡lido');
        });
        it('should include metrics when requested', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                gte: jest.fn().mockReturnThis(),
                lte: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                in: jest.fn().mockResolvedValue({
                    data: [
                        {
                            id: 1,
                            total_amount: 1000,
                            status: 'completed',
                            payment_status: 'approved',
                            created_at: '2024-01-01T00:00:00Z',
                            updated_at: '2024-01-01T01:00:00Z',
                            order_items: []
                        }
                    ],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports?include_metrics=true');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.data.metrics).toBeDefined();
            expect(data.data.metrics.total_transactions).toBeDefined();
            expect(data.data.metrics.total_amount).toBeDefined();
            expect(data.data.metrics.successful_payments).toBeDefined();
            expect(data.data.metrics.failed_payments).toBeDefined();
            expect(data.data.metrics.conversion_rate).toBeDefined();
            expect(data.data.metrics.average_ticket).toBeDefined();
        });
        it('should handle date range parameters', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                gte: jest.fn().mockReturnThis(),
                lte: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                in: jest.fn().mockResolvedValue({
                    data: [],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const dateFrom = '2024-01-01';
            const dateTo = '2024-01-31';
            const request = new _server.NextRequest(`http://localhost:3000/api/payments/reports?date_from=${dateFrom}&date_to=${dateTo}`);
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.data.date_from).toContain('2024-01-01');
            expect(data.data.date_to).toContain('2024-01-31');
        });
        it('should handle rate limiting', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter to return failure
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: false,
                remaining: 0,
                resetTime: Date.now() + 60000
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(429);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Demasiadas solicitudes');
        });
    });
    describe('POST', ()=>{
        it('should return 401 when user is not authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports', {
                method: 'POST',
                body: JSON.stringify({
                    type: 'account_money',
                    date_from: '2024-01-01',
                    date_to: '2024-01-31'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('No autorizado');
        });
        it('should create a new report when user is authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            const requestBody = {
                type: 'account_money',
                date_from: '2024-01-01',
                date_to: '2024-01-31'
            };
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports', {
                method: 'POST',
                body: JSON.stringify(requestBody)
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(201);
            expect(data.success).toBe(true);
            expect(data.data).toBeDefined();
            expect(data.data.id).toBeDefined();
            expect(data.data.type).toBe('account_money');
            expect(data.data.date_from).toBe('2024-01-01');
            expect(data.data.date_to).toBe('2024-01-31');
            expect(data.data.status).toBe('pending');
            expect(data.data.created_at).toBeDefined();
        });
        it('should validate required parameters', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Test missing type
            const request1 = new _server.NextRequest('http://localhost:3000/api/payments/reports', {
                method: 'POST',
                body: JSON.stringify({
                    date_from: '2024-01-01',
                    date_to: '2024-01-31'
                })
            });
            const response1 = await (0, _route.POST)(request1);
            const data1 = await response1.json();
            expect(response1.status).toBe(400);
            expect(data1.success).toBe(false);
            expect(data1.error).toBe('Faltan parÃ¡metros requeridos');
            // Test missing date_from
            const request2 = new _server.NextRequest('http://localhost:3000/api/payments/reports', {
                method: 'POST',
                body: JSON.stringify({
                    type: 'account_money',
                    date_to: '2024-01-31'
                })
            });
            const response2 = await (0, _route.POST)(request2);
            const data2 = await response2.json();
            expect(response2.status).toBe(400);
            expect(data2.success).toBe(false);
            expect(data2.error).toBe('Faltan parÃ¡metros requeridos');
        });
        it('should handle rate limiting for report creation', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter to return failure
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: false,
                remaining: 0,
                resetTime: Date.now() + 60000
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports', {
                method: 'POST',
                body: JSON.stringify({
                    type: 'account_money',
                    date_from: '2024-01-01',
                    date_to: '2024-01-31'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(429);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Demasiadas solicitudes');
        });
        it('should handle errors gracefully', async ()=>{
            mockAuth.mockRejectedValue(new Error('Auth service error'));
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports', {
                method: 'POST',
                body: JSON.stringify({
                    type: 'account_money',
                    date_from: '2024-01-01',
                    date_to: '2024-01-31'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Error interno del servidor');
        });
        it('should include processing time in response', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/reports', {
                method: 'POST',
                body: JSON.stringify({
                    type: 'account_money',
                    date_from: '2024-01-01',
                    date_to: '2024-01-31'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(201);
            expect(data.processing_time).toBeDefined();
            expect(typeof data.processing_time).toBe('number');
            expect(data.processing_time).toBeGreaterThanOrEqual(0);
            expect(data.timestamp).toBeDefined();
            expect(typeof data.timestamp).toBe('number');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxhcGlcXHBheW1lbnRzXFxyZXBvcnRzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QgfSBmcm9tICduZXh0L3NlcnZlcic7XHJcbmltcG9ydCB7IEdFVCwgUE9TVCB9IGZyb20gJ0AvYXBwL2FwaS9wYXltZW50cy9yZXBvcnRzL3JvdXRlJztcclxuaW1wb3J0IHsgYXV0aCB9IGZyb20gJ0BjbGVyay9uZXh0anMvc2VydmVyJztcclxuXHJcbi8vIE1vY2sgZGVwZW5kZW5jaWVzXHJcbmplc3QubW9jaygnQGNsZXJrL25leHRqcy9zZXJ2ZXInKTtcclxuamVzdC5tb2NrKCdAL2xpYi9zdXBhYmFzZScpO1xyXG5qZXN0Lm1vY2soJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG5qZXN0Lm1vY2soJ0AvbGliL21ldHJpY3MnKTtcclxuamVzdC5tb2NrKCdAL2xpYi9sb2dnZXInKTtcclxuXHJcbmNvbnN0IG1vY2tBdXRoID0gYXV0aCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBhdXRoPjtcclxuXHJcbmRlc2NyaWJlKCcvYXBpL3BheW1lbnRzL3JlcG9ydHMnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICAgIFxyXG4gICAgLy8gTW9jayBlbnZpcm9ubWVudCB2YXJpYWJsZXNcclxuICAgIHByb2Nlc3MuZW52Lk1FUkNBRE9QQUdPX0FDQ0VTU19UT0tFTiA9ICdBUFBfVVNSX3Rlc3RfdG9rZW4nO1xyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAndGVzdCc7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdHRVQnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgd2hlbiB1c2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogbnVsbCB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVwb3J0cycpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdObyBhdXRvcml6YWRvJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiByZXBvcnQgZGF0YSB3aGVuIHVzZXIgaXMgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6ICd1c2VyXzEyMycgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIHJhdGUgbGltaXRlclxyXG4gICAgICBjb25zdCB7IGNoZWNrUmF0ZUxpbWl0IH0gPSByZXF1aXJlKCdAL2xpYi9yYXRlLWxpbWl0ZXInKTtcclxuICAgICAgY2hlY2tSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCByZW1haW5pbmc6IDEwIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayBtZXRyaWNzIGNvbGxlY3RvclxyXG4gICAgICBjb25zdCB7IG1ldHJpY3NDb2xsZWN0b3IgfSA9IHJlcXVpcmUoJ0AvbGliL21ldHJpY3MnKTtcclxuICAgICAgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRBcGlDYWxsLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAvLyBNb2NrIFN1cGFiYXNlXHJcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJyk7XHJcbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcclxuICAgICAgICBmcm9tOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGd0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgbHRlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgaW46IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgICBkYXRhOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBpZDogMSxcclxuICAgICAgICAgICAgICB0b3RhbF9hbW91bnQ6IDEwMDAsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJyxcclxuICAgICAgICAgICAgICBwYXltZW50X3N0YXR1czogJ2FwcHJvdmVkJyxcclxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMDowMDowMFonLFxyXG4gICAgICAgICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAxOjAwOjAwWicsXHJcbiAgICAgICAgICAgICAgb3JkZXJfaXRlbXM6IFtcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IDIsXHJcbiAgICAgICAgICAgICAgICAgIHVuaXRfcHJpY2U6IDUwMCxcclxuICAgICAgICAgICAgICAgICAgcHJvZHVjdHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVGVzdCBQcm9kdWN0JyxcclxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeV9pZDogJ2NhdF8xJ1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVwb3J0cycpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YSkudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS50eXBlKS50b0JlKCdhY2NvdW50X21vbmV5Jyk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEucmVjb3JkcykudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhLnJlY29yZHMpKS50b0JlKHRydWUpO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhLnRvdGFsX3JlY29yZHMpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkaWZmZXJlbnQgcmVwb3J0IHR5cGVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIG1ldHJpY3MgY29sbGVjdG9yXHJcbiAgICAgIGNvbnN0IHsgbWV0cmljc0NvbGxlY3RvciB9ID0gcmVxdWlyZSgnQC9saWIvbWV0cmljcycpO1xyXG4gICAgICBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZEFwaUNhbGwubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcclxuXHJcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2VcclxuICAgICAgY29uc3QgeyBnZXRTdXBhYmFzZUNsaWVudCB9ID0gcmVxdWlyZSgnQC9saWIvc3VwYWJhc2UnKTtcclxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlID0ge1xyXG4gICAgICAgIGZyb206IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgZ3RlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBsdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBpbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIC8vIFRlc3QgcmVsZWFzZWRfbW9uZXkgcmVwb3J0XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QxID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlcG9ydHM/dHlwZT1yZWxlYXNlZF9tb25leScpO1xyXG4gICAgICBjb25zdCByZXNwb25zZTEgPSBhd2FpdCBHRVQocmVxdWVzdDEpO1xyXG4gICAgICBjb25zdCBkYXRhMSA9IGF3YWl0IHJlc3BvbnNlMS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2UxLnN0YXR1cykudG9CZSgyMDApO1xyXG4gICAgICBleHBlY3QoZGF0YTEuZGF0YS50eXBlKS50b0JlKCdyZWxlYXNlZF9tb25leScpO1xyXG5cclxuICAgICAgLy8gVGVzdCBzYWxlc19yZXBvcnRcclxuICAgICAgY29uc3QgcmVxdWVzdDIgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVwb3J0cz90eXBlPXNhbGVzX3JlcG9ydCcpO1xyXG4gICAgICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBHRVQocmVxdWVzdDIpO1xyXG4gICAgICBjb25zdCBkYXRhMiA9IGF3YWl0IHJlc3BvbnNlMi5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2UyLnN0YXR1cykudG9CZSgyMDApO1xyXG4gICAgICBleHBlY3QoZGF0YTIuZGF0YS50eXBlKS50b0JlKCdzYWxlc19yZXBvcnQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgcmVwb3J0IHR5cGUgcGFyYW1ldGVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlcG9ydHM/dHlwZT1pbnZhbGlkX3R5cGUnKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnVGlwbyBkZSByZXBvcnRlIGludsOhbGlkbycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIG1ldHJpY3Mgd2hlbiByZXF1ZXN0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXJcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgcmVtYWluaW5nOiAxMCB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgbWV0cmljcyBjb2xsZWN0b3JcclxuICAgICAgY29uc3QgeyBtZXRyaWNzQ29sbGVjdG9yIH0gPSByZXF1aXJlKCdAL2xpYi9tZXRyaWNzJyk7XHJcbiAgICAgIG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkQXBpQ2FsbC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xyXG5cclxuICAgICAgLy8gTW9jayBTdXBhYmFzZVxyXG4gICAgICBjb25zdCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xyXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2UgPSB7XHJcbiAgICAgICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBndGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGx0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGluOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgaWQ6IDEsXHJcbiAgICAgICAgICAgICAgdG90YWxfYW1vdW50OiAxMDAwLFxyXG4gICAgICAgICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcsXHJcbiAgICAgICAgICAgICAgcGF5bWVudF9zdGF0dXM6ICdhcHByb3ZlZCcsXHJcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcclxuICAgICAgICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNC0wMS0wMVQwMTowMDowMFonLFxyXG4gICAgICAgICAgICAgIG9yZGVyX2l0ZW1zOiBbXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVwb3J0cz9pbmNsdWRlX21ldHJpY3M9dHJ1ZScpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5tZXRyaWNzKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhLm1ldHJpY3MudG90YWxfdHJhbnNhY3Rpb25zKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhLm1ldHJpY3MudG90YWxfYW1vdW50KS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhLm1ldHJpY3Muc3VjY2Vzc2Z1bF9wYXltZW50cykudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5tZXRyaWNzLmZhaWxlZF9wYXltZW50cykudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5tZXRyaWNzLmNvbnZlcnNpb25fcmF0ZSkudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5tZXRyaWNzLmF2ZXJhZ2VfdGlja2V0KS50b0JlRGVmaW5lZCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZGF0ZSByYW5nZSBwYXJhbWV0ZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIG1ldHJpY3MgY29sbGVjdG9yXHJcbiAgICAgIGNvbnN0IHsgbWV0cmljc0NvbGxlY3RvciB9ID0gcmVxdWlyZSgnQC9saWIvbWV0cmljcycpO1xyXG4gICAgICBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZEFwaUNhbGwubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcclxuXHJcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2VcclxuICAgICAgY29uc3QgeyBnZXRTdXBhYmFzZUNsaWVudCB9ID0gcmVxdWlyZSgnQC9saWIvc3VwYWJhc2UnKTtcclxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlID0ge1xyXG4gICAgICAgIGZyb206IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgZ3RlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBsdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBpbjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IGRhdGVGcm9tID0gJzIwMjQtMDEtMDEnO1xyXG4gICAgICBjb25zdCBkYXRlVG8gPSAnMjAyNC0wMS0zMSc7XHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVwb3J0cz9kYXRlX2Zyb209JHtkYXRlRnJvbX0mZGF0ZV90bz0ke2RhdGVUb31gKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEuZGF0ZV9mcm9tKS50b0NvbnRhaW4oJzIwMjQtMDEtMDEnKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5kYXRlX3RvKS50b0NvbnRhaW4oJzIwMjQtMDEtMzEnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJhdGUgbGltaXRpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXIgdG8gcmV0dXJuIGZhaWx1cmVcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxyXG4gICAgICAgIHJlbWFpbmluZzogMCxcclxuICAgICAgICByZXNldFRpbWU6IERhdGUubm93KCkgKyA2MDAwMCBcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlcG9ydHMnKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQyOSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnRGVtYXNpYWRhcyBzb2xpY2l0dWRlcycpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdQT1NUJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIHdoZW4gdXNlciBpcyBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6IG51bGwgfSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlcG9ydHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgdHlwZTogJ2FjY291bnRfbW9uZXknLFxyXG4gICAgICAgICAgZGF0ZV9mcm9tOiAnMjAyNC0wMS0wMScsXHJcbiAgICAgICAgICBkYXRlX3RvOiAnMjAyNC0wMS0zMSdcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xyXG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ05vIGF1dG9yaXphZG8nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IHJlcG9ydCB3aGVuIHVzZXIgaXMgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6ICd1c2VyXzEyMycgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIHJhdGUgbGltaXRlclxyXG4gICAgICBjb25zdCB7IGNoZWNrUmF0ZUxpbWl0IH0gPSByZXF1aXJlKCdAL2xpYi9yYXRlLWxpbWl0ZXInKTtcclxuICAgICAgY2hlY2tSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCByZW1haW5pbmc6IDEwIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayBtZXRyaWNzIGNvbGxlY3RvclxyXG4gICAgICBjb25zdCB7IG1ldHJpY3NDb2xsZWN0b3IgfSA9IHJlcXVpcmUoJ0AvbGliL21ldHJpY3MnKTtcclxuICAgICAgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRBcGlDYWxsLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcclxuICAgICAgICB0eXBlOiAnYWNjb3VudF9tb25leScsXHJcbiAgICAgICAgZGF0ZV9mcm9tOiAnMjAyNC0wMS0wMScsXHJcbiAgICAgICAgZGF0ZV90bzogJzIwMjQtMDEtMzEnXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlcG9ydHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEuaWQpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEudHlwZSkudG9CZSgnYWNjb3VudF9tb25leScpO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhLmRhdGVfZnJvbSkudG9CZSgnMjAyNC0wMS0wMScpO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhLmRhdGVfdG8pLnRvQmUoJzIwMjQtMDEtMzEnKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5zdGF0dXMpLnRvQmUoJ3BlbmRpbmcnKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5jcmVhdGVkX2F0KS50b0JlRGVmaW5lZCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSByZXF1aXJlZCBwYXJhbWV0ZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBUZXN0IG1pc3NpbmcgdHlwZVxyXG4gICAgICBjb25zdCByZXF1ZXN0MSA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZXBvcnRzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIGRhdGVfZnJvbTogJzIwMjQtMDEtMDEnLFxyXG4gICAgICAgICAgZGF0ZV90bzogJzIwMjQtMDEtMzEnXHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlMSA9IGF3YWl0IFBPU1QocmVxdWVzdDEpO1xyXG4gICAgICBjb25zdCBkYXRhMSA9IGF3YWl0IHJlc3BvbnNlMS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2UxLnN0YXR1cykudG9CZSg0MDApO1xyXG4gICAgICBleHBlY3QoZGF0YTEuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhMS5lcnJvcikudG9CZSgnRmFsdGFuIHBhcsOhbWV0cm9zIHJlcXVlcmlkb3MnKTtcclxuXHJcbiAgICAgIC8vIFRlc3QgbWlzc2luZyBkYXRlX2Zyb21cclxuICAgICAgY29uc3QgcmVxdWVzdDIgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVwb3J0cycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICB0eXBlOiAnYWNjb3VudF9tb25leScsXHJcbiAgICAgICAgICBkYXRlX3RvOiAnMjAyNC0wMS0zMSdcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgUE9TVChyZXF1ZXN0Mik7XHJcbiAgICAgIGNvbnN0IGRhdGEyID0gYXdhaXQgcmVzcG9uc2UyLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZTIuc3RhdHVzKS50b0JlKDQwMCk7XHJcbiAgICAgIGV4cGVjdChkYXRhMi5zdWNjZXNzKS50b0JlKGZhbHNlKTtcclxuICAgICAgZXhwZWN0KGRhdGEyLmVycm9yKS50b0JlKCdGYWx0YW4gcGFyw6FtZXRyb3MgcmVxdWVyaWRvcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmF0ZSBsaW1pdGluZyBmb3IgcmVwb3J0IGNyZWF0aW9uJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyIHRvIHJldHVybiBmYWlsdXJlXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcclxuICAgICAgICByZW1haW5pbmc6IDAsXHJcbiAgICAgICAgcmVzZXRUaW1lOiBEYXRlLm5vdygpICsgNjAwMDAgXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZXBvcnRzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHR5cGU6ICdhY2NvdW50X21vbmV5JyxcclxuICAgICAgICAgIGRhdGVfZnJvbTogJzIwMjQtMDEtMDEnLFxyXG4gICAgICAgICAgZGF0ZV90bzogJzIwMjQtMDEtMzEnXHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDI5KTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdEZW1hc2lhZGFzIHNvbGljaXR1ZGVzJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdBdXRoIHNlcnZpY2UgZXJyb3InKSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlcG9ydHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgdHlwZTogJ2FjY291bnRfbW9uZXknLFxyXG4gICAgICAgICAgZGF0ZV9mcm9tOiAnMjAyNC0wMS0wMScsXHJcbiAgICAgICAgICBkYXRlX3RvOiAnMjAyNC0wMS0zMSdcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xyXG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0Vycm9yIGludGVybm8gZGVsIHNlcnZpZG9yJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGluY2x1ZGUgcHJvY2Vzc2luZyB0aW1lIGluIHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIG1ldHJpY3MgY29sbGVjdG9yXHJcbiAgICAgIGNvbnN0IHsgbWV0cmljc0NvbGxlY3RvciB9ID0gcmVxdWlyZSgnQC9saWIvbWV0cmljcycpO1xyXG4gICAgICBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZEFwaUNhbGwubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVwb3J0cycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICB0eXBlOiAnYWNjb3VudF9tb25leScsXHJcbiAgICAgICAgICBkYXRlX2Zyb206ICcyMDI0LTAxLTAxJyxcclxuICAgICAgICAgIGRhdGVfdG86ICcyMDI0LTAxLTMxJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnByb2Nlc3NpbmdfdGltZSkudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KHR5cGVvZiBkYXRhLnByb2Nlc3NpbmdfdGltZSkudG9CZSgnbnVtYmVyJyk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnByb2Nlc3NpbmdfdGltZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcclxuICAgICAgZXhwZWN0KGRhdGEudGltZXN0YW1wKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QodHlwZW9mIGRhdGEudGltZXN0YW1wKS50b0JlKCdudW1iZXInKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwibW9ja0F1dGgiLCJhdXRoIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsInByb2Nlc3MiLCJlbnYiLCJNRVJDQURPUEFHT19BQ0NFU1NfVE9LRU4iLCJOT0RFX0VOViIsIml0IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ1c2VySWQiLCJyZXF1ZXN0IiwiTmV4dFJlcXVlc3QiLCJyZXNwb25zZSIsIkdFVCIsImRhdGEiLCJqc29uIiwiZXhwZWN0Iiwic3RhdHVzIiwidG9CZSIsInN1Y2Nlc3MiLCJlcnJvciIsImNoZWNrUmF0ZUxpbWl0IiwicmVxdWlyZSIsInJlbWFpbmluZyIsIm1ldHJpY3NDb2xsZWN0b3IiLCJyZWNvcmRBcGlDYWxsIiwidW5kZWZpbmVkIiwiZ2V0U3VwYWJhc2VDbGllbnQiLCJtb2NrU3VwYWJhc2UiLCJmcm9tIiwiZm4iLCJtb2NrUmV0dXJuVGhpcyIsInNlbGVjdCIsImd0ZSIsImx0ZSIsImVxIiwiaW4iLCJpZCIsInRvdGFsX2Ftb3VudCIsInBheW1lbnRfc3RhdHVzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJvcmRlcl9pdGVtcyIsInF1YW50aXR5IiwidW5pdF9wcmljZSIsInByb2R1Y3RzIiwibmFtZSIsImNhdGVnb3J5X2lkIiwibW9ja1JldHVyblZhbHVlIiwidG9CZURlZmluZWQiLCJ0eXBlIiwicmVjb3JkcyIsIkFycmF5IiwiaXNBcnJheSIsInRvdGFsX3JlY29yZHMiLCJyZXF1ZXN0MSIsInJlc3BvbnNlMSIsImRhdGExIiwicmVxdWVzdDIiLCJyZXNwb25zZTIiLCJkYXRhMiIsIm1ldHJpY3MiLCJ0b3RhbF90cmFuc2FjdGlvbnMiLCJzdWNjZXNzZnVsX3BheW1lbnRzIiwiZmFpbGVkX3BheW1lbnRzIiwiY29udmVyc2lvbl9yYXRlIiwiYXZlcmFnZV90aWNrZXQiLCJkYXRlRnJvbSIsImRhdGVUbyIsImRhdGVfZnJvbSIsInRvQ29udGFpbiIsImRhdGVfdG8iLCJyZXNldFRpbWUiLCJEYXRlIiwibm93IiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJQT1NUIiwicmVxdWVzdEJvZHkiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwicHJvY2Vzc2luZ190aW1lIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInRpbWVzdGFtcCJdLCJtYXBwaW5ncyI6IjtBQUlBLG9CQUFvQjtBQUNwQkEsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQzs7Ozt3QkFUa0I7dUJBQ0Y7eUJBQ0w7QUFTckIsTUFBTUMsV0FBV0MsYUFBSTtBQUVyQkMsU0FBUyx5QkFBeUI7SUFDaENDLFdBQVc7UUFDVEwsS0FBS00sYUFBYTtRQUVsQiw2QkFBNkI7UUFDN0JDLFFBQVFDLEdBQUcsQ0FBQ0Msd0JBQXdCLEdBQUc7UUFDdkNGLFFBQVFDLEdBQUcsQ0FBQ0UsUUFBUSxHQUFHO0lBQ3pCO0lBRUFOLFNBQVMsT0FBTztRQUNkTyxHQUFHLG9EQUFvRDtZQUNyRFQsU0FBU1UsaUJBQWlCLENBQUM7Z0JBQUVDLFFBQVE7WUFBSztZQUUxQyxNQUFNQyxVQUFV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