{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\hooks\\admin\\useOrdersCache.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - ORDERS CACHE HOOK\n// Hook especializado para manejo de cache de órdenes\n// ===================================\n\nimport { useCallback, useRef } from 'react';\nimport { StrictOrdersListResponse } from '@/types/api-strict';\nimport { StrictOrderFilters } from './useOrdersEnterpriseStrict';\n\n// ===================================\n// TIPOS Y CONFIGURACIÓN\n// ===================================\n\ninterface CacheEntry {\n  data: StrictOrdersListResponse;\n  timestamp: number;\n  filters: StrictOrderFilters;\n  requestId: string;\n}\n\ninterface CacheOptions {\n  enableCache: boolean;\n  cacheTimeout: number;\n  maxSize?: number;\n  cleanupInterval?: number;\n  minRequestInterval?: number;\n}\n\n// Configuración de cache\nconst CACHE_CONFIG = {\n  MAX_SIZE: 50,\n  CLEANUP_INTERVAL: 10 * 60 * 1000, // 10 minutos\n  MIN_REQUEST_INTERVAL: 1000, // 1 segundo mínimo entre peticiones idénticas\n} as const;\n\n// ===================================\n// CACHE GLOBAL\n// ===================================\n\n// Cache compartido entre instancias del hook\nconst cache = new Map<string, CacheEntry>();\nconst pendingRequests = new Map<string, Promise<any>>();\nconst requestTimestamps = new Map<string, number>();\n\n// ===================================\n// UTILIDADES DE CACHE\n// ===================================\n\nfunction getCacheKey(filters: StrictOrderFilters): string {\n  // Crear clave más estable ordenando las propiedades y normalizando valores\n  const normalizedFilters = Object.keys(filters)\n    .sort()\n    .reduce((result, key) => {\n      const value = filters[key as keyof StrictOrderFilters];\n      // Normalizar valores para evitar claves duplicadas\n      if (value !== undefined && value !== null && value !== '' && value !== 'all') {\n        result[key] = value;\n      }\n      return result;\n    }, {} as any);\n  return JSON.stringify(normalizedFilters);\n}\n\nfunction cleanupExpiredCache(cacheTimeout: number): void {\n  const now = Date.now();\n  const expiredKeys: string[] = [];\n  \n  cache.forEach((entry, key) => {\n    if (now - entry.timestamp > cacheTimeout) {\n      expiredKeys.push(key);\n    }\n  });\n  \n  expiredKeys.forEach(key => {\n    cache.delete(key);\n    requestTimestamps.delete(key);\n  });\n  \n  // Limpiar cache si está muy grande\n  if (cache.size > CACHE_CONFIG.MAX_SIZE) {\n    const entries = Array.from(cache.entries());\n    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n    \n    const toDelete = entries.slice(0, cache.size - CACHE_CONFIG.MAX_SIZE);\n    toDelete.forEach(([key]) => {\n      cache.delete(key);\n      requestTimestamps.delete(key);\n    });\n  }\n  \n  if (process.env.NODE_ENV === 'development') {\n    console.log('[useOrdersCache] Cache cleanup completed:', {\n      expired: expiredKeys.length,\n      currentSize: cache.size,\n      maxSize: CACHE_CONFIG.MAX_SIZE\n    });\n  }\n}\n\n// ===================================\n// HOOK DE CACHE\n// ===================================\n\nexport interface UseOrdersCacheReturn {\n  getCachedData: (filters: StrictOrderFilters) => StrictOrdersListResponse | null;\n  setCachedData: (filters: StrictOrderFilters, data: StrictOrdersListResponse) => void;\n  clearCache: () => void;\n  isRequestTooRecent: (filters: StrictOrderFilters) => boolean;\n  setPendingRequest: (filters: StrictOrderFilters, promise: Promise<any>) => void;\n  getPendingRequest: (filters: StrictOrderFilters) => Promise<any> | null;\n  getCacheStats: () => { size: number; maxSize: number; pendingRequests: number };\n}\n\nexport function useOrdersCache(options: CacheOptions): UseOrdersCacheReturn {\n  const lastCleanupRef = useRef<number>(Date.now());\n  \n  const getCachedData = useCallback((filters: StrictOrderFilters): StrictOrdersListResponse | null => {\n    if (!options.enableCache) return null;\n    \n    const key = getCacheKey(filters);\n    const entry = cache.get(key);\n    \n    if (!entry) return null;\n    \n    const isExpired = Date.now() - entry.timestamp > options.cacheTimeout;\n    if (isExpired) {\n      cache.delete(key);\n      requestTimestamps.delete(key);\n      return null;\n    }\n    \n    // Log de cache hit en desarrollo\n    if (process.env.NODE_ENV === 'development') {\n      console.log('[useOrdersCache] Cache hit:', { \n        key: key.substring(0, 100) + '...', \n        age: Date.now() - entry.timestamp,\n        cacheSize: cache.size \n      });\n    }\n    \n    return entry.data;\n  }, [options.enableCache, options.cacheTimeout]);\n  \n  const setCachedData = useCallback((filters: StrictOrderFilters, data: StrictOrdersListResponse): void => {\n    if (!options.enableCache) return;\n    \n    const key = getCacheKey(filters);\n    const requestId = Math.random().toString(36).substr(2, 9);\n    \n    cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      filters,\n      requestId\n    });\n    \n    requestTimestamps.set(key, Date.now());\n    \n    // Cleanup automático periódico\n    const now = Date.now();\n    if (now - lastCleanupRef.current > (options.cleanupInterval || CACHE_CONFIG.CLEANUP_INTERVAL)) {\n      cleanupExpiredCache(options.cacheTimeout);\n      lastCleanupRef.current = now;\n    }\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.log('[useOrdersCache] Data cached:', {\n        key: key.substring(0, 100) + '...',\n        cacheSize: cache.size,\n        requestId\n      });\n    }\n  }, [options.enableCache, options.cacheTimeout, options.cleanupInterval]);\n  \n  const clearCache = useCallback((): void => {\n    cache.clear();\n    pendingRequests.clear();\n    requestTimestamps.clear();\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.log('[useOrdersCache] Cache cleared');\n    }\n  }, []);\n  \n  const isRequestTooRecent = useCallback((filters: StrictOrderFilters): boolean => {\n    const key = getCacheKey(filters);\n    const lastRequestTime = requestTimestamps.get(key);\n    \n    if (!lastRequestTime) return false;\n    \n    const timeSinceLastRequest = Date.now() - lastRequestTime;\n    return timeSinceLastRequest < (options.minRequestInterval || CACHE_CONFIG.MIN_REQUEST_INTERVAL);\n  }, [options.minRequestInterval]);\n  \n  const setPendingRequest = useCallback((filters: StrictOrderFilters, promise: Promise<any>): void => {\n    const key = getCacheKey(filters);\n    pendingRequests.set(key, promise);\n    \n    // Limpiar cuando la promesa se resuelve\n    promise.finally(() => {\n      pendingRequests.delete(key);\n    });\n  }, []);\n  \n  const getPendingRequest = useCallback((filters: StrictOrderFilters): Promise<any> | null => {\n    const key = getCacheKey(filters);\n    return pendingRequests.get(key) || null;\n  }, []);\n  \n  const getCacheStats = useCallback(() => ({\n    size: cache.size,\n    maxSize: options.maxSize || CACHE_CONFIG.MAX_SIZE,\n    pendingRequests: pendingRequests.size\n  }), [options.maxSize]);\n  \n  return {\n    getCachedData,\n    setCachedData,\n    clearCache,\n    isRequestTooRecent,\n    setPendingRequest,\n    getPendingRequest,\n    getCacheStats\n  };\n}\n"],"names":["useOrdersCache","CACHE_CONFIG","MAX_SIZE","CLEANUP_INTERVAL","MIN_REQUEST_INTERVAL","cache","Map","pendingRequests","requestTimestamps","getCacheKey","filters","normalizedFilters","Object","keys","sort","reduce","result","key","value","undefined","JSON","stringify","cleanupExpiredCache","cacheTimeout","now","Date","expiredKeys","forEach","entry","timestamp","push","delete","size","entries","Array","from","a","b","toDelete","slice","process","env","NODE_ENV","console","log","expired","length","currentSize","maxSize","options","lastCleanupRef","useRef","getCachedData","useCallback","enableCache","get","isExpired","substring","age","cacheSize","data","setCachedData","requestId","Math","random","toString","substr","set","current","cleanupInterval","clearCache","clear","isRequestTooRecent","lastRequestTime","timeSinceLastRequest","minRequestInterval","setPendingRequest","promise","finally","getPendingRequest","getCacheStats"],"mappings":"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"}