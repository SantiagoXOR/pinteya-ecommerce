adb1ba80c1ea572309447d61ae6147af
"use strict";
// Mock dependencies
jest.mock('@clerk/nextjs/server');
jest.mock('@/lib/supabase', ()=>({
        getSupabaseClient: jest.fn()
    }));
jest.mock('@/lib/rate-limiter', ()=>({
        checkRateLimit: jest.fn(),
        addRateLimitHeaders: jest.fn(),
        RATE_LIMIT_CONFIGS: {
            PAYMENT_CREATION: {
                requests: 10,
                window: 3600
            },
            ANALYTICS: {
                requests: 100,
                window: 3600
            }
        }
    }));
jest.mock('@/lib/metrics', ()=>({
        metricsCollector: {
            recordApiCall: jest.fn()
        }
    }));
jest.mock('@/lib/logger', ()=>({
        logger: {
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            INFO: 'info',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            API: 'api',
            PAYMENT: 'payment'
        }
    }));
jest.mock('@/lib/mercadopago', ()=>({
        createMercadoPagoClient: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../../../src/app/api/payments/refunds/route");
const _server1 = require("@clerk/nextjs/server");
const mockAuth = _server1.auth;
describe('/api/payments/refunds', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock environment variables
        process.env.MERCADOPAGO_ACCESS_TOKEN = 'APP_USR_test_token';
        process.env.NODE_ENV = 'test';
    });
    describe('POST', ()=>{
        it('should return 401 when user is not authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'payment_123',
                    amount: 1000
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('No autorizado');
        });
        it('should process refund when user is authenticated and payment exists', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                single: jest.fn().mockResolvedValue({
                    data: {
                        id: 1,
                        total_amount: 1000,
                        payment_status: 'approved',
                        external_reference: 'payment_123'
                    },
                    error: null
                }),
                update: jest.fn().mockReturnThis(),
                insert: jest.fn().mockResolvedValue({
                    data: null,
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const requestBody = {
                payment_id: 'payment_123',
                amount: 500,
                reason: 'Customer request'
            };
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify(requestBody)
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data).toBeDefined();
            expect(data.data.payment_id).toBe('payment_123');
            expect(data.data.amount).toBe(500);
            expect(data.data.status).toBeDefined();
        });
        it('should validate required payment_id', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    amount: 500
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('payment_id es requerido');
        });
        it('should return 404 when payment is not found', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock Supabase to return no order
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                single: jest.fn().mockResolvedValue({
                    data: null,
                    error: {
                        message: 'Not found'
                    }
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'nonexistent_payment'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(404);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Pago no encontrado');
        });
        it('should validate payment status is approved', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock Supabase to return pending payment
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                single: jest.fn().mockResolvedValue({
                    data: {
                        id: 1,
                        total_amount: 1000,
                        payment_status: 'pending',
                        external_reference: 'payment_123'
                    },
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'payment_123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Solo se pueden reembolsar pagos aprobados');
        });
        it('should validate refund amount does not exceed original payment', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                single: jest.fn().mockResolvedValue({
                    data: {
                        id: 1,
                        total_amount: 1000,
                        payment_status: 'approved',
                        external_reference: 'payment_123'
                    },
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'payment_123',
                    amount: 1500 // More than original payment
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('El monto del reembolso no puede ser mayor al pago original');
        });
        it('should handle rate limiting', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter to return failure
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: false,
                remaining: 0,
                resetTime: Date.now() + 60000
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'payment_123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(429);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Demasiadas solicitudes');
        });
    });
    describe('GET', ()=>{
        it('should return 401 when user is not authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('No autorizado');
        });
        it('should return refunds list when user is authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                order: jest.fn().mockReturnThis(),
                range: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({
                    data: [
                        {
                            id: 1,
                            payment_id: 'payment_123',
                            refund_id: 'refund_456',
                            amount: 500,
                            status: 'approved',
                            created_at: '2024-01-01T00:00:00Z',
                            orders: {
                                id: 1,
                                total_amount: 1000,
                                created_at: '2024-01-01T00:00:00Z'
                            }
                        }
                    ],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data).toBeDefined();
            expect(Array.isArray(data.data)).toBe(true);
            expect(data.pagination).toBeDefined();
        });
        it('should handle pagination parameters', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                order: jest.fn().mockReturnThis(),
                range: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({
                    data: [],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds?limit=5&offset=10');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.pagination.limit).toBe(5);
            expect(data.pagination.offset).toBe(10);
        });
        it('should filter by status when provided', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                order: jest.fn().mockReturnThis(),
                range: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({
                    data: [],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds?status=approved');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'approved');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXGJhY2t1cC1jbGVyay1taWdyYXRpb25cXF9fdGVzdHNfX1xcYXBpXFxwYXltZW50c1xccmVmdW5kcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xyXG5pbXBvcnQgeyBHRVQsIFBPU1QgfSBmcm9tICdAL2FwcC9hcGkvcGF5bWVudHMvcmVmdW5kcy9yb3V0ZSc7XHJcbmltcG9ydCB7IGF1dGggfSBmcm9tICdAY2xlcmsvbmV4dGpzL3NlcnZlcic7XHJcblxyXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xyXG5qZXN0Lm1vY2soJ0BjbGVyay9uZXh0anMvc2VydmVyJyk7XHJcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xyXG4gIGdldFN1cGFiYXNlQ2xpZW50OiBqZXN0LmZuKClcclxufSkpO1xyXG5qZXN0Lm1vY2soJ0AvbGliL3JhdGUtbGltaXRlcicsICgpID0+ICh7XHJcbiAgY2hlY2tSYXRlTGltaXQ6IGplc3QuZm4oKSxcclxuICBhZGRSYXRlTGltaXRIZWFkZXJzOiBqZXN0LmZuKCksXHJcbiAgUkFURV9MSU1JVF9DT05GSUdTOiB7XHJcbiAgICBQQVlNRU5UX0NSRUFUSU9OOiB7IHJlcXVlc3RzOiAxMCwgd2luZG93OiAzNjAwIH0sXHJcbiAgICBBTkFMWVRJQ1M6IHsgcmVxdWVzdHM6IDEwMCwgd2luZG93OiAzNjAwIH1cclxuICB9XHJcbn0pKTtcclxuamVzdC5tb2NrKCdAL2xpYi9tZXRyaWNzJywgKCkgPT4gKHtcclxuICBtZXRyaWNzQ29sbGVjdG9yOiB7XHJcbiAgICByZWNvcmRBcGlDYWxsOiBqZXN0LmZuKClcclxuICB9XHJcbn0pKTtcclxuamVzdC5tb2NrKCdAL2xpYi9sb2dnZXInLCAoKSA9PiAoe1xyXG4gIGxvZ2dlcjoge1xyXG4gICAgaW5mbzogamVzdC5mbigpLFxyXG4gICAgd2FybjogamVzdC5mbigpLFxyXG4gICAgZXJyb3I6IGplc3QuZm4oKVxyXG4gIH0sXHJcbiAgTG9nTGV2ZWw6IHtcclxuICAgIElORk86ICdpbmZvJyxcclxuICAgIFdBUk46ICd3YXJuJyxcclxuICAgIEVSUk9SOiAnZXJyb3InXHJcbiAgfSxcclxuICBMb2dDYXRlZ29yeToge1xyXG4gICAgQVBJOiAnYXBpJyxcclxuICAgIFBBWU1FTlQ6ICdwYXltZW50J1xyXG4gIH1cclxufSkpO1xyXG5qZXN0Lm1vY2soJ0AvbGliL21lcmNhZG9wYWdvJywgKCkgPT4gKHtcclxuICBjcmVhdGVNZXJjYWRvUGFnb0NsaWVudDogamVzdC5mbigpXHJcbn0pKTtcclxuXHJcbmNvbnN0IG1vY2tBdXRoID0gYXV0aCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBhdXRoPjtcclxuXHJcbmRlc2NyaWJlKCcvYXBpL3BheW1lbnRzL3JlZnVuZHMnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICAgIFxyXG4gICAgLy8gTW9jayBlbnZpcm9ubWVudCB2YXJpYWJsZXNcclxuICAgIHByb2Nlc3MuZW52Lk1FUkNBRE9QQUdPX0FDQ0VTU19UT0tFTiA9ICdBUFBfVVNSX3Rlc3RfdG9rZW4nO1xyXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPSAndGVzdCc7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdQT1NUJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIHdoZW4gdXNlciBpcyBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6IG51bGwgfSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlZnVuZHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgcGF5bWVudF9pZDogJ3BheW1lbnRfMTIzJyxcclxuICAgICAgICAgIGFtb3VudDogMTAwMFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnTm8gYXV0b3JpemFkbycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBwcm9jZXNzIHJlZnVuZCB3aGVuIHVzZXIgaXMgYXV0aGVudGljYXRlZCBhbmQgcGF5bWVudCBleGlzdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXJcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgcmVtYWluaW5nOiAxMCB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgbWV0cmljcyBjb2xsZWN0b3JcclxuICAgICAgY29uc3QgeyBtZXRyaWNzQ29sbGVjdG9yIH0gPSByZXF1aXJlKCdAL2xpYi9tZXRyaWNzJyk7XHJcbiAgICAgIG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkQXBpQ2FsbC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xyXG5cclxuICAgICAgLy8gTW9jayBTdXBhYmFzZVxyXG4gICAgICBjb25zdCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xyXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2UgPSB7XHJcbiAgICAgICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICBpZDogMSxcclxuICAgICAgICAgICAgdG90YWxfYW1vdW50OiAxMDAwLFxyXG4gICAgICAgICAgICBwYXltZW50X3N0YXR1czogJ2FwcHJvdmVkJyxcclxuICAgICAgICAgICAgZXh0ZXJuYWxfcmVmZXJlbmNlOiAncGF5bWVudF8xMjMnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KSxcclxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGluc2VydDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSlcclxuICAgICAgfTtcclxuICAgICAgZ2V0U3VwYWJhc2VDbGllbnQubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcclxuICAgICAgICBwYXltZW50X2lkOiAncGF5bWVudF8xMjMnLFxyXG4gICAgICAgIGFtb3VudDogNTAwLFxyXG4gICAgICAgIHJlYXNvbjogJ0N1c3RvbWVyIHJlcXVlc3QnXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlZnVuZHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEucGF5bWVudF9pZCkudG9CZSgncGF5bWVudF8xMjMnKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5hbW91bnQpLnRvQmUoNTAwKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5zdGF0dXMpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHJlcXVpcmVkIHBheW1lbnRfaWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXJcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgcmVtYWluaW5nOiAxMCB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVmdW5kcycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBhbW91bnQ6IDUwMFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgncGF5bWVudF9pZCBlcyByZXF1ZXJpZG8nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIDQwNCB3aGVuIHBheW1lbnQgaXMgbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIHRvIHJldHVybiBubyBvcmRlclxyXG4gICAgICBjb25zdCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xyXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2UgPSB7XHJcbiAgICAgICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogbnVsbCxcclxuICAgICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdOb3QgZm91bmQnIH1cclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVmdW5kcycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBwYXltZW50X2lkOiAnbm9uZXhpc3RlbnRfcGF5bWVudCdcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDQpO1xyXG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ1BhZ28gbm8gZW5jb250cmFkbycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBwYXltZW50IHN0YXR1cyBpcyBhcHByb3ZlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6ICd1c2VyXzEyMycgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIHJhdGUgbGltaXRlclxyXG4gICAgICBjb25zdCB7IGNoZWNrUmF0ZUxpbWl0IH0gPSByZXF1aXJlKCdAL2xpYi9yYXRlLWxpbWl0ZXInKTtcclxuICAgICAgY2hlY2tSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCByZW1haW5pbmc6IDEwIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayBTdXBhYmFzZSB0byByZXR1cm4gcGVuZGluZyBwYXltZW50XHJcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJyk7XHJcbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcclxuICAgICAgICBmcm9tOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIGlkOiAxLFxyXG4gICAgICAgICAgICB0b3RhbF9hbW91bnQ6IDEwMDAsXHJcbiAgICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiAncGVuZGluZycsXHJcbiAgICAgICAgICAgIGV4dGVybmFsX3JlZmVyZW5jZTogJ3BheW1lbnRfMTIzJ1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVycm9yOiBudWxsXHJcbiAgICAgICAgfSlcclxuICAgICAgfTtcclxuICAgICAgZ2V0U3VwYWJhc2VDbGllbnQubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlZnVuZHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgcGF5bWVudF9pZDogJ3BheW1lbnRfMTIzJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnU29sbyBzZSBwdWVkZW4gcmVlbWJvbHNhciBwYWdvcyBhcHJvYmFkb3MnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgcmVmdW5kIGFtb3VudCBkb2VzIG5vdCBleGNlZWQgb3JpZ2luYWwgcGF5bWVudCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6ICd1c2VyXzEyMycgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIHJhdGUgbGltaXRlclxyXG4gICAgICBjb25zdCB7IGNoZWNrUmF0ZUxpbWl0IH0gPSByZXF1aXJlKCdAL2xpYi9yYXRlLWxpbWl0ZXInKTtcclxuICAgICAgY2hlY2tSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCByZW1haW5pbmc6IDEwIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayBTdXBhYmFzZVxyXG4gICAgICBjb25zdCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xyXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2UgPSB7XHJcbiAgICAgICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICBpZDogMSxcclxuICAgICAgICAgICAgdG90YWxfYW1vdW50OiAxMDAwLFxyXG4gICAgICAgICAgICBwYXltZW50X3N0YXR1czogJ2FwcHJvdmVkJyxcclxuICAgICAgICAgICAgZXh0ZXJuYWxfcmVmZXJlbmNlOiAncGF5bWVudF8xMjMnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVmdW5kcycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBwYXltZW50X2lkOiAncGF5bWVudF8xMjMnLFxyXG4gICAgICAgICAgYW1vdW50OiAxNTAwIC8vIE1vcmUgdGhhbiBvcmlnaW5hbCBwYXltZW50XHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdFbCBtb250byBkZWwgcmVlbWJvbHNvIG5vIHB1ZWRlIHNlciBtYXlvciBhbCBwYWdvIG9yaWdpbmFsJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByYXRlIGxpbWl0aW5nJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyIHRvIHJldHVybiBmYWlsdXJlXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcclxuICAgICAgICByZW1haW5pbmc6IDAsXHJcbiAgICAgICAgcmVzZXRUaW1lOiBEYXRlLm5vdygpICsgNjAwMDAgXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZWZ1bmRzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHBheW1lbnRfaWQ6ICdwYXltZW50XzEyMydcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MjkpO1xyXG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0RlbWFzaWFkYXMgc29saWNpdHVkZXMnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnR0VUJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDAxIHdoZW4gdXNlciBpcyBub3QgYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6IG51bGwgfSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlZnVuZHMnKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnTm8gYXV0b3JpemFkbycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gcmVmdW5kcyBsaXN0IHdoZW4gdXNlciBpcyBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIG1ldHJpY3MgY29sbGVjdG9yXHJcbiAgICAgIGNvbnN0IHsgbWV0cmljc0NvbGxlY3RvciB9ID0gcmVxdWlyZSgnQC9saWIvbWV0cmljcycpO1xyXG4gICAgICBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZEFwaUNhbGwubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcclxuXHJcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2VcclxuICAgICAgY29uc3QgeyBnZXRTdXBhYmFzZUNsaWVudCB9ID0gcmVxdWlyZSgnQC9saWIvc3VwYWJhc2UnKTtcclxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlID0ge1xyXG4gICAgICAgIGZyb206IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgb3JkZXI6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHJhbmdlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgIGlkOiAxLFxyXG4gICAgICAgICAgICAgIHBheW1lbnRfaWQ6ICdwYXltZW50XzEyMycsXHJcbiAgICAgICAgICAgICAgcmVmdW5kX2lkOiAncmVmdW5kXzQ1NicsXHJcbiAgICAgICAgICAgICAgYW1vdW50OiA1MDAsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiAnYXBwcm92ZWQnLFxyXG4gICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXHJcbiAgICAgICAgICAgICAgb3JkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBpZDogMSxcclxuICAgICAgICAgICAgICAgIHRvdGFsX2Ftb3VudDogMTAwMCxcclxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWidcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgICBlcnJvcjogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH07XHJcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZWZ1bmRzJyk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xyXG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QoQXJyYXkuaXNBcnJheShkYXRhLmRhdGEpKS50b0JlKHRydWUpO1xyXG4gICAgICBleHBlY3QoZGF0YS5wYWdpbmF0aW9uKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcGFnaW5hdGlvbiBwYXJhbWV0ZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIG1ldHJpY3MgY29sbGVjdG9yXHJcbiAgICAgIGNvbnN0IHsgbWV0cmljc0NvbGxlY3RvciB9ID0gcmVxdWlyZSgnQC9saWIvbWV0cmljcycpO1xyXG4gICAgICBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZEFwaUNhbGwubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcclxuXHJcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2VcclxuICAgICAgY29uc3QgeyBnZXRTdXBhYmFzZUNsaWVudCB9ID0gcmVxdWlyZSgnQC9saWIvc3VwYWJhc2UnKTtcclxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlID0ge1xyXG4gICAgICAgIGZyb206IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgb3JkZXI6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHJhbmdlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6IFtdLFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVmdW5kcz9saW1pdD01Jm9mZnNldD0xMCcpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcclxuICAgICAgZXhwZWN0KGRhdGEucGFnaW5hdGlvbi5saW1pdCkudG9CZSg1KTtcclxuICAgICAgZXhwZWN0KGRhdGEucGFnaW5hdGlvbi5vZmZzZXQpLnRvQmUoMTApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBmaWx0ZXIgYnkgc3RhdHVzIHdoZW4gcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXJcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgcmVtYWluaW5nOiAxMCB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgbWV0cmljcyBjb2xsZWN0b3JcclxuICAgICAgY29uc3QgeyBtZXRyaWNzQ29sbGVjdG9yIH0gPSByZXF1aXJlKCdAL2xpYi9tZXRyaWNzJyk7XHJcbiAgICAgIG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkQXBpQ2FsbC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xyXG5cclxuICAgICAgLy8gTW9jayBTdXBhYmFzZVxyXG4gICAgICBjb25zdCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xyXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2UgPSB7XHJcbiAgICAgICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgcmFuZ2U6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogW10sXHJcbiAgICAgICAgICBlcnJvcjogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH07XHJcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZWZ1bmRzP3N0YXR1cz1hcHByb3ZlZCcpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcclxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZS5lcSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3N0YXR1cycsICdhcHByb3ZlZCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJnZXRTdXBhYmFzZUNsaWVudCIsImZuIiwiY2hlY2tSYXRlTGltaXQiLCJhZGRSYXRlTGltaXRIZWFkZXJzIiwiUkFURV9MSU1JVF9DT05GSUdTIiwiUEFZTUVOVF9DUkVBVElPTiIsInJlcXVlc3RzIiwid2luZG93IiwiQU5BTFlUSUNTIiwibWV0cmljc0NvbGxlY3RvciIsInJlY29yZEFwaUNhbGwiLCJsb2dnZXIiLCJpbmZvIiwid2FybiIsImVycm9yIiwiTG9nTGV2ZWwiLCJJTkZPIiwiV0FSTiIsIkVSUk9SIiwiTG9nQ2F0ZWdvcnkiLCJBUEkiLCJQQVlNRU5UIiwiY3JlYXRlTWVyY2Fkb1BhZ29DbGllbnQiLCJtb2NrQXV0aCIsImF1dGgiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwicHJvY2VzcyIsImVudiIsIk1FUkNBRE9QQUdPX0FDQ0VTU19UT0tFTiIsIk5PREVfRU5WIiwiaXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInVzZXJJZCIsInJlcXVlc3QiLCJOZXh0UmVxdWVzdCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicGF5bWVudF9pZCIsImFtb3VudCIsInJlc3BvbnNlIiwiUE9TVCIsImRhdGEiLCJqc29uIiwiZXhwZWN0Iiwic3RhdHVzIiwidG9CZSIsInN1Y2Nlc3MiLCJyZXF1aXJlIiwicmVtYWluaW5nIiwidW5kZWZpbmVkIiwibW9ja1N1cGFiYXNlIiwiZnJvbSIsIm1vY2tSZXR1cm5UaGlzIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJpZCIsInRvdGFsX2Ftb3VudCIsInBheW1lbnRfc3RhdHVzIiwiZXh0ZXJuYWxfcmVmZXJlbmNlIiwidXBkYXRlIiwiaW5zZXJ0IiwibW9ja1JldHVyblZhbHVlIiwicmVxdWVzdEJvZHkiLCJyZWFzb24iLCJ0b0JlRGVmaW5lZCIsIm1lc3NhZ2UiLCJyZXNldFRpbWUiLCJEYXRlIiwibm93IiwiR0VUIiwib3JkZXIiLCJyYW5nZSIsInJlZnVuZF9pZCIsImNyZWF0ZWRfYXQiLCJvcmRlcnMiLCJBcnJheSIsImlzQXJyYXkiLCJwYWdpbmF0aW9uIiwibGltaXQiLCJvZmZzZXQiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCJdLCJtYXBwaW5ncyI6IjtBQUlBLG9CQUFvQjtBQUNwQkEsS0FBS0MsSUFBSSxDQUFDO0FBQ1ZELEtBQUtDLElBQUksQ0FBQyxrQkFBa0IsSUFBTyxDQUFBO1FBQ2pDQyxtQkFBbUJGLEtBQUtHLEVBQUU7SUFDNUIsQ0FBQTtBQUNBSCxLQUFLQyxJQUFJ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