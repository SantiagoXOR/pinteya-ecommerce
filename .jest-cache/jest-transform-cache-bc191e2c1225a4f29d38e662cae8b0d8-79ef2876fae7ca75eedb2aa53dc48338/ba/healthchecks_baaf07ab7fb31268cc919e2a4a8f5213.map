{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\monitoring\\health-checks.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - ENTERPRISE HEALTH CHECKS SYSTEM\n// ===================================\n\nimport { logger, LogLevel, LogCategory } from '@/lib/logger';\nimport { getSupabaseClient } from '@/lib/supabase';\nimport { CacheUtils } from '@/lib/cache-manager';\nimport { \n  mercadoPagoCriticalBreaker, \n  mercadoPagoStandardBreaker, \n  webhookProcessingBreaker \n} from '@/lib/mercadopago/circuit-breaker';\nimport { recordPerformanceMetric, recordSecurityMetric } from './enterprise-metrics';\n\n// Estados de salud\nexport enum HealthStatus {\n  HEALTHY = 'healthy',\n  DEGRADED = 'degraded',\n  UNHEALTHY = 'unhealthy',\n  UNKNOWN = 'unknown'\n}\n\n// Severidad de problemas\nexport enum HealthSeverity {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  CRITICAL = 'critical'\n}\n\n// Resultado de health check\nexport interface HealthCheckResult {\n  service: string;\n  status: HealthStatus;\n  severity: HealthSeverity;\n  responseTime: number;\n  message: string;\n  details: Record<string, any>;\n  lastChecked: string;\n  nextCheck?: string;\n  recommendations?: string[];\n  metrics?: Record<string, number>;\n}\n\n// Configuración de health check\nexport interface HealthCheckConfig {\n  service: string;\n  enabled: boolean;\n  interval: number; // segundos\n  timeout: number; // segundos\n  retries: number;\n  thresholds: {\n    responseTime: {\n      warning: number;\n      critical: number;\n    };\n    errorRate: {\n      warning: number;\n      critical: number;\n    };\n  };\n  dependencies: string[];\n  autoRecover: boolean;\n  notifications: string[];\n}\n\n// Acción de recuperación\nexport interface RecoveryAction {\n  id: string;\n  name: string;\n  description: string;\n  service: string;\n  enabled: boolean;\n  automatic: boolean;\n  cooldownMinutes: number;\n  maxRetries: number;\n  action: (config?: any) => Promise<boolean>;\n}\n\n/**\n * Sistema Enterprise de Health Checks\n */\nexport class EnterpriseHealthSystem {\n  private static instance: EnterpriseHealthSystem;\n  private healthChecks: Map<string, HealthCheckConfig> = new Map();\n  private recoveryActions: Map<string, RecoveryAction> = new Map();\n  private lastResults: Map<string, HealthCheckResult> = new Map();\n  private checkIntervals: Map<string, NodeJS.Timeout> = new Map();\n  private recoveryAttempts: Map<string, { count: number; lastAttempt: Date }> = new Map();\n\n  constructor() {\n    this.initializeDefaultChecks();\n    this.initializeRecoveryActions();\n  }\n\n  static getInstance(): EnterpriseHealthSystem {\n    if (!EnterpriseHealthSystem.instance) {\n      EnterpriseHealthSystem.instance = new EnterpriseHealthSystem();\n    }\n    return EnterpriseHealthSystem.instance;\n  }\n\n  /**\n   * Registra un health check\n   */\n  registerHealthCheck(config: HealthCheckConfig): void {\n    this.healthChecks.set(config.service, config);\n    \n    if (config.enabled && config.interval > 0) {\n      this.scheduleHealthCheck(config);\n    }\n\n    logger.info(LogLevel.INFO, `Health check registered: ${config.service}`, {\n      interval: config.interval,\n      enabled: config.enabled,\n      autoRecover: config.autoRecover\n    }, LogCategory.SYSTEM);\n  }\n\n  /**\n   * Registra una acción de recuperación\n   */\n  registerRecoveryAction(action: RecoveryAction): void {\n    this.recoveryActions.set(action.id, action);\n    \n    logger.info(LogLevel.INFO, `Recovery action registered: ${action.id}`, {\n      service: action.service,\n      automatic: action.automatic,\n      enabled: action.enabled\n    }, LogCategory.SYSTEM);\n  }\n\n  /**\n   * Ejecuta health check específico\n   */\n  async runHealthCheck(service: string): Promise<HealthCheckResult> {\n    const config = this.healthChecks.get(service);\n    if (!config) {\n      throw new Error(`Health check not configured for service: ${service}`);\n    }\n\n    const startTime = Date.now();\n    let result: HealthCheckResult;\n\n    try {\n      result = await this.executeHealthCheck(service, config);\n    } catch (error) {\n      result = {\n        service,\n        status: HealthStatus.UNHEALTHY,\n        severity: HealthSeverity.CRITICAL,\n        responseTime: Date.now() - startTime,\n        message: `Health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date().toISOString()\n      };\n    }\n\n    // Almacenar resultado\n    this.lastResults.set(service, result);\n\n    // Registrar métricas\n    await this.recordHealthMetrics(result);\n\n    // Verificar si necesita recuperación automática\n    if (result.status === HealthStatus.UNHEALTHY && config.autoRecover) {\n      await this.attemptAutoRecovery(service, result);\n    }\n\n    return result;\n  }\n\n  /**\n   * Ejecuta todos los health checks\n   */\n  async runAllHealthChecks(): Promise<HealthCheckResult[]> {\n    const results: HealthCheckResult[] = [];\n    \n    for (const [service, config] of this.healthChecks.entries()) {\n      if (config.enabled) {\n        try {\n          const result = await this.runHealthCheck(service);\n          results.push(result);\n        } catch (error) {\n          logger.error(LogLevel.ERROR, `Failed to run health check for ${service}`, {\n            error: error instanceof Error ? error.message : 'Unknown error'\n          }, LogCategory.SYSTEM);\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Obtiene el estado general del sistema\n   */\n  getSystemHealth(): {\n    overall: HealthStatus;\n    services: HealthCheckResult[];\n    summary: Record<HealthStatus, number>;\n    lastUpdated: string;\n  } {\n    const services = Array.from(this.lastResults.values());\n    \n    const summary = {\n      [HealthStatus.HEALTHY]: 0,\n      [HealthStatus.DEGRADED]: 0,\n      [HealthStatus.UNHEALTHY]: 0,\n      [HealthStatus.UNKNOWN]: 0\n    };\n\n    services.forEach(service => {\n      summary[service.status]++;\n    });\n\n    // Determinar estado general\n    let overall = HealthStatus.HEALTHY;\n    if (summary[HealthStatus.UNHEALTHY] > 0) {\n      overall = HealthStatus.UNHEALTHY;\n    } else if (summary[HealthStatus.DEGRADED] > 0) {\n      overall = HealthStatus.DEGRADED;\n    } else if (summary[HealthStatus.UNKNOWN] > 0) {\n      overall = HealthStatus.UNKNOWN;\n    }\n\n    return {\n      overall,\n      services,\n      summary,\n      lastUpdated: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Ejecuta acción de recuperación manual\n   */\n  async executeRecoveryAction(actionId: string, config?: any): Promise<boolean> {\n    const action = this.recoveryActions.get(actionId);\n    if (!action) {\n      throw new Error(`Recovery action not found: ${actionId}`);\n    }\n\n    if (!action.enabled) {\n      throw new Error(`Recovery action disabled: ${actionId}`);\n    }\n\n    // Verificar cooldown\n    const attempts = this.recoveryAttempts.get(actionId);\n    if (attempts) {\n      const cooldownEnd = new Date(attempts.lastAttempt.getTime() + action.cooldownMinutes * 60 * 1000);\n      if (new Date() < cooldownEnd) {\n        throw new Error(`Recovery action in cooldown: ${actionId}`);\n      }\n\n      if (attempts.count >= action.maxRetries) {\n        throw new Error(`Recovery action max retries exceeded: ${actionId}`);\n      }\n    }\n\n    try {\n      const success = await action.action(config);\n      \n      // Actualizar intentos\n      const currentAttempts = this.recoveryAttempts.get(actionId) || { count: 0, lastAttempt: new Date() };\n      this.recoveryAttempts.set(actionId, {\n        count: success ? 0 : currentAttempts.count + 1,\n        lastAttempt: new Date()\n      });\n\n      logger.info(LogLevel.INFO, `Recovery action executed: ${actionId}`, {\n        success,\n        service: action.service,\n        automatic: false\n      }, LogCategory.SYSTEM);\n\n      return success;\n\n    } catch (error) {\n      logger.error(LogLevel.ERROR, `Recovery action failed: ${actionId}`, {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        service: action.service\n      }, LogCategory.SYSTEM);\n\n      throw error;\n    }\n  }\n\n  /**\n   * Implementaciones de health checks específicos\n   */\n  private async executeHealthCheck(service: string, config: HealthCheckConfig): Promise<HealthCheckResult> {\n    switch (service) {\n      case 'database':\n        return await this.checkDatabaseHealth(config);\n      case 'cache':\n        return await this.checkCacheHealth(config);\n      case 'mercadopago':\n        return await this.checkMercadoPagoHealth(config);\n      case 'circuit_breakers':\n        return await this.checkCircuitBreakersHealth(config);\n      case 'external_apis':\n        return await this.checkExternalAPIsHealth(config);\n      case 'file_system':\n        return await this.checkFileSystemHealth(config);\n      default:\n        throw new Error(`Unknown health check service: ${service}`);\n    }\n  }\n\n  private async checkDatabaseHealth(config: HealthCheckConfig): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      const supabase = getSupabaseClient(true);\n      if (!supabase) {\n        throw new Error('Supabase client not available');\n      }\n\n      // Test de conectividad\n      const { data, error } = await supabase\n        .from('products')\n        .select('id')\n        .limit(1);\n\n      if (error) {\n        throw error;\n      }\n\n      const responseTime = Date.now() - startTime;\n      \n      // Determinar estado basado en tiempo de respuesta\n      let status = HealthStatus.HEALTHY;\n      let severity = HealthSeverity.LOW;\n      \n      if (responseTime > config.thresholds.responseTime.critical) {\n        status = HealthStatus.UNHEALTHY;\n        severity = HealthSeverity.CRITICAL;\n      } else if (responseTime > config.thresholds.responseTime.warning) {\n        status = HealthStatus.DEGRADED;\n        severity = HealthSeverity.MEDIUM;\n      }\n\n      return {\n        service: 'database',\n        status,\n        severity,\n        responseTime,\n        message: `Database responding in ${responseTime}ms`,\n        details: {\n          recordsFound: data?.length || 0,\n          connectionPool: 'active',\n          queryType: 'SELECT'\n        },\n        lastChecked: new Date().toISOString(),\n        nextCheck: new Date(Date.now() + config.interval * 1000).toISOString(),\n        metrics: {\n          responseTime,\n          recordCount: data?.length || 0\n        }\n      };\n\n    } catch (error) {\n      return {\n        service: 'database',\n        status: HealthStatus.UNHEALTHY,\n        severity: HealthSeverity.CRITICAL,\n        responseTime: Date.now() - startTime,\n        message: `Database error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date().toISOString(),\n        recommendations: [\n          'Check database connection',\n          'Verify Supabase credentials',\n          'Check network connectivity'\n        ]\n      };\n    }\n  }\n\n  private async checkCacheHealth(config: HealthCheckConfig): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      const testKey = `health_check_${Date.now()}`;\n      const testValue = { test: true, timestamp: Date.now() };\n\n      // Test write\n      await CacheUtils.set(testKey, testValue, 10);\n      \n      // Test read\n      const retrieved = await CacheUtils.get(testKey);\n      \n      if (!retrieved || retrieved.test !== true) {\n        throw new Error('Cache read/write test failed');\n      }\n\n      const responseTime = Date.now() - startTime;\n      \n      let status = HealthStatus.HEALTHY;\n      let severity = HealthSeverity.LOW;\n      \n      if (responseTime > 500) {\n        status = HealthStatus.DEGRADED;\n        severity = HealthSeverity.MEDIUM;\n      }\n\n      return {\n        service: 'cache',\n        status,\n        severity,\n        responseTime,\n        message: `Cache responding in ${responseTime}ms`,\n        details: {\n          readWrite: 'success',\n          testKey,\n          provider: 'redis'\n        },\n        lastChecked: new Date().toISOString(),\n        nextCheck: new Date(Date.now() + config.interval * 1000).toISOString(),\n        metrics: {\n          responseTime,\n          operationsPerSecond: 1000 / responseTime\n        }\n      };\n\n    } catch (error) {\n      return {\n        service: 'cache',\n        status: HealthStatus.UNHEALTHY,\n        severity: HealthSeverity.HIGH,\n        responseTime: Date.now() - startTime,\n        message: `Cache error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date().toISOString(),\n        recommendations: [\n          'Check Redis connection',\n          'Verify cache configuration',\n          'Check memory usage'\n        ]\n      };\n    }\n  }\n\n  private async checkMercadoPagoHealth(config: HealthCheckConfig): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      const publicKey = process.env.MERCADOPAGO_PUBLIC_KEY_PROD || process.env.MERCADOPAGO_PUBLIC_KEY_TEST;\n      const accessToken = process.env.MERCADOPAGO_ACCESS_TOKEN_PROD || process.env.MERCADOPAGO_ACCESS_TOKEN_TEST;\n\n      if (!publicKey || !accessToken) {\n        throw new Error('MercadoPago credentials not configured');\n      }\n\n      const responseTime = Date.now() - startTime;\n      const environment = publicKey.includes('TEST') ? 'test' : 'production';\n\n      return {\n        service: 'mercadopago',\n        status: HealthStatus.HEALTHY,\n        severity: HealthSeverity.LOW,\n        responseTime,\n        message: `MercadoPago credentials configured for ${environment}`,\n        details: {\n          publicKeyConfigured: !!publicKey,\n          accessTokenConfigured: !!accessToken,\n          environment\n        },\n        lastChecked: new Date().toISOString(),\n        nextCheck: new Date(Date.now() + config.interval * 1000).toISOString(),\n        metrics: {\n          configurationScore: 100\n        }\n      };\n\n    } catch (error) {\n      return {\n        service: 'mercadopago',\n        status: HealthStatus.UNHEALTHY,\n        severity: HealthSeverity.CRITICAL,\n        responseTime: Date.now() - startTime,\n        message: `MercadoPago error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date().toISOString(),\n        recommendations: [\n          'Configure MercadoPago credentials',\n          'Check environment variables',\n          'Verify API keys'\n        ]\n      };\n    }\n  }\n\n  private async checkCircuitBreakersHealth(config: HealthCheckConfig): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      const criticalState = mercadoPagoCriticalBreaker.getState();\n      const standardState = mercadoPagoStandardBreaker.getState();\n      const webhookState = webhookProcessingBreaker.getState();\n\n      const states = [criticalState, standardState, webhookState];\n      const openBreakers = states.filter(state => state === 'open').length;\n      const halfOpenBreakers = states.filter(state => state === 'half-open').length;\n\n      let status = HealthStatus.HEALTHY;\n      let severity = HealthSeverity.LOW;\n      let message = 'All circuit breakers operational';\n\n      if (openBreakers > 0) {\n        status = HealthStatus.UNHEALTHY;\n        severity = HealthSeverity.CRITICAL;\n        message = `${openBreakers} circuit breaker(s) open`;\n      } else if (halfOpenBreakers > 0) {\n        status = HealthStatus.DEGRADED;\n        severity = HealthSeverity.MEDIUM;\n        message = `${halfOpenBreakers} circuit breaker(s) in recovery`;\n      }\n\n      const responseTime = Date.now() - startTime;\n\n      return {\n        service: 'circuit_breakers',\n        status,\n        severity,\n        responseTime,\n        message,\n        details: {\n          mercadopago_critical: criticalState,\n          mercadopago_standard: standardState,\n          webhook_processing: webhookState,\n          totalBreakers: 3,\n          openBreakers,\n          halfOpenBreakers\n        },\n        lastChecked: new Date().toISOString(),\n        nextCheck: new Date(Date.now() + config.interval * 1000).toISOString(),\n        metrics: {\n          healthScore: ((3 - openBreakers) / 3) * 100,\n          openBreakers,\n          halfOpenBreakers\n        },\n        recommendations: openBreakers > 0 ? [\n          'Check service dependencies',\n          'Review error logs',\n          'Consider manual reset if appropriate'\n        ] : undefined\n      };\n\n    } catch (error) {\n      return {\n        service: 'circuit_breakers',\n        status: HealthStatus.UNHEALTHY,\n        severity: HealthSeverity.HIGH,\n        responseTime: Date.now() - startTime,\n        message: `Circuit breakers error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date().toISOString()\n      };\n    }\n  }\n\n  private async checkExternalAPIsHealth(config: HealthCheckConfig): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    // Simulación de check de APIs externas\n    const responseTime = Date.now() - startTime + 150; // Simular latencia\n\n    return {\n      service: 'external_apis',\n      status: HealthStatus.HEALTHY,\n      severity: HealthSeverity.LOW,\n      responseTime,\n      message: 'External APIs responding normally',\n      details: {\n        checkedAPIs: ['mercadopago', 'vercel'],\n        successRate: 100\n      },\n      lastChecked: new Date().toISOString(),\n      nextCheck: new Date(Date.now() + config.interval * 1000).toISOString(),\n      metrics: {\n        responseTime,\n        successRate: 100\n      }\n    };\n  }\n\n  private async checkFileSystemHealth(config: HealthCheckConfig): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Verificar espacio en disco y permisos básicos\n      const responseTime = Date.now() - startTime + 50;\n\n      return {\n        service: 'file_system',\n        status: HealthStatus.HEALTHY,\n        severity: HealthSeverity.LOW,\n        responseTime,\n        message: 'File system accessible',\n        details: {\n          diskSpace: 'sufficient',\n          permissions: 'ok'\n        },\n        lastChecked: new Date().toISOString(),\n        nextCheck: new Date(Date.now() + config.interval * 1000).toISOString(),\n        metrics: {\n          responseTime,\n          diskUsage: 65\n        }\n      };\n\n    } catch (error) {\n      return {\n        service: 'file_system',\n        status: HealthStatus.UNHEALTHY,\n        severity: HealthSeverity.HIGH,\n        responseTime: Date.now() - startTime,\n        message: `File system error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        details: { error: error instanceof Error ? error.message : 'Unknown error' },\n        lastChecked: new Date().toISOString()\n      };\n    }\n  }\n\n  /**\n   * Programa health check automático\n   */\n  private scheduleHealthCheck(config: HealthCheckConfig): void {\n    // Limpiar intervalo existente\n    const existingInterval = this.checkIntervals.get(config.service);\n    if (existingInterval) {\n      clearInterval(existingInterval);\n    }\n\n    // Programar nuevo intervalo\n    const interval = setInterval(async () => {\n      try {\n        await this.runHealthCheck(config.service);\n      } catch (error) {\n        logger.error(LogLevel.ERROR, `Scheduled health check failed: ${config.service}`, {\n          error: error instanceof Error ? error.message : 'Unknown error'\n        }, LogCategory.SYSTEM);\n      }\n    }, config.interval * 1000);\n\n    this.checkIntervals.set(config.service, interval);\n  }\n\n  /**\n   * Registra métricas de health check\n   */\n  private async recordHealthMetrics(result: HealthCheckResult): Promise<void> {\n    try {\n      // Registrar métricas de performance\n      await recordPerformanceMetric(\n        `health.${result.service}.response_time`,\n        result.responseTime,\n        true,\n        { service: result.service, status: result.status }\n      );\n\n      // Registrar métricas de disponibilidad\n      const availabilityScore = result.status === HealthStatus.HEALTHY ? 1 : 0;\n      await recordPerformanceMetric(\n        `health.${result.service}.availability`,\n        availabilityScore,\n        true,\n        { service: result.service, status: result.status }\n      );\n\n      // Registrar eventos de seguridad si hay problemas\n      if (result.status === HealthStatus.UNHEALTHY && result.severity === HealthSeverity.CRITICAL) {\n        await recordSecurityMetric(\n          'health_check_critical_failure',\n          'high',\n          { \n            service: result.service,\n            message: result.message,\n            severity: result.severity\n          }\n        );\n      }\n\n    } catch (error) {\n      logger.error(LogLevel.ERROR, 'Failed to record health metrics', {\n        service: result.service,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      }, LogCategory.SYSTEM);\n    }\n  }\n\n  /**\n   * Intenta recuperación automática\n   */\n  private async attemptAutoRecovery(service: string, result: HealthCheckResult): Promise<void> {\n    const recoveryActions = Array.from(this.recoveryActions.values())\n      .filter(action => action.service === service && action.automatic && action.enabled);\n\n    for (const action of recoveryActions) {\n      try {\n        logger.info(LogLevel.INFO, `Attempting auto-recovery: ${action.id}`, {\n          service,\n          status: result.status,\n          severity: result.severity\n        }, LogCategory.SYSTEM);\n\n        const success = await this.executeRecoveryAction(action.id);\n        \n        if (success) {\n          logger.info(LogLevel.INFO, `Auto-recovery successful: ${action.id}`, {\n            service\n          }, LogCategory.SYSTEM);\n          break; // Salir si la recuperación fue exitosa\n        }\n\n      } catch (error) {\n        logger.error(LogLevel.ERROR, `Auto-recovery failed: ${action.id}`, {\n          service,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        }, LogCategory.SYSTEM);\n      }\n    }\n  }\n\n  /**\n   * Inicializa health checks por defecto\n   */\n  private initializeDefaultChecks(): void {\n    // Database health check\n    this.registerHealthCheck({\n      service: 'database',\n      enabled: true,\n      interval: 60, // 1 minuto\n      timeout: 5,\n      retries: 3,\n      thresholds: {\n        responseTime: { warning: 1000, critical: 3000 },\n        errorRate: { warning: 0.05, critical: 0.1 }\n      },\n      dependencies: [],\n      autoRecover: true,\n      notifications: ['default_log']\n    });\n\n    // Cache health check\n    this.registerHealthCheck({\n      service: 'cache',\n      enabled: true,\n      interval: 30, // 30 segundos\n      timeout: 3,\n      retries: 2,\n      thresholds: {\n        responseTime: { warning: 100, critical: 500 },\n        errorRate: { warning: 0.02, critical: 0.05 }\n      },\n      dependencies: [],\n      autoRecover: true,\n      notifications: ['default_log']\n    });\n\n    // MercadoPago health check\n    this.registerHealthCheck({\n      service: 'mercadopago',\n      enabled: true,\n      interval: 300, // 5 minutos\n      timeout: 10,\n      retries: 1,\n      thresholds: {\n        responseTime: { warning: 2000, critical: 5000 },\n        errorRate: { warning: 0.01, critical: 0.03 }\n      },\n      dependencies: [],\n      autoRecover: false,\n      notifications: ['default_log']\n    });\n\n    // Circuit breakers health check\n    this.registerHealthCheck({\n      service: 'circuit_breakers',\n      enabled: true,\n      interval: 30, // 30 segundos\n      timeout: 1,\n      retries: 1,\n      thresholds: {\n        responseTime: { warning: 100, critical: 1000 },\n        errorRate: { warning: 0, critical: 0 }\n      },\n      dependencies: [],\n      autoRecover: true,\n      notifications: ['default_log']\n    });\n  }\n\n  /**\n   * Inicializa acciones de recuperación\n   */\n  private initializeRecoveryActions(): void {\n    // Reset circuit breakers\n    this.registerRecoveryAction({\n      id: 'reset_circuit_breakers',\n      name: 'Reset Circuit Breakers',\n      description: 'Reset all circuit breakers to closed state',\n      service: 'circuit_breakers',\n      enabled: true,\n      automatic: true,\n      cooldownMinutes: 5,\n      maxRetries: 3,\n      action: async () => {\n        mercadoPagoCriticalBreaker.reset();\n        mercadoPagoStandardBreaker.reset();\n        webhookProcessingBreaker.reset();\n        return true;\n      }\n    });\n\n    // Clear cache\n    this.registerRecoveryAction({\n      id: 'clear_cache',\n      name: 'Clear Cache',\n      description: 'Clear cache to resolve potential issues',\n      service: 'cache',\n      enabled: true,\n      automatic: false, // Manual only\n      cooldownMinutes: 10,\n      maxRetries: 1,\n      action: async () => {\n        // Implementar limpieza de cache si es necesario\n        return true;\n      }\n    });\n  }\n\n  /**\n   * Limpia recursos\n   */\n  destroy(): void {\n    // Limpiar intervalos\n    for (const interval of this.checkIntervals.values()) {\n      clearInterval(interval);\n    }\n    this.checkIntervals.clear();\n  }\n}\n\n// Instancia singleton\nexport const enterpriseHealthSystem = EnterpriseHealthSystem.getInstance();\n"],"names":["EnterpriseHealthSystem","HealthSeverity","HealthStatus","enterpriseHealthSystem","constructor","healthChecks","Map","recoveryActions","lastResults","checkIntervals","recoveryAttempts","initializeDefaultChecks","initializeRecoveryActions","getInstance","instance","registerHealthCheck","config","set","service","enabled","interval","scheduleHealthCheck","logger","info","LogLevel","INFO","autoRecover","LogCategory","SYSTEM","registerRecoveryAction","action","id","automatic","runHealthCheck","get","Error","startTime","Date","now","result","executeHealthCheck","error","status","severity","responseTime","message","details","lastChecked","toISOString","recordHealthMetrics","attemptAutoRecovery","runAllHealthChecks","results","entries","push","ERROR","getSystemHealth","services","Array","from","values","summary","forEach","overall","lastUpdated","executeRecoveryAction","actionId","attempts","cooldownEnd","lastAttempt","getTime","cooldownMinutes","count","maxRetries","success","currentAttempts","checkDatabaseHealth","checkCacheHealth","checkMercadoPagoHealth","checkCircuitBreakersHealth","checkExternalAPIsHealth","checkFileSystemHealth","supabase","getSupabaseClient","data","select","limit","thresholds","critical","warning","recordsFound","length","connectionPool","queryType","nextCheck","metrics","recordCount","recommendations","testKey","testValue","test","timestamp","CacheUtils","retrieved","readWrite","provider","operationsPerSecond","publicKey","process","env","MERCADOPAGO_PUBLIC_KEY_PROD","MERCADOPAGO_PUBLIC_KEY_TEST","accessToken","MERCADOPAGO_ACCESS_TOKEN_PROD","MERCADOPAGO_ACCESS_TOKEN_TEST","environment","includes","publicKeyConfigured","accessTokenConfigured","configurationScore","criticalState","mercadoPagoCriticalBreaker","getState","standardState","mercadoPagoStandardBreaker","webhookState","webhookProcessingBreaker","states","openBreakers","filter","state","halfOpenBreakers","mercadopago_critical","mercadopago_standard","webhook_processing","totalBreakers","healthScore","undefined","checkedAPIs","successRate","diskSpace","permissions","diskUsage","existingInterval","clearInterval","setInterval","recordPerformanceMetric","availabilityScore","recordSecurityMetric","timeout","retries","errorRate","dependencies","notifications","name","description","reset","destroy","clear"],"mappings":"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"}