f8d4a43e12e03579c6c29c90b08c2772
// ===================================
// PINTEYA E-COMMERCE - STRICT ORDERS HOOK (REFACTORED)
// Hook orquestador para gestión de órdenes con validación estricta
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get useOrderDetailStrict () {
        return useOrderDetailStrict;
    },
    get useOrdersEnterpriseStrict () {
        return useOrdersEnterpriseStrict;
    }
});
const _react = require("react");
const _usetoast = require("../use-toast");
const _apistrict = require("../../types/api-strict");
const _apimonitoring = require("../../utils/api-monitoring");
const _useOrdersCache = require("./useOrdersCache");
const _useOrdersApi = require("./useOrdersApi");
const _useOrdersState = require("./useOrdersState");
// Función de debounce para evitar peticiones múltiples
function debounce(func, wait) {
    let timeout;
    return (...args)=>{
        clearTimeout(timeout);
        timeout = setTimeout(()=>func(...args), wait);
    };
}
const DEFAULT_OPTIONS = {
    autoFetch: true,
    refetchInterval: 0,
    maxRetries: 3,
    timeout: 10000,
    enableCache: true,
    cacheTimeout: 5 * 60 * 1000 // 5 minutes
};
function useOrdersEnterpriseStrict(initialFilters = {}, options = {}) {
    const { toast } = (0, _usetoast.useToast)();
    const apiMonitoring = (0, _apimonitoring.useApiMonitoring)();
    const opts = (0, _react.useMemo)(()=>({
            ...DEFAULT_OPTIONS,
            ...options
        }), [
        options
    ]);
    // Memoizar las funciones de monitoreo para evitar recreaciones
    const recordDiscrepancy = (0, _react.useCallback)(apiMonitoring.recordDiscrepancy, []);
    const recordRenderingIssue = (0, _react.useCallback)(apiMonitoring.recordRenderingIssue, []);
    // ===================================
    // HOOKS ESPECIALIZADOS
    // ===================================
    // Hook de cache
    const cache = (0, _useOrdersCache.useOrdersCache)({
        enableCache: opts.enableCache,
        cacheTimeout: opts.cacheTimeout,
        maxSize: 50,
        cleanupInterval: 10 * 60 * 1000,
        minRequestInterval: 1000
    });
    // Hook de estado
    const state = (0, _useOrdersState.useOrdersState)(initialFilters);
    // Hook de API
    const api = (0, _useOrdersApi.useOrdersApi)({
        timeout: opts.timeout,
        maxRetries: opts.maxRetries,
        enableCache: opts.enableCache,
        cache
    });
    // Referencias para control de requests (simplificadas)
    const retryCountRef = (0, _react.useRef)(0);
    const refetchIntervalRef = (0, _react.useRef)(null);
    const debounceTimeoutRef = (0, _react.useRef)(null);
    // ===================================
    // FUNCIONES DE FETCH SIMPLIFICADAS
    // ===================================
    // Usar el hook de API directamente
    const fetchOrdersInternal = api.fetchOrdersInternal;
    // ===================================
    // FUNCIONES DE FETCH PÚBLICAS
    // ===================================
    // Lógica de fetch movida a useOrdersApi.ts
    // ===================================
    // FUNCIÓN DE FETCH PÚBLICA CON RETRY
    // ===================================
    // Función interna sin debounce para uso directo
    const fetchOrdersImmediate = (0, _react.useCallback)(async (newFilters = {})=>{
        console.log('[useOrdersEnterpriseStrict] fetchOrdersImmediate called with filters:', newFilters);
        console.log('[useOrdersEnterpriseStrict] Current state filters:', state.filters);
        // Generar clave única para esta petición
        const requestKey = JSON.stringify({
            ...state.filters,
            ...newFilters
        });
        console.log('[useOrdersEnterpriseStrict] Request key:', requestKey);
        // Evitar peticiones duplicadas
        if (state.hasFiltersChanged({
            ...state.filters,
            ...newFilters
        }) && state.isLoading) {
            console.log('[useOrdersEnterpriseStrict] Skipping duplicate request');
            return;
        }
        // Actualizar filtros y estado de carga
        console.log('[useOrdersEnterpriseStrict] Updating filters and setting loading to true');
        state.updateFilters(newFilters);
        state.setLoading(true);
        retryCountRef.current = 0;
        const attemptFetch = async (attempt)=>{
            const currentFilters = state.getLastFilters();
            console.log('[useOrdersEnterpriseStrict] attemptFetch - attempt:', attempt, 'filters:', currentFilters);
            const result = await fetchOrdersInternal(currentFilters, attempt > 0);
            console.log('[useOrdersEnterpriseStrict] API result:', result);
            if ((0, _apistrict.isStrictApiResponse)(result)) {
                console.log('[useOrdersEnterpriseStrict] Valid API response received:', result.data);
                // Monitoreo automático de discrepancias
                const expectedCount = result.data.pagination.total;
                const actualCount = result.data.orders.length;
                const endpoint = `/api/admin/orders?${new URLSearchParams({
                    page: currentFilters.page?.toString() || '1',
                    limit: currentFilters.limit?.toString() || '20',
                    ...currentFilters.status && {
                        status: currentFilters.status
                    },
                    ...currentFilters.payment_status && {
                        payment_status: currentFilters.payment_status
                    },
                    ...currentFilters.fulfillment_status && {
                        fulfillment_status: currentFilters.fulfillment_status
                    },
                    ...currentFilters.sort_by && {
                        sort_by: currentFilters.sort_by
                    },
                    ...currentFilters.sort_order && {
                        sort_order: currentFilters.sort_order
                    }
                }).toString()}`;
                // Solo registrar discrepancia si hay una diferencia real (no por paginación)
                const expectedPageCount = Math.min(currentFilters.limit || 20, expectedCount - ((currentFilters.page || 1) - 1) * (currentFilters.limit || 20));
                if (actualCount < expectedPageCount && expectedPageCount > 0) {
                    recordDiscrepancy(endpoint, expectedPageCount, actualCount);
                }
                // Actualizar estado usando el hook especializado
                state.setOrders(result.data.orders);
                state.setPagination(result.data.pagination);
                state.setAnalytics(result.data.analytics || null);
                retryCountRef.current = 0;
            } else {
                // Es un error
                if (attempt < opts.maxRetries && result.code !== 'REQUEST_CANCELLED') {
                    retryCountRef.current = attempt + 1;
                    // Esperar antes del retry (exponential backoff)
                    const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
                    await new Promise((resolve)=>setTimeout(resolve, delay));
                    return attemptFetch(attempt + 1);
                }
                // Máximo de reintentos alcanzado o error no recuperable
                state.setError(result.error);
                // Registrar problema de renderizado por error de API
                recordRenderingIssue('useOrdersEnterpriseStrict', 0, 0, currentFilters, result.error);
                // Mostrar toast de error
                if (result.code !== 'REQUEST_CANCELLED') {
                    toast({
                        title: 'Error al cargar órdenes',
                        description: result.error,
                        variant: 'destructive'
                    });
                }
            }
        };
        await attemptFetch(0);
    }, [
        fetchOrdersInternal,
        opts.maxRetries,
        toast,
        recordDiscrepancy,
        recordRenderingIssue,
        state
    ]);
    // Función fetchOrders con debouncing para evitar peticiones múltiples
    const fetchOrders = (0, _react.useCallback)((newFilters = {})=>{
        return new Promise((resolve)=>{
            // Limpiar timeout anterior si existe
            if (debounceTimeoutRef.current) {
                clearTimeout(debounceTimeoutRef.current);
            }
            // Configurar nuevo timeout con debounce
            const debounceMs = process.env.NODE_ENV === 'development' ? 300 : 150;
            debounceTimeoutRef.current = setTimeout(async ()=>{
                try {
                    await fetchOrdersImmediate(newFilters);
                    resolve();
                } catch (error) {
                    console.error('Error in debounced fetchOrders:', error);
                    resolve(); // Resolver incluso en caso de error para evitar promesas colgadas
                }
            }, debounceMs);
        });
    }, [
        fetchOrdersImmediate
    ]);
    // ===================================
    // OTRAS ACCIONES
    // ===================================
    const refreshOrders = (0, _react.useCallback)(async ()=>{
        // Limpiar cache para forzar refresh
        if (opts.enableCache) {
            cache.clearCache();
        }
        await fetchOrders();
    }, [
        fetchOrders,
        opts.enableCache,
        cache
    ]);
    // Usar las funciones del hook de estado directamente
    const updateFilters = state.updateFilters;
    const clearError = state.clearError;
    const retryLastRequest = (0, _react.useCallback)(async ()=>{
        const lastFilters = state.getLastFilters();
        if (lastFilters) {
            await fetchOrders(lastFilters);
        }
    }, [
        fetchOrders,
        state
    ]);
    // ===================================
    // EFECTOS
    // ===================================
    // Auto-fetch inicial - SIMPLIFICADO
    const hasInitialFetchRef = (0, _react.useRef)(false);
    (0, _react.useEffect)(()=>{
        if (opts.autoFetch && !hasInitialFetchRef.current) {
            hasInitialFetchRef.current = true;
            fetchOrders();
        }
    }, [
        opts.autoFetch
    ]); // Solo ejecutar una vez al montar
    // Escuchar cambios en filtros con debouncing optimizado
    const filtersRef = (0, _react.useRef)(state.filters);
    const isInitialMount = (0, _react.useRef)(true);
    (0, _react.useEffect)(()=>{
        // Evitar fetch en el primer render (ya se hace en auto-fetch)
        if (isInitialMount.current) {
            isInitialMount.current = false;
            filtersRef.current = state.filters;
            return;
        }
        // Solo hacer fetch si los filtros han cambiado realmente
        const hasChanged = JSON.stringify(filtersRef.current) !== JSON.stringify(state.filters);
        if (hasChanged) {
            filtersRef.current = state.filters;
            fetchOrders();
        }
    }, [
        state.filters,
        fetchOrders
    ]); // Dependencias mínimas y estables
    // Refetch interval - TEMPORALMENTE DESHABILITADO para evitar refresco infinito
    (0, _react.useEffect)(()=>{
    // NOTA: Refetch interval deshabilitado temporalmente para solucionar refresco infinito
    // TODO: Reimplementar con useRef para fetchOrders o usar React Query
    /*
    if (opts.refetchInterval > 0) {
      refetchIntervalRef.current = setInterval(() => {
        if (!state.isLoading) {
          fetchOrders();
        }
      }, opts.refetchInterval);

      return () => {
        if (refetchIntervalRef.current) {
          clearInterval(refetchIntervalRef.current);
        }
      };
    }
    */ }, [
        opts.refetchInterval
    ]);
    // Limpieza automática de cache movida a useOrdersCache.ts
    // Cleanup al desmontar
    (0, _react.useEffect)(()=>{
        return ()=>{
            // Cancelar peticiones en progreso usando el hook de API
            api.abortCurrentRequest();
            // Limpiar intervalos y timeouts
            if (refetchIntervalRef.current) {
                clearInterval(refetchIntervalRef.current);
            }
            if (debounceTimeoutRef.current) {
                clearTimeout(debounceTimeoutRef.current);
            }
            if (process.env.NODE_ENV === 'development') {
                console.log('[useOrdersEnterpriseStrict] Hook cleanup completed');
            }
        };
    }, [
        api
    ]); // Depende del hook de API
    // ===================================
    // RETORNO DEL HOOK
    // ===================================
    return {
        // Estado
        orders: state.orders,
        pagination: state.pagination,
        filters: state.filters,
        analytics: state.analytics,
        isLoading: state.isLoading,
        error: state.error,
        lastFetch: state.lastFetch,
        // Acciones
        fetchOrders,
        refreshOrders,
        updateFilters,
        clearError,
        retryLastRequest
    };
}
function useOrderDetailStrict(orderId) {
    const { toast } = (0, _usetoast.useToast)();
    const [order, setOrder] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const fetchOrder = (0, _react.useCallback)(async ()=>{
        if (!orderId) return;
        setIsLoading(true);
        setError(null);
        try {
            const response = await fetch(`/api/admin/orders/${orderId}`);
            const data = await response.json();
            const validatedResponse = toStrictOrdersResponse(data);
            if ((0, _apistrict.isStrictApiError)(validatedResponse)) {
                setError(validatedResponse.error);
                toast({
                    title: 'Error al cargar orden',
                    description: validatedResponse.error,
                    variant: 'destructive'
                });
            } else {
                // Para orden individual, extraer la primera orden
                const orderData = validatedResponse.data.orders[0] || null;
                setOrder(orderData);
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Error desconocido';
            setError(errorMessage);
            toast({
                title: 'Error al cargar orden',
                description: errorMessage,
                variant: 'destructive'
            });
        } finally{
            setIsLoading(false);
        }
    }, [
        orderId,
        toast
    ]);
    (0, _react.useEffect)(()=>{
        fetchOrder();
    }, [
        fetchOrder
    ]);
    return {
        order,
        isLoading,
        error,
        refetch: fetchOrder
    };
} // ===================================
 // UTILIDADES EXPORTADAS
 // ===================================
 /**
 * Utilidades de cache movidas a useOrdersCache.ts
 * Estas funciones están disponibles a través del hook useOrdersCache
 */  // Las utilidades de cache ahora están disponibles a través del hook useOrdersCache:
 // - cache.clearCache()
 // - cache.getCacheStats()
 // - cache.getPendingRequest()
 // - cache.setPendingRequest()

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcaG9va3NcXGFkbWluXFx1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBTVFJJQ1QgT1JERVJTIEhPT0sgKFJFRkFDVE9SRUQpXG4vLyBIb29rIG9ycXVlc3RhZG9yIHBhcmEgZ2VzdGnDs24gZGUgw7NyZGVuZXMgY29uIHZhbGlkYWNpw7NuIGVzdHJpY3RhXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUb2FzdCB9IGZyb20gJ0AvaG9va3MvdXNlLXRvYXN0JztcbmltcG9ydCB7XG4gIFN0cmljdE9yZGVyc0xpc3RSZXNwb25zZSxcbiAgU3RyaWN0QXBpRXJyb3IsXG4gIEFwaVJlc3VsdCxcbiAgY3JlYXRlU3RyaWN0QXBpRXJyb3IsXG4gIFN0cmljdE9yZGVyRW50ZXJwcmlzZSxcbiAgU3RyaWN0UGFnaW5hdGlvbixcbiAgaXNTdHJpY3RBcGlFcnJvcixcbiAgaXNTdHJpY3RBcGlSZXNwb25zZVxufSBmcm9tICdAL3R5cGVzL2FwaS1zdHJpY3QnO1xuaW1wb3J0IHsgT3JkZXJTdGF0dXMsIFBheW1lbnRTdGF0dXMsIEZ1bGZpbGxtZW50U3RhdHVzIH0gZnJvbSAnQC90eXBlcy9vcmRlcnMtZW50ZXJwcmlzZSc7XG5pbXBvcnQgeyB1c2VBcGlNb25pdG9yaW5nIH0gZnJvbSAnQC91dGlscy9hcGktbW9uaXRvcmluZyc7XG5pbXBvcnQgeyB1c2VPcmRlcnNDYWNoZSB9IGZyb20gJy4vdXNlT3JkZXJzQ2FjaGUnO1xuaW1wb3J0IHsgdXNlT3JkZXJzQXBpIH0gZnJvbSAnLi91c2VPcmRlcnNBcGknO1xuaW1wb3J0IHsgdXNlT3JkZXJzU3RhdGUsIFN0cmljdE9yZGVyc1N0YXRlLCBTdHJpY3RPcmRlcnNBY3Rpb25zIH0gZnJvbSAnLi91c2VPcmRlcnNTdGF0ZSc7XG5cbi8vIEZ1bmNpw7NuIGRlIGRlYm91bmNlIHBhcmEgZXZpdGFyIHBldGljaW9uZXMgbcO6bHRpcGxlc1xuZnVuY3Rpb24gZGVib3VuY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgZnVuYzogVCxcbiAgd2FpdDogbnVtYmVyXG4pOiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4gdm9pZCB7XG4gIGxldCB0aW1lb3V0OiBOb2RlSlMuVGltZW91dDtcbiAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGZ1bmMoLi4uYXJncyksIHdhaXQpO1xuICB9O1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVElQT1MgREUgRklMVFJPUyBFU1RSSUNUT1Ncbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyaWN0T3JkZXJGaWx0ZXJzIHtcbiAgcmVhZG9ubHkgc2VhcmNoPzogc3RyaW5nO1xuICByZWFkb25seSBzdGF0dXM/OiBPcmRlclN0YXR1cyB8ICdhbGwnO1xuICByZWFkb25seSBwYXltZW50X3N0YXR1cz86IFBheW1lbnRTdGF0dXMgfCAnYWxsJztcbiAgcmVhZG9ubHkgZnVsZmlsbG1lbnRfc3RhdHVzPzogRnVsZmlsbG1lbnRTdGF0dXMgfCAnYWxsJztcbiAgcmVhZG9ubHkgZGF0ZV9mcm9tPzogc3RyaW5nO1xuICByZWFkb25seSBkYXRlX3RvPzogc3RyaW5nO1xuICByZWFkb25seSBwYWdlPzogbnVtYmVyO1xuICByZWFkb25seSBsaW1pdD86IG51bWJlcjtcbiAgcmVhZG9ubHkgc29ydF9ieT86ICdjcmVhdGVkX2F0JyB8ICd1cGRhdGVkX2F0JyB8ICd0b3RhbCcgfCAnb3JkZXJfbnVtYmVyJztcbiAgcmVhZG9ubHkgc29ydF9vcmRlcj86ICdhc2MnIHwgJ2Rlc2MnO1xufVxuXG4vLyBUaXBvcyBtb3ZpZG9zIGEgdXNlT3JkZXJzU3RhdGUudHNcblxuZXhwb3J0IGludGVyZmFjZSBVc2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0UmV0dXJuIGV4dGVuZHMgU3RyaWN0T3JkZXJzU3RhdGUsIFN0cmljdE9yZGVyc0FjdGlvbnMge1xuICByZWFkb25seSBmZXRjaE9yZGVyczogKGZpbHRlcnM/OiBQYXJ0aWFsPFN0cmljdE9yZGVyRmlsdGVycz4pID0+IFByb21pc2U8dm9pZD47XG4gIHJlYWRvbmx5IHJlZnJlc2hPcmRlcnM6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHJlYWRvbmx5IHJldHJ5TGFzdFJlcXVlc3Q6ICgpID0+IFByb21pc2U8dm9pZD47XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDT05GSUdVUkFDScOTTiBERUwgSE9PS1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuaW50ZXJmYWNlIFVzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RPcHRpb25zIHtcbiAgcmVhZG9ubHkgYXV0b0ZldGNoPzogYm9vbGVhbjtcbiAgcmVhZG9ubHkgcmVmZXRjaEludGVydmFsPzogbnVtYmVyO1xuICByZWFkb25seSBtYXhSZXRyaWVzPzogbnVtYmVyO1xuICByZWFkb25seSB0aW1lb3V0PzogbnVtYmVyO1xuICByZWFkb25seSBlbmFibGVDYWNoZT86IGJvb2xlYW47XG4gIHJlYWRvbmx5IGNhY2hlVGltZW91dD86IG51bWJlcjtcbn1cblxuY29uc3QgREVGQVVMVF9PUFRJT05TOiBSZXF1aXJlZDxVc2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0T3B0aW9ucz4gPSB7XG4gIGF1dG9GZXRjaDogdHJ1ZSxcbiAgcmVmZXRjaEludGVydmFsOiAwLCAvLyAwID0gZGlzYWJsZWRcbiAgbWF4UmV0cmllczogMyxcbiAgdGltZW91dDogMTAwMDAsIC8vIDEwIHNlY29uZHNcbiAgZW5hYmxlQ2FjaGU6IHRydWUsXG4gIGNhY2hlVGltZW91dDogNSAqIDYwICogMTAwMCAvLyA1IG1pbnV0ZXNcbn07XG5cbi8vIENvbnN0YW50ZXMgREVGQVVMVCBtb3ZpZGFzIGEgdXNlT3JkZXJzU3RhdGUudHNcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENPTkZJR1VSQUNJw5NOIERFTCBIT09LIE9SUVVFU1RBRE9SXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyBGdW5jaW9uZXMgZGUgY2FjaGUgbW92aWRhcyBhIHVzZU9yZGVyc0NhY2hlLnRzXG5cbi8vIEZ1bmNpb25lcyBkZSBjYWNoZSBtb3ZpZGFzIGEgdXNlT3JkZXJzQ2FjaGUudHNcblxuLy8gVG9kYXMgbGFzIGZ1bmNpb25lcyBkZSBjYWNoZSBtb3ZpZGFzIGEgdXNlT3JkZXJzQ2FjaGUudHNcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhPT0sgUFJJTkNJUEFMXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdChcbiAgaW5pdGlhbEZpbHRlcnM6IFBhcnRpYWw8U3RyaWN0T3JkZXJGaWx0ZXJzPiA9IHt9LFxuICBvcHRpb25zOiBQYXJ0aWFsPFVzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RPcHRpb25zPiA9IHt9XG4pOiBVc2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0UmV0dXJuIHtcbiAgY29uc3QgeyB0b2FzdCB9ID0gdXNlVG9hc3QoKTtcbiAgY29uc3QgYXBpTW9uaXRvcmluZyA9IHVzZUFwaU1vbml0b3JpbmcoKTtcbiAgY29uc3Qgb3B0cyA9IHVzZU1lbW8oKCkgPT4gKHsgLi4uREVGQVVMVF9PUFRJT05TLCAuLi5vcHRpb25zIH0pLCBbb3B0aW9uc10pO1xuXG4gIC8vIE1lbW9pemFyIGxhcyBmdW5jaW9uZXMgZGUgbW9uaXRvcmVvIHBhcmEgZXZpdGFyIHJlY3JlYWNpb25lc1xuICBjb25zdCByZWNvcmREaXNjcmVwYW5jeSA9IHVzZUNhbGxiYWNrKGFwaU1vbml0b3JpbmcucmVjb3JkRGlzY3JlcGFuY3ksIFtdKTtcbiAgY29uc3QgcmVjb3JkUmVuZGVyaW5nSXNzdWUgPSB1c2VDYWxsYmFjayhhcGlNb25pdG9yaW5nLnJlY29yZFJlbmRlcmluZ0lzc3VlLCBbXSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSE9PS1MgRVNQRUNJQUxJWkFET1NcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLyBIb29rIGRlIGNhY2hlXG4gIGNvbnN0IGNhY2hlID0gdXNlT3JkZXJzQ2FjaGUoe1xuICAgIGVuYWJsZUNhY2hlOiBvcHRzLmVuYWJsZUNhY2hlLFxuICAgIGNhY2hlVGltZW91dDogb3B0cy5jYWNoZVRpbWVvdXQsXG4gICAgbWF4U2l6ZTogNTAsXG4gICAgY2xlYW51cEludGVydmFsOiAxMCAqIDYwICogMTAwMCxcbiAgICBtaW5SZXF1ZXN0SW50ZXJ2YWw6IDEwMDBcbiAgfSk7XG5cbiAgLy8gSG9vayBkZSBlc3RhZG9cbiAgY29uc3Qgc3RhdGUgPSB1c2VPcmRlcnNTdGF0ZShpbml0aWFsRmlsdGVycyk7XG5cbiAgLy8gSG9vayBkZSBBUElcbiAgY29uc3QgYXBpID0gdXNlT3JkZXJzQXBpKHtcbiAgICB0aW1lb3V0OiBvcHRzLnRpbWVvdXQsXG4gICAgbWF4UmV0cmllczogb3B0cy5tYXhSZXRyaWVzLFxuICAgIGVuYWJsZUNhY2hlOiBvcHRzLmVuYWJsZUNhY2hlLFxuICAgIGNhY2hlXG4gIH0pO1xuICBcbiAgLy8gUmVmZXJlbmNpYXMgcGFyYSBjb250cm9sIGRlIHJlcXVlc3RzIChzaW1wbGlmaWNhZGFzKVxuICBjb25zdCByZXRyeUNvdW50UmVmID0gdXNlUmVmKDApO1xuICBjb25zdCByZWZldGNoSW50ZXJ2YWxSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgZGVib3VuY2VUaW1lb3V0UmVmID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRlVOQ0lPTkVTIERFIEZFVENIIFNJTVBMSUZJQ0FEQVNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLyBVc2FyIGVsIGhvb2sgZGUgQVBJIGRpcmVjdGFtZW50ZVxuICBjb25zdCBmZXRjaE9yZGVyc0ludGVybmFsID0gYXBpLmZldGNoT3JkZXJzSW50ZXJuYWw7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRlVOQ0lPTkVTIERFIEZFVENIIFDDmkJMSUNBU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8vIEzDs2dpY2EgZGUgZmV0Y2ggbW92aWRhIGEgdXNlT3JkZXJzQXBpLnRzXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRlVOQ0nDk04gREUgRkVUQ0ggUMOaQkxJQ0EgQ09OIFJFVFJZXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gRnVuY2nDs24gaW50ZXJuYSBzaW4gZGVib3VuY2UgcGFyYSB1c28gZGlyZWN0b1xuICBjb25zdCBmZXRjaE9yZGVyc0ltbWVkaWF0ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdGaWx0ZXJzOiBQYXJ0aWFsPFN0cmljdE9yZGVyRmlsdGVycz4gPSB7fSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbdXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdF0gZmV0Y2hPcmRlcnNJbW1lZGlhdGUgY2FsbGVkIHdpdGggZmlsdGVyczonLCBuZXdGaWx0ZXJzKTtcbiAgICBjb25zb2xlLmxvZygnW3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RdIEN1cnJlbnQgc3RhdGUgZmlsdGVyczonLCBzdGF0ZS5maWx0ZXJzKTtcbiAgICBcbiAgICAvLyBHZW5lcmFyIGNsYXZlIMO6bmljYSBwYXJhIGVzdGEgcGV0aWNpw7NuXG4gICAgY29uc3QgcmVxdWVzdEtleSA9IEpTT04uc3RyaW5naWZ5KHsgLi4uc3RhdGUuZmlsdGVycywgLi4ubmV3RmlsdGVycyB9KTtcbiAgICBjb25zb2xlLmxvZygnW3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RdIFJlcXVlc3Qga2V5OicsIHJlcXVlc3RLZXkpO1xuXG4gICAgLy8gRXZpdGFyIHBldGljaW9uZXMgZHVwbGljYWRhc1xuICAgIGlmIChzdGF0ZS5oYXNGaWx0ZXJzQ2hhbmdlZCh7IC4uLnN0YXRlLmZpbHRlcnMsIC4uLm5ld0ZpbHRlcnMgfSkgJiYgc3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RdIFNraXBwaW5nIGR1cGxpY2F0ZSByZXF1ZXN0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsaXphciBmaWx0cm9zIHkgZXN0YWRvIGRlIGNhcmdhXG4gICAgY29uc29sZS5sb2coJ1t1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0XSBVcGRhdGluZyBmaWx0ZXJzIGFuZCBzZXR0aW5nIGxvYWRpbmcgdG8gdHJ1ZScpO1xuICAgIHN0YXRlLnVwZGF0ZUZpbHRlcnMobmV3RmlsdGVycyk7XG4gICAgc3RhdGUuc2V0TG9hZGluZyh0cnVlKTtcbiAgICByZXRyeUNvdW50UmVmLmN1cnJlbnQgPSAwO1xuXG4gICAgY29uc3QgYXR0ZW1wdEZldGNoID0gYXN5bmMgKGF0dGVtcHQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgY29uc3QgY3VycmVudEZpbHRlcnMgPSBzdGF0ZS5nZXRMYXN0RmlsdGVycygpO1xuICAgICAgY29uc29sZS5sb2coJ1t1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0XSBhdHRlbXB0RmV0Y2ggLSBhdHRlbXB0OicsIGF0dGVtcHQsICdmaWx0ZXJzOicsIGN1cnJlbnRGaWx0ZXJzKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hPcmRlcnNJbnRlcm5hbChjdXJyZW50RmlsdGVycywgYXR0ZW1wdCA+IDApO1xuICAgICAgY29uc29sZS5sb2coJ1t1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0XSBBUEkgcmVzdWx0OicsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChpc1N0cmljdEFwaVJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1t1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0XSBWYWxpZCBBUEkgcmVzcG9uc2UgcmVjZWl2ZWQ6JywgcmVzdWx0LmRhdGEpO1xuICAgICAgICAvLyBNb25pdG9yZW8gYXV0b23DoXRpY28gZGUgZGlzY3JlcGFuY2lhc1xuICAgICAgICBjb25zdCBleHBlY3RlZENvdW50ID0gcmVzdWx0LmRhdGEucGFnaW5hdGlvbi50b3RhbDtcbiAgICAgICAgY29uc3QgYWN0dWFsQ291bnQgPSByZXN1bHQuZGF0YS5vcmRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAvYXBpL2FkbWluL29yZGVycz8ke25ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgIHBhZ2U6IGN1cnJlbnRGaWx0ZXJzLnBhZ2U/LnRvU3RyaW5nKCkgfHwgJzEnLFxuICAgICAgICAgIGxpbWl0OiBjdXJyZW50RmlsdGVycy5saW1pdD8udG9TdHJpbmcoKSB8fCAnMjAnLFxuICAgICAgICAgIC4uLihjdXJyZW50RmlsdGVycy5zdGF0dXMgJiYgeyBzdGF0dXM6IGN1cnJlbnRGaWx0ZXJzLnN0YXR1cyB9KSxcbiAgICAgICAgICAuLi4oY3VycmVudEZpbHRlcnMucGF5bWVudF9zdGF0dXMgJiYgeyBwYXltZW50X3N0YXR1czogY3VycmVudEZpbHRlcnMucGF5bWVudF9zdGF0dXMgfSksXG4gICAgICAgICAgLi4uKGN1cnJlbnRGaWx0ZXJzLmZ1bGZpbGxtZW50X3N0YXR1cyAmJiB7IGZ1bGZpbGxtZW50X3N0YXR1czogY3VycmVudEZpbHRlcnMuZnVsZmlsbG1lbnRfc3RhdHVzIH0pLFxuICAgICAgICAgIC4uLihjdXJyZW50RmlsdGVycy5zb3J0X2J5ICYmIHsgc29ydF9ieTogY3VycmVudEZpbHRlcnMuc29ydF9ieSB9KSxcbiAgICAgICAgICAuLi4oY3VycmVudEZpbHRlcnMuc29ydF9vcmRlciAmJiB7IHNvcnRfb3JkZXI6IGN1cnJlbnRGaWx0ZXJzLnNvcnRfb3JkZXIgfSlcbiAgICAgICAgfSkudG9TdHJpbmcoKX1gO1xuXG4gICAgICAgIC8vIFNvbG8gcmVnaXN0cmFyIGRpc2NyZXBhbmNpYSBzaSBoYXkgdW5hIGRpZmVyZW5jaWEgcmVhbCAobm8gcG9yIHBhZ2luYWNpw7NuKVxuICAgICAgICBjb25zdCBleHBlY3RlZFBhZ2VDb3VudCA9IE1hdGgubWluKGN1cnJlbnRGaWx0ZXJzLmxpbWl0IHx8IDIwLCBleHBlY3RlZENvdW50IC0gKChjdXJyZW50RmlsdGVycy5wYWdlIHx8IDEpIC0gMSkgKiAoY3VycmVudEZpbHRlcnMubGltaXQgfHwgMjApKTtcbiAgICAgICAgaWYgKGFjdHVhbENvdW50IDwgZXhwZWN0ZWRQYWdlQ291bnQgJiYgZXhwZWN0ZWRQYWdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgcmVjb3JkRGlzY3JlcGFuY3koZW5kcG9pbnQsIGV4cGVjdGVkUGFnZUNvdW50LCBhY3R1YWxDb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3R1YWxpemFyIGVzdGFkbyB1c2FuZG8gZWwgaG9vayBlc3BlY2lhbGl6YWRvXG4gICAgICAgIHN0YXRlLnNldE9yZGVycyhyZXN1bHQuZGF0YS5vcmRlcnMpO1xuICAgICAgICBzdGF0ZS5zZXRQYWdpbmF0aW9uKHJlc3VsdC5kYXRhLnBhZ2luYXRpb24pO1xuICAgICAgICBzdGF0ZS5zZXRBbmFseXRpY3MocmVzdWx0LmRhdGEuYW5hbHl0aWNzIHx8IG51bGwpO1xuICAgICAgICByZXRyeUNvdW50UmVmLmN1cnJlbnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXMgdW4gZXJyb3JcbiAgICAgICAgaWYgKGF0dGVtcHQgPCBvcHRzLm1heFJldHJpZXMgJiYgcmVzdWx0LmNvZGUgIT09ICdSRVFVRVNUX0NBTkNFTExFRCcpIHtcbiAgICAgICAgICByZXRyeUNvdW50UmVmLmN1cnJlbnQgPSBhdHRlbXB0ICsgMTtcbiAgICAgICAgICAvLyBFc3BlcmFyIGFudGVzIGRlbCByZXRyeSAoZXhwb25lbnRpYWwgYmFja29mZilcbiAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKDEwMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSwgMTAwMDApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgIHJldHVybiBhdHRlbXB0RmV0Y2goYXR0ZW1wdCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTcOheGltbyBkZSByZWludGVudG9zIGFsY2FuemFkbyBvIGVycm9yIG5vIHJlY3VwZXJhYmxlXG4gICAgICAgIHN0YXRlLnNldEVycm9yKHJlc3VsdC5lcnJvcik7XG5cbiAgICAgICAgLy8gUmVnaXN0cmFyIHByb2JsZW1hIGRlIHJlbmRlcml6YWRvIHBvciBlcnJvciBkZSBBUElcbiAgICAgICAgcmVjb3JkUmVuZGVyaW5nSXNzdWUoXG4gICAgICAgICAgJ3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3QnLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBjdXJyZW50RmlsdGVycyxcbiAgICAgICAgICByZXN1bHQuZXJyb3JcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBNb3N0cmFyIHRvYXN0IGRlIGVycm9yXG4gICAgICAgIGlmIChyZXN1bHQuY29kZSAhPT0gJ1JFUVVFU1RfQ0FOQ0VMTEVEJykge1xuICAgICAgICAgIHRvYXN0KHtcbiAgICAgICAgICAgIHRpdGxlOiAnRXJyb3IgYWwgY2FyZ2FyIMOzcmRlbmVzJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiByZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICB2YXJpYW50OiAnZGVzdHJ1Y3RpdmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgYXdhaXQgYXR0ZW1wdEZldGNoKDApO1xuICB9LCBbZmV0Y2hPcmRlcnNJbnRlcm5hbCwgb3B0cy5tYXhSZXRyaWVzLCB0b2FzdCwgcmVjb3JkRGlzY3JlcGFuY3ksIHJlY29yZFJlbmRlcmluZ0lzc3VlLCBzdGF0ZV0pO1xuXG4gIC8vIEZ1bmNpw7NuIGZldGNoT3JkZXJzIGNvbiBkZWJvdW5jaW5nIHBhcmEgZXZpdGFyIHBldGljaW9uZXMgbcO6bHRpcGxlc1xuICBjb25zdCBmZXRjaE9yZGVycyA9IHVzZUNhbGxiYWNrKChuZXdGaWx0ZXJzOiBQYXJ0aWFsPFN0cmljdE9yZGVyRmlsdGVycz4gPSB7fSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgLy8gTGltcGlhciB0aW1lb3V0IGFudGVyaW9yIHNpIGV4aXN0ZVxuICAgICAgaWYgKGRlYm91bmNlVGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvbmZpZ3VyYXIgbnVldm8gdGltZW91dCBjb24gZGVib3VuY2VcbiAgICAgIGNvbnN0IGRlYm91bmNlTXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IDMwMCA6IDE1MDtcbiAgICAgIGRlYm91bmNlVGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgZmV0Y2hPcmRlcnNJbW1lZGlhdGUobmV3RmlsdGVycyk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGRlYm91bmNlZCBmZXRjaE9yZGVyczonLCBlcnJvcik7XG4gICAgICAgICAgcmVzb2x2ZSgpOyAvLyBSZXNvbHZlciBpbmNsdXNvIGVuIGNhc28gZGUgZXJyb3IgcGFyYSBldml0YXIgcHJvbWVzYXMgY29sZ2FkYXNcbiAgICAgICAgfVxuICAgICAgfSwgZGVib3VuY2VNcyk7XG4gICAgfSk7XG4gIH0sIFtmZXRjaE9yZGVyc0ltbWVkaWF0ZV0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIE9UUkFTIEFDQ0lPTkVTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgY29uc3QgcmVmcmVzaE9yZGVycyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAvLyBMaW1waWFyIGNhY2hlIHBhcmEgZm9yemFyIHJlZnJlc2hcbiAgICBpZiAob3B0cy5lbmFibGVDYWNoZSkge1xuICAgICAgY2FjaGUuY2xlYXJDYWNoZSgpO1xuICAgIH1cbiAgICBhd2FpdCBmZXRjaE9yZGVycygpO1xuICB9LCBbZmV0Y2hPcmRlcnMsIG9wdHMuZW5hYmxlQ2FjaGUsIGNhY2hlXSk7XG5cbiAgLy8gVXNhciBsYXMgZnVuY2lvbmVzIGRlbCBob29rIGRlIGVzdGFkbyBkaXJlY3RhbWVudGVcbiAgY29uc3QgdXBkYXRlRmlsdGVycyA9IHN0YXRlLnVwZGF0ZUZpbHRlcnM7XG4gIGNvbnN0IGNsZWFyRXJyb3IgPSBzdGF0ZS5jbGVhckVycm9yO1xuXG4gIGNvbnN0IHJldHJ5TGFzdFJlcXVlc3QgPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc3QgbGFzdEZpbHRlcnMgPSBzdGF0ZS5nZXRMYXN0RmlsdGVycygpO1xuICAgIGlmIChsYXN0RmlsdGVycykge1xuICAgICAgYXdhaXQgZmV0Y2hPcmRlcnMobGFzdEZpbHRlcnMpO1xuICAgIH1cbiAgfSwgW2ZldGNoT3JkZXJzLCBzdGF0ZV0pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEVGRUNUT1NcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLyBBdXRvLWZldGNoIGluaWNpYWwgLSBTSU1QTElGSUNBRE9cbiAgY29uc3QgaGFzSW5pdGlhbEZldGNoUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob3B0cy5hdXRvRmV0Y2ggJiYgIWhhc0luaXRpYWxGZXRjaFJlZi5jdXJyZW50KSB7XG4gICAgICBoYXNJbml0aWFsRmV0Y2hSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBmZXRjaE9yZGVycygpO1xuICAgIH1cbiAgfSwgW29wdHMuYXV0b0ZldGNoXSk7IC8vIFNvbG8gZWplY3V0YXIgdW5hIHZleiBhbCBtb250YXJcblxuICAvLyBFc2N1Y2hhciBjYW1iaW9zIGVuIGZpbHRyb3MgY29uIGRlYm91bmNpbmcgb3B0aW1pemFkb1xuICBjb25zdCBmaWx0ZXJzUmVmID0gdXNlUmVmKHN0YXRlLmZpbHRlcnMpO1xuICBjb25zdCBpc0luaXRpYWxNb3VudCA9IHVzZVJlZih0cnVlKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRXZpdGFyIGZldGNoIGVuIGVsIHByaW1lciByZW5kZXIgKHlhIHNlIGhhY2UgZW4gYXV0by1mZXRjaClcbiAgICBpZiAoaXNJbml0aWFsTW91bnQuY3VycmVudCkge1xuICAgICAgaXNJbml0aWFsTW91bnQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgZmlsdGVyc1JlZi5jdXJyZW50ID0gc3RhdGUuZmlsdGVycztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTb2xvIGhhY2VyIGZldGNoIHNpIGxvcyBmaWx0cm9zIGhhbiBjYW1iaWFkbyByZWFsbWVudGVcbiAgICBjb25zdCBoYXNDaGFuZ2VkID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyc1JlZi5jdXJyZW50KSAhPT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUuZmlsdGVycyk7XG4gICAgXG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgIGZpbHRlcnNSZWYuY3VycmVudCA9IHN0YXRlLmZpbHRlcnM7XG4gICAgICBmZXRjaE9yZGVycygpO1xuICAgIH1cbiAgfSwgW3N0YXRlLmZpbHRlcnMsIGZldGNoT3JkZXJzXSk7IC8vIERlcGVuZGVuY2lhcyBtw61uaW1hcyB5IGVzdGFibGVzXG5cbiAgLy8gUmVmZXRjaCBpbnRlcnZhbCAtIFRFTVBPUkFMTUVOVEUgREVTSEFCSUxJVEFETyBwYXJhIGV2aXRhciByZWZyZXNjbyBpbmZpbml0b1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE5PVEE6IFJlZmV0Y2ggaW50ZXJ2YWwgZGVzaGFiaWxpdGFkbyB0ZW1wb3JhbG1lbnRlIHBhcmEgc29sdWNpb25hciByZWZyZXNjbyBpbmZpbml0b1xuICAgIC8vIFRPRE86IFJlaW1wbGVtZW50YXIgY29uIHVzZVJlZiBwYXJhIGZldGNoT3JkZXJzIG8gdXNhciBSZWFjdCBRdWVyeVxuICAgIC8qXG4gICAgaWYgKG9wdHMucmVmZXRjaEludGVydmFsID4gMCkge1xuICAgICAgcmVmZXRjaEludGVydmFsUmVmLmN1cnJlbnQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICghc3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgICAgICAgZmV0Y2hPcmRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgfSwgb3B0cy5yZWZldGNoSW50ZXJ2YWwpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAocmVmZXRjaEludGVydmFsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHJlZmV0Y2hJbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgKi9cbiAgfSwgW29wdHMucmVmZXRjaEludGVydmFsXSk7XG5cbiAgLy8gTGltcGllemEgYXV0b23DoXRpY2EgZGUgY2FjaGUgbW92aWRhIGEgdXNlT3JkZXJzQ2FjaGUudHNcblxuICAvLyBDbGVhbnVwIGFsIGRlc21vbnRhclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDYW5jZWxhciBwZXRpY2lvbmVzIGVuIHByb2dyZXNvIHVzYW5kbyBlbCBob29rIGRlIEFQSVxuICAgICAgYXBpLmFib3J0Q3VycmVudFJlcXVlc3QoKTtcblxuICAgICAgLy8gTGltcGlhciBpbnRlcnZhbG9zIHkgdGltZW91dHNcbiAgICAgIGlmIChyZWZldGNoSW50ZXJ2YWxSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKHJlZmV0Y2hJbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWJvdW5jZVRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1t1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0XSBIb29rIGNsZWFudXAgY29tcGxldGVkJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FwaV0pOyAvLyBEZXBlbmRlIGRlbCBob29rIGRlIEFQSVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFJFVE9STk8gREVMIEhPT0tcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICByZXR1cm4ge1xuICAgIC8vIEVzdGFkb1xuICAgIG9yZGVyczogc3RhdGUub3JkZXJzLFxuICAgIHBhZ2luYXRpb246IHN0YXRlLnBhZ2luYXRpb24sXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycyxcbiAgICBhbmFseXRpY3M6IHN0YXRlLmFuYWx5dGljcyxcbiAgICBpc0xvYWRpbmc6IHN0YXRlLmlzTG9hZGluZyxcbiAgICBlcnJvcjogc3RhdGUuZXJyb3IsXG4gICAgbGFzdEZldGNoOiBzdGF0ZS5sYXN0RmV0Y2gsXG4gICAgXG4gICAgLy8gQWNjaW9uZXNcbiAgICBmZXRjaE9yZGVycyxcbiAgICByZWZyZXNoT3JkZXJzLFxuICAgIHVwZGF0ZUZpbHRlcnMsXG4gICAgY2xlYXJFcnJvcixcbiAgICByZXRyeUxhc3RSZXF1ZXN0XG4gIH07XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIT09LIFBBUkEgT1JERU4gSU5ESVZJRFVBTFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU9yZGVyRGV0YWlsU3RyaWN0KG9yZGVySWQ6IHN0cmluZyB8IG51bGwpIHtcbiAgY29uc3QgeyB0b2FzdCB9ID0gdXNlVG9hc3QoKTtcbiAgY29uc3QgW29yZGVyLCBzZXRPcmRlcl0gPSB1c2VTdGF0ZTxTdHJpY3RPcmRlckVudGVycHJpc2UgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBmZXRjaE9yZGVyID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghb3JkZXJJZCkgcmV0dXJuO1xuXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvYWRtaW4vb3JkZXJzLyR7b3JkZXJJZH1gKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3BvbnNlID0gdG9TdHJpY3RPcmRlcnNSZXNwb25zZShkYXRhKTtcbiAgICAgIFxuICAgICAgaWYgKGlzU3RyaWN0QXBpRXJyb3IodmFsaWRhdGVkUmVzcG9uc2UpKSB7XG4gICAgICAgIHNldEVycm9yKHZhbGlkYXRlZFJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgdG9hc3Qoe1xuICAgICAgICAgIHRpdGxlOiAnRXJyb3IgYWwgY2FyZ2FyIG9yZGVuJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdmFsaWRhdGVkUmVzcG9uc2UuZXJyb3IsXG4gICAgICAgICAgdmFyaWFudDogJ2Rlc3RydWN0aXZlJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcmEgb3JkZW4gaW5kaXZpZHVhbCwgZXh0cmFlciBsYSBwcmltZXJhIG9yZGVuXG4gICAgICAgIGNvbnN0IG9yZGVyRGF0YSA9IHZhbGlkYXRlZFJlc3BvbnNlLmRhdGEub3JkZXJzWzBdIHx8IG51bGw7XG4gICAgICAgIHNldE9yZGVyKG9yZGVyRGF0YSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJztcbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiAnRXJyb3IgYWwgY2FyZ2FyIG9yZGVuJyxcbiAgICAgICAgZGVzY3JpcHRpb246IGVycm9yTWVzc2FnZSxcbiAgICAgICAgdmFyaWFudDogJ2Rlc3RydWN0aXZlJ1xuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbb3JkZXJJZCwgdG9hc3RdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoT3JkZXIoKTtcbiAgfSwgW2ZldGNoT3JkZXJdKTtcblxuICByZXR1cm4ge1xuICAgIG9yZGVyLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICByZWZldGNoOiBmZXRjaE9yZGVyXG4gIH07XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVVElMSURBREVTIEVYUE9SVEFEQVNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogVXRpbGlkYWRlcyBkZSBjYWNoZSBtb3ZpZGFzIGEgdXNlT3JkZXJzQ2FjaGUudHNcbiAqIEVzdGFzIGZ1bmNpb25lcyBlc3TDoW4gZGlzcG9uaWJsZXMgYSB0cmF2w6lzIGRlbCBob29rIHVzZU9yZGVyc0NhY2hlXG4gKi9cblxuLy8gTGFzIHV0aWxpZGFkZXMgZGUgY2FjaGUgYWhvcmEgZXN0w6FuIGRpc3BvbmlibGVzIGEgdHJhdsOpcyBkZWwgaG9vayB1c2VPcmRlcnNDYWNoZTpcbi8vIC0gY2FjaGUuY2xlYXJDYWNoZSgpXG4vLyAtIGNhY2hlLmdldENhY2hlU3RhdHMoKVxuLy8gLSBjYWNoZS5nZXRQZW5kaW5nUmVxdWVzdCgpXG4vLyAtIGNhY2hlLnNldFBlbmRpbmdSZXF1ZXN0KCkiXSwibmFtZXMiOlsidXNlT3JkZXJEZXRhaWxTdHJpY3QiLCJ1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0IiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsInRpbWVvdXQiLCJhcmdzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIkRFRkFVTFRfT1BUSU9OUyIsImF1dG9GZXRjaCIsInJlZmV0Y2hJbnRlcnZhbCIsIm1heFJldHJpZXMiLCJlbmFibGVDYWNoZSIsImNhY2hlVGltZW91dCIsImluaXRpYWxGaWx0ZXJzIiwib3B0aW9ucyIsInRvYXN0IiwidXNlVG9hc3QiLCJhcGlNb25pdG9yaW5nIiwidXNlQXBpTW9uaXRvcmluZyIsIm9wdHMiLCJ1c2VNZW1vIiwicmVjb3JkRGlzY3JlcGFuY3kiLCJ1c2VDYWxsYmFjayIsInJlY29yZFJlbmRlcmluZ0lzc3VlIiwiY2FjaGUiLCJ1c2VPcmRlcnNDYWNoZSIsIm1heFNpemUiLCJjbGVhbnVwSW50ZXJ2YWwiLCJtaW5SZXF1ZXN0SW50ZXJ2YWwiLCJzdGF0ZSIsInVzZU9yZGVyc1N0YXRlIiwiYXBpIiwidXNlT3JkZXJzQXBpIiwicmV0cnlDb3VudFJlZiIsInVzZVJlZiIsInJlZmV0Y2hJbnRlcnZhbFJlZiIsImRlYm91bmNlVGltZW91dFJlZiIsImZldGNoT3JkZXJzSW50ZXJuYWwiLCJmZXRjaE9yZGVyc0ltbWVkaWF0ZSIsIm5ld0ZpbHRlcnMiLCJjb25zb2xlIiwibG9nIiwiZmlsdGVycyIsInJlcXVlc3RLZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiaGFzRmlsdGVyc0NoYW5nZWQiLCJpc0xvYWRpbmciLCJ1cGRhdGVGaWx0ZXJzIiwic2V0TG9hZGluZyIsImN1cnJlbnQiLCJhdHRlbXB0RmV0Y2giLCJhdHRlbXB0IiwiY3VycmVudEZpbHRlcnMiLCJnZXRMYXN0RmlsdGVycyIsInJlc3VsdCIsImlzU3RyaWN0QXBpUmVzcG9uc2UiLCJkYXRhIiwiZXhwZWN0ZWRDb3VudCIsInBhZ2luYXRpb24iLCJ0b3RhbCIsImFjdHVhbENvdW50Iiwib3JkZXJzIiwibGVuZ3RoIiwiZW5kcG9pbnQiLCJVUkxTZWFyY2hQYXJhbXMiLCJwYWdlIiwidG9TdHJpbmciLCJsaW1pdCIsInN0YXR1cyIsInBheW1lbnRfc3RhdHVzIiwiZnVsZmlsbG1lbnRfc3RhdHVzIiwic29ydF9ieSIsInNvcnRfb3JkZXIiLCJleHBlY3RlZFBhZ2VDb3VudCIsIk1hdGgiLCJtaW4iLCJzZXRPcmRlcnMiLCJzZXRQYWdpbmF0aW9uIiwic2V0QW5hbHl0aWNzIiwiYW5hbHl0aWNzIiwiY29kZSIsImRlbGF5IiwicG93IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRFcnJvciIsImVycm9yIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInZhcmlhbnQiLCJmZXRjaE9yZGVycyIsImRlYm91bmNlTXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJyZWZyZXNoT3JkZXJzIiwiY2xlYXJDYWNoZSIsImNsZWFyRXJyb3IiLCJyZXRyeUxhc3RSZXF1ZXN0IiwibGFzdEZpbHRlcnMiLCJoYXNJbml0aWFsRmV0Y2hSZWYiLCJ1c2VFZmZlY3QiLCJmaWx0ZXJzUmVmIiwiaXNJbml0aWFsTW91bnQiLCJoYXNDaGFuZ2VkIiwiYWJvcnRDdXJyZW50UmVxdWVzdCIsImNsZWFySW50ZXJ2YWwiLCJsYXN0RmV0Y2giLCJvcmRlcklkIiwib3JkZXIiLCJzZXRPcmRlciIsInVzZVN0YXRlIiwic2V0SXNMb2FkaW5nIiwiZmV0Y2hPcmRlciIsInJlc3BvbnNlIiwiZmV0Y2giLCJqc29uIiwidmFsaWRhdGVkUmVzcG9uc2UiLCJ0b1N0cmljdE9yZGVyc1Jlc3BvbnNlIiwiaXNTdHJpY3RBcGlFcnJvciIsIm9yZGVyRGF0YSIsImVyciIsImVycm9yTWVzc2FnZSIsIkVycm9yIiwibWVzc2FnZSIsInJlZmV0Y2giXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0Qyx1REFBdUQ7QUFDdkQsbUVBQW1FO0FBQ25FLHNDQUFzQzs7Ozs7Ozs7Ozs7O1FBd1l0QkE7ZUFBQUE7O1FBelNBQztlQUFBQTs7O3VCQTdGd0M7MEJBQy9COzJCQVVsQjsrQkFF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