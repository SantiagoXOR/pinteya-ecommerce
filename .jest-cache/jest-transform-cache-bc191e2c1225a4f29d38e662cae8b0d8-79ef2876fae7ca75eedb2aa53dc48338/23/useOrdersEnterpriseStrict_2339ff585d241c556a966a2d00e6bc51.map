{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\hooks\\admin\\useOrdersEnterpriseStrict.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - STRICT ORDERS HOOK (REFACTORED)\n// Hook orquestador para gestión de órdenes con validación estricta\n// ===================================\n\nimport { useEffect, useCallback, useRef, useMemo } from 'react';\nimport { useToast } from '@/hooks/use-toast';\nimport {\n  StrictOrdersListResponse,\n  StrictApiError,\n  ApiResult,\n  createStrictApiError,\n  StrictOrderEnterprise,\n  StrictPagination,\n  isStrictApiError,\n  isStrictApiResponse\n} from '@/types/api-strict';\nimport { OrderStatus, PaymentStatus, FulfillmentStatus } from '@/types/orders-enterprise';\nimport { useApiMonitoring } from '@/utils/api-monitoring';\nimport { useOrdersCache } from './useOrdersCache';\nimport { useOrdersApi } from './useOrdersApi';\nimport { useOrdersState, StrictOrdersState, StrictOrdersActions } from './useOrdersState';\n\n// Función de debounce para evitar peticiones múltiples\nfunction debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n// ===================================\n// TIPOS DE FILTROS ESTRICTOS\n// ===================================\n\nexport interface StrictOrderFilters {\n  readonly search?: string;\n  readonly status?: OrderStatus | 'all';\n  readonly payment_status?: PaymentStatus | 'all';\n  readonly fulfillment_status?: FulfillmentStatus | 'all';\n  readonly date_from?: string;\n  readonly date_to?: string;\n  readonly page?: number;\n  readonly limit?: number;\n  readonly sort_by?: 'created_at' | 'updated_at' | 'total' | 'order_number';\n  readonly sort_order?: 'asc' | 'desc';\n}\n\n// Tipos movidos a useOrdersState.ts\n\nexport interface UseOrdersEnterpriseStrictReturn extends StrictOrdersState, StrictOrdersActions {\n  readonly fetchOrders: (filters?: Partial<StrictOrderFilters>) => Promise<void>;\n  readonly refreshOrders: () => Promise<void>;\n  readonly retryLastRequest: () => Promise<void>;\n}\n\n// ===================================\n// CONFIGURACIÓN DEL HOOK\n// ===================================\n\ninterface UseOrdersEnterpriseStrictOptions {\n  readonly autoFetch?: boolean;\n  readonly refetchInterval?: number;\n  readonly maxRetries?: number;\n  readonly timeout?: number;\n  readonly enableCache?: boolean;\n  readonly cacheTimeout?: number;\n}\n\nconst DEFAULT_OPTIONS: Required<UseOrdersEnterpriseStrictOptions> = {\n  autoFetch: true,\n  refetchInterval: 0, // 0 = disabled\n  maxRetries: 3,\n  timeout: 10000, // 10 seconds\n  enableCache: true,\n  cacheTimeout: 5 * 60 * 1000 // 5 minutes\n};\n\n// Constantes DEFAULT movidas a useOrdersState.ts\n\n// ===================================\n// CONFIGURACIÓN DEL HOOK ORQUESTADOR\n// ===================================\n\n// Funciones de cache movidas a useOrdersCache.ts\n\n// Funciones de cache movidas a useOrdersCache.ts\n\n// Todas las funciones de cache movidas a useOrdersCache.ts\n\n// ===================================\n// HOOK PRINCIPAL\n// ===================================\n\nexport function useOrdersEnterpriseStrict(\n  initialFilters: Partial<StrictOrderFilters> = {},\n  options: Partial<UseOrdersEnterpriseStrictOptions> = {}\n): UseOrdersEnterpriseStrictReturn {\n  const { toast } = useToast();\n  const apiMonitoring = useApiMonitoring();\n  const opts = useMemo(() => ({ ...DEFAULT_OPTIONS, ...options }), [options]);\n\n  // Memoizar las funciones de monitoreo para evitar recreaciones\n  const recordDiscrepancy = useCallback(apiMonitoring.recordDiscrepancy, []);\n  const recordRenderingIssue = useCallback(apiMonitoring.recordRenderingIssue, []);\n\n  // ===================================\n  // HOOKS ESPECIALIZADOS\n  // ===================================\n\n  // Hook de cache\n  const cache = useOrdersCache({\n    enableCache: opts.enableCache,\n    cacheTimeout: opts.cacheTimeout,\n    maxSize: 50,\n    cleanupInterval: 10 * 60 * 1000,\n    minRequestInterval: 1000\n  });\n\n  // Hook de estado\n  const state = useOrdersState(initialFilters);\n\n  // Hook de API\n  const api = useOrdersApi({\n    timeout: opts.timeout,\n    maxRetries: opts.maxRetries,\n    enableCache: opts.enableCache,\n    cache\n  });\n  \n  // Referencias para control de requests (simplificadas)\n  const retryCountRef = useRef(0);\n  const refetchIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // ===================================\n  // FUNCIONES DE FETCH SIMPLIFICADAS\n  // ===================================\n\n  // Usar el hook de API directamente\n  const fetchOrdersInternal = api.fetchOrdersInternal;\n\n  // ===================================\n  // FUNCIONES DE FETCH PÚBLICAS\n  // ===================================\n\n  // Lógica de fetch movida a useOrdersApi.ts\n\n  // ===================================\n  // FUNCIÓN DE FETCH PÚBLICA CON RETRY\n  // ===================================\n\n  // Función interna sin debounce para uso directo\n  const fetchOrdersImmediate = useCallback(async (newFilters: Partial<StrictOrderFilters> = {}): Promise<void> => {\n    console.log('[useOrdersEnterpriseStrict] fetchOrdersImmediate called with filters:', newFilters);\n    console.log('[useOrdersEnterpriseStrict] Current state filters:', state.filters);\n    \n    // Generar clave única para esta petición\n    const requestKey = JSON.stringify({ ...state.filters, ...newFilters });\n    console.log('[useOrdersEnterpriseStrict] Request key:', requestKey);\n\n    // Evitar peticiones duplicadas\n    if (state.hasFiltersChanged({ ...state.filters, ...newFilters }) && state.isLoading) {\n      console.log('[useOrdersEnterpriseStrict] Skipping duplicate request');\n      return;\n    }\n\n    // Actualizar filtros y estado de carga\n    console.log('[useOrdersEnterpriseStrict] Updating filters and setting loading to true');\n    state.updateFilters(newFilters);\n    state.setLoading(true);\n    retryCountRef.current = 0;\n\n    const attemptFetch = async (attempt: number): Promise<void> => {\n      const currentFilters = state.getLastFilters();\n      console.log('[useOrdersEnterpriseStrict] attemptFetch - attempt:', attempt, 'filters:', currentFilters);\n      \n      const result = await fetchOrdersInternal(currentFilters, attempt > 0);\n      console.log('[useOrdersEnterpriseStrict] API result:', result);\n\n      if (isStrictApiResponse(result)) {\n        console.log('[useOrdersEnterpriseStrict] Valid API response received:', result.data);\n        // Monitoreo automático de discrepancias\n        const expectedCount = result.data.pagination.total;\n        const actualCount = result.data.orders.length;\n        const endpoint = `/api/admin/orders?${new URLSearchParams({\n          page: currentFilters.page?.toString() || '1',\n          limit: currentFilters.limit?.toString() || '20',\n          ...(currentFilters.status && { status: currentFilters.status }),\n          ...(currentFilters.payment_status && { payment_status: currentFilters.payment_status }),\n          ...(currentFilters.fulfillment_status && { fulfillment_status: currentFilters.fulfillment_status }),\n          ...(currentFilters.sort_by && { sort_by: currentFilters.sort_by }),\n          ...(currentFilters.sort_order && { sort_order: currentFilters.sort_order })\n        }).toString()}`;\n\n        // Solo registrar discrepancia si hay una diferencia real (no por paginación)\n        const expectedPageCount = Math.min(currentFilters.limit || 20, expectedCount - ((currentFilters.page || 1) - 1) * (currentFilters.limit || 20));\n        if (actualCount < expectedPageCount && expectedPageCount > 0) {\n          recordDiscrepancy(endpoint, expectedPageCount, actualCount);\n        }\n\n        // Actualizar estado usando el hook especializado\n        state.setOrders(result.data.orders);\n        state.setPagination(result.data.pagination);\n        state.setAnalytics(result.data.analytics || null);\n        retryCountRef.current = 0;\n      } else {\n        // Es un error\n        if (attempt < opts.maxRetries && result.code !== 'REQUEST_CANCELLED') {\n          retryCountRef.current = attempt + 1;\n          // Esperar antes del retry (exponential backoff)\n          const delay = Math.min(1000 * Math.pow(2, attempt), 10000);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return attemptFetch(attempt + 1);\n        }\n\n        // Máximo de reintentos alcanzado o error no recuperable\n        state.setError(result.error);\n\n        // Registrar problema de renderizado por error de API\n        recordRenderingIssue(\n          'useOrdersEnterpriseStrict',\n          0,\n          0,\n          currentFilters,\n          result.error\n        );\n\n        // Mostrar toast de error\n        if (result.code !== 'REQUEST_CANCELLED') {\n          toast({\n            title: 'Error al cargar órdenes',\n            description: result.error,\n            variant: 'destructive'\n          });\n        }\n      }\n    };\n\n    await attemptFetch(0);\n  }, [fetchOrdersInternal, opts.maxRetries, toast, recordDiscrepancy, recordRenderingIssue, state]);\n\n  // Función fetchOrders con debouncing para evitar peticiones múltiples\n  const fetchOrders = useCallback((newFilters: Partial<StrictOrderFilters> = {}): Promise<void> => {\n    return new Promise<void>((resolve) => {\n      // Limpiar timeout anterior si existe\n      if (debounceTimeoutRef.current) {\n        clearTimeout(debounceTimeoutRef.current);\n      }\n      \n      // Configurar nuevo timeout con debounce\n      const debounceMs = process.env.NODE_ENV === 'development' ? 300 : 150;\n      debounceTimeoutRef.current = setTimeout(async () => {\n        try {\n          await fetchOrdersImmediate(newFilters);\n          resolve();\n        } catch (error) {\n          console.error('Error in debounced fetchOrders:', error);\n          resolve(); // Resolver incluso en caso de error para evitar promesas colgadas\n        }\n      }, debounceMs);\n    });\n  }, [fetchOrdersImmediate]);\n\n  // ===================================\n  // OTRAS ACCIONES\n  // ===================================\n\n  const refreshOrders = useCallback(async (): Promise<void> => {\n    // Limpiar cache para forzar refresh\n    if (opts.enableCache) {\n      cache.clearCache();\n    }\n    await fetchOrders();\n  }, [fetchOrders, opts.enableCache, cache]);\n\n  // Usar las funciones del hook de estado directamente\n  const updateFilters = state.updateFilters;\n  const clearError = state.clearError;\n\n  const retryLastRequest = useCallback(async (): Promise<void> => {\n    const lastFilters = state.getLastFilters();\n    if (lastFilters) {\n      await fetchOrders(lastFilters);\n    }\n  }, [fetchOrders, state]);\n\n  // ===================================\n  // EFECTOS\n  // ===================================\n\n  // Auto-fetch inicial - SIMPLIFICADO\n  const hasInitialFetchRef = useRef(false);\n  useEffect(() => {\n    if (opts.autoFetch && !hasInitialFetchRef.current) {\n      hasInitialFetchRef.current = true;\n      fetchOrders();\n    }\n  }, [opts.autoFetch]); // Solo ejecutar una vez al montar\n\n  // Escuchar cambios en filtros con debouncing optimizado\n  const filtersRef = useRef(state.filters);\n  const isInitialMount = useRef(true);\n  \n  useEffect(() => {\n    // Evitar fetch en el primer render (ya se hace en auto-fetch)\n    if (isInitialMount.current) {\n      isInitialMount.current = false;\n      filtersRef.current = state.filters;\n      return;\n    }\n\n    // Solo hacer fetch si los filtros han cambiado realmente\n    const hasChanged = JSON.stringify(filtersRef.current) !== JSON.stringify(state.filters);\n    \n    if (hasChanged) {\n      filtersRef.current = state.filters;\n      fetchOrders();\n    }\n  }, [state.filters, fetchOrders]); // Dependencias mínimas y estables\n\n  // Refetch interval - TEMPORALMENTE DESHABILITADO para evitar refresco infinito\n  useEffect(() => {\n    // NOTA: Refetch interval deshabilitado temporalmente para solucionar refresco infinito\n    // TODO: Reimplementar con useRef para fetchOrders o usar React Query\n    /*\n    if (opts.refetchInterval > 0) {\n      refetchIntervalRef.current = setInterval(() => {\n        if (!state.isLoading) {\n          fetchOrders();\n        }\n      }, opts.refetchInterval);\n\n      return () => {\n        if (refetchIntervalRef.current) {\n          clearInterval(refetchIntervalRef.current);\n        }\n      };\n    }\n    */\n  }, [opts.refetchInterval]);\n\n  // Limpieza automática de cache movida a useOrdersCache.ts\n\n  // Cleanup al desmontar\n  useEffect(() => {\n    return () => {\n      // Cancelar peticiones en progreso usando el hook de API\n      api.abortCurrentRequest();\n\n      // Limpiar intervalos y timeouts\n      if (refetchIntervalRef.current) {\n        clearInterval(refetchIntervalRef.current);\n      }\n      if (debounceTimeoutRef.current) {\n        clearTimeout(debounceTimeoutRef.current);\n      }\n      \n      if (process.env.NODE_ENV === 'development') {\n        console.log('[useOrdersEnterpriseStrict] Hook cleanup completed');\n      }\n    };\n  }, [api]); // Depende del hook de API\n\n  // ===================================\n  // RETORNO DEL HOOK\n  // ===================================\n\n  return {\n    // Estado\n    orders: state.orders,\n    pagination: state.pagination,\n    filters: state.filters,\n    analytics: state.analytics,\n    isLoading: state.isLoading,\n    error: state.error,\n    lastFetch: state.lastFetch,\n    \n    // Acciones\n    fetchOrders,\n    refreshOrders,\n    updateFilters,\n    clearError,\n    retryLastRequest\n  };\n}\n\n// ===================================\n// HOOK PARA ORDEN INDIVIDUAL\n// ===================================\n\nexport function useOrderDetailStrict(orderId: string | null) {\n  const { toast } = useToast();\n  const [order, setOrder] = useState<StrictOrderEnterprise | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchOrder = useCallback(async () => {\n    if (!orderId) return;\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response = await fetch(`/api/admin/orders/${orderId}`);\n      const data = await response.json();\n\n      const validatedResponse = toStrictOrdersResponse(data);\n      \n      if (isStrictApiError(validatedResponse)) {\n        setError(validatedResponse.error);\n        toast({\n          title: 'Error al cargar orden',\n          description: validatedResponse.error,\n          variant: 'destructive'\n        });\n      } else {\n        // Para orden individual, extraer la primera orden\n        const orderData = validatedResponse.data.orders[0] || null;\n        setOrder(orderData);\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Error desconocido';\n      setError(errorMessage);\n      toast({\n        title: 'Error al cargar orden',\n        description: errorMessage,\n        variant: 'destructive'\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [orderId, toast]);\n\n  useEffect(() => {\n    fetchOrder();\n  }, [fetchOrder]);\n\n  return {\n    order,\n    isLoading,\n    error,\n    refetch: fetchOrder\n  };\n}\n\n// ===================================\n// UTILIDADES EXPORTADAS\n// ===================================\n\n/**\n * Utilidades de cache movidas a useOrdersCache.ts\n * Estas funciones están disponibles a través del hook useOrdersCache\n */\n\n// Las utilidades de cache ahora están disponibles a través del hook useOrdersCache:\n// - cache.clearCache()\n// - cache.getCacheStats()\n// - cache.getPendingRequest()\n// - cache.setPendingRequest()"],"names":["useOrderDetailStrict","useOrdersEnterpriseStrict","debounce","func","wait","timeout","args","clearTimeout","setTimeout","DEFAULT_OPTIONS","autoFetch","refetchInterval","maxRetries","enableCache","cacheTimeout","initialFilters","options","toast","useToast","apiMonitoring","useApiMonitoring","opts","useMemo","recordDiscrepancy","useCallback","recordRenderingIssue","cache","useOrdersCache","maxSize","cleanupInterval","minRequestInterval","state","useOrdersState","api","useOrdersApi","retryCountRef","useRef","refetchIntervalRef","debounceTimeoutRef","fetchOrdersInternal","fetchOrdersImmediate","newFilters","console","log","filters","requestKey","JSON","stringify","hasFiltersChanged","isLoading","updateFilters","setLoading","current","attemptFetch","attempt","currentFilters","getLastFilters","result","isStrictApiResponse","data","expectedCount","pagination","total","actualCount","orders","length","endpoint","URLSearchParams","page","toString","limit","status","payment_status","fulfillment_status","sort_by","sort_order","expectedPageCount","Math","min","setOrders","setPagination","setAnalytics","analytics","code","delay","pow","Promise","resolve","setError","error","title","description","variant","fetchOrders","debounceMs","process","env","NODE_ENV","refreshOrders","clearCache","clearError","retryLastRequest","lastFilters","hasInitialFetchRef","useEffect","filtersRef","isInitialMount","hasChanged","abortCurrentRequest","clearInterval","lastFetch","orderId","order","setOrder","useState","setIsLoading","fetchOrder","response","fetch","json","validatedResponse","toStrictOrdersResponse","isStrictApiError","orderData","err","errorMessage","Error","message","refetch"],"mappings":"AAAA,sCAAsC;AACtC,uDAAuD;AACvD,mEAAmE;AACnE,sCAAsC;;;;;;;;;;;;QAwYtBA;eAAAA;;QAzSAC;eAAAA;;;uBA7FwC;0BAC/B;2BAUlB;+BAE0B;gCACF;8BACF;gCAC0C;AAEvE,uDAAuD;AACvD,SAASC,SACPC,IAAO,EACPC,IAAY;IAEZ,IAAIC;IACJ,OAAO,CAAC,GAAGC;QACTC,aAAaF;QACbA,UAAUG,WAAW,IAAML,QAAQG,OAAOF;IAC5C;AACF;AAwCA,MAAMK,kBAA8D;IAClEC,WAAW;IACXC,iBAAiB;IACjBC,YAAY;IACZP,SAAS;IACTQ,aAAa;IACbC,cAAc,IAAI,KAAK,KAAK,YAAY;AAC1C;AAkBO,SAASb,0BACdc,iBAA8C,CAAC,CAAC,EAChDC,UAAqD,CAAC,CAAC;IAEvD,MAAM,EAAEC,KAAK,EAAE,GAAGC,IAAAA,kBAAQ;IAC1B,MAAMC,gBAAgBC,IAAAA,+BAAgB;IACtC,MAAMC,OAAOC,IAAAA,cAAO,EAAC,IAAO,CAAA;YAAE,GAAGb,eAAe;YAAE,GAAGO,OAAO;QAAC,CAAA,GAAI;QAACA;KAAQ;IAE1E,+DAA+D;IAC/D,MAAMO,oBAAoBC,IAAAA,kBAAW,EAACL,cAAcI,iBAAiB,EAAE,EAAE;IACzE,MAAME,uBAAuBD,IAAAA,kBAAW,EAACL,cAAcM,oBAAoB,EAAE,EAAE;IAE/E,sCAAsC;IACtC,uBAAuB;IACvB,sCAAsC;IAEtC,gBAAgB;IAChB,MAAMC,QAAQC,IAAAA,8BAAc,EAAC;QAC3Bd,aAAaQ,KAAKR,WAAW;QAC7BC,cAAcO,KAAKP,YAAY;QAC/Bc,SAAS;QACTC,iBAAiB,KAAK,KAAK;QAC3BC,oBAAoB;IACtB;IAEA,iBAAiB;IACjB,MAAMC,QAAQC,IAAAA,8BAAc,EAACjB;IAE7B,cAAc;IACd,MAAMkB,MAAMC,IAAAA,0BAAY,EAAC;QACvB7B,SAASgB,KAAKhB,OAAO;QACrBO,YAAYS,KAAKT,UAAU;QAC3BC,aAAaQ,KAAKR,WAAW;QAC7Ba;IACF;IAEA,uDAAuD;IACvD,MAAMS,gBAAgBC,IAAAA,aAAM,EAAC;IAC7B,MAAMC,qBAAqBD,IAAAA,aAAM,EAAwB;IACzD,MAAME,qBAAqBF,IAAAA,aAAM,EAAwB;IAEzD,sCAAsC;IACtC,mCAAmC;IACnC,sCAAsC;IAEtC,mCAAmC;IACnC,MAAMG,sBAAsBN,IAAIM,mBAAmB;IAEnD,sCAAsC;IACtC,8BAA8B;IAC9B,sCAAsC;IAEtC,2CAA2C;IAE3C,sCAAsC;IACtC,qCAAqC;IACrC,sCAAsC;IAEtC,gDAAgD;IAChD,MAAMC,uBAAuBhB,IAAAA,kBAAW,EAAC,OAAOiB,aAA0C,CAAC,CAAC;QAC1FC,QAAQC,GAAG,CAAC,yEAAyEF;QACrFC,QAAQC,GAAG,CAAC,sDAAsDZ,MAAMa,OAAO;QAE/E,yCAAyC;QACzC,MAAMC,aAAaC,KAAKC,SAAS,CAAC;YAAE,GAAGhB,MAAMa,OAAO;YAAE,GAAGH,UAAU;QAAC;QACpEC,QAAQC,GAAG,CAAC,4CAA4CE;QAExD,+BAA+B;QAC/B,IAAId,MAAMiB,iBAAiB,CAAC;YAAE,GAAGjB,MAAMa,OAAO;YAAE,GAAGH,UAAU;QAAC,MAAMV,MAAMkB,SAAS,EAAE;YACnFP,QAAQC,GAAG,CAAC;YACZ;QACF;QAEA,uCAAuC;QACvCD,QAAQC,GAAG,CAAC;QACZZ,MAAMmB,aAAa,CAACT;QACpBV,MAAMoB,UAAU,CAAC;QACjBhB,cAAciB,OAAO,GAAG;QAExB,MAAMC,eAAe,OAAOC;YAC1B,MAAMC,iBAAiBxB,MAAMyB,cAAc;YAC3Cd,QAAQC,GAAG,CAAC,uDAAuDW,SAAS,YAAYC;YAExF,MAAME,SAAS,MAAMlB,oBAAoBgB,gBAAgBD,UAAU;YACnEZ,QAAQC,GAAG,CAAC,2CAA2Cc;YAEvD,IAAIC,IAAAA,8BAAmB,EAACD,SAAS;gBAC/Bf,QAAQC,GAAG,CAAC,4DAA4Dc,OAAOE,IAAI;gBACnF,wCAAwC;gBACxC,MAAMC,gBAAgBH,OAAOE,IAAI,CAACE,UAAU,CAACC,KAAK;gBAClD,MAAMC,cAAcN,OAAOE,IAAI,CAACK,MAAM,CAACC,MAAM;gBAC7C,MAAMC,WAAW,CAAC,kBAAkB,EAAE,IAAIC,gBAAgB;oBACxDC,MAAMb,eAAea,IAAI,EAAEC,cAAc;oBACzCC,OAAOf,eAAee,KAAK,EAAED,cAAc;oBAC3C,GAAId,eAAegB,MAAM,IAAI;wBAAEA,QAAQhB,eAAegB,MAAM;oBAAC,CAAC;oBAC9D,GAAIhB,eAAeiB,cAAc,IAAI;wBAAEA,gBAAgBjB,eAAeiB,cAAc;oBAAC,CAAC;oBACtF,GAAIjB,eAAekB,kBAAkB,IAAI;wBAAEA,oBAAoBlB,eAAekB,kBAAkB;oBAAC,CAAC;oBAClG,GAAIlB,eAAemB,OAAO,IAAI;wBAAEA,SAASnB,eAAemB,OAAO;oBAAC,CAAC;oBACjE,GAAInB,eAAeoB,UAAU,IAAI;wBAAEA,YAAYpB,eAAeoB,UAAU;oBAAC,CAAC;gBAC5E,GAAGN,QAAQ,IAAI;gBAEf,6EAA6E;gBAC7E,MAAMO,oBAAoBC,KAAKC,GAAG,CAACvB,eAAee,KAAK,IAAI,IAAIV,gBAAgB,AAAC,CAAA,AAACL,CAAAA,eAAea,IAAI,IAAI,CAAA,IAAK,CAAA,IAAMb,CAAAA,eAAee,KAAK,IAAI,EAAC;gBAC5I,IAAIP,cAAca,qBAAqBA,oBAAoB,GAAG;oBAC5DrD,kBAAkB2C,UAAUU,mBAAmBb;gBACjD;gBAEA,iDAAiD;gBACjDhC,MAAMgD,SAAS,CAACtB,OAAOE,IAAI,CAACK,MAAM;gBAClCjC,MAAMiD,aAAa,CAACvB,OAAOE,IAAI,CAACE,UAAU;gBAC1C9B,MAAMkD,YAAY,CAACxB,OAAOE,IAAI,CAACuB,SAAS,IAAI;gBAC5C/C,cAAciB,OAAO,GAAG;YAC1B,OAAO;gBACL,cAAc;gBACd,IAAIE,UAAUjC,KAAKT,UAAU,IAAI6C,OAAO0B,IAAI,KAAK,qBAAqB;oBACpEhD,cAAciB,OAAO,GAAGE,UAAU;oBAClC,gDAAgD;oBAChD,MAAM8B,QAAQP,KAAKC,GAAG,CAAC,OAAOD,KAAKQ,GAAG,CAAC,GAAG/B,UAAU;oBACpD,MAAM,IAAIgC,QAAQC,CAAAA,UAAW/E,WAAW+E,SAASH;oBACjD,OAAO/B,aAAaC,UAAU;gBAChC;gBAEA,wDAAwD;gBACxDvB,MAAMyD,QAAQ,CAAC/B,OAAOgC,KAAK;gBAE3B,qDAAqD;gBACrDhE,qBACE,6BACA,GACA,GACA8B,gBACAE,OAAOgC,KAAK;gBAGd,yBAAyB;gBACzB,IAAIhC,OAAO0B,IAAI,KAAK,qBAAqB;oBACvClE,MAAM;wBACJyE,OAAO;wBACPC,aAAalC,OAAOgC,KAAK;wBACzBG,SAAS;oBACX;gBACF;YACF;QACF;QAEA,MAAMvC,aAAa;IACrB,GAAG;QAACd;QAAqBlB,KAAKT,UAAU;QAAEK;QAAOM;QAAmBE;QAAsBM;KAAM;IAEhG,sEAAsE;IACtE,MAAM8D,cAAcrE,IAAAA,kBAAW,EAAC,CAACiB,aAA0C,CAAC,CAAC;QAC3E,OAAO,IAAI6C,QAAc,CAACC;YACxB,qCAAqC;YACrC,IAAIjD,mBAAmBc,OAAO,EAAE;gBAC9B7C,aAAa+B,mBAAmBc,OAAO;YACzC;YAEA,wCAAwC;YACxC,MAAM0C,aAAaC,QAAQC,GAAG,CAACC,QAAQ,KAAK,gBAAgB,MAAM;YAClE3D,mBAAmBc,OAAO,GAAG5C,WAAW;gBACtC,IAAI;oBACF,MAAMgC,qBAAqBC;oBAC3B8C;gBACF,EAAE,OAAOE,OAAO;oBACd/C,QAAQ+C,KAAK,CAAC,mCAAmCA;oBACjDF,WAAW,kEAAkE;gBAC/E;YACF,GAAGO;QACL;IACF,GAAG;QAACtD;KAAqB;IAEzB,sCAAsC;IACtC,iBAAiB;IACjB,sCAAsC;IAEtC,MAAM0D,gBAAgB1E,IAAAA,kBAAW,EAAC;QAChC,oCAAoC;QACpC,IAAIH,KAAKR,WAAW,EAAE;YACpBa,MAAMyE,UAAU;QAClB;QACA,MAAMN;IACR,GAAG;QAACA;QAAaxE,KAAKR,WAAW;QAAEa;KAAM;IAEzC,qDAAqD;IACrD,MAAMwB,gBAAgBnB,MAAMmB,aAAa;IACzC,MAAMkD,aAAarE,MAAMqE,UAAU;IAEnC,MAAMC,mBAAmB7E,IAAAA,kBAAW,EAAC;QACnC,MAAM8E,cAAcvE,MAAMyB,cAAc;QACxC,IAAI8C,aAAa;YACf,MAAMT,YAAYS;QACpB;IACF,GAAG;QAACT;QAAa9D;KAAM;IAEvB,sCAAsC;IACtC,UAAU;IACV,sCAAsC;IAEtC,oCAAoC;IACpC,MAAMwE,qBAAqBnE,IAAAA,aAAM,EAAC;IAClCoE,IAAAA,gBAAS,EAAC;QACR,IAAInF,KAAKX,SAAS,IAAI,CAAC6F,mBAAmBnD,OAAO,EAAE;YACjDmD,mBAAmBnD,OAAO,GAAG;YAC7ByC;QACF;IACF,GAAG;QAACxE,KAAKX,SAAS;KAAC,GAAG,kCAAkC;IAExD,wDAAwD;IACxD,MAAM+F,aAAarE,IAAAA,aAAM,EAACL,MAAMa,OAAO;IACvC,MAAM8D,iBAAiBtE,IAAAA,aAAM,EAAC;IAE9BoE,IAAAA,gBAAS,EAAC;QACR,8DAA8D;QAC9D,IAAIE,eAAetD,OAAO,EAAE;YAC1BsD,eAAetD,OAAO,GAAG;YACzBqD,WAAWrD,OAAO,GAAGrB,MAAMa,OAAO;YAClC;QACF;QAEA,yDAAyD;QACzD,MAAM+D,aAAa7D,KAAKC,SAAS,CAAC0D,WAAWrD,OAAO,MAAMN,KAAKC,SAAS,CAAChB,MAAMa,OAAO;QAEtF,IAAI+D,YAAY;YACdF,WAAWrD,OAAO,GAAGrB,MAAMa,OAAO;YAClCiD;QACF;IACF,GAAG;QAAC9D,MAAMa,OAAO;QAAEiD;KAAY,GAAG,kCAAkC;IAEpE,+EAA+E;IAC/EW,IAAAA,gBAAS,EAAC;IACR,uFAAuF;IACvF,qEAAqE;IACrE;;;;;;;;;;;;;;IAcA,GACF,GAAG;QAACnF,KAAKV,eAAe;KAAC;IAEzB,0DAA0D;IAE1D,uBAAuB;IACvB6F,IAAAA,gBAAS,EAAC;QACR,OAAO;YACL,wDAAwD;YACxDvE,IAAI2E,mBAAmB;YAEvB,gCAAgC;YAChC,IAAIvE,mBAAmBe,OAAO,EAAE;gBAC9ByD,cAAcxE,mBAAmBe,OAAO;YAC1C;YACA,IAAId,mBAAmBc,OAAO,EAAE;gBAC9B7C,aAAa+B,mBAAmBc,OAAO;YACzC;YAEA,IAAI2C,QAAQC,GAAG,CAACC,QAAQ,KAAK,eAAe;gBAC1CvD,QAAQC,GAAG,CAAC;YACd;QACF;IACF,GAAG;QAACV;KAAI,GAAG,0BAA0B;IAErC,sCAAsC;IACtC,mBAAmB;IACnB,sCAAsC;IAEtC,OAAO;QACL,SAAS;QACT+B,QAAQjC,MAAMiC,MAAM;QACpBH,YAAY9B,MAAM8B,UAAU;QAC5BjB,SAASb,MAAMa,OAAO;QACtBsC,WAAWnD,MAAMmD,SAAS;QAC1BjC,WAAWlB,MAAMkB,SAAS;QAC1BwC,OAAO1D,MAAM0D,KAAK;QAClBqB,WAAW/E,MAAM+E,SAAS;QAE1B,WAAW;QACXjB;QACAK;QACAhD;QACAkD;QACAC;IACF;AACF;AAMO,SAASrG,qBAAqB+G,OAAsB;IACzD,MAAM,EAAE9F,KAAK,EAAE,GAAGC,IAAAA,kBAAQ;IAC1B,MAAM,CAAC8F,OAAOC,SAAS,GAAGC,SAAuC;IACjE,MAAM,CAACjE,WAAWkE,aAAa,GAAGD,SAAS;IAC3C,MAAM,CAACzB,OAAOD,SAAS,GAAG0B,SAAwB;IAElD,MAAME,aAAa5F,IAAAA,kBAAW,EAAC;QAC7B,IAAI,CAACuF,SAAS;QAEdI,aAAa;QACb3B,SAAS;QAET,IAAI;YACF,MAAM6B,WAAW,MAAMC,MAAM,CAAC,kBAAkB,EAAEP,SAAS;YAC3D,MAAMpD,OAAO,MAAM0D,SAASE,IAAI;YAEhC,MAAMC,oBAAoBC,uBAAuB9D;YAEjD,IAAI+D,IAAAA,2BAAgB,EAACF,oBAAoB;gBACvChC,SAASgC,kBAAkB/B,KAAK;gBAChCxE,MAAM;oBACJyE,OAAO;oBACPC,aAAa6B,kBAAkB/B,KAAK;oBACpCG,SAAS;gBACX;YACF,OAAO;gBACL,kDAAkD;gBAClD,MAAM+B,YAAYH,kBAAkB7D,IAAI,CAACK,MAAM,CAAC,EAAE,IAAI;gBACtDiD,SAASU;YACX;QACF,EAAE,OAAOC,KAAK;YACZ,MAAMC,eAAeD,eAAeE,QAAQF,IAAIG,OAAO,GAAG;YAC1DvC,SAASqC;YACT5G,MAAM;gBACJyE,OAAO;gBACPC,aAAakC;gBACbjC,SAAS;YACX;QACF,SAAU;YACRuB,aAAa;QACf;IACF,GAAG;QAACJ;QAAS9F;KAAM;IAEnBuF,IAAAA,gBAAS,EAAC;QACRY;IACF,GAAG;QAACA;KAAW;IAEf,OAAO;QACLJ;QACA/D;QACAwC;QACAuC,SAASZ;IACX;AACF,EAEA,sCAAsC;CACtC,wBAAwB;CACxB,sCAAsC;CAEtC;;;CAGC,IAED,oFAAoF;CACpF,uBAAuB;CACvB,0BAA0B;CAC1B,8BAA8B;CAC9B,8BAA8B"}