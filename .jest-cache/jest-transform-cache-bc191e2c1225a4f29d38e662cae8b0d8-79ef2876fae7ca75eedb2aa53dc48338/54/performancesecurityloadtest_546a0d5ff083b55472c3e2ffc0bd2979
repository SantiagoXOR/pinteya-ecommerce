f19e3b8c1daae4914b5cc2234416af27
/**
 * Tests de Performance y Carga para Sistemas de Seguridad Enterprise
 * Valida el rendimiento bajo carga extrema y condiciones adversas
 */ // Mock de dependencias para performance testing
"use strict";
jest.mock('ioredis', ()=>{
    const mockRedis = {
        get: jest.fn().mockImplementation(()=>Promise.resolve(null)),
        set: jest.fn().mockImplementation(()=>Promise.resolve('OK')),
        incr: jest.fn().mockImplementation(()=>Promise.resolve(1)),
        expire: jest.fn().mockImplementation(()=>Promise.resolve(1)),
        del: jest.fn().mockImplementation(()=>Promise.resolve(1)),
        pipeline: jest.fn(()=>({
                get: jest.fn(),
                incr: jest.fn(),
                expire: jest.fn(),
                exec: jest.fn().mockResolvedValue([
                    [
                        null,
                        '1'
                    ],
                    [
                        null,
                        'OK'
                    ]
                ])
            })),
        disconnect: jest.fn()
    };
    return jest.fn(()=>mockRedis);
});
jest.mock('@/lib/supabase', ()=>({
        supabaseAdmin: {
            from: jest.fn(()=>({
                    select: jest.fn(()=>({
                            eq: jest.fn(()=>({
                                    single: jest.fn().mockResolvedValue({
                                        data: null,
                                        error: null
                                    })
                                })),
                            insert: jest.fn(()=>({
                                    select: jest.fn(()=>({
                                            single: jest.fn().mockResolvedValue({
                                                data: {
                                                    id: 'perf_test_id'
                                                },
                                                error: null
                                            })
                                        }))
                                }))
                        }))
                }))
        }
    }));
jest.mock('@/lib/auth/security-audit', ()=>({
        logSecurityEvent: jest.fn().mockResolvedValue(true)
    }));
jest.mock('isomorphic-dompurify', ()=>({
        __esModule: true,
        default: {
            sanitize: jest.fn((input)=>input.replace(/<script.*?<\/script>/gi, ''))
        }
    }));
jest.mock('validator', ()=>({
        __esModule: true,
        default: {
            escape: jest.fn((input)=>input)
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _zod = require("zod");
const _enterpriseratelimiter = require("../../lib/rate-limiting/enterprise-rate-limiter");
const _enterpriseauditsystem = require("../../lib/security/enterprise-audit-system");
const _enterprisevalidationsystem = require("../../lib/validation/enterprise-validation-system");
describe('Tests de Performance y Carga - Sistemas de Seguridad Enterprise', ()=>{
    let mockContext;
    beforeEach(()=>{
        jest.clearAllMocks();
        mockContext = {
            userId: 'perf_test_user',
            sessionId: 'perf_test_session',
            email: 'perf@pinteya.com',
            role: 'admin',
            permissions: [
                'admin_access'
            ],
            sessionValid: true,
            securityLevel: 'critical',
            ipAddress: '192.168.1.1',
            userAgent: 'PerformanceTestBot/1.0',
            supabase: {},
            validations: {
                jwtValid: true,
                csrfValid: true,
                rateLimitPassed: true,
                originValid: true
            }
        };
        // Reset metrics
        _enterpriseratelimiter.metricsCollector.metrics = {
            totalRequests: 0,
            allowedRequests: 0,
            blockedRequests: 0,
            redisHits: 0,
            memoryFallbacks: 0,
            errors: 0,
            averageResponseTime: 0,
            topBlockedIPs: [],
            topEndpoints: []
        };
    });
    describe('Performance Rate Limiting bajo Carga Extrema', ()=>{
        it('debe mantener latencia baja con 10,000 requests concurrentes', async ()=>{
            const concurrentRequests = 10000;
            const maxLatencyMs = 100; // 100ms máximo por request
            const startTime = Date.now();
            // Generar requests concurrentes
            const requestPromises = Array.from({
                length: concurrentRequests
            }, (_, i)=>{
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            `192.168.${Math.floor(i / 255)}.${i % 255}`
                        ],
                        [
                            'user-agent',
                            'LoadTestBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/public/products'
                    },
                    method: 'GET'
                };
                return (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD, `load_test_${i}`);
            });
            // Ejecutar todos los requests concurrentemente
            const results = await Promise.all(requestPromises);
            const endTime = Date.now();
            const totalTime = endTime - startTime;
            const avgLatency = totalTime / concurrentRequests;
            // Verificar que todos los requests fueron procesados
            expect(results.length).toBe(concurrentRequests);
            // Verificar latencia promedio
            expect(avgLatency).toBeLessThan(maxLatencyMs);
            // Verificar que el sistema aplicó rate limiting apropiadamente
            const allowedRequests = results.filter((r)=>r.allowed).length;
            const blockedRequests = results.filter((r)=>!r.allowed).length;
            expect(allowedRequests + blockedRequests).toBe(concurrentRequests);
            // Verificar métricas de performance
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.totalRequests).toBeGreaterThan(0);
            expect(metrics.averageResponseTime).toBeLessThan(maxLatencyMs);
        });
        it('debe escalar linealmente con aumento de carga', async ()=>{
            const loadLevels = [
                100,
                500,
                1000,
                2000,
                5000
            ];
            const performanceResults = [];
            for (const loadLevel of loadLevels){
                const startTime = Date.now();
                const requestPromises = Array.from({
                    length: loadLevel
                }, (_, i)=>{
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                `10.0.${Math.floor(i / 255)}.${i % 255}`
                            ],
                            [
                                'user-agent',
                                'ScalabilityTestBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/admin/test'
                        },
                        method: 'POST'
                    };
                    return (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL, `scale_test_${loadLevel}_${i}`);
                });
                const results = await Promise.all(requestPromises);
                const endTime = Date.now();
                const totalTime = endTime - startTime;
                const avgLatency = totalTime / loadLevel;
                const throughput = loadLevel / (totalTime / 1000); // requests per second
                performanceResults.push({
                    loadLevel,
                    totalTime,
                    avgLatency,
                    throughput,
                    successRate: results.filter((r)=>r.allowed || !r.allowed).length / loadLevel
                });
            }
            // Verificar escalabilidad
            for(let i = 1; i < performanceResults.length; i++){
                const current = performanceResults[i];
                const previous = performanceResults[i - 1];
                // La latencia no debería aumentar más de 3x con el aumento de carga
                const latencyIncrease = current.avgLatency / previous.avgLatency;
                expect(latencyIncrease).toBeLessThan(3);
                // El throughput debería mantenerse razonablemente alto
                expect(current.throughput).toBeGreaterThan(50); // > 50 RPS mínimo
                // La tasa de éxito debería mantenerse alta
                expect(current.successRate).toBeGreaterThan(0.95); // > 95%
            }
        });
        it('debe manejar picos de tráfico sin degradación', async ()=>{
            const baselineLoad = 100;
            const spikeLoad = 5000;
            const spikeDuration = 2000; // 2 segundos
            // Fase 1: Carga baseline
            const baselineStart = Date.now();
            const baselinePromises = Array.from({
                length: baselineLoad
            }, (_, i)=>(0, _enterpriseratelimiter.checkEnterpriseRateLimit)({
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            `172.16.0.${i % 255}`
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/test'
                    },
                    method: 'GET'
                }, _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD, `baseline_${i}`));
            const baselineResults = await Promise.all(baselinePromises);
            const baselineTime = Date.now() - baselineStart;
            const baselineLatency = baselineTime / baselineLoad;
            // Fase 2: Pico de tráfico
            const spikeStart = Date.now();
            const spikePromises = Array.from({
                length: spikeLoad
            }, (_, i)=>(0, _enterpriseratelimiter.checkEnterpriseRateLimit)({
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            `203.0.113.${i % 255}`
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/test'
                    },
                    method: 'GET'
                }, _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD, `spike_${i}`));
            const spikeResults = await Promise.all(spikePromises);
            const spikeTime = Date.now() - spikeStart;
            const spikeLatency = spikeTime / spikeLoad;
            // Fase 3: Vuelta a baseline
            const recoveryStart = Date.now();
            const recoveryPromises = Array.from({
                length: baselineLoad
            }, (_, i)=>(0, _enterpriseratelimiter.checkEnterpriseRateLimit)({
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            `172.16.1.${i % 255}`
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/test'
                    },
                    method: 'GET'
                }, _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD, `recovery_${i}`));
            const recoveryResults = await Promise.all(recoveryPromises);
            const recoveryTime = Date.now() - recoveryStart;
            const recoveryLatency = recoveryTime / baselineLoad;
            // Verificar que el sistema manejó el pico
            expect(baselineResults.length).toBe(baselineLoad);
            expect(spikeResults.length).toBe(spikeLoad);
            expect(recoveryResults.length).toBe(baselineLoad);
            // Verificar que la latencia se recuperó después del pico
            const latencyIncrease = spikeLatency / baselineLatency;
            const recoveryRatio = recoveryLatency / baselineLatency;
            expect(latencyIncrease).toBeLessThan(5); // Máximo 5x durante pico
            expect(recoveryRatio).toBeLessThan(2); // Recuperación a menos de 2x baseline
        });
    });
    describe('Performance Sistema de Auditoría bajo Carga', ()=>{
        it('debe procesar 50,000 eventos de auditoría en menos de 30 segundos', async ()=>{
            const eventCount = 50000;
            const maxTimeSeconds = 30;
            const startTime = Date.now();
            // Generar eventos de auditoría masivos
            const auditPromises = Array.from({
                length: eventCount
            }, (_, i)=>_enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent({
                    user_id: `perf_user_${i % 1000}`,
                    event_type: [
                        'AUTH_SUCCESS',
                        'DATA_ACCESS',
                        'SYSTEM_ACCESS'
                    ][i % 3],
                    event_category: 'performance_test',
                    severity: [
                        'low',
                        'medium',
                        'high'
                    ][i % 3],
                    description: `Performance test event ${i}`,
                    metadata: {
                        test_batch: Math.floor(i / 1000),
                        event_index: i
                    },
                    ip_address: `192.168.${Math.floor(i / 255)}.${i % 255}`,
                    user_agent: 'PerformanceTestBot/1.0'
                }, mockContext));
            const results = await Promise.all(auditPromises);
            const endTime = Date.now();
            const totalTime = (endTime - startTime) / 1000; // segundos
            // Verificar que todos los eventos fueron procesados
            expect(results.length).toBe(eventCount);
            expect(results.every((r)=>r && r.startsWith('corr_'))).toBe(true);
            // Verificar tiempo de procesamiento
            expect(totalTime).toBeLessThan(maxTimeSeconds);
            // Verificar throughput
            const eventsPerSecond = eventCount / totalTime;
            expect(eventsPerSecond).toBeGreaterThan(1000); // > 1000 eventos/segundo
        });
        it('debe mantener performance durante detección de anomalías masiva', async ()=>{
            const userCount = 1000;
            const maxTimePerUser = 100; // 100ms máximo por usuario
            // Generar datos de usuarios para análisis
            const userIds = Array.from({
                length: userCount
            }, (_, i)=>`anomaly_user_${i}`);
            const startTime = Date.now();
            // Ejecutar detección de anomalías para todos los usuarios
            const anomalyPromises = userIds.map((userId)=>_enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies(userId));
            const results = await Promise.all(anomalyPromises);
            const endTime = Date.now();
            const totalTime = endTime - startTime;
            const avgTimePerUser = totalTime / userCount;
            // Verificar que se procesaron todos los usuarios
            expect(results.length).toBe(userCount);
            expect(results.every((r)=>Array.isArray(r))).toBe(true);
            // Verificar performance
            expect(avgTimePerUser).toBeLessThan(maxTimePerUser);
            expect(totalTime).toBeLessThan(30000); // < 30 segundos total
        });
        it('debe generar reportes enterprise rápidamente', async ()=>{
            const maxReportTime = 10000; // 10 segundos máximo
            const startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(); // 7 días
            const endDate = new Date().toISOString();
            const startTime = Date.now();
            // Generar reporte enterprise completo
            const report = await _enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport(startDate, endDate, true, true // incluir incidentes
            );
            const endTime = Date.now();
            const reportTime = endTime - startTime;
            // Verificar que el reporte se generó
            expect(report).toBeDefined();
            expect(report.enterprise_data).toBeDefined();
            // Verificar tiempo de generación
            expect(reportTime).toBeLessThan(maxReportTime);
        });
    });
    describe('Performance Sistema de Validación bajo Carga', ()=>{
        it('debe validar 100,000 objetos complejos en menos de 60 segundos', async ()=>{
            const objectCount = 100000;
            const maxTimeSeconds = 60;
            const complexSchema = _zod.z.object({
                name: _zod.z.string().min(1).max(100),
                email: _zod.z.string().email(),
                age: _zod.z.number().min(0).max(120),
                address: _zod.z.object({
                    street: _zod.z.string().max(200),
                    city: _zod.z.string().max(100),
                    country: _zod.z.string().max(100)
                }),
                tags: _zod.z.array(_zod.z.string().max(50)).max(20),
                metadata: _zod.z.record(_zod.z.any()).optional()
            });
            const startTime = Date.now();
            // Generar objetos para validación
            const validationPromises = Array.from({
                length: objectCount
            }, (_, i)=>_enterprisevalidationsystem.standardValidator.validateAndSanitize(complexSchema, {
                    name: `User ${i}`,
                    email: `user${i}@example.com`,
                    age: 20 + i % 60,
                    address: {
                        street: `Street ${i}`,
                        city: `City ${i % 100}`,
                        country: 'Argentina'
                    },
                    tags: [
                        `tag${i % 10}`,
                        `category${i % 5}`
                    ],
                    metadata: {
                        index: i,
                        batch: Math.floor(i / 1000)
                    }
                }, mockContext));
            const results = await Promise.all(validationPromises);
            const endTime = Date.now();
            const totalTime = (endTime - startTime) / 1000; // segundos
            // Verificar que todos los objetos fueron procesados
            expect(results.length).toBe(objectCount);
            // Verificar tiempo de procesamiento
            expect(totalTime).toBeLessThan(maxTimeSeconds);
            // Verificar throughput
            const objectsPerSecond = objectCount / totalTime;
            expect(objectsPerSecond).toBeGreaterThan(1000); // > 1000 objetos/segundo
            // Verificar que la mayoría fueron exitosos
            const successCount = results.filter((r)=>r.success).length;
            expect(successCount / objectCount).toBeGreaterThan(0.95); // > 95% éxito
        });
        it('debe detectar ataques en tiempo real con alta carga', async ()=>{
            const attackCount = 10000;
            const maxDetectionTime = 20000; // 20 segundos
            const maliciousPayloads = [
                "'; DROP TABLE users; --",
                '<script>alert("XSS")</script>',
                '../../../etc/passwd',
                'SELECT * FROM admin_users',
                '<img src="x" onerror="alert(1)">'
            ];
            const schema = _zod.z.object({
                input: _zod.z.string().max(1000)
            });
            const startTime = Date.now();
            // Generar ataques masivos
            const attackPromises = Array.from({
                length: attackCount
            }, (_, i)=>_enterprisevalidationsystem.criticalValidator.validateAndSanitize(schema, {
                    input: maliciousPayloads[i % maliciousPayloads.length]
                }, {
                    ...mockContext,
                    userId: `attacker_${i % 100}`
                }));
            const results = await Promise.all(attackPromises);
            const endTime = Date.now();
            const totalTime = endTime - startTime;
            // Verificar que todos los ataques fueron procesados
            expect(results.length).toBe(attackCount);
            // Verificar tiempo de detección
            expect(totalTime).toBeLessThan(maxDetectionTime);
            // Verificar que se detectaron ataques
            const blockedAttacks = results.filter((r)=>!r.success).length;
            const detectionRate = blockedAttacks / attackCount;
            expect(detectionRate).toBeGreaterThan(0.8); // > 80% de detección
            // Verificar throughput de detección
            const attacksPerSecond = attackCount / (totalTime / 1000);
            expect(attacksPerSecond).toBeGreaterThan(300); // > 300 ataques/segundo
        });
    });
    describe('Performance Memoria y Recursos', ()=>{
        it('debe mantener uso de memoria estable durante carga sostenida', async ()=>{
            const initialMemory = process.memoryUsage();
            const maxMemoryIncrease = 200 * 1024 * 1024; // 200MB máximo
            // Simular carga sostenida por 30 segundos
            const duration = 30000; // 30 segundos
            const startTime = Date.now();
            const sustainedLoad = async ()=>{
                while(Date.now() - startTime < duration){
                    // Rate limiting
                    await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)({
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                '192.168.1.100'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/test'
                        },
                        method: 'GET'
                    }, _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD, `sustained_${Date.now()}`);
                    // Auditoría
                    await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent({
                        user_id: 'sustained_user',
                        event_type: 'SUSTAINED_TEST',
                        event_category: 'test',
                        severity: 'low',
                        description: 'Sustained load test',
                        metadata: {
                            timestamp: Date.now()
                        },
                        ip_address: '192.168.1.100',
                        user_agent: 'SustainedTestBot/1.0'
                    }, mockContext);
                    // Validación
                    await _enterprisevalidationsystem.standardValidator.validateAndSanitize(_zod.z.object({
                        test: _zod.z.string()
                    }), {
                        test: 'sustained test data'
                    }, mockContext);
                    // Pequeña pausa para evitar saturación
                    await new Promise((resolve)=>setTimeout(resolve, 10));
                }
            };
            await sustainedLoad();
            const finalMemory = process.memoryUsage();
            const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;
            // Verificar que el uso de memoria se mantuvo estable
            expect(memoryIncrease).toBeLessThan(maxMemoryIncrease);
        });
        it('debe liberar recursos correctamente después de carga extrema', async ()=>{
            const initialMemory = process.memoryUsage();
            // Fase 1: Carga extrema
            const extremeLoadPromises = Array.from({
                length: 10000
            }, (_, i)=>Promise.all([
                    (0, _enterpriseratelimiter.checkEnterpriseRateLimit)({
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                `10.0.${Math.floor(i / 255)}.${i % 255}`
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/extreme'
                        },
                        method: 'POST'
                    }, _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL, `extreme_${i}`),
                    _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent({
                        user_id: `extreme_user_${i}`,
                        event_type: 'EXTREME_LOAD',
                        event_category: 'test',
                        severity: 'medium',
                        description: `Extreme load event ${i}`,
                        metadata: {
                            index: i,
                            large_data: 'x'.repeat(1000)
                        },
                        ip_address: `10.0.${Math.floor(i / 255)}.${i % 255}`,
                        user_agent: 'ExtremeLoadBot/1.0'
                    }, mockContext),
                    _enterprisevalidationsystem.standardValidator.validateAndSanitize(_zod.z.object({
                        data: _zod.z.string()
                    }), {
                        data: `extreme test data ${i}`
                    }, mockContext)
                ]));
            await Promise.all(extremeLoadPromises);
            const peakMemory = process.memoryUsage();
            // Fase 2: Esperar liberación de recursos
            await new Promise((resolve)=>setTimeout(resolve, 5000)); // 5 segundos
            // Forzar garbage collection si está disponible
            if (global.gc) {
                global.gc();
            }
            const finalMemory = process.memoryUsage();
            // Verificar que se liberaron recursos
            const memoryReduction = peakMemory.heapUsed - finalMemory.heapUsed;
            const reductionPercentage = memoryReduction / peakMemory.heapUsed * 100;
            // Debería liberar al menos 30% de la memoria pico
            expect(reductionPercentage).toBeGreaterThan(30);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxzZWN1cml0eVxccGVyZm9ybWFuY2Utc2VjdXJpdHktbG9hZC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUZXN0cyBkZSBQZXJmb3JtYW5jZSB5IENhcmdhIHBhcmEgU2lzdGVtYXMgZGUgU2VndXJpZGFkIEVudGVycHJpc2VcclxuICogVmFsaWRhIGVsIHJlbmRpbWllbnRvIGJham8gY2FyZ2EgZXh0cmVtYSB5IGNvbmRpY2lvbmVzIGFkdmVyc2FzXHJcbiAqL1xyXG5cclxuLy8gTW9jayBkZSBkZXBlbmRlbmNpYXMgcGFyYSBwZXJmb3JtYW5jZSB0ZXN0aW5nXHJcbmplc3QubW9jaygnaW9yZWRpcycsICgpID0+IHtcclxuICBjb25zdCBtb2NrUmVkaXMgPSB7XHJcbiAgICBnZXQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG51bGwpKSxcclxuICAgIHNldDogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBQcm9taXNlLnJlc29sdmUoJ09LJykpLFxyXG4gICAgaW5jcjogamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBQcm9taXNlLnJlc29sdmUoMSkpLFxyXG4gICAgZXhwaXJlOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IFByb21pc2UucmVzb2x2ZSgxKSksXHJcbiAgICBkZWw6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gUHJvbWlzZS5yZXNvbHZlKDEpKSxcclxuICAgIHBpcGVsaW5lOiBqZXN0LmZuKCgpID0+ICh7XHJcbiAgICAgIGdldDogamVzdC5mbigpLFxyXG4gICAgICBpbmNyOiBqZXN0LmZuKCksXHJcbiAgICAgIGV4cGlyZTogamVzdC5mbigpLFxyXG4gICAgICBleGVjOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW1tudWxsLCAnMSddLCBbbnVsbCwgJ09LJ11dKVxyXG4gICAgfSkpLFxyXG4gICAgZGlzY29ubmVjdDogamVzdC5mbigpXHJcbiAgfTtcclxuICByZXR1cm4gamVzdC5mbigoKSA9PiBtb2NrUmVkaXMpO1xyXG59KTtcclxuXHJcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xyXG4gIHN1cGFiYXNlQWRtaW46IHtcclxuICAgIGZyb206IGplc3QuZm4oKCkgPT4gKHtcclxuICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XHJcbiAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcclxuICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfSlcclxuICAgICAgICB9KSksXHJcbiAgICAgICAgaW5zZXJ0OiBqZXN0LmZuKCgpID0+ICh7XHJcbiAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gKHtcclxuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiB7IGlkOiAncGVyZl90ZXN0X2lkJyB9LCBlcnJvcjogbnVsbCB9KVxyXG4gICAgICAgICAgfSkpXHJcbiAgICAgICAgfSkpXHJcbiAgICAgIH0pKVxyXG4gICAgfSkpXHJcbiAgfVxyXG59KSk7XHJcblxyXG5qZXN0Lm1vY2soJ0AvbGliL2F1dGgvc2VjdXJpdHktYXVkaXQnLCAoKSA9PiAoe1xyXG4gIGxvZ1NlY3VyaXR5RXZlbnQ6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKVxyXG59KSk7XHJcblxyXG5qZXN0Lm1vY2soJ2lzb21vcnBoaWMtZG9tcHVyaWZ5JywgKCkgPT4gKHtcclxuICBfX2VzTW9kdWxlOiB0cnVlLFxyXG4gIGRlZmF1bHQ6IHtcclxuICAgIHNhbml0aXplOiBqZXN0LmZuKChpbnB1dCkgPT4gaW5wdXQucmVwbGFjZSgvPHNjcmlwdC4qPzxcXC9zY3JpcHQ+L2dpLCAnJykpXHJcbiAgfVxyXG59KSk7XHJcblxyXG5qZXN0Lm1vY2soJ3ZhbGlkYXRvcicsICgpID0+ICh7XHJcbiAgX19lc01vZHVsZTogdHJ1ZSxcclxuICBkZWZhdWx0OiB7XHJcbiAgICBlc2NhcGU6IGplc3QuZm4oKGlucHV0KSA9PiBpbnB1dClcclxuICB9XHJcbn0pKTtcclxuXHJcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xyXG5pbXBvcnQge1xyXG4gIGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdCxcclxuICBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUyxcclxuICBtZXRyaWNzQ29sbGVjdG9yXHJcbn0gZnJvbSAnQC9saWIvcmF0ZS1saW1pdGluZy9lbnRlcnByaXNlLXJhdGUtbGltaXRlcic7XHJcbmltcG9ydCB7IGVudGVycHJpc2VBdWRpdFN5c3RlbSB9IGZyb20gJ0AvbGliL3NlY3VyaXR5L2VudGVycHJpc2UtYXVkaXQtc3lzdGVtJztcclxuaW1wb3J0IHtcclxuICBjcml0aWNhbFZhbGlkYXRvcixcclxuICBoaWdoVmFsaWRhdG9yLFxyXG4gIHN0YW5kYXJkVmFsaWRhdG9yLFxyXG4gIGJhc2ljVmFsaWRhdG9yXHJcbn0gZnJvbSAnQC9saWIvdmFsaWRhdGlvbi9lbnRlcnByaXNlLXZhbGlkYXRpb24tc3lzdGVtJztcclxuaW1wb3J0IHR5cGUgeyBFbnRlcnByaXNlQXV0aENvbnRleHQgfSBmcm9tICdAL2xpYi9hdXRoL2VudGVycHJpc2UtYXV0aC11dGlscyc7XHJcblxyXG5kZXNjcmliZSgnVGVzdHMgZGUgUGVyZm9ybWFuY2UgeSBDYXJnYSAtIFNpc3RlbWFzIGRlIFNlZ3VyaWRhZCBFbnRlcnByaXNlJywgKCkgPT4ge1xyXG4gIGxldCBtb2NrQ29udGV4dDogRW50ZXJwcmlzZUF1dGhDb250ZXh0O1xyXG5cclxuICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gICAgXHJcbiAgICBtb2NrQ29udGV4dCA9IHtcclxuICAgICAgdXNlcklkOiAncGVyZl90ZXN0X3VzZXInLFxyXG4gICAgICBzZXNzaW9uSWQ6ICdwZXJmX3Rlc3Rfc2Vzc2lvbicsXHJcbiAgICAgIGVtYWlsOiAncGVyZkBwaW50ZXlhLmNvbScsXHJcbiAgICAgIHJvbGU6ICdhZG1pbicsXHJcbiAgICAgIHBlcm1pc3Npb25zOiBbJ2FkbWluX2FjY2VzcyddLFxyXG4gICAgICBzZXNzaW9uVmFsaWQ6IHRydWUsXHJcbiAgICAgIHNlY3VyaXR5TGV2ZWw6ICdjcml0aWNhbCcsXHJcbiAgICAgIGlwQWRkcmVzczogJzE5Mi4xNjguMS4xJyxcclxuICAgICAgdXNlckFnZW50OiAnUGVyZm9ybWFuY2VUZXN0Qm90LzEuMCcsXHJcbiAgICAgIHN1cGFiYXNlOiB7fSBhcyBhbnksXHJcbiAgICAgIHZhbGlkYXRpb25zOiB7XHJcbiAgICAgICAgand0VmFsaWQ6IHRydWUsXHJcbiAgICAgICAgY3NyZlZhbGlkOiB0cnVlLFxyXG4gICAgICAgIHJhdGVMaW1pdFBhc3NlZDogdHJ1ZSxcclxuICAgICAgICBvcmlnaW5WYWxpZDogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlc2V0IG1ldHJpY3NcclxuICAgIChtZXRyaWNzQ29sbGVjdG9yIGFzIGFueSkubWV0cmljcyA9IHtcclxuICAgICAgdG90YWxSZXF1ZXN0czogMCxcclxuICAgICAgYWxsb3dlZFJlcXVlc3RzOiAwLFxyXG4gICAgICBibG9ja2VkUmVxdWVzdHM6IDAsXHJcbiAgICAgIHJlZGlzSGl0czogMCxcclxuICAgICAgbWVtb3J5RmFsbGJhY2tzOiAwLFxyXG4gICAgICBlcnJvcnM6IDAsXHJcbiAgICAgIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IDAsXHJcbiAgICAgIHRvcEJsb2NrZWRJUHM6IFtdLFxyXG4gICAgICB0b3BFbmRwb2ludHM6IFtdXHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UgUmF0ZSBMaW1pdGluZyBiYWpvIENhcmdhIEV4dHJlbWEnLCAoKSA9PiB7XHJcbiAgICBpdCgnZGViZSBtYW50ZW5lciBsYXRlbmNpYSBiYWphIGNvbiAxMCwwMDAgcmVxdWVzdHMgY29uY3VycmVudGVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb25jdXJyZW50UmVxdWVzdHMgPSAxMDAwMDtcclxuICAgICAgY29uc3QgbWF4TGF0ZW5jeU1zID0gMTAwOyAvLyAxMDBtcyBtw6F4aW1vIHBvciByZXF1ZXN0XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2VuZXJhciByZXF1ZXN0cyBjb25jdXJyZW50ZXNcclxuICAgICAgY29uc3QgcmVxdWVzdFByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogY29uY3VycmVudFJlcXVlc3RzIH0sIChfLCBpKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XHJcbiAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtcclxuICAgICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBgMTkyLjE2OC4ke01hdGguZmxvb3IoaS8yNTUpfS4ke2klMjU1fWBdLFxyXG4gICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnTG9hZFRlc3RCb3QvMS4wJ11cclxuICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvcHVibGljL3Byb2R1Y3RzJyB9LFxyXG4gICAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICAgIH0gYXMgYW55O1xyXG5cclxuICAgICAgICByZXR1cm4gY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxyXG4gICAgICAgICAgbW9ja1JlcXVlc3QsXHJcbiAgICAgICAgICBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5QVUJMSUNfU1RBTkRBUkQsXHJcbiAgICAgICAgICBgbG9hZF90ZXN0XyR7aX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBFamVjdXRhciB0b2RvcyBsb3MgcmVxdWVzdHMgY29uY3VycmVudGVtZW50ZVxyXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdFByb21pc2VzKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xyXG4gICAgICBjb25zdCBhdmdMYXRlbmN5ID0gdG90YWxUaW1lIC8gY29uY3VycmVudFJlcXVlc3RzO1xyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSB0b2RvcyBsb3MgcmVxdWVzdHMgZnVlcm9uIHByb2Nlc2Fkb3NcclxuICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0JlKGNvbmN1cnJlbnRSZXF1ZXN0cyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBWZXJpZmljYXIgbGF0ZW5jaWEgcHJvbWVkaW9cclxuICAgICAgZXhwZWN0KGF2Z0xhdGVuY3kpLnRvQmVMZXNzVGhhbihtYXhMYXRlbmN5TXMpO1xyXG4gICAgICBcclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBzaXN0ZW1hIGFwbGljw7MgcmF0ZSBsaW1pdGluZyBhcHJvcGlhZGFtZW50ZVxyXG4gICAgICBjb25zdCBhbGxvd2VkUmVxdWVzdHMgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuYWxsb3dlZCkubGVuZ3RoO1xyXG4gICAgICBjb25zdCBibG9ja2VkUmVxdWVzdHMgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLmFsbG93ZWQpLmxlbmd0aDtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChhbGxvd2VkUmVxdWVzdHMgKyBibG9ja2VkUmVxdWVzdHMpLnRvQmUoY29uY3VycmVudFJlcXVlc3RzKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFZlcmlmaWNhciBtw6l0cmljYXMgZGUgcGVyZm9ybWFuY2VcclxuICAgICAgY29uc3QgbWV0cmljcyA9IG1ldHJpY3NDb2xsZWN0b3IuZ2V0TWV0cmljcygpO1xyXG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbFJlcXVlc3RzKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgIGV4cGVjdChtZXRyaWNzLmF2ZXJhZ2VSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbihtYXhMYXRlbmN5TXMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RlYmUgZXNjYWxhciBsaW5lYWxtZW50ZSBjb24gYXVtZW50byBkZSBjYXJnYScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbG9hZExldmVscyA9IFsxMDAsIDUwMCwgMTAwMCwgMjAwMCwgNTAwMF07XHJcbiAgICAgIGNvbnN0IHBlcmZvcm1hbmNlUmVzdWx0cyA9IFtdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBsb2FkTGV2ZWwgb2YgbG9hZExldmVscykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbG9hZExldmVsIH0sIChfLCBpKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbXHJcbiAgICAgICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBgMTAuMC4ke01hdGguZmxvb3IoaS8yNTUpfS4ke2klMjU1fWBdLFxyXG4gICAgICAgICAgICAgIFsndXNlci1hZ2VudCcsICdTY2FsYWJpbGl0eVRlc3RCb3QvMS4wJ11cclxuICAgICAgICAgICAgXSksXHJcbiAgICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL2FkbWluL3Rlc3QnIH0sXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXHJcbiAgICAgICAgICB9IGFzIGFueTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxyXG4gICAgICAgICAgICBtb2NrUmVxdWVzdCxcclxuICAgICAgICAgICAgRU5URVJQUklTRV9SQVRFX0xJTUlUX0NPTkZJR1MuQURNSU5fQ1JJVElDQUwsXHJcbiAgICAgICAgICAgIGBzY2FsZV90ZXN0XyR7bG9hZExldmVsfV8ke2l9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RQcm9taXNlcyk7XHJcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcclxuICAgICAgICBjb25zdCBhdmdMYXRlbmN5ID0gdG90YWxUaW1lIC8gbG9hZExldmVsO1xyXG4gICAgICAgIGNvbnN0IHRocm91Z2hwdXQgPSBsb2FkTGV2ZWwgLyAodG90YWxUaW1lIC8gMTAwMCk7IC8vIHJlcXVlc3RzIHBlciBzZWNvbmRcclxuXHJcbiAgICAgICAgcGVyZm9ybWFuY2VSZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgbG9hZExldmVsLFxyXG4gICAgICAgICAgdG90YWxUaW1lLFxyXG4gICAgICAgICAgYXZnTGF0ZW5jeSxcclxuICAgICAgICAgIHRocm91Z2hwdXQsXHJcbiAgICAgICAgICBzdWNjZXNzUmF0ZTogcmVzdWx0cy5maWx0ZXIociA9PiByLmFsbG93ZWQgfHwgIXIuYWxsb3dlZCkubGVuZ3RoIC8gbG9hZExldmVsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZlcmlmaWNhciBlc2NhbGFiaWxpZGFkXHJcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGVyZm9ybWFuY2VSZXN1bHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBlcmZvcm1hbmNlUmVzdWx0c1tpXTtcclxuICAgICAgICBjb25zdCBwcmV2aW91cyA9IHBlcmZvcm1hbmNlUmVzdWx0c1tpIC0gMV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTGEgbGF0ZW5jaWEgbm8gZGViZXLDrWEgYXVtZW50YXIgbcOhcyBkZSAzeCBjb24gZWwgYXVtZW50byBkZSBjYXJnYVxyXG4gICAgICAgIGNvbnN0IGxhdGVuY3lJbmNyZWFzZSA9IGN1cnJlbnQuYXZnTGF0ZW5jeSAvIHByZXZpb3VzLmF2Z0xhdGVuY3k7XHJcbiAgICAgICAgZXhwZWN0KGxhdGVuY3lJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEVsIHRocm91Z2hwdXQgZGViZXLDrWEgbWFudGVuZXJzZSByYXpvbmFibGVtZW50ZSBhbHRvXHJcbiAgICAgICAgZXhwZWN0KGN1cnJlbnQudGhyb3VnaHB1dCkudG9CZUdyZWF0ZXJUaGFuKDUwKTsgLy8gPiA1MCBSUFMgbcOtbmltb1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIExhIHRhc2EgZGUgw6l4aXRvIGRlYmVyw61hIG1hbnRlbmVyc2UgYWx0YVxyXG4gICAgICAgIGV4cGVjdChjdXJyZW50LnN1Y2Nlc3NSYXRlKS50b0JlR3JlYXRlclRoYW4oMC45NSk7IC8vID4gOTUlXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkZWJlIG1hbmVqYXIgcGljb3MgZGUgdHLDoWZpY28gc2luIGRlZ3JhZGFjacOzbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgYmFzZWxpbmVMb2FkID0gMTAwO1xyXG4gICAgICBjb25zdCBzcGlrZUxvYWQgPSA1MDAwO1xyXG4gICAgICBjb25zdCBzcGlrZUR1cmF0aW9uID0gMjAwMDsgLy8gMiBzZWd1bmRvc1xyXG4gICAgICBcclxuICAgICAgLy8gRmFzZSAxOiBDYXJnYSBiYXNlbGluZVxyXG4gICAgICBjb25zdCBiYXNlbGluZVN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgY29uc3QgYmFzZWxpbmVQcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGJhc2VsaW5lTG9hZCB9LCAoXywgaSkgPT4gXHJcbiAgICAgICAgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ3gtZm9yd2FyZGVkLWZvcicsIGAxNzIuMTYuMC4ke2klMjU1fWBdXSksXHJcbiAgICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Rlc3QnIH0sXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgICAgICAgIH0gYXMgYW55LFxyXG4gICAgICAgICAgRU5URVJQUklTRV9SQVRFX0xJTUlUX0NPTkZJR1MuUFVCTElDX1NUQU5EQVJELFxyXG4gICAgICAgICAgYGJhc2VsaW5lXyR7aX1gXHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgYmFzZWxpbmVSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYmFzZWxpbmVQcm9taXNlcyk7XHJcbiAgICAgIGNvbnN0IGJhc2VsaW5lVGltZSA9IERhdGUubm93KCkgLSBiYXNlbGluZVN0YXJ0O1xyXG4gICAgICBjb25zdCBiYXNlbGluZUxhdGVuY3kgPSBiYXNlbGluZVRpbWUgLyBiYXNlbGluZUxvYWQ7XHJcblxyXG4gICAgICAvLyBGYXNlIDI6IFBpY28gZGUgdHLDoWZpY29cclxuICAgICAgY29uc3Qgc3Bpa2VTdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHNwaWtlUHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBzcGlrZUxvYWQgfSwgKF8sIGkpID0+IFxyXG4gICAgICAgIGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbWyd4LWZvcndhcmRlZC1mb3InLCBgMjAzLjAuMTEzLiR7aSUyNTV9YF1dKSxcclxuICAgICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvdGVzdCcgfSxcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICAgICAgfSBhcyBhbnksXHJcbiAgICAgICAgICBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5QVUJMSUNfU1RBTkRBUkQsXHJcbiAgICAgICAgICBgc3Bpa2VfJHtpfWBcclxuICAgICAgICApXHJcbiAgICAgICk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzcGlrZVJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChzcGlrZVByb21pc2VzKTtcclxuICAgICAgY29uc3Qgc3Bpa2VUaW1lID0gRGF0ZS5ub3coKSAtIHNwaWtlU3RhcnQ7XHJcbiAgICAgIGNvbnN0IHNwaWtlTGF0ZW5jeSA9IHNwaWtlVGltZSAvIHNwaWtlTG9hZDtcclxuXHJcbiAgICAgIC8vIEZhc2UgMzogVnVlbHRhIGEgYmFzZWxpbmVcclxuICAgICAgY29uc3QgcmVjb3ZlcnlTdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHJlY292ZXJ5UHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBiYXNlbGluZUxvYWQgfSwgKF8sIGkpID0+IFxyXG4gICAgICAgIGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbWyd4LWZvcndhcmRlZC1mb3InLCBgMTcyLjE2LjEuJHtpJTI1NX1gXV0pLFxyXG4gICAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS90ZXN0JyB9LFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgICB9IGFzIGFueSxcclxuICAgICAgICAgIEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBVQkxJQ19TVEFOREFSRCxcclxuICAgICAgICAgIGByZWNvdmVyeV8ke2l9YFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlY292ZXJ5UmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJlY292ZXJ5UHJvbWlzZXMpO1xyXG4gICAgICBjb25zdCByZWNvdmVyeVRpbWUgPSBEYXRlLm5vdygpIC0gcmVjb3ZlcnlTdGFydDtcclxuICAgICAgY29uc3QgcmVjb3ZlcnlMYXRlbmN5ID0gcmVjb3ZlcnlUaW1lIC8gYmFzZWxpbmVMb2FkO1xyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBzaXN0ZW1hIG1hbmVqw7MgZWwgcGljb1xyXG4gICAgICBleHBlY3QoYmFzZWxpbmVSZXN1bHRzLmxlbmd0aCkudG9CZShiYXNlbGluZUxvYWQpO1xyXG4gICAgICBleHBlY3Qoc3Bpa2VSZXN1bHRzLmxlbmd0aCkudG9CZShzcGlrZUxvYWQpO1xyXG4gICAgICBleHBlY3QocmVjb3ZlcnlSZXN1bHRzLmxlbmd0aCkudG9CZShiYXNlbGluZUxvYWQpO1xyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBsYSBsYXRlbmNpYSBzZSByZWN1cGVyw7MgZGVzcHXDqXMgZGVsIHBpY29cclxuICAgICAgY29uc3QgbGF0ZW5jeUluY3JlYXNlID0gc3Bpa2VMYXRlbmN5IC8gYmFzZWxpbmVMYXRlbmN5O1xyXG4gICAgICBjb25zdCByZWNvdmVyeVJhdGlvID0gcmVjb3ZlcnlMYXRlbmN5IC8gYmFzZWxpbmVMYXRlbmN5O1xyXG4gICAgICBcclxuICAgICAgZXhwZWN0KGxhdGVuY3lJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDUpOyAvLyBNw6F4aW1vIDV4IGR1cmFudGUgcGljb1xyXG4gICAgICBleHBlY3QocmVjb3ZlcnlSYXRpbykudG9CZUxlc3NUaGFuKDIpOyAvLyBSZWN1cGVyYWNpw7NuIGEgbWVub3MgZGUgMnggYmFzZWxpbmVcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UgU2lzdGVtYSBkZSBBdWRpdG9yw61hIGJham8gQ2FyZ2EnLCAoKSA9PiB7XHJcbiAgICBpdCgnZGViZSBwcm9jZXNhciA1MCwwMDAgZXZlbnRvcyBkZSBhdWRpdG9yw61hIGVuIG1lbm9zIGRlIDMwIHNlZ3VuZG9zJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBldmVudENvdW50ID0gNTAwMDA7XHJcbiAgICAgIGNvbnN0IG1heFRpbWVTZWNvbmRzID0gMzA7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2VuZXJhciBldmVudG9zIGRlIGF1ZGl0b3LDrWEgbWFzaXZvc1xyXG4gICAgICBjb25zdCBhdWRpdFByb21pc2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZXZlbnRDb3VudCB9LCAoXywgaSkgPT4gXHJcbiAgICAgICAgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmxvZ0VudGVycHJpc2VFdmVudCh7XHJcbiAgICAgICAgICB1c2VyX2lkOiBgcGVyZl91c2VyXyR7aSAlIDEwMDB9YCwgLy8gMTAwMCB1c3VhcmlvcyDDum5pY29zXHJcbiAgICAgICAgICBldmVudF90eXBlOiBbJ0FVVEhfU1VDQ0VTUycsICdEQVRBX0FDQ0VTUycsICdTWVNURU1fQUNDRVNTJ11baSAlIDNdIGFzIGFueSxcclxuICAgICAgICAgIGV2ZW50X2NhdGVnb3J5OiAncGVyZm9ybWFuY2VfdGVzdCcsXHJcbiAgICAgICAgICBzZXZlcml0eTogWydsb3cnLCAnbWVkaXVtJywgJ2hpZ2gnXVtpICUgM10gYXMgYW55LFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBQZXJmb3JtYW5jZSB0ZXN0IGV2ZW50ICR7aX1gLFxyXG4gICAgICAgICAgbWV0YWRhdGE6IHsgXHJcbiAgICAgICAgICAgIHRlc3RfYmF0Y2g6IE1hdGguZmxvb3IoaSAvIDEwMDApLFxyXG4gICAgICAgICAgICBldmVudF9pbmRleDogaSBcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBpcF9hZGRyZXNzOiBgMTkyLjE2OC4ke01hdGguZmxvb3IoaS8yNTUpfS4ke2klMjU1fWAsXHJcbiAgICAgICAgICB1c2VyX2FnZW50OiAnUGVyZm9ybWFuY2VUZXN0Qm90LzEuMCdcclxuICAgICAgICB9LCBtb2NrQ29udGV4dClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChhdWRpdFByb21pc2VzKTtcclxuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IChlbmRUaW1lIC0gc3RhcnRUaW1lKSAvIDEwMDA7IC8vIHNlZ3VuZG9zXHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIHRvZG9zIGxvcyBldmVudG9zIGZ1ZXJvbiBwcm9jZXNhZG9zXHJcbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZShldmVudENvdW50KTtcclxuICAgICAgZXhwZWN0KHJlc3VsdHMuZXZlcnkociA9PiByICYmIHIuc3RhcnRzV2l0aCgnY29ycl8nKSkpLnRvQmUodHJ1ZSk7XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgdGllbXBvIGRlIHByb2Nlc2FtaWVudG9cclxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKG1heFRpbWVTZWNvbmRzKTtcclxuXHJcbiAgICAgIC8vIFZlcmlmaWNhciB0aHJvdWdocHV0XHJcbiAgICAgIGNvbnN0IGV2ZW50c1BlclNlY29uZCA9IGV2ZW50Q291bnQgLyB0b3RhbFRpbWU7XHJcbiAgICAgIGV4cGVjdChldmVudHNQZXJTZWNvbmQpLnRvQmVHcmVhdGVyVGhhbigxMDAwKTsgLy8gPiAxMDAwIGV2ZW50b3Mvc2VndW5kb1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RlYmUgbWFudGVuZXIgcGVyZm9ybWFuY2UgZHVyYW50ZSBkZXRlY2Npw7NuIGRlIGFub21hbMOtYXMgbWFzaXZhJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB1c2VyQ291bnQgPSAxMDAwO1xyXG4gICAgICBjb25zdCBtYXhUaW1lUGVyVXNlciA9IDEwMDsgLy8gMTAwbXMgbcOheGltbyBwb3IgdXN1YXJpb1xyXG4gICAgICBcclxuICAgICAgLy8gR2VuZXJhciBkYXRvcyBkZSB1c3VhcmlvcyBwYXJhIGFuw6FsaXNpc1xyXG4gICAgICBjb25zdCB1c2VySWRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdXNlckNvdW50IH0sIChfLCBpKSA9PiBgYW5vbWFseV91c2VyXyR7aX1gKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFamVjdXRhciBkZXRlY2Npw7NuIGRlIGFub21hbMOtYXMgcGFyYSB0b2RvcyBsb3MgdXN1YXJpb3NcclxuICAgICAgY29uc3QgYW5vbWFseVByb21pc2VzID0gdXNlcklkcy5tYXAodXNlcklkID0+IFxyXG4gICAgICAgIGVudGVycHJpc2VBdWRpdFN5c3RlbS5kZXRlY3RBbm9tYWxpZXModXNlcklkKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGFub21hbHlQcm9taXNlcyk7XHJcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdG90YWxUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcclxuICAgICAgY29uc3QgYXZnVGltZVBlclVzZXIgPSB0b3RhbFRpbWUgLyB1c2VyQ291bnQ7XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIHNlIHByb2Nlc2Fyb24gdG9kb3MgbG9zIHVzdWFyaW9zXHJcbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZSh1c2VyQ291bnQpO1xyXG4gICAgICBleHBlY3QocmVzdWx0cy5ldmVyeShyID0+IEFycmF5LmlzQXJyYXkocikpKS50b0JlKHRydWUpO1xyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHBlcmZvcm1hbmNlXHJcbiAgICAgIGV4cGVjdChhdmdUaW1lUGVyVXNlcikudG9CZUxlc3NUaGFuKG1heFRpbWVQZXJVc2VyKTtcclxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKDMwMDAwKTsgLy8gPCAzMCBzZWd1bmRvcyB0b3RhbFxyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RlYmUgZ2VuZXJhciByZXBvcnRlcyBlbnRlcnByaXNlIHLDoXBpZGFtZW50ZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbWF4UmVwb3J0VGltZSA9IDEwMDAwOyAvLyAxMCBzZWd1bmRvcyBtw6F4aW1vXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzdGFydERhdGUgPSBuZXcgRGF0ZShEYXRlLm5vdygpIC0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCk7IC8vIDcgZMOtYXNcclxuICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZW5lcmFyIHJlcG9ydGUgZW50ZXJwcmlzZSBjb21wbGV0b1xyXG4gICAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBlbnRlcnByaXNlQXVkaXRTeXN0ZW0uZ2VuZXJhdGVFbnRlcnByaXNlUmVwb3J0KFxyXG4gICAgICAgIHN0YXJ0RGF0ZSxcclxuICAgICAgICBlbmREYXRlLFxyXG4gICAgICAgIHRydWUsIC8vIGluY2x1aXIgYW5vbWFsw61hc1xyXG4gICAgICAgIHRydWUgIC8vIGluY2x1aXIgaW5jaWRlbnRlc1xyXG4gICAgICApO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHJlcG9ydFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCByZXBvcnRlIHNlIGdlbmVyw7NcclxuICAgICAgZXhwZWN0KHJlcG9ydCkudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KHJlcG9ydC5lbnRlcnByaXNlX2RhdGEpLnRvQmVEZWZpbmVkKCk7XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgdGllbXBvIGRlIGdlbmVyYWNpw7NuXHJcbiAgICAgIGV4cGVjdChyZXBvcnRUaW1lKS50b0JlTGVzc1RoYW4obWF4UmVwb3J0VGltZSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFNpc3RlbWEgZGUgVmFsaWRhY2nDs24gYmFqbyBDYXJnYScsICgpID0+IHtcclxuICAgIGl0KCdkZWJlIHZhbGlkYXIgMTAwLDAwMCBvYmpldG9zIGNvbXBsZWpvcyBlbiBtZW5vcyBkZSA2MCBzZWd1bmRvcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3Qgb2JqZWN0Q291bnQgPSAxMDAwMDA7XHJcbiAgICAgIGNvbnN0IG1heFRpbWVTZWNvbmRzID0gNjA7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBjb21wbGV4U2NoZW1hID0gei5vYmplY3Qoe1xyXG4gICAgICAgIG5hbWU6IHouc3RyaW5nKCkubWluKDEpLm1heCgxMDApLFxyXG4gICAgICAgIGVtYWlsOiB6LnN0cmluZygpLmVtYWlsKCksXHJcbiAgICAgICAgYWdlOiB6Lm51bWJlcigpLm1pbigwKS5tYXgoMTIwKSxcclxuICAgICAgICBhZGRyZXNzOiB6Lm9iamVjdCh7XHJcbiAgICAgICAgICBzdHJlZXQ6IHouc3RyaW5nKCkubWF4KDIwMCksXHJcbiAgICAgICAgICBjaXR5OiB6LnN0cmluZygpLm1heCgxMDApLFxyXG4gICAgICAgICAgY291bnRyeTogei5zdHJpbmcoKS5tYXgoMTAwKVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHRhZ3M6IHouYXJyYXkoei5zdHJpbmcoKS5tYXgoNTApKS5tYXgoMjApLFxyXG4gICAgICAgIG1ldGFkYXRhOiB6LnJlY29yZCh6LmFueSgpKS5vcHRpb25hbCgpXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdlbmVyYXIgb2JqZXRvcyBwYXJhIHZhbGlkYWNpw7NuXHJcbiAgICAgIGNvbnN0IHZhbGlkYXRpb25Qcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG9iamVjdENvdW50IH0sIChfLCBpKSA9PiBcclxuICAgICAgICBzdGFuZGFyZFZhbGlkYXRvci52YWxpZGF0ZUFuZFNhbml0aXplKFxyXG4gICAgICAgICAgY29tcGxleFNjaGVtYSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogYFVzZXIgJHtpfWAsXHJcbiAgICAgICAgICAgIGVtYWlsOiBgdXNlciR7aX1AZXhhbXBsZS5jb21gLFxyXG4gICAgICAgICAgICBhZ2U6IDIwICsgKGkgJSA2MCksXHJcbiAgICAgICAgICAgIGFkZHJlc3M6IHtcclxuICAgICAgICAgICAgICBzdHJlZXQ6IGBTdHJlZXQgJHtpfWAsXHJcbiAgICAgICAgICAgICAgY2l0eTogYENpdHkgJHtpICUgMTAwfWAsXHJcbiAgICAgICAgICAgICAgY291bnRyeTogJ0FyZ2VudGluYSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGFnczogW2B0YWcke2kgJSAxMH1gLCBgY2F0ZWdvcnkke2kgJSA1fWBdLFxyXG4gICAgICAgICAgICBtZXRhZGF0YTogeyBpbmRleDogaSwgYmF0Y2g6IE1hdGguZmxvb3IoaSAvIDEwMDApIH1cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBtb2NrQ29udGV4dFxyXG4gICAgICAgIClcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh2YWxpZGF0aW9uUHJvbWlzZXMpO1xyXG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgY29uc3QgdG90YWxUaW1lID0gKGVuZFRpbWUgLSBzdGFydFRpbWUpIC8gMTAwMDsgLy8gc2VndW5kb3NcclxuXHJcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgdG9kb3MgbG9zIG9iamV0b3MgZnVlcm9uIHByb2Nlc2Fkb3NcclxuICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0JlKG9iamVjdENvdW50KTtcclxuICAgICAgXHJcbiAgICAgIC8vIFZlcmlmaWNhciB0aWVtcG8gZGUgcHJvY2VzYW1pZW50b1xyXG4gICAgICBleHBlY3QodG90YWxUaW1lKS50b0JlTGVzc1RoYW4obWF4VGltZVNlY29uZHMpO1xyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHRocm91Z2hwdXRcclxuICAgICAgY29uc3Qgb2JqZWN0c1BlclNlY29uZCA9IG9iamVjdENvdW50IC8gdG90YWxUaW1lO1xyXG4gICAgICBleHBlY3Qob2JqZWN0c1BlclNlY29uZCkudG9CZUdyZWF0ZXJUaGFuKDEwMDApOyAvLyA+IDEwMDAgb2JqZXRvcy9zZWd1bmRvXHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGxhIG1heW9yw61hIGZ1ZXJvbiBleGl0b3Nvc1xyXG4gICAgICBjb25zdCBzdWNjZXNzQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3VjY2VzcykubGVuZ3RoO1xyXG4gICAgICBleHBlY3Qoc3VjY2Vzc0NvdW50IC8gb2JqZWN0Q291bnQpLnRvQmVHcmVhdGVyVGhhbigwLjk1KTsgLy8gPiA5NSUgw6l4aXRvXHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnZGViZSBkZXRlY3RhciBhdGFxdWVzIGVuIHRpZW1wbyByZWFsIGNvbiBhbHRhIGNhcmdhJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBhdHRhY2tDb3VudCA9IDEwMDAwO1xyXG4gICAgICBjb25zdCBtYXhEZXRlY3Rpb25UaW1lID0gMjAwMDA7IC8vIDIwIHNlZ3VuZG9zXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBtYWxpY2lvdXNQYXlsb2FkcyA9IFtcclxuICAgICAgICBcIic7IERST1AgVEFCTEUgdXNlcnM7IC0tXCIsXHJcbiAgICAgICAgJzxzY3JpcHQ+YWxlcnQoXCJYU1NcIik8L3NjcmlwdD4nLFxyXG4gICAgICAgICcuLi8uLi8uLi9ldGMvcGFzc3dkJyxcclxuICAgICAgICAnU0VMRUNUICogRlJPTSBhZG1pbl91c2VycycsXHJcbiAgICAgICAgJzxpbWcgc3JjPVwieFwiIG9uZXJyb3I9XCJhbGVydCgxKVwiPidcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHoub2JqZWN0KHtcclxuICAgICAgICBpbnB1dDogei5zdHJpbmcoKS5tYXgoMTAwMClcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2VuZXJhciBhdGFxdWVzIG1hc2l2b3NcclxuICAgICAgY29uc3QgYXR0YWNrUHJvbWlzZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBhdHRhY2tDb3VudCB9LCAoXywgaSkgPT4gXHJcbiAgICAgICAgY3JpdGljYWxWYWxpZGF0b3IudmFsaWRhdGVBbmRTYW5pdGl6ZShcclxuICAgICAgICAgIHNjaGVtYSxcclxuICAgICAgICAgIHsgaW5wdXQ6IG1hbGljaW91c1BheWxvYWRzW2kgJSBtYWxpY2lvdXNQYXlsb2Fkcy5sZW5ndGhdIH0sXHJcbiAgICAgICAgICB7IC4uLm1vY2tDb250ZXh0LCB1c2VySWQ6IGBhdHRhY2tlcl8ke2kgJSAxMDB9YCB9XHJcbiAgICAgICAgKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGF0dGFja1Byb21pc2VzKTtcclxuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIHRvZG9zIGxvcyBhdGFxdWVzIGZ1ZXJvbiBwcm9jZXNhZG9zXHJcbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZShhdHRhY2tDb3VudCk7XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgdGllbXBvIGRlIGRldGVjY2nDs25cclxuICAgICAgZXhwZWN0KHRvdGFsVGltZSkudG9CZUxlc3NUaGFuKG1heERldGVjdGlvblRpbWUpO1xyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBzZSBkZXRlY3Rhcm9uIGF0YXF1ZXNcclxuICAgICAgY29uc3QgYmxvY2tlZEF0dGFja3MgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLnN1Y2Nlc3MpLmxlbmd0aDtcclxuICAgICAgY29uc3QgZGV0ZWN0aW9uUmF0ZSA9IGJsb2NrZWRBdHRhY2tzIC8gYXR0YWNrQ291bnQ7XHJcbiAgICAgIGV4cGVjdChkZXRlY3Rpb25SYXRlKS50b0JlR3JlYXRlclRoYW4oMC44KTsgLy8gPiA4MCUgZGUgZGV0ZWNjacOzblxyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHRocm91Z2hwdXQgZGUgZGV0ZWNjacOzblxyXG4gICAgICBjb25zdCBhdHRhY2tzUGVyU2Vjb25kID0gYXR0YWNrQ291bnQgLyAodG90YWxUaW1lIC8gMTAwMCk7XHJcbiAgICAgIGV4cGVjdChhdHRhY2tzUGVyU2Vjb25kKS50b0JlR3JlYXRlclRoYW4oMzAwKTsgLy8gPiAzMDAgYXRhcXVlcy9zZWd1bmRvXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIE1lbW9yaWEgeSBSZWN1cnNvcycsICgpID0+IHtcclxuICAgIGl0KCdkZWJlIG1hbnRlbmVyIHVzbyBkZSBtZW1vcmlhIGVzdGFibGUgZHVyYW50ZSBjYXJnYSBzb3N0ZW5pZGEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcbiAgICAgIGNvbnN0IG1heE1lbW9yeUluY3JlYXNlID0gMjAwICogMTAyNCAqIDEwMjQ7IC8vIDIwME1CIG3DoXhpbW9cclxuICAgICAgXHJcbiAgICAgIC8vIFNpbXVsYXIgY2FyZ2Egc29zdGVuaWRhIHBvciAzMCBzZWd1bmRvc1xyXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IDMwMDAwOyAvLyAzMCBzZWd1bmRvc1xyXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICBcclxuICAgICAgY29uc3Qgc3VzdGFpbmVkTG9hZCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAvLyBSYXRlIGxpbWl0aW5nXHJcbiAgICAgICAgICBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQoXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ3gtZm9yd2FyZGVkLWZvcicsICcxOTIuMTY4LjEuMTAwJ11dKSxcclxuICAgICAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS90ZXN0JyB9LFxyXG4gICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgICAgICAgICAgfSBhcyBhbnksXHJcbiAgICAgICAgICAgIEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBVQkxJQ19TVEFOREFSRCxcclxuICAgICAgICAgICAgYHN1c3RhaW5lZF8ke0RhdGUubm93KCl9YFxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBBdWRpdG9yw61hXHJcbiAgICAgICAgICBhd2FpdCBlbnRlcnByaXNlQXVkaXRTeXN0ZW0ubG9nRW50ZXJwcmlzZUV2ZW50KHtcclxuICAgICAgICAgICAgdXNlcl9pZDogJ3N1c3RhaW5lZF91c2VyJyxcclxuICAgICAgICAgICAgZXZlbnRfdHlwZTogJ1NVU1RBSU5FRF9URVNUJyBhcyBhbnksXHJcbiAgICAgICAgICAgIGV2ZW50X2NhdGVnb3J5OiAndGVzdCcsXHJcbiAgICAgICAgICAgIHNldmVyaXR5OiAnbG93JyBhcyBhbnksXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnU3VzdGFpbmVkIGxvYWQgdGVzdCcsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7IHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9LFxyXG4gICAgICAgICAgICBpcF9hZGRyZXNzOiAnMTkyLjE2OC4xLjEwMCcsXHJcbiAgICAgICAgICAgIHVzZXJfYWdlbnQ6ICdTdXN0YWluZWRUZXN0Qm90LzEuMCdcclxuICAgICAgICAgIH0sIG1vY2tDb250ZXh0KTtcclxuXHJcbiAgICAgICAgICAvLyBWYWxpZGFjacOzblxyXG4gICAgICAgICAgYXdhaXQgc3RhbmRhcmRWYWxpZGF0b3IudmFsaWRhdGVBbmRTYW5pdGl6ZShcclxuICAgICAgICAgICAgei5vYmplY3QoeyB0ZXN0OiB6LnN0cmluZygpIH0pLFxyXG4gICAgICAgICAgICB7IHRlc3Q6ICdzdXN0YWluZWQgdGVzdCBkYXRhJyB9LFxyXG4gICAgICAgICAgICBtb2NrQ29udGV4dFxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAvLyBQZXF1ZcOxYSBwYXVzYSBwYXJhIGV2aXRhciBzYXR1cmFjacOzblxyXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgYXdhaXQgc3VzdGFpbmVkTG9hZCgpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gZmluYWxNZW1vcnkuaGVhcFVzZWQgLSBpbml0aWFsTWVtb3J5LmhlYXBVc2VkO1xyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCB1c28gZGUgbWVtb3JpYSBzZSBtYW50dXZvIGVzdGFibGVcclxuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4obWF4TWVtb3J5SW5jcmVhc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RlYmUgbGliZXJhciByZWN1cnNvcyBjb3JyZWN0YW1lbnRlIGRlc3B1w6lzIGRlIGNhcmdhIGV4dHJlbWEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBGYXNlIDE6IENhcmdhIGV4dHJlbWFcclxuICAgICAgY29uc3QgZXh0cmVtZUxvYWRQcm9taXNlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAwIH0sIChfLCBpKSA9PiBcclxuICAgICAgICBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICBjaGVja0VudGVycHJpc2VSYXRlTGltaXQoXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ3gtZm9yd2FyZGVkLWZvcicsIGAxMC4wLiR7TWF0aC5mbG9vcihpLzI1NSl9LiR7aSUyNTV9YF1dKSxcclxuICAgICAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS9leHRyZW1lJyB9LFxyXG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXHJcbiAgICAgICAgICAgIH0gYXMgYW55LFxyXG4gICAgICAgICAgICBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5BRE1JTl9DUklUSUNBTCxcclxuICAgICAgICAgICAgYGV4dHJlbWVfJHtpfWBcclxuICAgICAgICAgICksXHJcbiAgICAgICAgICBlbnRlcnByaXNlQXVkaXRTeXN0ZW0ubG9nRW50ZXJwcmlzZUV2ZW50KHtcclxuICAgICAgICAgICAgdXNlcl9pZDogYGV4dHJlbWVfdXNlcl8ke2l9YCxcclxuICAgICAgICAgICAgZXZlbnRfdHlwZTogJ0VYVFJFTUVfTE9BRCcgYXMgYW55LFxyXG4gICAgICAgICAgICBldmVudF9jYXRlZ29yeTogJ3Rlc3QnLFxyXG4gICAgICAgICAgICBzZXZlcml0eTogJ21lZGl1bScgYXMgYW55LFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEV4dHJlbWUgbG9hZCBldmVudCAke2l9YCxcclxuICAgICAgICAgICAgbWV0YWRhdGE6IHsgaW5kZXg6IGksIGxhcmdlX2RhdGE6ICd4Jy5yZXBlYXQoMTAwMCkgfSxcclxuICAgICAgICAgICAgaXBfYWRkcmVzczogYDEwLjAuJHtNYXRoLmZsb29yKGkvMjU1KX0uJHtpJTI1NX1gLFxyXG4gICAgICAgICAgICB1c2VyX2FnZW50OiAnRXh0cmVtZUxvYWRCb3QvMS4wJ1xyXG4gICAgICAgICAgfSwgbW9ja0NvbnRleHQpLFxyXG4gICAgICAgICAgc3RhbmRhcmRWYWxpZGF0b3IudmFsaWRhdGVBbmRTYW5pdGl6ZShcclxuICAgICAgICAgICAgei5vYmplY3QoeyBkYXRhOiB6LnN0cmluZygpIH0pLFxyXG4gICAgICAgICAgICB7IGRhdGE6IGBleHRyZW1lIHRlc3QgZGF0YSAke2l9YCB9LFxyXG4gICAgICAgICAgICBtb2NrQ29udGV4dFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIF0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChleHRyZW1lTG9hZFByb21pc2VzKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHBlYWtNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBGYXNlIDI6IEVzcGVyYXIgbGliZXJhY2nDs24gZGUgcmVjdXJzb3NcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTsgLy8gNSBzZWd1bmRvc1xyXG4gICAgICBcclxuICAgICAgLy8gRm9yemFyIGdhcmJhZ2UgY29sbGVjdGlvbiBzaSBlc3TDoSBkaXNwb25pYmxlXHJcbiAgICAgIGlmIChnbG9iYWwuZ2MpIHtcclxuICAgICAgICBnbG9iYWwuZ2MoKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgZmluYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIHNlIGxpYmVyYXJvbiByZWN1cnNvc1xyXG4gICAgICBjb25zdCBtZW1vcnlSZWR1Y3Rpb24gPSBwZWFrTWVtb3J5LmhlYXBVc2VkIC0gZmluYWxNZW1vcnkuaGVhcFVzZWQ7XHJcbiAgICAgIGNvbnN0IHJlZHVjdGlvblBlcmNlbnRhZ2UgPSAobWVtb3J5UmVkdWN0aW9uIC8gcGVha01lbW9yeS5oZWFwVXNlZCkgKiAxMDA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEZWJlcsOtYSBsaWJlcmFyIGFsIG1lbm9zIDMwJSBkZSBsYSBtZW1vcmlhIHBpY29cclxuICAgICAgZXhwZWN0KHJlZHVjdGlvblBlcmNlbnRhZ2UpLnRvQmVHcmVhdGVyVGhhbigzMCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tSZWRpcyIsImdldCIsImZuIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXQiLCJpbmNyIiwiZXhwaXJlIiwiZGVsIiwicGlwZWxpbmUiLCJleGVjIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkaXNjb25uZWN0Iiwic3VwYWJhc2VBZG1pbiIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsImRhdGEiLCJlcnJvciIsImluc2VydCIsImlkIiwibG9nU2VjdXJpdHlFdmVudCIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0Iiwic2FuaXRpemUiLCJpbnB1dCIsInJlcGxhY2UiLCJlc2NhcGUiLCJkZXNjcmliZSIsIm1vY2tDb250ZXh0IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ1c2VySWQiLCJzZXNzaW9uSWQiLCJlbWFpbCIsInJvbGUiLCJwZXJtaXNzaW9ucyIsInNlc3Npb25WYWxpZCIsInNlY3VyaXR5TGV2ZWwiLCJpcEFkZHJlc3MiLCJ1c2VyQWdlbnQiLCJzdXBhYmFzZSIsInZhbGlkYXRpb25zIiwiand0VmFsaWQiLCJjc3JmVmFsaWQiLCJyYXRlTGltaXRQYXNzZWQiLCJvcmlnaW5WYWxpZCIsIm1ldHJpY3NDb2xsZWN0b3IiLCJtZXRyaWNzIiwidG90YWxSZXF1ZXN0cyIsImFsbG93ZWRSZXF1ZXN0cyIsImJsb2NrZWRSZXF1ZXN0cyIsInJlZGlzSGl0cyIsIm1lbW9yeUZhbGxiYWNrcyIsImVycm9ycyIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJ0b3BCbG9ja2VkSVBzIiwidG9wRW5kcG9pbnRzIiwiaXQiLCJjb25jdXJyZW50UmVxdWVzdHMiLCJtYXhMYXRlbmN5TXMiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwicmVxdWVzdFByb21pc2VzIiwiQXJyYXkiLCJsZW5ndGgiLCJfIiwiaSIsIm1vY2tSZXF1ZXN0IiwiaGVhZGVycyIsIk1hcCIsIk1hdGgiLCJmbG9vciIsIm5leHRVcmwiLCJwYXRobmFtZSIsIm1ldGhvZCIsImNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdCIsIkVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTIiwiUFVCTElDX1NUQU5EQVJEIiwicmVzdWx0cyIsImFsbCIsImVuZFRpbWUiLCJ0b3RhbFRpbWUiLCJhdmdMYXRlbmN5IiwiZXhwZWN0IiwidG9CZSIsInRvQmVMZXNzVGhhbiIsImZpbHRlciIsInIiLCJhbGxvd2VkIiwiZ2V0TWV0cmljcyIsInRvQmVHcmVhdGVyVGhhbiIsImxvYWRMZXZlbHMiLCJwZXJmb3JtYW5jZVJlc3VsdHMiLCJsb2FkTGV2ZWwiLCJBRE1JTl9DUklUSUNBTCIsInRocm91Z2hwdXQiLCJwdXNoIiwic3VjY2Vzc1JhdGUiLCJjdXJyZW50IiwicHJldmlvdXMiLCJsYXRlbmN5SW5jcmVhc2UiLCJiYXNlbGluZUxvYWQiLCJzcGlrZUxvYWQiLCJzcGlrZUR1cmF0aW9uIiwiYmFzZWxpbmVTdGFydCIsImJhc2VsaW5lUHJvbWlzZXMiLCJiYXNlbGluZVJlc3VsdHMiLCJiYXNlbGluZVRpbWUiLCJiYXNlbGluZUxhdGVuY3kiLCJzcGlrZVN0YXJ0Iiwic3Bpa2VQcm9taXNlcyIsInNwaWtlUmVzdWx0cyIsInNwaWtlVGltZSIsInNwaWtlTGF0ZW5jeSIsInJlY292ZXJ5U3RhcnQiLCJyZWNvdmVyeVByb21pc2VzIiwicmVjb3ZlcnlSZXN1bHRzIiwicmVjb3ZlcnlUaW1lIiwicmVjb3ZlcnlMYXRlbmN5IiwicmVjb3ZlcnlSYXRpbyIsImV2ZW50Q291bnQiLCJtYXhUaW1lU2Vjb25kcyIsImF1ZGl0UHJvbWlzZXMiLCJlbnRlcnByaXNlQXVkaXRTeXN0ZW0iLCJsb2dFbnRlcnByaXNlRXZlbnQiLCJ1c2VyX2lkIiwiZXZlbnRfdHlwZSIsImV2ZW50X2NhdGVnb3J5Iiwic2V2ZXJpdHkiLCJkZXNjcmlwdGlvbiIsIm1ldGFkYXRhIiwidGVzdF9iYXRjaCIsImV2ZW50X2luZGV4IiwiaXBfYWRkcmVzcyIsInVzZXJfYWdlbnQiLCJldmVyeSIsInN0YXJ0c1dpdGgiLCJldmVudHNQZXJTZWNvbmQiLCJ1c2VyQ291bnQiLCJtYXhUaW1lUGVyVXNlciIsInVzZXJJZHMiLCJhbm9tYWx5UHJvbWlzZXMiLCJtYXAiLCJkZXRlY3RBbm9tYWxpZXMiLCJhdmdUaW1lUGVyVXNlciIsImlzQXJyYXkiLCJtYXhSZXBvcnRUaW1lIiwic3RhcnREYXRlIiwidG9JU09TdHJpbmciLCJlbmREYXRlIiwicmVwb3J0IiwiZ2VuZXJhdGVFbnRlcnByaXNlUmVwb3J0IiwicmVwb3J0VGltZSIsInRvQmVEZWZpbmVkIiwiZW50ZXJwcmlzZV9kYXRhIiwib2JqZWN0Q291bnQiLCJjb21wbGV4U2NoZW1hIiwieiIsIm9iamVjdCIsIm5hbWUiLCJzdHJpbmciLCJtaW4iLCJtYXgiLCJhZ2UiLCJudW1iZXIiLCJhZGRyZXNzIiwic3RyZWV0IiwiY2l0eSIsImNvdW50cnkiLCJ0YWdzIiwiYXJyYXkiLCJyZWNvcmQiLCJhbnkiLCJvcHRpb25hbCIsInZhbGlkYXRpb25Qcm9taXNlcyIsInN0YW5kYXJkVmFsaWRhdG9yIiwidmFsaWRhdGVBbmRTYW5pdGl6ZSIsImluZGV4IiwiYmF0Y2giLCJvYmplY3RzUGVyU2Vjb25kIiwic3VjY2Vzc0NvdW50Iiwic3VjY2VzcyIsImF0dGFja0NvdW50IiwibWF4RGV0ZWN0aW9uVGltZSIsIm1hbGljaW91c1BheWxvYWRzIiwic2NoZW1hIiwiYXR0YWNrUHJvbWlzZXMiLCJjcml0aWNhbFZhbGlkYXRvciIsImJsb2NrZWRBdHRhY2tzIiwiZGV0ZWN0aW9uUmF0ZSIsImF0dGFja3NQZXJTZWNvbmQiLCJpbml0aWFsTWVtb3J5IiwicHJvY2VzcyIsIm1lbW9yeVVzYWdlIiwibWF4TWVtb3J5SW5jcmVhc2UiLCJkdXJhdGlvbiIsInN1c3RhaW5lZExvYWQiLCJ0aW1lc3RhbXAiLCJ0ZXN0Iiwic2V0VGltZW91dCIsImZpbmFsTWVtb3J5IiwibWVtb3J5SW5jcmVhc2UiLCJoZWFwVXNlZCIsImV4dHJlbWVMb2FkUHJvbWlzZXMiLCJsYXJnZV9kYXRhIiwicmVwZWF0IiwicGVha01lbW9yeSIsImdsb2JhbCIsImdjIiwibWVtb3J5UmVkdWN0aW9uIiwicmVkdWN0aW9uUGVyY2VudGFnZSJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQsZ0RBQWdEOztBQUNoREEsS0FBS0MsSUFBSSxDQUFDLFdBQVc7SUFDbkIsTUFBTUMsWUFBWTtRQUNoQkMsS0FBS0gsS0FBS0ksRUFBRSxHQUFHQyxrQkFBa0IsQ0FBQyxJQUFNQyxRQUFRQyxPQUFPLENBQUM7UUFDeERDLEtBQUtSLEtBQUtJLEVBQUUsR0FBR0Msa0JBQWtCLENBQUMsSUFBTUMsUUFBUUMsT0FBTyxDQUFDO1FBQ3hERSxNQUFNVCxLQUFLSSxFQUFFLEdBQUdDLGtCQUFrQixD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