{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\auth\\admin-auth.ts"],"sourcesContent":["/**\n * Sistema de Autenticación y Autorización para Panel Administrativo\n * Implementa verificación de roles y permisos granulares\n */\n\nimport { auth, currentUser, getAuth } from '@clerk/nextjs/server';\nimport { supabaseAdmin } from '@/lib/supabase';\nimport { NextRequest } from 'next/server';\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport {\n  validateSecurityContext,\n  getSecurityContext,\n  type SecurityValidationResult,\n  type SecurityContext\n} from './security-validations';\nimport {\n  logAuthSuccess,\n  logAuthFailure,\n  logPermissionDenied,\n  runSecurityDetection\n} from './security-audit';\nimport {\n  logAuthentication,\n  logDataAccess,\n  logAdminAction,\n  AuditResult\n} from '@/lib/security/audit-trail';\nimport {\n  validateJWTIntegrity,\n  validateJWTPermissions,\n  type JWTValidationResult\n} from './jwt-validation';\nimport {\n  validateRequestOrigin,\n  type CSRFValidationResult\n} from './csrf-protection';\nimport {\n  checkRateLimit,\n  RATE_LIMIT_CONFIGS,\n  type RateLimitResult\n} from './rate-limiting';\n\n// =====================================================\n// TIPOS Y INTERFACES\n// =====================================================\n\nexport interface UserProfile {\n  id: string;\n  supabase_user_id: string | null;\n  clerk_user_id: string | null;\n  email: string;\n  first_name: string | null;\n  last_name: string | null;\n  role_id: number;\n  is_active: boolean;\n  is_verified: boolean;\n  user_roles: {\n    id: number;\n    role_name: string;\n    display_name: string;\n    permissions: Record<string, any>;\n    is_active: boolean;\n  };\n}\n\nexport interface AdminAuthResult {\n  success: boolean;\n  user?: UserProfile;\n  error?: string;\n  status?: number;\n}\n\nexport interface PermissionCheck {\n  resource: string;\n  action: string;\n  userId?: string;\n}\n\n// =====================================================\n// FUNCIONES DE VERIFICACIÓN DE AUTENTICACIÓN\n// =====================================================\n\n/**\n * Obtiene el usuario autenticado usando SOLO métodos oficiales de Clerk\n * MIGRADO: Ya no usa headers ni JWT como fallback - Solo getAuth(req) y auth()\n */\nexport async function getAuthenticatedUser(\n  request?: NextRequest | NextApiRequest\n): Promise<{ userId: string | null; sessionId?: string; error?: string; isAdmin?: boolean }> {\n  try {\n    // Método 1: Usar getAuth oficial de Clerk para API Routes (PREFERIDO)\n    if (request && 'query' in request) {\n      // Es NextApiRequest (Pages Router)\n      const { userId, sessionId, getToken } = getAuth(request as NextApiRequest);\n      if (userId) {\n        console.log(`[AUTH] Usuario autenticado via getAuth: ${userId}`);\n\n        // Verificar si es admin usando el token\n        let isAdmin = false;\n        try {\n          const token = await getToken();\n          if (token) {\n            // Decodificar token para obtener metadata\n            const payload = JSON.parse(atob(token.split('.')[1]));\n            isAdmin = payload.metadata?.role === 'admin';\n          }\n        } catch (tokenError) {\n          console.warn('[AUTH] Error obteniendo token para verificar admin:', tokenError);\n        }\n\n        return { userId, sessionId, isAdmin };\n      }\n    }\n\n    // Método 2: Usar auth() para App Router Route Handlers\n    if (!request || !('query' in request)) {\n      try {\n        const { userId, sessionId, sessionClaims } = await auth();\n        if (userId) {\n          console.log(`[AUTH] Usuario autenticado via auth(): ${userId}`);\n\n          // Verificar si es admin usando sessionClaims\n          const isAdmin = sessionClaims?.metadata?.role === 'admin';\n\n          return { userId, sessionId, isAdmin };\n        }\n      } catch (authError) {\n        console.warn('[AUTH] Error usando auth():', authError);\n        return {\n          userId: null,\n          error: `Error de autenticación: ${authError.message}`\n        };\n      }\n    }\n\n    console.warn('[AUTH] No se pudo obtener userId - usuario no autenticado');\n    return { userId: null, error: 'Usuario no autenticado' };\n  } catch (error) {\n    console.error('[AUTH] Error en getAuthenticatedUser:', error);\n    return {\n      userId: null,\n      error: error instanceof Error ? error.message : 'Error de autenticación'\n    };\n  }\n}\n\n/**\n * Función de migración para APIs que aún usan headers directamente\n * DEPRECADA: Usar getAuthenticatedUser() en su lugar\n */\nexport async function getAuthFromHeaders(\n  request: NextRequest\n): Promise<{ userId: string | null; error?: string; deprecated: boolean }> {\n  console.warn('[AUTH] ⚠️ DEPRECADO: getAuthFromHeaders() - Migrar a getAuthenticatedUser()');\n\n  const clerkUserId = request.headers.get('x-clerk-user-id');\n\n  if (!clerkUserId) {\n    return {\n      userId: null,\n      error: 'Header x-clerk-user-id no encontrado',\n      deprecated: true\n    };\n  }\n\n  return {\n    userId: clerkUserId,\n    deprecated: true\n  };\n}\n\n/**\n * Función mejorada que combina autenticación y verificación de admin\n * Reemplaza el patrón común de getAuthenticatedUser + checkAdminAccess\n */\nexport async function getAuthenticatedAdmin(\n  request?: NextRequest | NextApiRequest\n): Promise<{\n  userId: string | null;\n  sessionId?: string;\n  isAdmin: boolean;\n  user?: any;\n  supabase?: any;\n  error?: string;\n  status?: number;\n}> {\n  try {\n    // Obtener usuario autenticado\n    const authResult = await getAuthenticatedUser(request);\n\n    if (!authResult.userId) {\n      return {\n        userId: null,\n        isAdmin: false,\n        error: authResult.error || 'Usuario no autenticado',\n        status: 401\n      };\n    }\n\n    // Si ya tenemos información de admin del token, usarla\n    if (authResult.isAdmin !== undefined) {\n      if (!authResult.isAdmin) {\n        return {\n          userId: authResult.userId,\n          sessionId: authResult.sessionId,\n          isAdmin: false,\n          error: 'Permisos de administrador requeridos',\n          status: 403\n        };\n      }\n\n      return {\n        userId: authResult.userId,\n        sessionId: authResult.sessionId,\n        isAdmin: true,\n        supabase: supabaseAdmin\n      };\n    }\n\n    // Fallback: verificar admin en base de datos\n    const adminCheck = await checkAdminAccess(authResult.userId);\n\n    if (!adminCheck.success) {\n      return {\n        userId: authResult.userId,\n        sessionId: authResult.sessionId,\n        isAdmin: false,\n        error: adminCheck.error,\n        status: adminCheck.status\n      };\n    }\n\n    return {\n      userId: authResult.userId,\n      sessionId: authResult.sessionId,\n      isAdmin: true,\n      user: adminCheck.user,\n      supabase: adminCheck.supabase\n    };\n  } catch (error) {\n    console.error('[AUTH] Error en getAuthenticatedAdmin:', error);\n    return {\n      userId: null,\n      isAdmin: false,\n      error: 'Error interno de autenticación',\n      status: 500\n    };\n  }\n}\n\n/**\n * Nueva función específica para Pages Router API Routes\n * Usa getAuth(req) oficial de Clerk\n */\nexport function getAuthFromApiRoute(req: NextApiRequest, res: NextApiResponse) {\n  const { userId, sessionId, getToken } = getAuth(req);\n\n  if (!userId) {\n    throw new Error('Usuario no autenticado');\n  }\n\n  console.log(`[AUTH] API Route autenticada: ${userId}`);\n  return { userId, sessionId, getToken };\n}\n\n/**\n * Nueva función específica para App Router Route Handlers\n * Usa auth() oficial de Clerk\n */\nexport async function getAuthFromRouteHandler() {\n  const { userId, sessionId, getToken } = await auth();\n\n  if (!userId) {\n    throw new Error('Usuario no autenticado');\n  }\n\n  console.log(`[AUTH] Route Handler autenticado: ${userId}`);\n  return { userId, sessionId, getToken };\n}\n\n/**\n * Función unificada que detecta automáticamente el tipo de ruta\n * Con manejo robusto de errores y fallbacks\n */\nexport async function getUnifiedAuth(request?: NextRequest | NextApiRequest) {\n  try {\n    // Detectar si es API Route (Pages Router)\n    if (request && 'query' in request) {\n      try {\n        return getAuthFromApiRoute(request as NextApiRequest, {} as NextApiResponse);\n      } catch (apiError) {\n        console.warn('[AUTH] Error en API Route, usando fallback:', apiError);\n        // Fallback a función original\n        return await getAuthenticatedUser(request);\n      }\n    }\n\n    // Detectar si es Route Handler (App Router) o sin request\n    if (!request || !('query' in request)) {\n      try {\n        return await getAuthFromRouteHandler();\n      } catch (routeError) {\n        console.warn('[AUTH] Error en Route Handler, usando fallback:', routeError);\n        // Fallback a función original\n        return await getAuthenticatedUser(request);\n      }\n    }\n\n    // Fallback a función original\n    return await getAuthenticatedUser(request);\n  } catch (error) {\n    console.error('[AUTH] Error en getUnifiedAuth:', error);\n    // En lugar de lanzar error, retornar resultado de fallback\n    return await getAuthenticatedUser(request);\n  }\n}\n\n/**\n * Obtiene el perfil completo del usuario desde Supabase\n */\nexport async function getUserProfile(clerkUserId: string): Promise<UserProfile | null> {\n  try {\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client not available');\n    }\n\n    // Primero obtener el perfil del usuario\n    const { data: profile, error: profileError } = await supabaseAdmin\n      .from('user_profiles')\n      .select('*')\n      .eq('clerk_user_id', clerkUserId)\n      .eq('is_active', true)\n      .single();\n\n    if (profileError) {\n      console.error('Error fetching user profile:', profileError);\n      return null;\n    }\n\n    if (!profile) {\n      return null;\n    }\n\n    // Luego obtener el rol del usuario\n    const { data: role, error: roleError } = await supabaseAdmin\n      .from('user_roles')\n      .select('*')\n      .eq('id', profile.role_id)\n      .single();\n\n    if (roleError) {\n      console.error('Error fetching user role:', roleError);\n      return null;\n    }\n\n    // Combinar los datos\n    const userProfile: UserProfile = {\n      ...profile,\n      user_roles: role\n    };\n\n    return userProfile;\n  } catch (error) {\n    console.error('Error in getUserProfile:', error);\n    return null;\n  }\n}\n\n/**\n * Verifica si un usuario tiene acceso al panel administrativo\n */\nexport async function checkAdminAccess(clerkUserId: string): Promise<AdminAuthResult> {\n  try {\n    const profile = await getUserProfile(clerkUserId);\n    \n    if (!profile) {\n      return {\n        success: false,\n        error: 'Perfil de usuario no encontrado',\n        status: 404\n      };\n    }\n\n    if (!profile.user_roles || !profile.is_active) {\n      return {\n        success: false,\n        error: 'Rol de usuario no válido',\n        status: 403\n      };\n    }\n\n    // Verificar si tiene acceso al panel admin\n    const hasAdminAccess = hasPermission(profile, ['admin_panel', 'access']);\n    \n    if (!hasAdminAccess) {\n      return {\n        success: false,\n        error: 'Acceso denegado al panel administrativo',\n        status: 403\n      };\n    }\n\n    return {\n      success: true,\n      user: profile\n    };\n  } catch (error) {\n    console.error('Error in checkAdminAccess:', error);\n    return {\n      success: false,\n      error: 'Error interno del servidor',\n      status: 500\n    };\n  }\n}\n\n// =====================================================\n// FUNCIONES DE VERIFICACIÓN DE PERMISOS\n// =====================================================\n\n/**\n * Verifica si un usuario tiene un permiso específico\n */\nexport function hasPermission(\n  userProfile: UserProfile,\n  permissionPath: string[]\n): boolean {\n  try {\n    if (!userProfile.user_roles || !userProfile.user_roles.permissions) {\n      return false;\n    }\n\n    let current: any = userProfile.user_roles.permissions;\n    \n    for (const path of permissionPath) {\n      if (current[path] === undefined) {\n        return false;\n      }\n      current = current[path];\n    }\n\n    // Manejar diferentes tipos de valores de permisos\n    if (typeof current === 'boolean') {\n      return current;\n    }\n    \n    if (typeof current === 'string') {\n      // Para permisos como \"own\", \"own_limited\", etc.\n      return current !== 'false';\n    }\n\n    return false;\n  } catch (error) {\n    console.error('Error checking permission:', error);\n    return false;\n  }\n}\n\n/**\n * Verifica múltiples permisos\n */\nexport function hasAnyPermission(\n  userProfile: UserProfile,\n  permissions: string[][]\n): boolean {\n  return permissions.some(permission => hasPermission(userProfile, permission));\n}\n\n/**\n * Verifica todos los permisos\n */\nexport function hasAllPermissions(\n  userProfile: UserProfile,\n  permissions: string[][]\n): boolean {\n  return permissions.every(permission => hasPermission(userProfile, permission));\n}\n\n/**\n * Verifica si el usuario es administrador\n */\nexport function isAdmin(userProfile: UserProfile): boolean {\n  return userProfile.user_roles?.role_name === 'admin';\n}\n\n/**\n * Verifica si el usuario es moderador o administrador\n */\nexport function isModeratorOrAdmin(userProfile: UserProfile): boolean {\n  const role = userProfile.user_roles?.role_name;\n  return role === 'admin' || role === 'moderator';\n}\n\n// =====================================================\n// MIDDLEWARE DE AUTORIZACIÓN\n// =====================================================\n\n/**\n * Middleware principal para verificar permisos administrativos\n * MEJORADO: Incluye validaciones adicionales de seguridad (JWT, CSRF, Rate Limiting)\n */\nexport async function checkAdminPermissions(\n  requiredPermissions?: string[][],\n  request?: NextRequest | NextApiRequest\n): Promise<AdminAuthResult & {\n  supabase?: typeof supabaseAdmin;\n  securityContext?: SecurityContext;\n  jwtValidation?: JWTValidationResult;\n  csrfValidation?: CSRFValidationResult;\n  rateLimitResult?: RateLimitResult;\n}> {\n  try {\n    // 1. NUEVA VALIDACIÓN: Rate Limiting para APIs admin\n    const rateLimitResult = await checkRateLimit(\n      request!,\n      RATE_LIMIT_CONFIGS.admin,\n      'admin'\n    );\n\n    if (!rateLimitResult.allowed) {\n      await logAuthFailure(\n        'unknown',\n        'Rate limit exceeded for admin API',\n        request\n      );\n\n      return {\n        success: false,\n        error: rateLimitResult.error || 'Demasiadas requests administrativas',\n        status: 429,\n        rateLimitResult\n      };\n    }\n\n    // 2. NUEVA VALIDACIÓN: Origen de request (CSRF Protection)\n    const csrfValidation = await validateRequestOrigin(request!);\n\n    if (!csrfValidation.valid) {\n      await logAuthFailure(\n        'unknown',\n        `CSRF validation failed: ${csrfValidation.error}`,\n        request\n      );\n\n      return {\n        success: false,\n        error: csrfValidation.error || 'Origen de request no válido',\n        status: 403,\n        csrfValidation\n      };\n    }\n\n    // 3. Verificar autenticación con Clerk usando métodos oficiales\n    let userId: string;\n    let sessionId: string | undefined;\n\n    try {\n      const authResult = await getUnifiedAuth(request);\n      userId = authResult.userId;\n      sessionId = authResult.sessionId;\n\n      // Log autenticación exitosa\n      const securityContext = await getSecurityContext(userId, request);\n      if (securityContext) {\n        await logAuthSuccess(userId, securityContext, request);\n      }\n\n      // ✅ ENTERPRISE: Audit trail para autenticación exitosa\n      await logAuthentication(\n        'user_authenticated',\n        AuditResult.SUCCESS,\n        userId,\n        {\n          sessionId,\n          authMethod: 'clerk',\n          securityContext: securityContext?.riskLevel\n        },\n        {\n          ip: securityContext?.ipAddress || 'unknown',\n          userAgent: securityContext?.userAgent || 'unknown',\n          sessionId\n        }\n      );\n    } catch (authError) {\n      console.warn('[AUTH] Error en autenticación unificada, intentando fallback');\n      await logAuthFailure(null, `Error de autenticación: ${authError.message}`, request);\n\n      // ✅ ENTERPRISE: Audit trail para fallo de autenticación\n      await logAuthentication(\n        'authentication_failed',\n        AuditResult.FAILURE,\n        undefined,\n        {\n          error: authError.message,\n          authMethod: 'clerk',\n          fallbackAttempted: true\n        },\n        {\n          ip: request?.headers?.get('x-forwarded-for') || 'unknown',\n          userAgent: request?.headers?.get('user-agent') || 'unknown'\n        }\n      );\n\n      const fallbackResult = await getAuthenticatedUser(request);\n      if (!fallbackResult.userId) {\n        await logAuthFailure(null, fallbackResult.error || 'No autorizado', request);\n\n        // ✅ ENTERPRISE: Audit trail para fallo de fallback\n        await logAuthentication(\n          'authentication_fallback_failed',\n          AuditResult.FAILURE,\n          undefined,\n          {\n            error: fallbackResult.error,\n            authMethod: 'fallback'\n          },\n          {\n            ip: request?.headers?.get('x-forwarded-for') || 'unknown',\n            userAgent: request?.headers?.get('user-agent') || 'unknown'\n          }\n        );\n\n        return {\n          success: false,\n          error: fallbackResult.error || 'No autorizado',\n          status: 401\n        };\n      }\n      userId = fallbackResult.userId;\n      sessionId = fallbackResult.sessionId;\n    }\n\n    // 4. NUEVA VALIDACIÓN: Integridad del JWT\n    const jwtValidation = await validateJWTIntegrity(request);\n\n    if (!jwtValidation.valid) {\n      await logAuthFailure(\n        userId,\n        `JWT validation failed: ${jwtValidation.error}`,\n        request\n      );\n\n      return {\n        success: false,\n        error: jwtValidation.error || 'Token JWT inválido',\n        status: 401,\n        jwtValidation\n      };\n    }\n\n    // 5. NUEVA VALIDACIÓN: Permisos específicos en JWT\n    const jwtPermissionValidation = await validateJWTPermissions(\n      'admin',\n      ['admin_access'],\n      request\n    );\n\n    if (!jwtPermissionValidation.valid) {\n      await logPermissionDenied(\n        userId,\n        `JWT permission validation failed: ${jwtPermissionValidation.error}`,\n        request\n      );\n\n      return {\n        success: false,\n        error: jwtPermissionValidation.error || 'Permisos JWT insuficientes',\n        status: 403,\n        jwtValidation: jwtPermissionValidation\n      };\n    }\n\n    // 6. Ejecutar detección de seguridad\n    await runSecurityDetection(userId);\n\n    // 3. Obtener contexto de seguridad completo\n    const securityContext = await getSecurityContext(userId, request);\n    if (!securityContext) {\n      await logAuthFailure(userId, 'No se pudo obtener contexto de seguridad', request);\n      return {\n        success: false,\n        error: 'Error obteniendo contexto de seguridad',\n        status: 500\n      };\n    }\n\n    // 4. Verificar disponibilidad de Supabase\n    if (!supabaseAdmin) {\n      return {\n        success: false,\n        error: 'Servicio administrativo no disponible',\n        status: 503\n      };\n    }\n\n    // 5. Verificar acceso administrativo básico\n    const adminCheck = await checkAdminAccess(userId);\n\n    if (!adminCheck.success) {\n      await logPermissionDenied(userId, 'ADMIN_ACCESS', ['admin_panel'], securityContext);\n      return adminCheck;\n    }\n\n    const userProfile = adminCheck.user!;\n\n    // 6. Verificar permisos específicos con validaciones de seguridad\n    if (requiredPermissions && requiredPermissions.length > 0) {\n      const hasRequiredPermissions = hasAnyPermission(userProfile, requiredPermissions);\n\n      if (!hasRequiredPermissions) {\n        await logPermissionDenied(\n          userId,\n          'SPECIFIC_PERMISSIONS',\n          requiredPermissions.flat(),\n          securityContext\n        );\n        return {\n          success: false,\n          error: 'Permisos insuficientes para esta operación',\n          status: 403\n        };\n      }\n    }\n\n    // 7. Registrar acceso en audit log\n    await logAdminAccess(userProfile.id, 'API_ACCESS');\n\n    return {\n      success: true,\n      user: userProfile,\n      supabase: supabaseAdmin,\n      securityContext,\n      jwtValidation,\n      csrfValidation,\n      rateLimitResult\n    };\n  } catch (error) {\n    console.error('Error in checkAdminPermissions:', error);\n    return {\n      success: false,\n      error: 'Error interno del servidor',\n      status: 500\n    };\n  }\n}\n\n/**\n * Middleware específico para operaciones CRUD con validaciones de seguridad\n * Actualizado para soportar tanto NextRequest como NextApiRequest\n */\nexport async function checkCRUDPermissions(\n  resource: string,\n  action: 'create' | 'read' | 'update' | 'delete',\n  request?: NextRequest | NextApiRequest\n): Promise<AdminAuthResult & { supabase?: typeof supabaseAdmin; securityContext?: SecurityContext }> {\n  const requiredPermissions = [[resource, action]];\n  return checkAdminPermissions(requiredPermissions, request);\n}\n\n/**\n * Nueva función de validación de seguridad avanzada\n * Integra todas las validaciones de seguridad en una sola función\n */\nexport async function checkAdvancedSecurity(\n  userId: string,\n  operation: string,\n  requiredPermissions: string[],\n  request?: NextRequest | NextApiRequest\n): Promise<SecurityValidationResult & { userProfile?: UserProfile; supabase?: typeof supabaseAdmin }> {\n  try {\n    // 1. Ejecutar detección de seguridad\n    await runSecurityDetection(userId);\n\n    // 2. Validar contexto de seguridad\n    const securityValidation = await validateSecurityContext(\n      userId,\n      operation,\n      requiredPermissions as any,\n      request\n    );\n\n    if (!securityValidation.valid) {\n      return securityValidation;\n    }\n\n    // 3. Obtener perfil de usuario desde Supabase\n    const userProfile = await getUserProfile(userId);\n    if (!userProfile) {\n      return {\n        valid: false,\n        error: 'Perfil de usuario no encontrado',\n        code: 'USER_PROFILE_NOT_FOUND',\n        severity: 'high'\n      };\n    }\n\n    // 4. Verificar disponibilidad de Supabase\n    if (!supabaseAdmin) {\n      return {\n        valid: false,\n        error: 'Servicio administrativo no disponible',\n        code: 'SERVICE_UNAVAILABLE',\n        severity: 'critical'\n      };\n    }\n\n    return {\n      valid: true,\n      context: securityValidation.context,\n      userProfile,\n      supabase: supabaseAdmin\n    };\n  } catch (error) {\n    console.error('[SECURITY] Error en checkAdvancedSecurity:', error);\n    return {\n      valid: false,\n      error: 'Error interno en validación de seguridad',\n      code: 'SECURITY_VALIDATION_ERROR',\n      severity: 'critical'\n    };\n  }\n}\n\n// =====================================================\n// FUNCIONES DE LOGGING Y AUDITORÍA\n// =====================================================\n\n/**\n * Registra acceso administrativo en el audit log\n */\nexport async function logAdminAccess(\n  userProfileId: string,\n  action: string,\n  resourceType?: string,\n  resourceId?: string,\n  additionalData?: Record<string, any>\n): Promise<void> {\n  try {\n    if (!supabaseAdmin) return;\n\n    await supabaseAdmin\n      .from('admin_audit_log')\n      .insert({\n        user_id: userProfileId,\n        action,\n        resource_type: resourceType || 'system',\n        resource_id: resourceId,\n        new_values: additionalData ? JSON.stringify(additionalData) : null\n      });\n  } catch (error) {\n    console.error('Error logging admin access:', error);\n    // No lanzar error para no interrumpir el flujo principal\n  }\n}\n\n/**\n * Registra cambios en recursos administrativos\n */\nexport async function logAdminAction(\n  userProfileId: string,\n  action: string,\n  resourceType: string,\n  resourceId: string,\n  oldValues?: any,\n  newValues?: any\n): Promise<void> {\n  try {\n    if (!supabaseAdmin) return;\n\n    await supabaseAdmin\n      .from('admin_audit_log')\n      .insert({\n        user_id: userProfileId,\n        action,\n        resource_type: resourceType,\n        resource_id: resourceId,\n        old_values: oldValues ? JSON.stringify(oldValues) : null,\n        new_values: newValues ? JSON.stringify(newValues) : null\n      });\n  } catch (error) {\n    console.error('Error logging admin action:', error);\n  }\n}\n\n// =====================================================\n// UTILIDADES PARA NEXT.JS API ROUTES\n// =====================================================\n\n/**\n * Wrapper para API routes que requieren autenticación admin (App Router)\n */\nexport function withAdminAuth(\n  handler: (\n    request: NextRequest,\n    context: { user: UserProfile; supabase: typeof supabaseAdmin }\n  ) => Promise<Response>,\n  requiredPermissions?: string[][]\n) {\n  return async (request: NextRequest): Promise<Response> => {\n    const authResult = await checkAdminPermissions(requiredPermissions, request);\n\n    if (!authResult.success) {\n      return new Response(\n        JSON.stringify({\n          success: false,\n          error: authResult.error\n        }),\n        {\n          status: authResult.status || 500,\n          headers: { 'Content-Type': 'application/json' }\n        }\n      );\n    }\n\n    return handler(request, {\n      user: authResult.user!,\n      supabase: authResult.supabase!\n    });\n  };\n}\n\n/**\n * Wrapper para Pages Router API Routes que requieren autenticación admin\n */\nexport function withAdminAuthPages(\n  handler: (\n    req: NextApiRequest,\n    res: NextApiResponse,\n    context: { user: UserProfile; supabase: typeof supabaseAdmin }\n  ) => Promise<void>,\n  requiredPermissions?: string[][]\n) {\n  return async (req: NextApiRequest, res: NextApiResponse): Promise<void> => {\n    const authResult = await checkAdminPermissions(requiredPermissions, req);\n\n    if (!authResult.success) {\n      return res.status(authResult.status || 500).json({\n        success: false,\n        error: authResult.error\n      });\n    }\n\n    return handler(req, res, {\n      user: authResult.user!,\n      supabase: authResult.supabase!\n    });\n  };\n}\n\n/**\n * Extrae información de la request para logging\n * Soporta tanto NextRequest como NextApiRequest\n */\nexport function getRequestInfo(request: NextRequest | NextApiRequest) {\n  if ('query' in request) {\n    // NextApiRequest (Pages Router)\n    const req = request as NextApiRequest;\n    return {\n      method: req.method || 'GET',\n      url: req.url || 'unknown',\n      userAgent: req.headers['user-agent'] || 'unknown',\n      ip: req.headers['x-forwarded-for'] ||\n          req.headers['x-real-ip'] ||\n          req.connection?.remoteAddress ||\n          'unknown'\n    };\n  } else {\n    // NextRequest (App Router)\n    const req = request as NextRequest;\n    return {\n      method: req.method,\n      url: req.url,\n      userAgent: req.headers.get('user-agent') || 'unknown',\n      ip: req.headers.get('x-forwarded-for') ||\n          req.headers.get('x-real-ip') ||\n          'unknown'\n    };\n  }\n}\n"],"names":["checkAdminAccess","checkAdminPermissions","checkAdvancedSecurity","checkCRUDPermissions","getAuthFromApiRoute","getAuthFromHeaders","getAuthFromRouteHandler","getAuthenticatedAdmin","getAuthenticatedUser","getRequestInfo","getUnifiedAuth","getUserProfile","hasAllPermissions","hasAnyPermission","hasPermission","isAdmin","isModeratorOrAdmin","logAdminAccess","logAdminAction","withAdminAuth","withAdminAuthPages","request","userId","sessionId","getToken","getAuth","console","log","token","payload","JSON","parse","atob","split","metadata","role","tokenError","warn","sessionClaims","auth","authError","error","message","Error","clerkUserId","headers","get","deprecated","authResult","status","undefined","supabase","supabaseAdmin","adminCheck","success","user","req","res","apiError","routeError","data","profile","profileError","from","select","eq","single","roleError","role_id","userProfile","user_roles","is_active","hasAdminAccess","permissionPath","permissions","current","path","some","permission","every","role_name","requiredPermissions","rateLimitResult","checkRateLimit","RATE_LIMIT_CONFIGS","admin","allowed","logAuthFailure","csrfValidation","validateRequestOrigin","valid","securityContext","getSecurityContext","logAuthSuccess","logAuthentication","AuditResult","SUCCESS","authMethod","riskLevel","ip","ipAddress","userAgent","FAILURE","fallbackAttempted","fallbackResult","jwtValidation","validateJWTIntegrity","jwtPermissionValidation","validateJWTPermissions","logPermissionDenied","runSecurityDetection","length","hasRequiredPermissions","flat","id","resource","action","operation","securityValidation","validateSecurityContext","code","severity","context","userProfileId","resourceType","resourceId","additionalData","insert","user_id","resource_type","resource_id","new_values","stringify","oldValues","newValues","old_values","handler","Response","json","method","url","connection","remoteAddress"],"mappings":"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"}