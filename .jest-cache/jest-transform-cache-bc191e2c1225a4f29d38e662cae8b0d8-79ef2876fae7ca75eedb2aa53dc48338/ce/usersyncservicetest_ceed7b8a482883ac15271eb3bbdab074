c49b1ce366346247b7c9043771ee9280
/**
 * Tests para el servicio de sincronización automática de usuarios
 * Verifica la sincronización robusta entre Clerk y Supabase
 */ "use strict";
// Mock de Clerk
jest.mock('@clerk/nextjs/server', ()=>({
        clerkClient: jest.fn(()=>({
                users: {
                    getUser: jest.fn(),
                    getUserList: jest.fn()
                }
            }))
    }));
jest.mock('@/lib/supabase', ()=>({
        supabaseAdmin: mockSupabaseAdmin
    }));
// Mock de security audit
jest.mock('@/lib/auth/security-audit', ()=>({
        logSecurityEvent: jest.fn(),
        logAdminAction: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _usersyncservice = require("../lib/auth/user-sync-service");
const _server = require("@clerk/nextjs/server");
// Mock de Supabase
const mockSupabaseAdmin = {
    from: jest.fn(()=>({
            select: jest.fn(()=>({
                    eq: jest.fn(()=>({
                            single: jest.fn(),
                            or: jest.fn(()=>({
                                    single: jest.fn()
                                }))
                        })),
                    or: jest.fn(()=>({
                            single: jest.fn()
                        }))
                })),
            insert: jest.fn(()=>({
                    select: jest.fn(()=>({
                            single: jest.fn()
                        }))
                })),
            update: jest.fn(()=>({
                    eq: jest.fn(()=>({
                            select: jest.fn(()=>({
                                    single: jest.fn()
                                }))
                        }))
                }))
        }))
};
describe('Servicio de Sincronización de Usuarios', ()=>{
    let mockClerkClient;
    beforeEach(()=>{
        mockClerkClient = _server.clerkClient;
        jest.clearAllMocks();
    });
    const mockClerkUserData = {
        id: 'user_123',
        email_addresses: [
            {
                email_address: 'test@example.com',
                id: 'email_123',
                verification: {
                    status: 'verified',
                    strategy: 'email_code'
                }
            }
        ],
        first_name: 'John',
        last_name: 'Doe',
        created_at: Date.now(),
        updated_at: Date.now(),
        image_url: 'https://example.com/avatar.jpg',
        public_metadata: {
            role: 'customer'
        }
    };
    describe('syncUserToSupabase', ()=>{
        it('debe crear un nuevo usuario exitosamente', async ()=>{
            // Mock: usuario no existe
            mockSupabaseAdmin.from().select().or().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            // Mock: rol por defecto existe
            mockSupabaseAdmin.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            // Mock: inserción exitosa
            mockSupabaseAdmin.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'user_456',
                    email: 'test@example.com'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData);
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
            expect(result.userId).toBe('user_456');
        });
        it('debe actualizar un usuario existente', async ()=>{
            const existingUser = {
                id: 'user_456',
                email: 'test@example.com',
                first_name: 'Jane'
            };
            // Mock: usuario existe
            mockSupabaseAdmin.from().select().or().single.mockResolvedValue({
                data: existingUser,
                error: null
            });
            // Mock: actualización exitosa
            mockSupabaseAdmin.from().update().eq().select().single.mockResolvedValue({
                data: {
                    ...existingUser,
                    first_name: 'John'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData);
            expect(result.success).toBe(true);
            expect(result.action).toBe('updated');
            expect(result.details?.newData.first_name).toBe('John');
        });
        it('debe manejar errores de validación', async ()=>{
            const invalidUserData = {
                ...mockClerkUserData,
                email_addresses: []
            };
            const result = await (0, _usersyncservice.syncUserToSupabase)(invalidUserData);
            expect(result.success).toBe(false);
            expect(result.action).toBe('error');
            expect(result.error).toContain('Al menos un email es requerido');
        });
        it('debe reintentar en caso de error temporal', async ()=>{
            // Mock: primer intento falla, segundo intento exitoso
            mockSupabaseAdmin.from().select().or().single.mockRejectedValueOnce(new Error('Conexión temporal perdida')).mockResolvedValueOnce({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            mockSupabaseAdmin.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            mockSupabaseAdmin.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'user_456'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData, {
                retryAttempts: 2,
                retryDelay: 100
            });
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
        });
        it('debe fallar después de agotar reintentos', async ()=>{
            // Mock: todos los intentos fallan
            mockSupabaseAdmin.from().select().or().single.mockRejectedValue(new Error('Error persistente'));
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData, {
                retryAttempts: 2,
                retryDelay: 100
            });
            expect(result.success).toBe(false);
            expect(result.action).toBe('error');
            expect(result.error).toContain('Error después de 2 intentos');
        });
    });
    describe('deleteUserFromSupabase', ()=>{
        it('debe eliminar usuario exitosamente (soft delete)', async ()=>{
            const existingUser = {
                id: 'user_456',
                email: 'test@example.com',
                is_active: true
            };
            // Mock: actualización exitosa (soft delete)
            mockSupabaseAdmin.from().update().eq().select().single.mockResolvedValue({
                data: {
                    ...existingUser,
                    is_active: false
                },
                error: null
            });
            const result = await (0, _usersyncservice.deleteUserFromSupabase)('user_123');
            expect(result.success).toBe(true);
            expect(result.action).toBe('deleted');
        });
        it('debe manejar usuario no encontrado', async ()=>{
            // Mock: usuario no encontrado
            mockSupabaseAdmin.from().update().eq().select().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            const result = await (0, _usersyncservice.deleteUserFromSupabase)('user_not_found');
            expect(result.success).toBe(true);
            expect(result.action).toBe('deleted');
            expect(result.details?.message).toContain('Usuario no encontrado');
        });
    });
    describe('syncUserFromClerk', ()=>{
        it('debe sincronizar usuario desde Clerk exitosamente', async ()=>{
            const mockClerkUser = {
                id: 'user_123',
                emailAddresses: [
                    {
                        emailAddress: 'test@example.com',
                        id: 'email_123',
                        verification: {
                            status: 'verified',
                            strategy: 'email_code'
                        }
                    }
                ],
                firstName: 'John',
                lastName: 'Doe',
                createdAt: Date.now(),
                updatedAt: Date.now(),
                imageUrl: 'https://example.com/avatar.jpg',
                phoneNumbers: [],
                publicMetadata: {
                    role: 'customer'
                },
                privateMetadata: {}
            };
            mockClerkClient.mockReturnValue({
                users: {
                    getUser: jest.fn().mockResolvedValue(mockClerkUser)
                }
            });
            // Mock: usuario no existe, crear nuevo
            mockSupabaseAdmin.from().select().or().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            mockSupabaseAdmin.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            mockSupabaseAdmin.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'user_456'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserFromClerk)('user_123');
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
        });
        it('debe manejar usuario no encontrado en Clerk', async ()=>{
            mockClerkClient.mockReturnValue({
                users: {
                    getUser: jest.fn().mockResolvedValue(null)
                }
            });
            const result = await (0, _usersyncservice.syncUserFromClerk)('user_not_found');
            expect(result.success).toBe(false);
            expect(result.error).toContain('Usuario no encontrado en Clerk');
        });
    });
    describe('bulkSyncUsersFromClerk', ()=>{
        it('debe sincronizar múltiples usuarios exitosamente', async ()=>{
            const mockClerkUsers = [
                {
                    id: 'user_1',
                    emailAddresses: [
                        {
                            emailAddress: 'user1@example.com',
                            id: 'email_1',
                            verification: {
                                status: 'verified'
                            }
                        }
                    ],
                    firstName: 'User',
                    lastName: 'One',
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    imageUrl: '',
                    phoneNumbers: [],
                    publicMetadata: {},
                    privateMetadata: {}
                },
                {
                    id: 'user_2',
                    emailAddresses: [
                        {
                            emailAddress: 'user2@example.com',
                            id: 'email_2',
                            verification: {
                                status: 'verified'
                            }
                        }
                    ],
                    firstName: 'User',
                    lastName: 'Two',
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    imageUrl: '',
                    phoneNumbers: [],
                    publicMetadata: {},
                    privateMetadata: {}
                }
            ];
            mockClerkClient.mockReturnValue({
                users: {
                    getUserList: jest.fn().mockResolvedValue(mockClerkUsers)
                }
            });
            // Mock: usuarios no existen, crear nuevos
            mockSupabaseAdmin.from().select().or().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            mockSupabaseAdmin.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            mockSupabaseAdmin.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'new_user'
                },
                error: null
            });
            const result = await (0, _usersyncservice.bulkSyncUsersFromClerk)({
                batchSize: 2,
                maxUsers: 2
            });
            expect(result.success).toBe(true);
            expect(result.totalProcessed).toBe(2);
            expect(result.successful).toBe(2);
            expect(result.failed).toBe(0);
        });
        it('debe manejar errores en sincronización masiva', async ()=>{
            mockClerkClient.mockReturnValue({
                users: {
                    getUserList: jest.fn().mockRejectedValue(new Error('Error de Clerk'))
                }
            });
            const result = await (0, _usersyncservice.bulkSyncUsersFromClerk)();
            expect(result.success).toBe(false);
            expect(result.failed).toBe(1);
            expect(result.results[0].error).toContain('Error en sincronización masiva');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFx1c2VyLXN5bmMtc2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgcGFyYSBlbCBzZXJ2aWNpbyBkZSBzaW5jcm9uaXphY2nDs24gYXV0b23DoXRpY2EgZGUgdXN1YXJpb3NcbiAqIFZlcmlmaWNhIGxhIHNpbmNyb25pemFjacOzbiByb2J1c3RhIGVudHJlIENsZXJrIHkgU3VwYWJhc2VcbiAqL1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcblxuLy8gTW9jayBkZSBDbGVya1xuamVzdC5tb2NrKCdAY2xlcmsvbmV4dGpzL3NlcnZlcicsICgpID0+ICh7XG4gIGNsZXJrQ2xpZW50OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgdXNlcnM6IHtcbiAgICAgIGdldFVzZXI6IGplc3QuZm4oKSxcbiAgICAgIGdldFVzZXJMaXN0OiBqZXN0LmZuKClcbiAgICB9XG4gIH0pKVxufSkpO1xuXG4vLyBNb2NrIGRlIFN1cGFiYXNlXG5jb25zdCBtb2NrU3VwYWJhc2VBZG1pbiA9IHtcbiAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCksXG4gICAgICAgIG9yOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKClcbiAgICAgICAgfSkpXG4gICAgICB9KSksXG4gICAgICBvcjogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBzaW5nbGU6IGplc3QuZm4oKVxuICAgICAgfSkpXG4gICAgfSkpLFxuICAgIGluc2VydDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIHNpbmdsZTogamVzdC5mbigpXG4gICAgICB9KSlcbiAgICB9KSksXG4gICAgdXBkYXRlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICBlcTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKVxuICAgICAgICB9KSlcbiAgICAgIH0pKVxuICAgIH0pKVxuICB9KSlcbn07XG5cbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBzdXBhYmFzZUFkbWluOiBtb2NrU3VwYWJhc2VBZG1pblxufSkpO1xuXG4vLyBNb2NrIGRlIHNlY3VyaXR5IGF1ZGl0XG5qZXN0Lm1vY2soJ0AvbGliL2F1dGgvc2VjdXJpdHktYXVkaXQnLCAoKSA9PiAoe1xuICBsb2dTZWN1cml0eUV2ZW50OiBqZXN0LmZuKCksXG4gIGxvZ0FkbWluQWN0aW9uOiBqZXN0LmZuKClcbn0pKTtcblxuaW1wb3J0IHtcbiAgc3luY1VzZXJUb1N1cGFiYXNlLFxuICBzeW5jVXNlckZyb21DbGVyayxcbiAgZGVsZXRlVXNlckZyb21TdXBhYmFzZSxcbiAgYnVsa1N5bmNVc2Vyc0Zyb21DbGVyayxcbiAgdHlwZSBDbGVya1VzZXJEYXRhLFxuICB0eXBlIFN5bmNPcHRpb25zXG59IGZyb20gJ0AvbGliL2F1dGgvdXNlci1zeW5jLXNlcnZpY2UnO1xuaW1wb3J0IHsgY2xlcmtDbGllbnQgfSBmcm9tICdAY2xlcmsvbmV4dGpzL3NlcnZlcic7XG5cbmRlc2NyaWJlKCdTZXJ2aWNpbyBkZSBTaW5jcm9uaXphY2nDs24gZGUgVXN1YXJpb3MnLCAoKSA9PiB7XG4gIGxldCBtb2NrQ2xlcmtDbGllbnQ6IGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGNsZXJrQ2xpZW50PjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrQ2xlcmtDbGllbnQgPSBjbGVya0NsaWVudCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBjbGVya0NsaWVudD47XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGNvbnN0IG1vY2tDbGVya1VzZXJEYXRhOiBDbGVya1VzZXJEYXRhID0ge1xuICAgIGlkOiAndXNlcl8xMjMnLFxuICAgIGVtYWlsX2FkZHJlc3NlczogW3tcbiAgICAgIGVtYWlsX2FkZHJlc3M6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgIGlkOiAnZW1haWxfMTIzJyxcbiAgICAgIHZlcmlmaWNhdGlvbjoge1xuICAgICAgICBzdGF0dXM6ICd2ZXJpZmllZCcsXG4gICAgICAgIHN0cmF0ZWd5OiAnZW1haWxfY29kZSdcbiAgICAgIH1cbiAgICB9XSxcbiAgICBmaXJzdF9uYW1lOiAnSm9obicsXG4gICAgbGFzdF9uYW1lOiAnRG9lJyxcbiAgICBjcmVhdGVkX2F0OiBEYXRlLm5vdygpLFxuICAgIHVwZGF0ZWRfYXQ6IERhdGUubm93KCksXG4gICAgaW1hZ2VfdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9hdmF0YXIuanBnJyxcbiAgICBwdWJsaWNfbWV0YWRhdGE6IHsgcm9sZTogJ2N1c3RvbWVyJyB9XG4gIH07XG5cbiAgZGVzY3JpYmUoJ3N5bmNVc2VyVG9TdXBhYmFzZScsICgpID0+IHtcbiAgICBpdCgnZGViZSBjcmVhciB1biBudWV2byB1c3VhcmlvIGV4aXRvc2FtZW50ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2s6IHVzdWFyaW8gbm8gZXhpc3RlXG4gICAgICBtb2NrU3VwYWJhc2VBZG1pbi5mcm9tKCkuc2VsZWN0KCkub3IoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrOiByb2wgcG9yIGRlZmVjdG8gZXhpc3RlXG4gICAgICBtb2NrU3VwYWJhc2VBZG1pbi5mcm9tKCkuc2VsZWN0KCkuZXEoKS5lcSgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6IDEgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrOiBpbnNlcmNpw7NuIGV4aXRvc2FcbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5pbnNlcnQoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAndXNlcl80NTYnLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJUb1N1cGFiYXNlKG1vY2tDbGVya1VzZXJEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hY3Rpb24pLnRvQmUoJ2NyZWF0ZWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCd1c2VyXzQ1NicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgYWN0dWFsaXphciB1biB1c3VhcmlvIGV4aXN0ZW50ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IHtcbiAgICAgICAgaWQ6ICd1c2VyXzQ1NicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIGZpcnN0X25hbWU6ICdKYW5lJ1xuICAgICAgfTtcblxuICAgICAgLy8gTW9jazogdXN1YXJpbyBleGlzdGVcbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5zZWxlY3QoKS5vcigpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IGV4aXN0aW5nVXNlcixcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrOiBhY3R1YWxpemFjacOzbiBleGl0b3NhXG4gICAgICBtb2NrU3VwYWJhc2VBZG1pbi5mcm9tKCkudXBkYXRlKCkuZXEoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IC4uLmV4aXN0aW5nVXNlciwgZmlyc3RfbmFtZTogJ0pvaG4nIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJUb1N1cGFiYXNlKG1vY2tDbGVya1VzZXJEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hY3Rpb24pLnRvQmUoJ3VwZGF0ZWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGV0YWlscz8ubmV3RGF0YS5maXJzdF9uYW1lKS50b0JlKCdKb2huJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIGVycm9yZXMgZGUgdmFsaWRhY2nDs24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVXNlckRhdGEgPSB7XG4gICAgICAgIC4uLm1vY2tDbGVya1VzZXJEYXRhLFxuICAgICAgICBlbWFpbF9hZGRyZXNzZXM6IFtdXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzeW5jVXNlclRvU3VwYWJhc2UoaW52YWxpZFVzZXJEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdlcnJvcicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdBbCBtZW5vcyB1biBlbWFpbCBlcyByZXF1ZXJpZG8nKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIHJlaW50ZW50YXIgZW4gY2FzbyBkZSBlcnJvciB0ZW1wb3JhbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2s6IHByaW1lciBpbnRlbnRvIGZhbGxhLCBzZWd1bmRvIGludGVudG8gZXhpdG9zb1xuICAgICAgbW9ja1N1cGFiYXNlQWRtaW4uZnJvbSgpLnNlbGVjdCgpLm9yKCkuc2luZ2xlXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdDb25leGnDs24gdGVtcG9yYWwgcGVyZGlkYScpKVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfVxuICAgICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQWRtaW4uZnJvbSgpLnNlbGVjdCgpLmVxKCkuZXEoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAxIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQWRtaW4uZnJvbSgpLmluc2VydCgpLnNlbGVjdCgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6ICd1c2VyXzQ1NicgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzeW5jVXNlclRvU3VwYWJhc2UobW9ja0NsZXJrVXNlckRhdGEsIHtcbiAgICAgICAgcmV0cnlBdHRlbXB0czogMixcbiAgICAgICAgcmV0cnlEZWxheTogMTAwXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hY3Rpb24pLnRvQmUoJ2NyZWF0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGZhbGxhciBkZXNwdcOpcyBkZSBhZ290YXIgcmVpbnRlbnRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2s6IHRvZG9zIGxvcyBpbnRlbnRvcyBmYWxsYW5cbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5zZWxlY3QoKS5vcigpLnNpbmdsZVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdFcnJvciBwZXJzaXN0ZW50ZScpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJUb1N1cGFiYXNlKG1vY2tDbGVya1VzZXJEYXRhLCB7XG4gICAgICAgIHJldHJ5QXR0ZW1wdHM6IDIsXG4gICAgICAgIHJldHJ5RGVsYXk6IDEwMFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFjdGlvbikudG9CZSgnZXJyb3InKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbignRXJyb3IgZGVzcHXDqXMgZGUgMiBpbnRlbnRvcycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGVsZXRlVXNlckZyb21TdXBhYmFzZScsICgpID0+IHtcbiAgICBpdCgnZGViZSBlbGltaW5hciB1c3VhcmlvIGV4aXRvc2FtZW50ZSAoc29mdCBkZWxldGUpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXJfNDU2JyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrOiBhY3R1YWxpemFjacOzbiBleGl0b3NhIChzb2Z0IGRlbGV0ZSlcbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS51cGRhdGUoKS5lcSgpLnNlbGVjdCgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgLi4uZXhpc3RpbmdVc2VyLCBpc19hY3RpdmU6IGZhbHNlIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVsZXRlVXNlckZyb21TdXBhYmFzZSgndXNlcl8xMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hY3Rpb24pLnRvQmUoJ2RlbGV0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIG1hbmVqYXIgdXN1YXJpbyBubyBlbmNvbnRyYWRvJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jazogdXN1YXJpbyBubyBlbmNvbnRyYWRvXG4gICAgICBtb2NrU3VwYWJhc2VBZG1pbi5mcm9tKCkudXBkYXRlKCkuZXEoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWxldGVVc2VyRnJvbVN1cGFiYXNlKCd1c2VyX25vdF9mb3VuZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFjdGlvbikudG9CZSgnZGVsZXRlZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kZXRhaWxzPy5tZXNzYWdlKS50b0NvbnRhaW4oJ1VzdWFyaW8gbm8gZW5jb250cmFkbycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnc3luY1VzZXJGcm9tQ2xlcmsnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgc2luY3Jvbml6YXIgdXN1YXJpbyBkZXNkZSBDbGVyayBleGl0b3NhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ2xlcmtVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgZW1haWxBZGRyZXNzZXM6IFt7XG4gICAgICAgICAgZW1haWxBZGRyZXNzOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgaWQ6ICdlbWFpbF8xMjMnLFxuICAgICAgICAgIHZlcmlmaWNhdGlvbjogeyBzdGF0dXM6ICd2ZXJpZmllZCcsIHN0cmF0ZWd5OiAnZW1haWxfY29kZScgfVxuICAgICAgICB9XSxcbiAgICAgICAgZmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgIGxhc3ROYW1lOiAnRG9lJyxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIGltYWdlVXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9hdmF0YXIuanBnJyxcbiAgICAgICAgcGhvbmVOdW1iZXJzOiBbXSxcbiAgICAgICAgcHVibGljTWV0YWRhdGE6IHsgcm9sZTogJ2N1c3RvbWVyJyB9LFxuICAgICAgICBwcml2YXRlTWV0YWRhdGE6IHt9XG4gICAgICB9O1xuXG4gICAgICBtb2NrQ2xlcmtDbGllbnQubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdXNlcnM6IHtcbiAgICAgICAgICBnZXRVc2VyOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NsZXJrVXNlcilcbiAgICAgICAgfVxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAvLyBNb2NrOiB1c3VhcmlvIG5vIGV4aXN0ZSwgY3JlYXIgbnVldm9cbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5zZWxlY3QoKS5vcigpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5zZWxlY3QoKS5lcSgpLmVxKCkuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBpZDogMSB9LFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5pbnNlcnQoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAndXNlcl80NTYnIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJGcm9tQ2xlcmsoJ3VzZXJfMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdjcmVhdGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIHVzdWFyaW8gbm8gZW5jb250cmFkbyBlbiBDbGVyaycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDbGVya0NsaWVudC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2Vyczoge1xuICAgICAgICAgIGdldFVzZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN5bmNVc2VyRnJvbUNsZXJrKCd1c2VyX25vdF9mb3VuZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdVc3VhcmlvIG5vIGVuY29udHJhZG8gZW4gQ2xlcmsnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2J1bGtTeW5jVXNlcnNGcm9tQ2xlcmsnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgc2luY3Jvbml6YXIgbcO6bHRpcGxlcyB1c3VhcmlvcyBleGl0b3NhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ2xlcmtVc2VycyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndXNlcl8xJyxcbiAgICAgICAgICBlbWFpbEFkZHJlc3NlczogW3sgZW1haWxBZGRyZXNzOiAndXNlcjFAZXhhbXBsZS5jb20nLCBpZDogJ2VtYWlsXzEnLCB2ZXJpZmljYXRpb246IHsgc3RhdHVzOiAndmVyaWZpZWQnIH0gfV0sXG4gICAgICAgICAgZmlyc3ROYW1lOiAnVXNlcicsXG4gICAgICAgICAgbGFzdE5hbWU6ICdPbmUnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgaW1hZ2VVcmw6ICcnLFxuICAgICAgICAgIHBob25lTnVtYmVyczogW10sXG4gICAgICAgICAgcHVibGljTWV0YWRhdGE6IHt9LFxuICAgICAgICAgIHByaXZhdGVNZXRhZGF0YToge31cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndXNlcl8yJyxcbiAgICAgICAgICBlbWFpbEFkZHJlc3NlczogW3sgZW1haWxBZGRyZXNzOiAndXNlcjJAZXhhbXBsZS5jb20nLCBpZDogJ2VtYWlsXzInLCB2ZXJpZmljYXRpb246IHsgc3RhdHVzOiAndmVyaWZpZWQnIH0gfV0sXG4gICAgICAgICAgZmlyc3ROYW1lOiAnVXNlcicsXG4gICAgICAgICAgbGFzdE5hbWU6ICdUd28nLFxuICAgICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgaW1hZ2VVcmw6ICcnLFxuICAgICAgICAgIHBob25lTnVtYmVyczogW10sXG4gICAgICAgICAgcHVibGljTWV0YWRhdGE6IHt9LFxuICAgICAgICAgIHByaXZhdGVNZXRhZGF0YToge31cbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgbW9ja0NsZXJrQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHVzZXJzOiB7XG4gICAgICAgICAgZ2V0VXNlckxpc3Q6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ2xlcmtVc2VycylcbiAgICAgICAgfVxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAvLyBNb2NrOiB1c3VhcmlvcyBubyBleGlzdGVuLCBjcmVhciBudWV2b3NcbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5zZWxlY3QoKS5vcigpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5zZWxlY3QoKS5lcSgpLmVxKCkuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBpZDogMSB9LFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUFkbWluLmZyb20oKS5pbnNlcnQoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAnbmV3X3VzZXInIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYnVsa1N5bmNVc2Vyc0Zyb21DbGVyayh7XG4gICAgICAgIGJhdGNoU2l6ZTogMixcbiAgICAgICAgbWF4VXNlcnM6IDJcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnRvdGFsUHJvY2Vzc2VkKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzZnVsKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWQpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIGVycm9yZXMgZW4gc2luY3Jvbml6YWNpw7NuIG1hc2l2YScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDbGVya0NsaWVudC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2Vyczoge1xuICAgICAgICAgIGdldFVzZXJMaXN0OiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdFcnJvciBkZSBDbGVyaycpKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJ1bGtTeW5jVXNlcnNGcm9tQ2xlcmsoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZmFpbGVkKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yZXN1bHRzWzBdLmVycm9yKS50b0NvbnRhaW4oJ0Vycm9yIGVuIHNpbmNyb25pemFjacOzbiBtYXNpdmEnKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNsZXJrQ2xpZW50IiwiZm4iLCJ1c2VycyIsImdldFVzZXIiLCJnZXRVc2VyTGlzdCIsInN1cGFiYXNlQWRtaW4iLCJtb2NrU3VwYWJhc2VBZG1pbiIsImxvZ1NlY3VyaXR5RXZlbnQiLCJsb2dBZG1pbkFjdGlvbiIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsIm9yIiwiaW5zZXJ0IiwidXBkYXRlIiwiZGVzY3JpYmUiLCJtb2NrQ2xlcmtDbGllbnQiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tDbGVya1VzZXJEYXRhIiwiaWQiLCJlbWFpbF9hZGRyZXNzZXMiLCJlbWFpbF9hZGRyZXNzIiwidmVyaWZpY2F0aW9uIiwic3RhdHVzIiwic3RyYXRlZ3kiLCJmaXJzdF9uYW1lIiwibGFzdF9uYW1lIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJub3ciLCJ1cGRhdGVkX2F0IiwiaW1hZ2VfdXJsIiwicHVibGljX21ldGFkYXRhIiwicm9sZSIsIml0IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkYXRhIiwiZXJyb3IiLCJjb2RlIiwiZW1haWwiLCJyZXN1bHQiLCJzeW5jVXNlclRvU3VwYWJhc2UiLCJleHBlY3QiLCJzdWNjZXNzIiwidG9CZSIsImFjdGlvbiIsInVzZXJJZCIsImV4aXN0aW5nVXNlciIsImRldGFpbHMiLCJuZXdEYXRhIiwiaW52YWxpZFVzZXJEYXRhIiwidG9Db250YWluIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwiRXJyb3IiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJyZXRyeUF0dGVtcHRzIiwicmV0cnlEZWxheSIsIm1vY2tSZWplY3RlZFZhbHVlIiwiaXNfYWN0aXZlIiwiZGVsZXRlVXNlckZyb21TdXBhYmFzZSIsIm1lc3NhZ2UiLCJtb2NrQ2xlcmtVc2VyIiwiZW1haWxBZGRyZXNzZXMiLCJlbWFpbEFkZHJlc3MiLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImltYWdlVXJsIiwicGhvbmVOdW1iZXJzIiwicHVibGljTWV0YWRhdGEiLCJwcml2YXRlTWV0YWRhdGEiLCJtb2NrUmV0dXJuVmFsdWUiLCJzeW5jVXNlckZyb21DbGVyayIsIm1vY2tDbGVya1VzZXJzIiwiYnVsa1N5bmNVc2Vyc0Zyb21DbGVyayIsImJhdGNoU2l6ZSIsIm1heFVzZXJzIiwidG90YWxQcm9jZXNzZWQiLCJzdWNjZXNzZnVsIiwiZmFpbGVkIiwicmVzdWx0cyJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBSUQsZ0JBQWdCO0FBQ2hCQSxLQUFLQyxJQUFJLENBQUMsd0JBQXdCLElBQU8sQ0FBQTtRQUN2Q0MsYUFBYUYsS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTtnQkFDMUJDLE9BQU87b0JBQ0xDLFNBQVNMLEtBQUtHLEVBQUU7b0JBQ2hCRyxhQUFhTixLQUFLRyxFQUFFO2dCQUN0QjtZQUNGLENBQUE7SUFDRixDQUFBO0FBK0JBSCxLQUFLQyxJQUFJLENBQUMsa0JBQWtCLElBQU8sQ0FBQTtRQUNqQ00sZUFBZUM7SUFD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