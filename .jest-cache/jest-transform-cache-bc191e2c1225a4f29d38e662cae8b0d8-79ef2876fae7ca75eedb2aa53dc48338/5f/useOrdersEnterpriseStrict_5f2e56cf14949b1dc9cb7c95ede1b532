f5d1c5ada4a4d15a20ec3af37cfa9628
// ===================================
// PINTEYA E-COMMERCE - STRICT ORDERS HOOK (REFACTORED)
// Hook orquestador para gestión de órdenes con validación estricta
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get useOrderDetailStrict () {
        return useOrderDetailStrict;
    },
    get useOrdersEnterpriseStrict () {
        return useOrdersEnterpriseStrict;
    }
});
const _react = require("react");
const _usetoast = require("../use-toast");
const _apistrict = require("../../types/api-strict");
const _apimonitoring = require("../../utils/api-monitoring");
const _useOrdersCache = require("./useOrdersCache");
const _useOrdersApi = require("./useOrdersApi");
const _useOrdersState = require("./useOrdersState");
const _useOrdersDevPersistence = require("./useOrdersDevPersistence");
// Función de debounce para evitar peticiones múltiples
function debounce(func, wait) {
    let timeout;
    return (...args)=>{
        clearTimeout(timeout);
        timeout = setTimeout(()=>func(...args), wait);
    };
}
const DEFAULT_OPTIONS = {
    autoFetch: true,
    refetchInterval: 0,
    maxRetries: 3,
    timeout: 10000,
    enableCache: true,
    cacheTimeout: 5 * 60 * 1000 // 5 minutes
};
function useOrdersEnterpriseStrict(initialFilters = {}, options = {}) {
    const { toast } = (0, _usetoast.useToast)();
    const apiMonitoring = (0, _apimonitoring.useApiMonitoring)();
    const opts = (0, _react.useMemo)(()=>({
            ...DEFAULT_OPTIONS,
            ...options
        }), [
        options
    ]);
    // Memoizar las funciones de monitoreo para evitar recreaciones
    const recordDiscrepancy = (0, _react.useCallback)(apiMonitoring.recordDiscrepancy, []);
    const recordRenderingIssue = (0, _react.useCallback)(apiMonitoring.recordRenderingIssue, []);
    // ===================================
    // HOOKS ESPECIALIZADOS
    // ===================================
    // Hook de cache
    const cache = (0, _useOrdersCache.useOrdersCache)({
        enableCache: opts.enableCache,
        cacheTimeout: opts.cacheTimeout,
        maxSize: 50,
        cleanupInterval: 10 * 60 * 1000,
        minRequestInterval: 1000
    });
    // Hook de persistencia para desarrollo (Fast Refresh)
    const devPersistence = (0, _useOrdersDevPersistence.useOrdersDevState)('orders-enterprise-dev');
    // Hook de estado
    const state = (0, _useOrdersState.useOrdersState)(initialFilters);
    // Hook de API
    const api = (0, _useOrdersApi.useOrdersApi)({
        timeout: opts.timeout,
        maxRetries: opts.maxRetries,
        enableCache: opts.enableCache,
        cache
    });
    // Referencias para control de requests (simplificadas)
    const retryCountRef = (0, _react.useRef)(0);
    const refetchIntervalRef = (0, _react.useRef)(null);
    const debounceTimeoutRef = (0, _react.useRef)(null);
    // ===================================
    // FUNCIONES DE FETCH SIMPLIFICADAS
    // ===================================
    // Usar el hook de API directamente
    const fetchOrdersInternal = api.fetchOrdersInternal;
    // ===================================
    // FUNCIONES DE FETCH PÚBLICAS
    // ===================================
    // Lógica de fetch movida a useOrdersApi.ts
    // ===================================
    // FUNCIÓN DE FETCH PÚBLICA CON RETRY
    // ===================================
    // Función interna sin debounce para uso directo
    const fetchOrdersImmediate = (0, _react.useCallback)(async (newFilters = {})=>{
        console.log('[useOrdersEnterpriseStrict] fetchOrdersImmediate called with filters:', newFilters);
        console.log('[useOrdersEnterpriseStrict] Current state filters:', state.filters);
        // Generar clave única para esta petición
        const requestKey = JSON.stringify({
            ...state.filters,
            ...newFilters
        });
        console.log('[useOrdersEnterpriseStrict] Request key:', requestKey);
        // Evitar peticiones duplicadas
        if (state.hasFiltersChanged({
            ...state.filters,
            ...newFilters
        }) && state.isLoading) {
            console.log('[useOrdersEnterpriseStrict] Skipping duplicate request');
            return;
        }
        // Actualizar filtros y estado de carga
        console.log('[useOrdersEnterpriseStrict] Updating filters and setting loading to true');
        state.updateFilters(newFilters);
        state.setLoading(true);
        retryCountRef.current = 0;
        const attemptFetch = async (attempt)=>{
            const currentFilters = state.getLastFilters();
            console.log('[useOrdersEnterpriseStrict] attemptFetch - attempt:', attempt, 'filters:', currentFilters);
            const result = await fetchOrdersInternal(currentFilters, attempt > 0);
            console.log('[useOrdersEnterpriseStrict] API result:', result);
            if ((0, _apistrict.isStrictApiResponse)(result)) {
                console.log('[useOrdersEnterpriseStrict] Valid API response received:', result.data);
                // Monitoreo automático de discrepancias
                const expectedCount = result.data.pagination.total;
                const actualCount = result.data.orders.length;
                const endpoint = `/api/admin/orders?${new URLSearchParams({
                    page: currentFilters.page?.toString() || '1',
                    limit: currentFilters.limit?.toString() || '20',
                    ...currentFilters.status && {
                        status: currentFilters.status
                    },
                    ...currentFilters.payment_status && {
                        payment_status: currentFilters.payment_status
                    },
                    ...currentFilters.fulfillment_status && {
                        fulfillment_status: currentFilters.fulfillment_status
                    },
                    ...currentFilters.sort_by && {
                        sort_by: currentFilters.sort_by
                    },
                    ...currentFilters.sort_order && {
                        sort_order: currentFilters.sort_order
                    }
                }).toString()}`;
                // Solo registrar discrepancia si hay una diferencia real (no por paginación)
                const expectedPageCount = Math.min(currentFilters.limit || 20, expectedCount - ((currentFilters.page || 1) - 1) * (currentFilters.limit || 20));
                if (actualCount < expectedPageCount && expectedPageCount > 0) {
                    recordDiscrepancy(endpoint, expectedPageCount, actualCount);
                }
                // Actualizar estado usando el hook especializado
                state.setOrders(result.data.orders);
                state.setPagination(result.data.pagination);
                state.setAnalytics(result.data.analytics || null);
                retryCountRef.current = 0;
                // ✅ PERSISTIR ESTADO PARA DESARROLLO (Fast Refresh)
                if (process.env.NODE_ENV === 'development') {
                    devPersistence.persistState({
                        orders: result.data.orders,
                        pagination: result.data.pagination,
                        analytics: result.data.analytics || null,
                        filters: currentFilters,
                        hasData: true,
                        lastFetchTime: Date.now()
                    });
                }
            } else {
                // Es un error
                if (attempt < opts.maxRetries && result.code !== 'REQUEST_CANCELLED') {
                    retryCountRef.current = attempt + 1;
                    // Esperar antes del retry (exponential backoff)
                    const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
                    await new Promise((resolve)=>setTimeout(resolve, delay));
                    return attemptFetch(attempt + 1);
                }
                // Máximo de reintentos alcanzado o error no recuperable
                state.setError(result.error);
                // Registrar problema de renderizado por error de API
                recordRenderingIssue('useOrdersEnterpriseStrict', 0, 0, currentFilters, result.error);
                // Mostrar toast de error
                if (result.code !== 'REQUEST_CANCELLED') {
                    toast({
                        title: 'Error al cargar órdenes',
                        description: result.error,
                        variant: 'destructive'
                    });
                }
            }
        };
        await attemptFetch(0);
    }, [
        fetchOrdersInternal,
        opts.maxRetries,
        toast,
        recordDiscrepancy,
        recordRenderingIssue,
        state
    ]);
    // Función fetchOrders con debouncing para evitar peticiones múltiples
    const fetchOrders = (0, _react.useCallback)((newFilters = {})=>{
        return new Promise((resolve)=>{
            // Limpiar timeout anterior si existe
            if (debounceTimeoutRef.current) {
                clearTimeout(debounceTimeoutRef.current);
            }
            // Configurar nuevo timeout con debounce
            const debounceMs = process.env.NODE_ENV === 'development' ? 300 : 150;
            debounceTimeoutRef.current = setTimeout(async ()=>{
                try {
                    await fetchOrdersImmediate(newFilters);
                    resolve();
                } catch (error) {
                    console.error('Error in debounced fetchOrders:', error);
                    resolve(); // Resolver incluso en caso de error para evitar promesas colgadas
                }
            }, debounceMs);
        });
    }, [
        fetchOrdersImmediate
    ]);
    // ===================================
    // OTRAS ACCIONES
    // ===================================
    const refreshOrders = (0, _react.useCallback)(async ()=>{
        // Limpiar cache para forzar refresh
        if (opts.enableCache) {
            cache.clearCache();
        }
        await fetchOrders();
    }, [
        fetchOrders,
        opts.enableCache,
        cache
    ]);
    // Usar las funciones del hook de estado directamente
    const updateFilters = state.updateFilters;
    const clearError = state.clearError;
    const retryLastRequest = (0, _react.useCallback)(async ()=>{
        const lastFilters = state.getLastFilters();
        if (lastFilters) {
            await fetchOrders(lastFilters);
        }
    }, [
        fetchOrders,
        state
    ]);
    // ===================================
    // EFECTOS
    // ===================================
    // ===================================
    // RESTAURACIÓN DE ESTADO PERSISTIDO (DESARROLLO)
    // ===================================
    const hasRestoredRef = (0, _react.useRef)(false);
    (0, _react.useEffect)(()=>{
        if (!hasRestoredRef.current && process.env.NODE_ENV === 'development') {
            hasRestoredRef.current = true;
            // Intentar restaurar estado persistido
            if (devPersistence.hasValidPersistedData()) {
                const persistedState = devPersistence.getPersistedState();
                if (persistedState) {
                    console.log('[useOrdersEnterpriseStrict] Restoring persisted state:', {
                        ordersCount: persistedState.orders.length,
                        hasData: persistedState.hasData
                    });
                    // Restaurar estado
                    state.setOrders(persistedState.orders);
                    state.setPagination(persistedState.pagination);
                    state.setAnalytics(persistedState.analytics);
                    state.updateFilters(persistedState.filters);
                    return; // No hacer auto-fetch si tenemos datos persistidos
                }
            }
        }
        // Auto-fetch inicial solo si no hay datos persistidos
        if (opts.autoFetch && !hasRestoredRef.current) {
            fetchOrders();
        }
    }, [
        opts.autoFetch
    ]); // Solo ejecutar una vez al montar
    // Escuchar cambios en filtros con debouncing optimizado
    const filtersRef = (0, _react.useRef)(state.filters);
    const isInitialMount = (0, _react.useRef)(true);
    (0, _react.useEffect)(()=>{
        // Evitar fetch en el primer render (ya se hace en auto-fetch)
        if (isInitialMount.current) {
            isInitialMount.current = false;
            filtersRef.current = state.filters;
            return;
        }
        // Solo hacer fetch si los filtros han cambiado realmente
        const hasChanged = JSON.stringify(filtersRef.current) !== JSON.stringify(state.filters);
        if (hasChanged) {
            filtersRef.current = state.filters;
            fetchOrders();
        }
    }, [
        state.filters,
        fetchOrders
    ]); // Dependencias mínimas y estables
    // Refetch interval - TEMPORALMENTE DESHABILITADO para evitar refresco infinito
    (0, _react.useEffect)(()=>{
    // NOTA: Refetch interval deshabilitado temporalmente para solucionar refresco infinito
    // TODO: Reimplementar con useRef para fetchOrders o usar React Query
    /*
    if (opts.refetchInterval > 0) {
      refetchIntervalRef.current = setInterval(() => {
        if (!state.isLoading) {
          fetchOrders();
        }
      }, opts.refetchInterval);

      return () => {
        if (refetchIntervalRef.current) {
          clearInterval(refetchIntervalRef.current);
        }
      };
    }
    */ }, [
        opts.refetchInterval
    ]);
    // Limpieza automática de cache movida a useOrdersCache.ts
    // Cleanup al desmontar - OPTIMIZADO: Sin dependencias inestables
    (0, _react.useEffect)(()=>{
        return ()=>{
            // Cancelar peticiones en progreso usando el hook de API
            api.abortCurrentRequest();
            // Limpiar intervalos y timeouts
            if (refetchIntervalRef.current) {
                clearInterval(refetchIntervalRef.current);
            }
            if (debounceTimeoutRef.current) {
                clearTimeout(debounceTimeoutRef.current);
            }
            if (process.env.NODE_ENV === 'development') {
                console.log('[useOrdersEnterpriseStrict] Hook cleanup completed');
            }
        };
    }, []); // ✅ CORREGIDO: Sin dependencias para evitar remontajes por Fast Refresh
    // ===================================
    // RETORNO DEL HOOK
    // ===================================
    return {
        // Estado
        orders: state.orders,
        pagination: state.pagination,
        filters: state.filters,
        analytics: state.analytics,
        isLoading: state.isLoading,
        error: state.error,
        lastFetch: state.lastFetch,
        // Acciones
        fetchOrders,
        refreshOrders,
        updateFilters,
        clearError,
        retryLastRequest
    };
}
function useOrderDetailStrict(orderId) {
    const { toast } = (0, _usetoast.useToast)();
    const [order, setOrder] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const fetchOrder = (0, _react.useCallback)(async ()=>{
        if (!orderId) return;
        setIsLoading(true);
        setError(null);
        try {
            const response = await fetch(`/api/admin/orders/${orderId}`, {
                credentials: 'include' // ✅ AGREGADO: Incluir cookies de sesión NextAuth.js
            });
            const data = await response.json();
            const validatedResponse = toStrictOrdersResponse(data);
            if ((0, _apistrict.isStrictApiError)(validatedResponse)) {
                setError(validatedResponse.error);
                toast({
                    title: 'Error al cargar orden',
                    description: validatedResponse.error,
                    variant: 'destructive'
                });
            } else {
                // Para orden individual, extraer la primera orden
                const orderData = validatedResponse.data.orders[0] || null;
                setOrder(orderData);
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Error desconocido';
            setError(errorMessage);
            toast({
                title: 'Error al cargar orden',
                description: errorMessage,
                variant: 'destructive'
            });
        } finally{
            setIsLoading(false);
        }
    }, [
        orderId,
        toast
    ]);
    (0, _react.useEffect)(()=>{
        fetchOrder();
    }, [
        fetchOrder
    ]);
    return {
        order,
        isLoading,
        error,
        refetch: fetchOrder
    };
} // ===================================
 // UTILIDADES EXPORTADAS
 // ===================================
 /**
 * Utilidades de cache movidas a useOrdersCache.ts
 * Estas funciones están disponibles a través del hook useOrdersCache
 */  // Las utilidades de cache ahora están disponibles a través del hook useOrdersCache:
 // - cache.clearCache()
 // - cache.getCacheStats()
 // - cache.getPendingRequest()
 // - cache.setPendingRequest()

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcaG9va3NcXGFkbWluXFx1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBTVFJJQ1QgT1JERVJTIEhPT0sgKFJFRkFDVE9SRUQpXG4vLyBIb29rIG9ycXVlc3RhZG9yIHBhcmEgZ2VzdGnDs24gZGUgw7NyZGVuZXMgY29uIHZhbGlkYWNpw7NuIGVzdHJpY3RhXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUb2FzdCB9IGZyb20gJ0AvaG9va3MvdXNlLXRvYXN0JztcbmltcG9ydCB7XG4gIFN0cmljdE9yZGVyc0xpc3RSZXNwb25zZSxcbiAgU3RyaWN0QXBpRXJyb3IsXG4gIEFwaVJlc3VsdCxcbiAgY3JlYXRlU3RyaWN0QXBpRXJyb3IsXG4gIFN0cmljdE9yZGVyRW50ZXJwcmlzZSxcbiAgU3RyaWN0UGFnaW5hdGlvbixcbiAgaXNTdHJpY3RBcGlFcnJvcixcbiAgaXNTdHJpY3RBcGlSZXNwb25zZVxufSBmcm9tICdAL3R5cGVzL2FwaS1zdHJpY3QnO1xuaW1wb3J0IHsgT3JkZXJTdGF0dXMsIFBheW1lbnRTdGF0dXMsIEZ1bGZpbGxtZW50U3RhdHVzIH0gZnJvbSAnQC90eXBlcy9vcmRlcnMtZW50ZXJwcmlzZSc7XG5pbXBvcnQgeyB1c2VBcGlNb25pdG9yaW5nIH0gZnJvbSAnQC91dGlscy9hcGktbW9uaXRvcmluZyc7XG5pbXBvcnQgeyB1c2VPcmRlcnNDYWNoZSB9IGZyb20gJy4vdXNlT3JkZXJzQ2FjaGUnO1xuaW1wb3J0IHsgdXNlT3JkZXJzQXBpIH0gZnJvbSAnLi91c2VPcmRlcnNBcGknO1xuaW1wb3J0IHsgdXNlT3JkZXJzU3RhdGUsIFN0cmljdE9yZGVyc1N0YXRlLCBTdHJpY3RPcmRlcnNBY3Rpb25zIH0gZnJvbSAnLi91c2VPcmRlcnNTdGF0ZSc7XG5pbXBvcnQgeyB1c2VPcmRlcnNEZXZTdGF0ZSB9IGZyb20gJy4vdXNlT3JkZXJzRGV2UGVyc2lzdGVuY2UnO1xuXG4vLyBGdW5jacOzbiBkZSBkZWJvdW5jZSBwYXJhIGV2aXRhciBwZXRpY2lvbmVzIG3Dumx0aXBsZXNcbmZ1bmN0aW9uIGRlYm91bmNlPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG4gIGZ1bmM6IFQsXG4gIHdhaXQ6IG51bWJlclxuKTogKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHZvaWQge1xuICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXQ7XG4gIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBmdW5jKC4uLmFyZ3MpLCB3YWl0KTtcbiAgfTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRJUE9TIERFIEZJTFRST1MgRVNUUklDVE9TXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmljdE9yZGVyRmlsdGVycyB7XG4gIHJlYWRvbmx5IHNlYXJjaD86IHN0cmluZztcbiAgcmVhZG9ubHkgc3RhdHVzPzogT3JkZXJTdGF0dXMgfCAnYWxsJztcbiAgcmVhZG9ubHkgcGF5bWVudF9zdGF0dXM/OiBQYXltZW50U3RhdHVzIHwgJ2FsbCc7XG4gIHJlYWRvbmx5IGZ1bGZpbGxtZW50X3N0YXR1cz86IEZ1bGZpbGxtZW50U3RhdHVzIHwgJ2FsbCc7XG4gIHJlYWRvbmx5IGRhdGVfZnJvbT86IHN0cmluZztcbiAgcmVhZG9ubHkgZGF0ZV90bz86IHN0cmluZztcbiAgcmVhZG9ubHkgcGFnZT86IG51bWJlcjtcbiAgcmVhZG9ubHkgbGltaXQ/OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNvcnRfYnk/OiAnY3JlYXRlZF9hdCcgfCAndXBkYXRlZF9hdCcgfCAndG90YWwnIHwgJ29yZGVyX251bWJlcic7XG4gIHJlYWRvbmx5IHNvcnRfb3JkZXI/OiAnYXNjJyB8ICdkZXNjJztcbn1cblxuLy8gVGlwb3MgbW92aWRvcyBhIHVzZU9yZGVyc1N0YXRlLnRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdFJldHVybiBleHRlbmRzIFN0cmljdE9yZGVyc1N0YXRlLCBTdHJpY3RPcmRlcnNBY3Rpb25zIHtcbiAgcmVhZG9ubHkgZmV0Y2hPcmRlcnM6IChmaWx0ZXJzPzogUGFydGlhbDxTdHJpY3RPcmRlckZpbHRlcnM+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZWFkb25seSByZWZyZXNoT3JkZXJzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZWFkb25seSByZXRyeUxhc3RSZXF1ZXN0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ09ORklHVVJBQ0nDk04gREVMIEhPT0tcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmludGVyZmFjZSBVc2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0T3B0aW9ucyB7XG4gIHJlYWRvbmx5IGF1dG9GZXRjaD86IGJvb2xlYW47XG4gIHJlYWRvbmx5IHJlZmV0Y2hJbnRlcnZhbD86IG51bWJlcjtcbiAgcmVhZG9ubHkgbWF4UmV0cmllcz86IG51bWJlcjtcbiAgcmVhZG9ubHkgdGltZW91dD86IG51bWJlcjtcbiAgcmVhZG9ubHkgZW5hYmxlQ2FjaGU/OiBib29sZWFuO1xuICByZWFkb25seSBjYWNoZVRpbWVvdXQ/OiBudW1iZXI7XG59XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUzogUmVxdWlyZWQ8VXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdE9wdGlvbnM+ID0ge1xuICBhdXRvRmV0Y2g6IHRydWUsXG4gIHJlZmV0Y2hJbnRlcnZhbDogMCwgLy8gMCA9IGRpc2FibGVkXG4gIG1heFJldHJpZXM6IDMsXG4gIHRpbWVvdXQ6IDEwMDAwLCAvLyAxMCBzZWNvbmRzXG4gIGVuYWJsZUNhY2hlOiB0cnVlLFxuICBjYWNoZVRpbWVvdXQ6IDUgKiA2MCAqIDEwMDAgLy8gNSBtaW51dGVzXG59O1xuXG4vLyBDb25zdGFudGVzIERFRkFVTFQgbW92aWRhcyBhIHVzZU9yZGVyc1N0YXRlLnRzXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDT05GSUdVUkFDScOTTiBERUwgSE9PSyBPUlFVRVNUQURPUlxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gRnVuY2lvbmVzIGRlIGNhY2hlIG1vdmlkYXMgYSB1c2VPcmRlcnNDYWNoZS50c1xuXG4vLyBGdW5jaW9uZXMgZGUgY2FjaGUgbW92aWRhcyBhIHVzZU9yZGVyc0NhY2hlLnRzXG5cbi8vIFRvZGFzIGxhcyBmdW5jaW9uZXMgZGUgY2FjaGUgbW92aWRhcyBhIHVzZU9yZGVyc0NhY2hlLnRzXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIT09LIFBSSU5DSVBBTFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU9yZGVyc0VudGVycHJpc2VTdHJpY3QoXG4gIGluaXRpYWxGaWx0ZXJzOiBQYXJ0aWFsPFN0cmljdE9yZGVyRmlsdGVycz4gPSB7fSxcbiAgb3B0aW9uczogUGFydGlhbDxVc2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0T3B0aW9ucz4gPSB7fVxuKTogVXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdFJldHVybiB7XG4gIGNvbnN0IHsgdG9hc3QgfSA9IHVzZVRvYXN0KCk7XG4gIGNvbnN0IGFwaU1vbml0b3JpbmcgPSB1c2VBcGlNb25pdG9yaW5nKCk7XG4gIGNvbnN0IG9wdHMgPSB1c2VNZW1vKCgpID0+ICh7IC4uLkRFRkFVTFRfT1BUSU9OUywgLi4ub3B0aW9ucyB9KSwgW29wdGlvbnNdKTtcblxuICAvLyBNZW1vaXphciBsYXMgZnVuY2lvbmVzIGRlIG1vbml0b3JlbyBwYXJhIGV2aXRhciByZWNyZWFjaW9uZXNcbiAgY29uc3QgcmVjb3JkRGlzY3JlcGFuY3kgPSB1c2VDYWxsYmFjayhhcGlNb25pdG9yaW5nLnJlY29yZERpc2NyZXBhbmN5LCBbXSk7XG4gIGNvbnN0IHJlY29yZFJlbmRlcmluZ0lzc3VlID0gdXNlQ2FsbGJhY2soYXBpTW9uaXRvcmluZy5yZWNvcmRSZW5kZXJpbmdJc3N1ZSwgW10pO1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEhPT0tTIEVTUEVDSUFMSVpBRE9TXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gSG9vayBkZSBjYWNoZVxuICBjb25zdCBjYWNoZSA9IHVzZU9yZGVyc0NhY2hlKHtcbiAgICBlbmFibGVDYWNoZTogb3B0cy5lbmFibGVDYWNoZSxcbiAgICBjYWNoZVRpbWVvdXQ6IG9wdHMuY2FjaGVUaW1lb3V0LFxuICAgIG1heFNpemU6IDUwLFxuICAgIGNsZWFudXBJbnRlcnZhbDogMTAgKiA2MCAqIDEwMDAsXG4gICAgbWluUmVxdWVzdEludGVydmFsOiAxMDAwXG4gIH0pO1xuXG4gIC8vIEhvb2sgZGUgcGVyc2lzdGVuY2lhIHBhcmEgZGVzYXJyb2xsbyAoRmFzdCBSZWZyZXNoKVxuICBjb25zdCBkZXZQZXJzaXN0ZW5jZSA9IHVzZU9yZGVyc0RldlN0YXRlKCdvcmRlcnMtZW50ZXJwcmlzZS1kZXYnKTtcblxuICAvLyBIb29rIGRlIGVzdGFkb1xuICBjb25zdCBzdGF0ZSA9IHVzZU9yZGVyc1N0YXRlKGluaXRpYWxGaWx0ZXJzKTtcblxuICAvLyBIb29rIGRlIEFQSVxuICBjb25zdCBhcGkgPSB1c2VPcmRlcnNBcGkoe1xuICAgIHRpbWVvdXQ6IG9wdHMudGltZW91dCxcbiAgICBtYXhSZXRyaWVzOiBvcHRzLm1heFJldHJpZXMsXG4gICAgZW5hYmxlQ2FjaGU6IG9wdHMuZW5hYmxlQ2FjaGUsXG4gICAgY2FjaGVcbiAgfSk7XG4gIFxuICAvLyBSZWZlcmVuY2lhcyBwYXJhIGNvbnRyb2wgZGUgcmVxdWVzdHMgKHNpbXBsaWZpY2FkYXMpXG4gIGNvbnN0IHJldHJ5Q291bnRSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IHJlZmV0Y2hJbnRlcnZhbFJlZiA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBkZWJvdW5jZVRpbWVvdXRSZWYgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBGVU5DSU9ORVMgREUgRkVUQ0ggU0lNUExJRklDQURBU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8vIFVzYXIgZWwgaG9vayBkZSBBUEkgZGlyZWN0YW1lbnRlXG4gIGNvbnN0IGZldGNoT3JkZXJzSW50ZXJuYWwgPSBhcGkuZmV0Y2hPcmRlcnNJbnRlcm5hbDtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBGVU5DSU9ORVMgREUgRkVUQ0ggUMOaQkxJQ0FTXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gTMOzZ2ljYSBkZSBmZXRjaCBtb3ZpZGEgYSB1c2VPcmRlcnNBcGkudHNcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBGVU5DScOTTiBERSBGRVRDSCBQw5pCTElDQSBDT04gUkVUUllcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvLyBGdW5jacOzbiBpbnRlcm5hIHNpbiBkZWJvdW5jZSBwYXJhIHVzbyBkaXJlY3RvXG4gIGNvbnN0IGZldGNoT3JkZXJzSW1tZWRpYXRlID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0ZpbHRlcnM6IFBhcnRpYWw8U3RyaWN0T3JkZXJGaWx0ZXJzPiA9IHt9KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0XSBmZXRjaE9yZGVyc0ltbWVkaWF0ZSBjYWxsZWQgd2l0aCBmaWx0ZXJzOicsIG5ld0ZpbHRlcnMpO1xuICAgIGNvbnNvbGUubG9nKCdbdXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdF0gQ3VycmVudCBzdGF0ZSBmaWx0ZXJzOicsIHN0YXRlLmZpbHRlcnMpO1xuICAgIFxuICAgIC8vIEdlbmVyYXIgY2xhdmUgw7puaWNhIHBhcmEgZXN0YSBwZXRpY2nDs25cbiAgICBjb25zdCByZXF1ZXN0S2V5ID0gSlNPTi5zdHJpbmdpZnkoeyAuLi5zdGF0ZS5maWx0ZXJzLCAuLi5uZXdGaWx0ZXJzIH0pO1xuICAgIGNvbnNvbGUubG9nKCdbdXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdF0gUmVxdWVzdCBrZXk6JywgcmVxdWVzdEtleSk7XG5cbiAgICAvLyBFdml0YXIgcGV0aWNpb25lcyBkdXBsaWNhZGFzXG4gICAgaWYgKHN0YXRlLmhhc0ZpbHRlcnNDaGFuZ2VkKHsgLi4uc3RhdGUuZmlsdGVycywgLi4ubmV3RmlsdGVycyB9KSAmJiBzdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdF0gU2tpcHBpbmcgZHVwbGljYXRlIHJlcXVlc3QnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBY3R1YWxpemFyIGZpbHRyb3MgeSBlc3RhZG8gZGUgY2FyZ2FcbiAgICBjb25zb2xlLmxvZygnW3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RdIFVwZGF0aW5nIGZpbHRlcnMgYW5kIHNldHRpbmcgbG9hZGluZyB0byB0cnVlJyk7XG4gICAgc3RhdGUudXBkYXRlRmlsdGVycyhuZXdGaWx0ZXJzKTtcbiAgICBzdGF0ZS5zZXRMb2FkaW5nKHRydWUpO1xuICAgIHJldHJ5Q291bnRSZWYuY3VycmVudCA9IDA7XG5cbiAgICBjb25zdCBhdHRlbXB0RmV0Y2ggPSBhc3luYyAoYXR0ZW1wdDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50RmlsdGVycyA9IHN0YXRlLmdldExhc3RGaWx0ZXJzKCk7XG4gICAgICBjb25zb2xlLmxvZygnW3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RdIGF0dGVtcHRGZXRjaCAtIGF0dGVtcHQ6JywgYXR0ZW1wdCwgJ2ZpbHRlcnM6JywgY3VycmVudEZpbHRlcnMpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaE9yZGVyc0ludGVybmFsKGN1cnJlbnRGaWx0ZXJzLCBhdHRlbXB0ID4gMCk7XG4gICAgICBjb25zb2xlLmxvZygnW3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RdIEFQSSByZXN1bHQ6JywgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU3RyaWN0QXBpUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICBjb25zb2xlLmxvZygnW3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RdIFZhbGlkIEFQSSByZXNwb25zZSByZWNlaXZlZDonLCByZXN1bHQuZGF0YSk7XG4gICAgICAgIC8vIE1vbml0b3JlbyBhdXRvbcOhdGljbyBkZSBkaXNjcmVwYW5jaWFzXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSByZXN1bHQuZGF0YS5wYWdpbmF0aW9uLnRvdGFsO1xuICAgICAgICBjb25zdCBhY3R1YWxDb3VudCA9IHJlc3VsdC5kYXRhLm9yZGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYC9hcGkvYWRtaW4vb3JkZXJzPyR7bmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgcGFnZTogY3VycmVudEZpbHRlcnMucGFnZT8udG9TdHJpbmcoKSB8fCAnMScsXG4gICAgICAgICAgbGltaXQ6IGN1cnJlbnRGaWx0ZXJzLmxpbWl0Py50b1N0cmluZygpIHx8ICcyMCcsXG4gICAgICAgICAgLi4uKGN1cnJlbnRGaWx0ZXJzLnN0YXR1cyAmJiB7IHN0YXR1czogY3VycmVudEZpbHRlcnMuc3RhdHVzIH0pLFxuICAgICAgICAgIC4uLihjdXJyZW50RmlsdGVycy5wYXltZW50X3N0YXR1cyAmJiB7IHBheW1lbnRfc3RhdHVzOiBjdXJyZW50RmlsdGVycy5wYXltZW50X3N0YXR1cyB9KSxcbiAgICAgICAgICAuLi4oY3VycmVudEZpbHRlcnMuZnVsZmlsbG1lbnRfc3RhdHVzICYmIHsgZnVsZmlsbG1lbnRfc3RhdHVzOiBjdXJyZW50RmlsdGVycy5mdWxmaWxsbWVudF9zdGF0dXMgfSksXG4gICAgICAgICAgLi4uKGN1cnJlbnRGaWx0ZXJzLnNvcnRfYnkgJiYgeyBzb3J0X2J5OiBjdXJyZW50RmlsdGVycy5zb3J0X2J5IH0pLFxuICAgICAgICAgIC4uLihjdXJyZW50RmlsdGVycy5zb3J0X29yZGVyICYmIHsgc29ydF9vcmRlcjogY3VycmVudEZpbHRlcnMuc29ydF9vcmRlciB9KVxuICAgICAgICB9KS50b1N0cmluZygpfWA7XG5cbiAgICAgICAgLy8gU29sbyByZWdpc3RyYXIgZGlzY3JlcGFuY2lhIHNpIGhheSB1bmEgZGlmZXJlbmNpYSByZWFsIChubyBwb3IgcGFnaW5hY2nDs24pXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUGFnZUNvdW50ID0gTWF0aC5taW4oY3VycmVudEZpbHRlcnMubGltaXQgfHwgMjAsIGV4cGVjdGVkQ291bnQgLSAoKGN1cnJlbnRGaWx0ZXJzLnBhZ2UgfHwgMSkgLSAxKSAqIChjdXJyZW50RmlsdGVycy5saW1pdCB8fCAyMCkpO1xuICAgICAgICBpZiAoYWN0dWFsQ291bnQgPCBleHBlY3RlZFBhZ2VDb3VudCAmJiBleHBlY3RlZFBhZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICByZWNvcmREaXNjcmVwYW5jeShlbmRwb2ludCwgZXhwZWN0ZWRQYWdlQ291bnQsIGFjdHVhbENvdW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFjdHVhbGl6YXIgZXN0YWRvIHVzYW5kbyBlbCBob29rIGVzcGVjaWFsaXphZG9cbiAgICAgICAgc3RhdGUuc2V0T3JkZXJzKHJlc3VsdC5kYXRhLm9yZGVycyk7XG4gICAgICAgIHN0YXRlLnNldFBhZ2luYXRpb24ocmVzdWx0LmRhdGEucGFnaW5hdGlvbik7XG4gICAgICAgIHN0YXRlLnNldEFuYWx5dGljcyhyZXN1bHQuZGF0YS5hbmFseXRpY3MgfHwgbnVsbCk7XG4gICAgICAgIHJldHJ5Q291bnRSZWYuY3VycmVudCA9IDA7XG5cbiAgICAgICAgLy8g4pyFIFBFUlNJU1RJUiBFU1RBRE8gUEFSQSBERVNBUlJPTExPIChGYXN0IFJlZnJlc2gpXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGRldlBlcnNpc3RlbmNlLnBlcnNpc3RTdGF0ZSh7XG4gICAgICAgICAgICBvcmRlcnM6IHJlc3VsdC5kYXRhLm9yZGVycyxcbiAgICAgICAgICAgIHBhZ2luYXRpb246IHJlc3VsdC5kYXRhLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBhbmFseXRpY3M6IHJlc3VsdC5kYXRhLmFuYWx5dGljcyB8fCBudWxsLFxuICAgICAgICAgICAgZmlsdGVyczogY3VycmVudEZpbHRlcnMsXG4gICAgICAgICAgICBoYXNEYXRhOiB0cnVlLFxuICAgICAgICAgICAgbGFzdEZldGNoVGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFcyB1biBlcnJvclxuICAgICAgICBpZiAoYXR0ZW1wdCA8IG9wdHMubWF4UmV0cmllcyAmJiByZXN1bHQuY29kZSAhPT0gJ1JFUVVFU1RfQ0FOQ0VMTEVEJykge1xuICAgICAgICAgIHJldHJ5Q291bnRSZWYuY3VycmVudCA9IGF0dGVtcHQgKyAxO1xuICAgICAgICAgIC8vIEVzcGVyYXIgYW50ZXMgZGVsIHJldHJ5IChleHBvbmVudGlhbCBiYWNrb2ZmKVxuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5taW4oMTAwMCAqIE1hdGgucG93KDIsIGF0dGVtcHQpLCAxMDAwMCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgcmV0dXJuIGF0dGVtcHRGZXRjaChhdHRlbXB0ICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNw6F4aW1vIGRlIHJlaW50ZW50b3MgYWxjYW56YWRvIG8gZXJyb3Igbm8gcmVjdXBlcmFibGVcbiAgICAgICAgc3RhdGUuc2V0RXJyb3IocmVzdWx0LmVycm9yKTtcblxuICAgICAgICAvLyBSZWdpc3RyYXIgcHJvYmxlbWEgZGUgcmVuZGVyaXphZG8gcG9yIGVycm9yIGRlIEFQSVxuICAgICAgICByZWNvcmRSZW5kZXJpbmdJc3N1ZShcbiAgICAgICAgICAndXNlT3JkZXJzRW50ZXJwcmlzZVN0cmljdCcsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIGN1cnJlbnRGaWx0ZXJzLFxuICAgICAgICAgIHJlc3VsdC5lcnJvclxuICAgICAgICApO1xuXG4gICAgICAgIC8vIE1vc3RyYXIgdG9hc3QgZGUgZXJyb3JcbiAgICAgICAgaWYgKHJlc3VsdC5jb2RlICE9PSAnUkVRVUVTVF9DQU5DRUxMRUQnKSB7XG4gICAgICAgICAgdG9hc3Qoe1xuICAgICAgICAgICAgdGl0bGU6ICdFcnJvciBhbCBjYXJnYXIgw7NyZGVuZXMnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHJlc3VsdC5lcnJvcixcbiAgICAgICAgICAgIHZhcmlhbnQ6ICdkZXN0cnVjdGl2ZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBhd2FpdCBhdHRlbXB0RmV0Y2goMCk7XG4gIH0sIFtmZXRjaE9yZGVyc0ludGVybmFsLCBvcHRzLm1heFJldHJpZXMsIHRvYXN0LCByZWNvcmREaXNjcmVwYW5jeSwgcmVjb3JkUmVuZGVyaW5nSXNzdWUsIHN0YXRlXSk7XG5cbiAgLy8gRnVuY2nDs24gZmV0Y2hPcmRlcnMgY29uIGRlYm91bmNpbmcgcGFyYSBldml0YXIgcGV0aWNpb25lcyBtw7psdGlwbGVzXG4gIGNvbnN0IGZldGNoT3JkZXJzID0gdXNlQ2FsbGJhY2soKG5ld0ZpbHRlcnM6IFBhcnRpYWw8U3RyaWN0T3JkZXJGaWx0ZXJzPiA9IHt9KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAvLyBMaW1waWFyIHRpbWVvdXQgYW50ZXJpb3Igc2kgZXhpc3RlXG4gICAgICBpZiAoZGVib3VuY2VUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29uZmlndXJhciBudWV2byB0aW1lb3V0IGNvbiBkZWJvdW5jZVxuICAgICAgY29uc3QgZGVib3VuY2VNcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gMzAwIDogMTUwO1xuICAgICAgZGVib3VuY2VUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBmZXRjaE9yZGVyc0ltbWVkaWF0ZShuZXdGaWx0ZXJzKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZGVib3VuY2VkIGZldGNoT3JkZXJzOicsIGVycm9yKTtcbiAgICAgICAgICByZXNvbHZlKCk7IC8vIFJlc29sdmVyIGluY2x1c28gZW4gY2FzbyBkZSBlcnJvciBwYXJhIGV2aXRhciBwcm9tZXNhcyBjb2xnYWRhc1xuICAgICAgICB9XG4gICAgICB9LCBkZWJvdW5jZU1zKTtcbiAgICB9KTtcbiAgfSwgW2ZldGNoT3JkZXJzSW1tZWRpYXRlXSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gT1RSQVMgQUNDSU9ORVNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBjb25zdCByZWZyZXNoT3JkZXJzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIC8vIExpbXBpYXIgY2FjaGUgcGFyYSBmb3J6YXIgcmVmcmVzaFxuICAgIGlmIChvcHRzLmVuYWJsZUNhY2hlKSB7XG4gICAgICBjYWNoZS5jbGVhckNhY2hlKCk7XG4gICAgfVxuICAgIGF3YWl0IGZldGNoT3JkZXJzKCk7XG4gIH0sIFtmZXRjaE9yZGVycywgb3B0cy5lbmFibGVDYWNoZSwgY2FjaGVdKTtcblxuICAvLyBVc2FyIGxhcyBmdW5jaW9uZXMgZGVsIGhvb2sgZGUgZXN0YWRvIGRpcmVjdGFtZW50ZVxuICBjb25zdCB1cGRhdGVGaWx0ZXJzID0gc3RhdGUudXBkYXRlRmlsdGVycztcbiAgY29uc3QgY2xlYXJFcnJvciA9IHN0YXRlLmNsZWFyRXJyb3I7XG5cbiAgY29uc3QgcmV0cnlMYXN0UmVxdWVzdCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBjb25zdCBsYXN0RmlsdGVycyA9IHN0YXRlLmdldExhc3RGaWx0ZXJzKCk7XG4gICAgaWYgKGxhc3RGaWx0ZXJzKSB7XG4gICAgICBhd2FpdCBmZXRjaE9yZGVycyhsYXN0RmlsdGVycyk7XG4gICAgfVxuICB9LCBbZmV0Y2hPcmRlcnMsIHN0YXRlXSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRUZFQ1RPU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFJFU1RBVVJBQ0nDk04gREUgRVNUQURPIFBFUlNJU1RJRE8gKERFU0FSUk9MTE8pXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgY29uc3QgaGFzUmVzdG9yZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaGFzUmVzdG9yZWRSZWYuY3VycmVudCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaGFzUmVzdG9yZWRSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgIC8vIEludGVudGFyIHJlc3RhdXJhciBlc3RhZG8gcGVyc2lzdGlkb1xuICAgICAgaWYgKGRldlBlcnNpc3RlbmNlLmhhc1ZhbGlkUGVyc2lzdGVkRGF0YSgpKSB7XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlZFN0YXRlID0gZGV2UGVyc2lzdGVuY2UuZ2V0UGVyc2lzdGVkU3RhdGUoKTtcbiAgICAgICAgaWYgKHBlcnNpc3RlZFN0YXRlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1t1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0XSBSZXN0b3JpbmcgcGVyc2lzdGVkIHN0YXRlOicsIHtcbiAgICAgICAgICAgIG9yZGVyc0NvdW50OiBwZXJzaXN0ZWRTdGF0ZS5vcmRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgaGFzRGF0YTogcGVyc2lzdGVkU3RhdGUuaGFzRGF0YVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUmVzdGF1cmFyIGVzdGFkb1xuICAgICAgICAgIHN0YXRlLnNldE9yZGVycyhwZXJzaXN0ZWRTdGF0ZS5vcmRlcnMpO1xuICAgICAgICAgIHN0YXRlLnNldFBhZ2luYXRpb24ocGVyc2lzdGVkU3RhdGUucGFnaW5hdGlvbik7XG4gICAgICAgICAgc3RhdGUuc2V0QW5hbHl0aWNzKHBlcnNpc3RlZFN0YXRlLmFuYWx5dGljcyk7XG4gICAgICAgICAgc3RhdGUudXBkYXRlRmlsdGVycyhwZXJzaXN0ZWRTdGF0ZS5maWx0ZXJzKTtcblxuICAgICAgICAgIHJldHVybjsgLy8gTm8gaGFjZXIgYXV0by1mZXRjaCBzaSB0ZW5lbW9zIGRhdG9zIHBlcnNpc3RpZG9zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdXRvLWZldGNoIGluaWNpYWwgc29sbyBzaSBubyBoYXkgZGF0b3MgcGVyc2lzdGlkb3NcbiAgICBpZiAob3B0cy5hdXRvRmV0Y2ggJiYgIWhhc1Jlc3RvcmVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIGZldGNoT3JkZXJzKCk7XG4gICAgfVxuICB9LCBbb3B0cy5hdXRvRmV0Y2hdKTsgLy8gU29sbyBlamVjdXRhciB1bmEgdmV6IGFsIG1vbnRhclxuXG4gIC8vIEVzY3VjaGFyIGNhbWJpb3MgZW4gZmlsdHJvcyBjb24gZGVib3VuY2luZyBvcHRpbWl6YWRvXG4gIGNvbnN0IGZpbHRlcnNSZWYgPSB1c2VSZWYoc3RhdGUuZmlsdGVycyk7XG4gIGNvbnN0IGlzSW5pdGlhbE1vdW50ID0gdXNlUmVmKHRydWUpO1xuICBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBFdml0YXIgZmV0Y2ggZW4gZWwgcHJpbWVyIHJlbmRlciAoeWEgc2UgaGFjZSBlbiBhdXRvLWZldGNoKVxuICAgIGlmIChpc0luaXRpYWxNb3VudC5jdXJyZW50KSB7XG4gICAgICBpc0luaXRpYWxNb3VudC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBmaWx0ZXJzUmVmLmN1cnJlbnQgPSBzdGF0ZS5maWx0ZXJzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNvbG8gaGFjZXIgZmV0Y2ggc2kgbG9zIGZpbHRyb3MgaGFuIGNhbWJpYWRvIHJlYWxtZW50ZVxuICAgIGNvbnN0IGhhc0NoYW5nZWQgPSBKU09OLnN0cmluZ2lmeShmaWx0ZXJzUmVmLmN1cnJlbnQpICE9PSBKU09OLnN0cmluZ2lmeShzdGF0ZS5maWx0ZXJzKTtcbiAgICBcbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgZmlsdGVyc1JlZi5jdXJyZW50ID0gc3RhdGUuZmlsdGVycztcbiAgICAgIGZldGNoT3JkZXJzKCk7XG4gICAgfVxuICB9LCBbc3RhdGUuZmlsdGVycywgZmV0Y2hPcmRlcnNdKTsgLy8gRGVwZW5kZW5jaWFzIG3DrW5pbWFzIHkgZXN0YWJsZXNcblxuICAvLyBSZWZldGNoIGludGVydmFsIC0gVEVNUE9SQUxNRU5URSBERVNIQUJJTElUQURPIHBhcmEgZXZpdGFyIHJlZnJlc2NvIGluZmluaXRvXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gTk9UQTogUmVmZXRjaCBpbnRlcnZhbCBkZXNoYWJpbGl0YWRvIHRlbXBvcmFsbWVudGUgcGFyYSBzb2x1Y2lvbmFyIHJlZnJlc2NvIGluZmluaXRvXG4gICAgLy8gVE9ETzogUmVpbXBsZW1lbnRhciBjb24gdXNlUmVmIHBhcmEgZmV0Y2hPcmRlcnMgbyB1c2FyIFJlYWN0IFF1ZXJ5XG4gICAgLypcbiAgICBpZiAob3B0cy5yZWZldGNoSW50ZXJ2YWwgPiAwKSB7XG4gICAgICByZWZldGNoSW50ZXJ2YWxSZWYuY3VycmVudCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKCFzdGF0ZS5pc0xvYWRpbmcpIHtcbiAgICAgICAgICBmZXRjaE9yZGVycygpO1xuICAgICAgICB9XG4gICAgICB9LCBvcHRzLnJlZmV0Y2hJbnRlcnZhbCk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChyZWZldGNoSW50ZXJ2YWxSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVmZXRjaEludGVydmFsUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICAqL1xuICB9LCBbb3B0cy5yZWZldGNoSW50ZXJ2YWxdKTtcblxuICAvLyBMaW1waWV6YSBhdXRvbcOhdGljYSBkZSBjYWNoZSBtb3ZpZGEgYSB1c2VPcmRlcnNDYWNoZS50c1xuXG4gIC8vIENsZWFudXAgYWwgZGVzbW9udGFyIC0gT1BUSU1JWkFETzogU2luIGRlcGVuZGVuY2lhcyBpbmVzdGFibGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIENhbmNlbGFyIHBldGljaW9uZXMgZW4gcHJvZ3Jlc28gdXNhbmRvIGVsIGhvb2sgZGUgQVBJXG4gICAgICBhcGkuYWJvcnRDdXJyZW50UmVxdWVzdCgpO1xuXG4gICAgICAvLyBMaW1waWFyIGludGVydmFsb3MgeSB0aW1lb3V0c1xuICAgICAgaWYgKHJlZmV0Y2hJbnRlcnZhbFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocmVmZXRjaEludGVydmFsUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGRlYm91bmNlVGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmxvZygnW3VzZU9yZGVyc0VudGVycHJpc2VTdHJpY3RdIEhvb2sgY2xlYW51cCBjb21wbGV0ZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7IC8vIOKchSBDT1JSRUdJRE86IFNpbiBkZXBlbmRlbmNpYXMgcGFyYSBldml0YXIgcmVtb250YWplcyBwb3IgRmFzdCBSZWZyZXNoXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUkVUT1JOTyBERUwgSE9PS1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHJldHVybiB7XG4gICAgLy8gRXN0YWRvXG4gICAgb3JkZXJzOiBzdGF0ZS5vcmRlcnMsXG4gICAgcGFnaW5hdGlvbjogc3RhdGUucGFnaW5hdGlvbixcbiAgICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLFxuICAgIGFuYWx5dGljczogc3RhdGUuYW5hbHl0aWNzLFxuICAgIGlzTG9hZGluZzogc3RhdGUuaXNMb2FkaW5nLFxuICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICBsYXN0RmV0Y2g6IHN0YXRlLmxhc3RGZXRjaCxcbiAgICBcbiAgICAvLyBBY2Npb25lc1xuICAgIGZldGNoT3JkZXJzLFxuICAgIHJlZnJlc2hPcmRlcnMsXG4gICAgdXBkYXRlRmlsdGVycyxcbiAgICBjbGVhckVycm9yLFxuICAgIHJldHJ5TGFzdFJlcXVlc3RcbiAgfTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhPT0sgUEFSQSBPUkRFTiBJTkRJVklEVUFMXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlT3JkZXJEZXRhaWxTdHJpY3Qob3JkZXJJZDogc3RyaW5nIHwgbnVsbCkge1xuICBjb25zdCB7IHRvYXN0IH0gPSB1c2VUb2FzdCgpO1xuICBjb25zdCBbb3JkZXIsIHNldE9yZGVyXSA9IHVzZVN0YXRlPFN0cmljdE9yZGVyRW50ZXJwcmlzZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGZldGNoT3JkZXIgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFvcmRlcklkKSByZXR1cm47XG5cbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9hZG1pbi9vcmRlcnMvJHtvcmRlcklkfWAsIHtcbiAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyAvLyDinIUgQUdSRUdBRE86IEluY2x1aXIgY29va2llcyBkZSBzZXNpw7NuIE5leHRBdXRoLmpzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3BvbnNlID0gdG9TdHJpY3RPcmRlcnNSZXNwb25zZShkYXRhKTtcbiAgICAgIFxuICAgICAgaWYgKGlzU3RyaWN0QXBpRXJyb3IodmFsaWRhdGVkUmVzcG9uc2UpKSB7XG4gICAgICAgIHNldEVycm9yKHZhbGlkYXRlZFJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgdG9hc3Qoe1xuICAgICAgICAgIHRpdGxlOiAnRXJyb3IgYWwgY2FyZ2FyIG9yZGVuJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdmFsaWRhdGVkUmVzcG9uc2UuZXJyb3IsXG4gICAgICAgICAgdmFyaWFudDogJ2Rlc3RydWN0aXZlJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcmEgb3JkZW4gaW5kaXZpZHVhbCwgZXh0cmFlciBsYSBwcmltZXJhIG9yZGVuXG4gICAgICAgIGNvbnN0IG9yZGVyRGF0YSA9IHZhbGlkYXRlZFJlc3BvbnNlLmRhdGEub3JkZXJzWzBdIHx8IG51bGw7XG4gICAgICAgIHNldE9yZGVyKG9yZGVyRGF0YSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJztcbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB0b2FzdCh7XG4gICAgICAgIHRpdGxlOiAnRXJyb3IgYWwgY2FyZ2FyIG9yZGVuJyxcbiAgICAgICAgZGVzY3JpcHRpb246IGVycm9yTWVzc2FnZSxcbiAgICAgICAgdmFyaWFudDogJ2Rlc3RydWN0aXZlJ1xuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbb3JkZXJJZCwgdG9hc3RdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZldGNoT3JkZXIoKTtcbiAgfSwgW2ZldGNoT3JkZXJdKTtcblxuICByZXR1cm4ge1xuICAgIG9yZGVyLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICByZWZldGNoOiBmZXRjaE9yZGVyXG4gIH07XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVVElMSURBREVTIEVYUE9SVEFEQVNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogVXRpbGlkYWRlcyBkZSBjYWNoZSBtb3ZpZGFzIGEgdXNlT3JkZXJzQ2FjaGUudHNcbiAqIEVzdGFzIGZ1bmNpb25lcyBlc3TDoW4gZGlzcG9uaWJsZXMgYSB0cmF2w6lzIGRlbCBob29rIHVzZU9yZGVyc0NhY2hlXG4gKi9cblxuLy8gTGFzIHV0aWxpZGFkZXMgZGUgY2FjaGUgYWhvcmEgZXN0w6FuIGRpc3BvbmlibGVzIGEgdHJhdsOpcyBkZWwgaG9vayB1c2VPcmRlcnNDYWNoZTpcbi8vIC0gY2FjaGUuY2xlYXJDYWNoZSgpXG4vLyAtIGNhY2hlLmdldENhY2hlU3RhdHMoKVxuLy8gLSBjYWNoZS5nZXRQZW5kaW5nUmVxdWVzdCgpXG4vLyAtIGNhY2hlLnNldFBlbmRpbmdSZXF1ZXN0KCkiXSwibmFtZXMiOlsidXNlT3JkZXJEZXRhaWxTdHJpY3QiLCJ1c2VPcmRlcnNFbnRlcnByaXNlU3RyaWN0IiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsInRpbWVvdXQiLCJhcmdzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIkRFRkFVTFRfT1BUSU9OUyIsImF1dG9GZXRjaCIsInJlZmV0Y2hJbnRlcnZhbCIsIm1heFJldHJpZXMiLCJlbmFibGVDYWNoZSIsImNhY2hlVGltZW91dCIsImluaXRpYWxGaWx0ZXJzIiwib3B0aW9ucyIsInRvYXN0IiwidXNlVG9hc3QiLCJhcGlNb25pdG9yaW5nIiwidXNlQXBpTW9uaXRvcmluZyIsIm9wdHMiLCJ1c2VNZW1vIiwicmVjb3JkRGlzY3JlcGFuY3kiLCJ1c2VDYWxsYmFjayIsInJlY29yZFJlbmRlcmluZ0lzc3VlIiwiY2FjaGUiLCJ1c2VPcmRlcnNDYWNoZSIsIm1heFNpemUiLCJjbGVhbnVwSW50ZXJ2YWwiLCJtaW5SZXF1ZXN0SW50ZXJ2YWwiLCJkZXZQZXJzaXN0ZW5jZSIsInVzZU9yZGVyc0RldlN0YXRlIiwic3RhdGUiLCJ1c2VPcmRlcnNTdGF0ZSIsImFwaSIsInVzZU9yZGVyc0FwaSIsInJldHJ5Q291bnRSZWYiLCJ1c2VSZWYiLCJyZWZldGNoSW50ZXJ2YWxSZWYiLCJkZWJvdW5jZVRpbWVvdXRSZWYiLCJmZXRjaE9yZGVyc0ludGVybmFsIiwiZmV0Y2hPcmRlcnNJbW1lZGlhdGUiLCJuZXdGaWx0ZXJzIiwiY29uc29sZSIsImxvZyIsImZpbHRlcnMiLCJyZXF1ZXN0S2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImhhc0ZpbHRlcnNDaGFuZ2VkIiwiaXNMb2FkaW5nIiwidXBkYXRlRmlsdGVycyIsInNldExvYWRpbmciLCJjdXJyZW50IiwiYXR0ZW1wdEZldGNoIiwiYXR0ZW1wdCIsImN1cnJlbnRGaWx0ZXJzIiwiZ2V0TGFzdEZpbHRlcnMiLCJyZXN1bHQiLCJpc1N0cmljdEFwaVJlc3BvbnNlIiwiZGF0YSIsImV4cGVjdGVkQ291bnQiLCJwYWdpbmF0aW9uIiwidG90YWwiLCJhY3R1YWxDb3VudCIsIm9yZGVycyIsImxlbmd0aCIsImVuZHBvaW50IiwiVVJMU2VhcmNoUGFyYW1zIiwicGFnZSIsInRvU3RyaW5nIiwibGltaXQiLCJzdGF0dXMiLCJwYXltZW50X3N0YXR1cyIsImZ1bGZpbGxtZW50X3N0YXR1cyIsInNvcnRfYnkiLCJzb3J0X29yZGVyIiwiZXhwZWN0ZWRQYWdlQ291bnQiLCJNYXRoIiwibWluIiwic2V0T3JkZXJzIiwic2V0UGFnaW5hdGlvbiIsInNldEFuYWx5dGljcyIsImFuYWx5dGljcyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInBlcnNpc3RTdGF0ZSIsImhhc0RhdGEiLCJsYXN0RmV0Y2hUaW1lIiwiRGF0ZSIsIm5vdyIsImNvZGUiLCJkZWxheSIsInBvdyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0RXJyb3IiLCJlcnJvciIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJ2YXJpYW50IiwiZmV0Y2hPcmRlcnMiLCJkZWJvdW5jZU1zIiwicmVmcmVzaE9yZGVycyIsImNsZWFyQ2FjaGUiLCJjbGVhckVycm9yIiwicmV0cnlMYXN0UmVxdWVzdCIsImxhc3RGaWx0ZXJzIiwiaGFzUmVzdG9yZWRSZWYiLCJ1c2VFZmZlY3QiLCJoYXNWYWxpZFBlcnNpc3RlZERhdGEiLCJwZXJzaXN0ZWRTdGF0ZSIsImdldFBlcnNpc3RlZFN0YXRlIiwib3JkZXJzQ291bnQiLCJmaWx0ZXJzUmVmIiwiaXNJbml0aWFsTW91bnQiLCJoYXNDaGFuZ2VkIiwiYWJvcnRDdXJyZW50UmVxdWVzdCIsImNsZWFySW50ZXJ2YWwiLCJsYXN0RmV0Y2giLCJvcmRlcklkIiwib3JkZXIiLCJzZXRPcmRlciIsInVzZVN0YXRlIiwic2V0SXNMb2FkaW5nIiwiZmV0Y2hPcmRlciIsInJlc3BvbnNlIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsImpzb24iLCJ2YWxpZGF0ZWRSZXNwb25zZSIsInRvU3RyaWN0T3JkZXJzUmVzcG9uc2UiLCJpc1N0cmljdEFwaUVycm9yIiwib3JkZXJEYXRhIiwiZXJyIiwi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