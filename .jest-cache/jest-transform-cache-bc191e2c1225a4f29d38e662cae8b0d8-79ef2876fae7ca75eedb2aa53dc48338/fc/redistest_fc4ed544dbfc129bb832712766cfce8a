806b53308d41201a6bbc05647c6b5908
// ===================================
// PINTEYA E-COMMERCE - REDIS TESTS
// ===================================
"use strict";
// Mock ioredis
jest.mock('ioredis', ()=>{
    const mockRedis = {
        ping: jest.fn(),
        get: jest.fn(),
        set: jest.fn(),
        setex: jest.fn(),
        del: jest.fn(),
        incr: jest.fn(),
        expire: jest.fn(),
        ttl: jest.fn(),
        pipeline: jest.fn(),
        quit: jest.fn(),
        on: jest.fn()
    };
    return jest.fn().mockImplementation(()=>mockRedis);
});
// Mock logger
jest.mock('@/lib/logger', ()=>({
        logger: {
            info: jest.fn(),
            debug: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            INFO: 'info',
            DEBUG: 'debug',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            SYSTEM: 'system',
            CACHE: 'cache'
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _redis = require("../../lib/redis");
// Obtener referencia al mock después de la definición
const Redis = require('ioredis');
const mockRedis = new Redis();
describe('Redis Configuration', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('getRedisClient', ()=>{
        it('should create and return Redis client', ()=>{
            const client = (0, _redis.getRedisClient)();
            expect(client).toBeDefined();
            expect(typeof client).toBe('object');
        });
        it('should return same instance on multiple calls', ()=>{
            const client1 = (0, _redis.getRedisClient)();
            const client2 = (0, _redis.getRedisClient)();
            expect(client1).toBe(client2);
        });
    });
    describe('isRedisAvailable', ()=>{
        it('should return true when Redis is available', async ()=>{
            mockRedis.ping.mockResolvedValue('PONG');
            const available = await (0, _redis.isRedisAvailable)();
            expect(available).toBe(true);
            expect(mockRedis.ping).toHaveBeenCalled();
        });
        it('should return false when Redis is not available', async ()=>{
            mockRedis.ping.mockRejectedValue(new Error('Connection failed'));
            const available = await (0, _redis.isRedisAvailable)();
            expect(available).toBe(false);
            expect(mockRedis.ping).toHaveBeenCalled();
        });
    });
});
describe('RedisCache', ()=>{
    let cache;
    beforeEach(()=>{
        jest.clearAllMocks();
        cache = new _redis.RedisCache();
    });
    describe('get', ()=>{
        it('should get value from cache', async ()=>{
            const testValue = 'test-value';
            mockRedis.get.mockResolvedValue(testValue);
            const result = await cache.get('test-key');
            expect(result).toBe(testValue);
            expect(mockRedis.get).toHaveBeenCalledWith('test-key');
        });
        it('should return null when key does not exist', async ()=>{
            mockRedis.get.mockResolvedValue(null);
            const result = await cache.get('non-existent-key');
            expect(result).toBeNull();
            expect(mockRedis.get).toHaveBeenCalledWith('non-existent-key');
        });
        it('should handle errors gracefully', async ()=>{
            mockRedis.get.mockRejectedValue(new Error('Redis error'));
            const result = await cache.get('error-key');
            expect(result).toBeNull();
        });
    });
    describe('set', ()=>{
        it('should set value without TTL', async ()=>{
            mockRedis.set.mockResolvedValue('OK');
            const result = await cache.set('test-key', 'test-value');
            expect(result).toBe(true);
            expect(mockRedis.set).toHaveBeenCalledWith('test-key', 'test-value');
        });
        it('should set value with TTL', async ()=>{
            mockRedis.setex.mockResolvedValue('OK');
            const result = await cache.set('test-key', 'test-value', 3600);
            expect(result).toBe(true);
            expect(mockRedis.setex).toHaveBeenCalledWith('test-key', 3600, 'test-value');
        });
        it('should handle errors gracefully', async ()=>{
            mockRedis.set.mockRejectedValue(new Error('Redis error'));
            const result = await cache.set('error-key', 'test-value');
            expect(result).toBe(false);
        });
    });
    describe('del', ()=>{
        it('should delete existing key', async ()=>{
            mockRedis.del.mockResolvedValue(1);
            const result = await cache.del('test-key');
            expect(result).toBe(true);
            expect(mockRedis.del).toHaveBeenCalledWith('test-key');
        });
        it('should return false for non-existent key', async ()=>{
            mockRedis.del.mockResolvedValue(0);
            const result = await cache.del('non-existent-key');
            expect(result).toBe(false);
        });
        it('should handle errors gracefully', async ()=>{
            mockRedis.del.mockRejectedValue(new Error('Redis error'));
            const result = await cache.del('error-key');
            expect(result).toBe(false);
        });
    });
    describe('incr', ()=>{
        it('should increment counter', async ()=>{
            mockRedis.incr.mockResolvedValue(5);
            const result = await cache.incr('counter-key');
            expect(result).toBe(5);
            expect(mockRedis.incr).toHaveBeenCalledWith('counter-key');
        });
        it('should handle errors gracefully', async ()=>{
            mockRedis.incr.mockRejectedValue(new Error('Redis error'));
            const result = await cache.incr('error-key');
            expect(result).toBeNull();
        });
    });
    describe('expire', ()=>{
        it('should set TTL for existing key', async ()=>{
            mockRedis.expire.mockResolvedValue(1);
            const result = await cache.expire('test-key', 3600);
            expect(result).toBe(true);
            expect(mockRedis.expire).toHaveBeenCalledWith('test-key', 3600);
        });
        it('should return false for non-existent key', async ()=>{
            mockRedis.expire.mockResolvedValue(0);
            const result = await cache.expire('non-existent-key', 3600);
            expect(result).toBe(false);
        });
        it('should handle errors gracefully', async ()=>{
            mockRedis.expire.mockRejectedValue(new Error('Redis error'));
            const result = await cache.expire('error-key', 3600);
            expect(result).toBe(false);
        });
    });
    describe('ttl', ()=>{
        it('should get TTL for key', async ()=>{
            mockRedis.ttl.mockResolvedValue(3600);
            const result = await cache.ttl('test-key');
            expect(result).toBe(3600);
            expect(mockRedis.ttl).toHaveBeenCalledWith('test-key');
        });
        it('should handle errors gracefully', async ()=>{
            mockRedis.ttl.mockRejectedValue(new Error('Redis error'));
            const result = await cache.ttl('error-key');
            expect(result).toBeNull();
        });
    });
});
describe('Rate Limiting Functions', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('getRateLimitInfo', ()=>{
        it('should get rate limit info', async ()=>{
            const mockPipeline = {
                get: jest.fn().mockReturnThis(),
                ttl: jest.fn().mockReturnThis(),
                exec: jest.fn().mockResolvedValue([
                    [
                        null,
                        '5'
                    ],
                    [
                        null,
                        3600
                    ] // ttl
                ])
            };
            mockRedis.pipeline.mockReturnValue(mockPipeline);
            const result = await (0, _redis.getRateLimitInfo)('test-key');
            expect(result).toEqual({
                count: 5,
                ttl: 3600
            });
            expect(mockPipeline.get).toHaveBeenCalledWith('test-key');
            expect(mockPipeline.ttl).toHaveBeenCalledWith('test-key');
        });
        it('should handle errors gracefully', async ()=>{
            const mockPipeline = {
                get: jest.fn().mockReturnThis(),
                ttl: jest.fn().mockReturnThis(),
                exec: jest.fn().mockRejectedValue(new Error('Pipeline error'))
            };
            mockRedis.pipeline.mockReturnValue(mockPipeline);
            const result = await (0, _redis.getRateLimitInfo)('error-key');
            expect(result).toBeNull();
        });
    });
    describe('incrementRateLimit', ()=>{
        it('should increment rate limit counter', async ()=>{
            const mockPipeline = {
                incr: jest.fn().mockReturnThis(),
                expire: jest.fn().mockReturnThis(),
                ttl: jest.fn().mockReturnThis(),
                exec: jest.fn().mockResolvedValue([
                    [
                        null,
                        1
                    ],
                    [
                        null,
                        1
                    ],
                    [
                        null,
                        3600
                    ] // ttl result
                ])
            };
            mockRedis.pipeline.mockReturnValue(mockPipeline);
            const result = await (0, _redis.incrementRateLimit)('test-key', 3600);
            expect(result).toEqual({
                count: 1,
                ttl: 3600,
                isNewWindow: true
            });
            expect(mockPipeline.incr).toHaveBeenCalledWith('test-key');
            expect(mockPipeline.expire).toHaveBeenCalledWith('test-key', 3600);
        });
        it('should handle errors gracefully', async ()=>{
            const mockPipeline = {
                incr: jest.fn().mockReturnThis(),
                expire: jest.fn().mockReturnThis(),
                ttl: jest.fn().mockReturnThis(),
                exec: jest.fn().mockRejectedValue(new Error('Pipeline error'))
            };
            mockRedis.pipeline.mockReturnValue(mockPipeline);
            const result = await (0, _redis.incrementRateLimit)('error-key', 3600);
            expect(result).toBeNull();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxsaWJcXHJlZGlzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUElOVEVZQSBFLUNPTU1FUkNFIC0gUkVESVMgVEVTVFNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmltcG9ydCB7IFxyXG4gIGdldFJlZGlzQ2xpZW50LCBcclxuICBpc1JlZGlzQXZhaWxhYmxlLCBcclxuICBSZWRpc0NhY2hlLCBcclxuICBnZXRSYXRlTGltaXRJbmZvLCBcclxuICBpbmNyZW1lbnRSYXRlTGltaXQgXHJcbn0gZnJvbSAnQC9saWIvcmVkaXMnO1xyXG5cclxuLy8gTW9jayBpb3JlZGlzXHJcbmplc3QubW9jaygnaW9yZWRpcycsICgpID0+IHtcclxuICBjb25zdCBtb2NrUmVkaXMgPSB7XHJcbiAgICBwaW5nOiBqZXN0LmZuKCksXHJcbiAgICBnZXQ6IGplc3QuZm4oKSxcclxuICAgIHNldDogamVzdC5mbigpLFxyXG4gICAgc2V0ZXg6IGplc3QuZm4oKSxcclxuICAgIGRlbDogamVzdC5mbigpLFxyXG4gICAgaW5jcjogamVzdC5mbigpLFxyXG4gICAgZXhwaXJlOiBqZXN0LmZuKCksXHJcbiAgICB0dGw6IGplc3QuZm4oKSxcclxuICAgIHBpcGVsaW5lOiBqZXN0LmZuKCksXHJcbiAgICBxdWl0OiBqZXN0LmZuKCksXHJcbiAgICBvbjogamVzdC5mbigpLFxyXG4gIH07XHJcblxyXG4gIHJldHVybiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tSZWRpcyk7XHJcbn0pO1xyXG5cclxuLy8gT2J0ZW5lciByZWZlcmVuY2lhIGFsIG1vY2sgZGVzcHXDqXMgZGUgbGEgZGVmaW5pY2nDs25cclxuY29uc3QgUmVkaXMgPSByZXF1aXJlKCdpb3JlZGlzJyk7XHJcbmNvbnN0IG1vY2tSZWRpcyA9IG5ldyBSZWRpcygpO1xyXG5cclxuLy8gTW9jayBsb2dnZXJcclxuamVzdC5tb2NrKCdAL2xpYi9sb2dnZXInLCAoKSA9PiAoe1xyXG4gIGxvZ2dlcjoge1xyXG4gICAgaW5mbzogamVzdC5mbigpLFxyXG4gICAgZGVidWc6IGplc3QuZm4oKSxcclxuICAgIHdhcm46IGplc3QuZm4oKSxcclxuICAgIGVycm9yOiBqZXN0LmZuKCksXHJcbiAgfSxcclxuICBMb2dMZXZlbDoge1xyXG4gICAgSU5GTzogJ2luZm8nLFxyXG4gICAgREVCVUc6ICdkZWJ1ZycsXHJcbiAgICBXQVJOOiAnd2FybicsXHJcbiAgICBFUlJPUjogJ2Vycm9yJyxcclxuICB9LFxyXG4gIExvZ0NhdGVnb3J5OiB7XHJcbiAgICBTWVNURU06ICdzeXN0ZW0nLFxyXG4gICAgQ0FDSEU6ICdjYWNoZScsXHJcbiAgfSxcclxufSkpO1xyXG5cclxuZGVzY3JpYmUoJ1JlZGlzIENvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2dldFJlZGlzQ2xpZW50JywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYW5kIHJldHVybiBSZWRpcyBjbGllbnQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNsaWVudCA9IGdldFJlZGlzQ2xpZW50KCk7XHJcbiAgICAgIGV4cGVjdChjbGllbnQpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdCh0eXBlb2YgY2xpZW50KS50b0JlKCdvYmplY3QnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHNhbWUgaW5zdGFuY2Ugb24gbXVsdGlwbGUgY2FsbHMnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNsaWVudDEgPSBnZXRSZWRpc0NsaWVudCgpO1xyXG4gICAgICBjb25zdCBjbGllbnQyID0gZ2V0UmVkaXNDbGllbnQoKTtcclxuICAgICAgZXhwZWN0KGNsaWVudDEpLnRvQmUoY2xpZW50Mik7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2lzUmVkaXNBdmFpbGFibGUnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gUmVkaXMgaXMgYXZhaWxhYmxlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrUmVkaXMucGluZy5tb2NrUmVzb2x2ZWRWYWx1ZSgnUE9ORycpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgYXZhaWxhYmxlID0gYXdhaXQgaXNSZWRpc0F2YWlsYWJsZSgpO1xyXG4gICAgICBcclxuICAgICAgZXhwZWN0KGF2YWlsYWJsZSkudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KG1vY2tSZWRpcy5waW5nKS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIFJlZGlzIGlzIG5vdCBhdmFpbGFibGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tSZWRpcy5waW5nLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ29ubmVjdGlvbiBmYWlsZWQnKSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBhdmFpbGFibGUgPSBhd2FpdCBpc1JlZGlzQXZhaWxhYmxlKCk7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoYXZhaWxhYmxlKS50b0JlKGZhbHNlKTtcclxuICAgICAgZXhwZWN0KG1vY2tSZWRpcy5waW5nKS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcblxyXG5kZXNjcmliZSgnUmVkaXNDYWNoZScsICgpID0+IHtcclxuICBsZXQgY2FjaGU6IFJlZGlzQ2FjaGU7XHJcblxyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgICBjYWNoZSA9IG5ldyBSZWRpc0NhY2hlKCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdnZXQnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGdldCB2YWx1ZSBmcm9tIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0ZXN0VmFsdWUgPSAndGVzdC12YWx1ZSc7XHJcbiAgICAgIG1vY2tSZWRpcy5nZXQubW9ja1Jlc29sdmVkVmFsdWUodGVzdFZhbHVlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlLmdldCgndGVzdC1rZXknKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodGVzdFZhbHVlKTtcclxuICAgICAgZXhwZWN0KG1vY2tSZWRpcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0ZXN0LWtleScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCB3aGVuIGtleSBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja1JlZGlzLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlLmdldCgnbm9uLWV4aXN0ZW50LWtleScpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcclxuICAgICAgZXhwZWN0KG1vY2tSZWRpcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdub24tZXhpc3RlbnQta2V5Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja1JlZGlzLmdldC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlZGlzIGVycm9yJykpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUuZ2V0KCdlcnJvci1rZXknKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3NldCcsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgc2V0IHZhbHVlIHdpdGhvdXQgVFRMJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrUmVkaXMuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKCdPSycpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUuc2V0KCd0ZXN0LWtleScsICd0ZXN0LXZhbHVlJyk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xyXG4gICAgICBleHBlY3QobW9ja1JlZGlzLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Rlc3Qta2V5JywgJ3Rlc3QtdmFsdWUnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgc2V0IHZhbHVlIHdpdGggVFRMJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrUmVkaXMuc2V0ZXgubW9ja1Jlc29sdmVkVmFsdWUoJ09LJyk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZS5zZXQoJ3Rlc3Qta2V5JywgJ3Rlc3QtdmFsdWUnLCAzNjAwKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChtb2NrUmVkaXMuc2V0ZXgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0ZXN0LWtleScsIDM2MDAsICd0ZXN0LXZhbHVlJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja1JlZGlzLnNldC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlZGlzIGVycm9yJykpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUuc2V0KCdlcnJvci1rZXknLCAndGVzdC12YWx1ZScpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2RlbCcsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgZGVsZXRlIGV4aXN0aW5nIGtleScsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja1JlZGlzLmRlbC5tb2NrUmVzb2x2ZWRWYWx1ZSgxKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlLmRlbCgndGVzdC1rZXknKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChtb2NrUmVkaXMuZGVsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdC1rZXknKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBub24tZXhpc3RlbnQga2V5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrUmVkaXMuZGVsLm1vY2tSZXNvbHZlZFZhbHVlKDApO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUuZGVsKCdub24tZXhpc3RlbnQta2V5Jyk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrUmVkaXMuZGVsLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignUmVkaXMgZXJyb3InKSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZS5kZWwoJ2Vycm9yLWtleScpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2luY3InLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGluY3JlbWVudCBjb3VudGVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrUmVkaXMuaW5jci5tb2NrUmVzb2x2ZWRWYWx1ZSg1KTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlLmluY3IoJ2NvdW50ZXIta2V5Jyk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKDUpO1xyXG4gICAgICBleHBlY3QobW9ja1JlZGlzLmluY3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdjb3VudGVyLWtleScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tSZWRpcy5pbmNyLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignUmVkaXMgZXJyb3InKSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZS5pbmNyKCdlcnJvci1rZXknKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2V4cGlyZScsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgc2V0IFRUTCBmb3IgZXhpc3Rpbmcga2V5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrUmVkaXMuZXhwaXJlLm1vY2tSZXNvbHZlZFZhbHVlKDEpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUuZXhwaXJlKCd0ZXN0LWtleScsIDM2MDApO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KG1vY2tSZWRpcy5leHBpcmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0ZXN0LWtleScsIDM2MDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFsc2UgZm9yIG5vbi1leGlzdGVudCBrZXknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tSZWRpcy5leHBpcmUubW9ja1Jlc29sdmVkVmFsdWUoMCk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZS5leHBpcmUoJ25vbi1leGlzdGVudC1rZXknLCAzNjAwKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tSZWRpcy5leHBpcmUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdSZWRpcyBlcnJvcicpKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlLmV4cGlyZSgnZXJyb3Ita2V5JywgMzYwMCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgndHRsJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBnZXQgVFRMIGZvciBrZXknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tSZWRpcy50dGwubW9ja1Jlc29sdmVkVmFsdWUoMzYwMCk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZS50dGwoJ3Rlc3Qta2V5Jyk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKDM2MDApO1xyXG4gICAgICBleHBlY3QobW9ja1JlZGlzLnR0bCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Rlc3Qta2V5Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja1JlZGlzLnR0bC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlZGlzIGVycm9yJykpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUudHRsKCdlcnJvci1rZXknKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcblxyXG5kZXNjcmliZSgnUmF0ZSBMaW1pdGluZyBGdW5jdGlvbnMnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2dldFJhdGVMaW1pdEluZm8nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGdldCByYXRlIGxpbWl0IGluZm8nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tQaXBlbGluZSA9IHtcclxuICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHR0bDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgZXhlYzogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFtcclxuICAgICAgICAgIFtudWxsLCAnNSddLCAgLy8gY291bnRcclxuICAgICAgICAgIFtudWxsLCAzNjAwXSAgLy8gdHRsXHJcbiAgICAgICAgXSlcclxuICAgICAgfTtcclxuICAgICAgbW9ja1JlZGlzLnBpcGVsaW5lLm1vY2tSZXR1cm5WYWx1ZShtb2NrUGlwZWxpbmUpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmF0ZUxpbWl0SW5mbygndGVzdC1rZXknKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBjb3VudDogNSwgdHRsOiAzNjAwIH0pO1xyXG4gICAgICBleHBlY3QobW9ja1BpcGVsaW5lLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Rlc3Qta2V5Jyk7XHJcbiAgICAgIGV4cGVjdChtb2NrUGlwZWxpbmUudHRsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdC1rZXknKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrUGlwZWxpbmUgPSB7XHJcbiAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICB0dGw6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGV4ZWM6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1BpcGVsaW5lIGVycm9yJykpXHJcbiAgICAgIH07XHJcbiAgICAgIG1vY2tSZWRpcy5waXBlbGluZS5tb2NrUmV0dXJuVmFsdWUobW9ja1BpcGVsaW5lKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJhdGVMaW1pdEluZm8oJ2Vycm9yLWtleScpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnaW5jcmVtZW50UmF0ZUxpbWl0JywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBpbmNyZW1lbnQgcmF0ZSBsaW1pdCBjb3VudGVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrUGlwZWxpbmUgPSB7XHJcbiAgICAgICAgaW5jcjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgZXhwaXJlOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICB0dGw6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGV4ZWM6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShbXHJcbiAgICAgICAgICBbbnVsbCwgMV0sICAgIC8vIGluY3IgcmVzdWx0XHJcbiAgICAgICAgICBbbnVsbCwgMV0sICAgIC8vIGV4cGlyZSByZXN1bHRcclxuICAgICAgICAgIFtudWxsLCAzNjAwXSAgLy8gdHRsIHJlc3VsdFxyXG4gICAgICAgIF0pXHJcbiAgICAgIH07XHJcbiAgICAgIG1vY2tSZWRpcy5waXBlbGluZS5tb2NrUmV0dXJuVmFsdWUobW9ja1BpcGVsaW5lKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGluY3JlbWVudFJhdGVMaW1pdCgndGVzdC1rZXknLCAzNjAwKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBjb3VudDogMSwgdHRsOiAzNjAwLCBpc05ld1dpbmRvdzogdHJ1ZSB9KTtcclxuICAgICAgZXhwZWN0KG1vY2tQaXBlbGluZS5pbmNyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdC1rZXknKTtcclxuICAgICAgZXhwZWN0KG1vY2tQaXBlbGluZS5leHBpcmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0ZXN0LWtleScsIDM2MDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tQaXBlbGluZSA9IHtcclxuICAgICAgICBpbmNyOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBleHBpcmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHR0bDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgZXhlYzogamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignUGlwZWxpbmUgZXJyb3InKSlcclxuICAgICAgfTtcclxuICAgICAgbW9ja1JlZGlzLnBpcGVsaW5lLm1vY2tSZXR1cm5WYWx1ZShtb2NrUGlwZWxpbmUpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW5jcmVtZW50UmF0ZUxpbWl0KCdlcnJvci1rZXknLCAzNjAwKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tSZWRpcyIsInBpbmciLCJmbiIsImdldCIsInNldCIsInNldGV4IiwiZGVsIiwiaW5jciIsImV4cGlyZSIsInR0bCIsInBpcGVsaW5lIiwicXVpdCIsIm9uIiwibW9ja0ltcGxlbWVudGF0aW9uIiwibG9nZ2VyIiwiaW5mbyIsImRlYnVnIiwid2FybiIsImVycm9yIiwiTG9nTGV2ZWwiLCJJTkZPIiwiREVCVUciLCJXQVJOIiwiRVJST1IiLCJMb2dDYXRlZ29yeSIsIlNZU1RFTSIsIkNBQ0hFIiwiUmVkaXMiLCJyZXF1aXJlIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0IiwiY2xpZW50IiwiZ2V0UmVkaXNDbGllbnQiLCJleHBlY3QiLCJ0b0JlRGVmaW5lZCIsInRvQmUiLCJjbGllbnQxIiwiY2xpZW50MiIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiYXZhaWxhYmxlIiwiaXNSZWRpc0F2YWlsYWJsZSIsInRvSGF2ZUJlZW5DYWxsZWQiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwiY2FjaGUiLCJSZWRpc0NhY2hlIiwidGVzdFZhbHVlIiwicmVzdWx0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0JlTnVsbCIsIm1vY2tQaXBlbGluZSIsIm1vY2tSZXR1cm5UaGlzIiwiZXhlYyIsIm1vY2tSZXR1cm5WYWx1ZSIsImdldFJhdGVMaW1pdEluZm8iLCJ0b0VxdWFsIiwiY291bnQiLCJpbmNyZW1lbnRSYXRlTGltaXQiLCJpc05ld1dpbmRvdyJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLG1DQUFtQztBQUNuQyxzQ0FBc0M7O0FBVXRDLGVBQWU7QUFDZkEsS0FBS0MsSUFBSSxDQUFDLFdBQVc7SUFDbkIsTUFBTUMs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