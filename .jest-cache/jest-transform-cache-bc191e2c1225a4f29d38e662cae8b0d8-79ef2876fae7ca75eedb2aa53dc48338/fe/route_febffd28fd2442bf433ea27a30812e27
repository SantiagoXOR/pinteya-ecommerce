d2be0f5cac405449817ea33d6fb34c3e
// ===================================
// PINTEYA E-COMMERCE - API DE MARCAS
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get GET () {
        return GET;
    },
    get POST () {
        return POST;
    }
});
const _server = require("next/server");
const _supabase = require("../../../lib/supabase");
async function GET(request) {
    try {
        const { searchParams } = new URL(request.url);
        // Extraer parámetros de query
        const filters = {
            search: searchParams.get('search') || undefined,
            minProducts: searchParams.get('minProducts') ? Number(searchParams.get('minProducts')) : 1
        };
        const supabase = (0, _supabase.getSupabaseClient)();
        // Verificar que el cliente de Supabase esté disponible
        if (!supabase) {
            console.error('Cliente de Supabase no disponible en GET /api/brands');
            const errorResponse = {
                data: null,
                success: false,
                error: 'Servicio de base de datos no disponible'
            };
            return _server.NextResponse.json(errorResponse, {
                status: 503
            });
        }
        // Construir query para obtener marcas con conteo de productos
        let query = supabase.from('products').select('brand').not('brand', 'is', null).gt('stock', 0); // Solo productos con stock
        // Aplicar filtro de búsqueda si existe
        if (filters.search) {
            query = query.ilike('brand', `%${filters.search}%`);
        }
        // Ejecutar query
        const { data: products, error } = await query;
        if (error) {
            (0, _supabase.handleSupabaseError)(error, 'GET /api/brands');
        }
        // Procesar datos para obtener marcas únicas con conteo
        const brandCounts = {};
        products?.forEach((product)=>{
            if (product.brand) {
                brandCounts[product.brand] = (brandCounts[product.brand] || 0) + 1;
            }
        });
        // Convertir a array y filtrar por mínimo de productos
        const brands = Object.entries(brandCounts).filter(([_, count])=>count >= (filters.minProducts || 1)).map(([name, products_count])=>({
                name,
                products_count
            })).sort((a, b)=>{
            // Ordenar por número de productos (descendente) y luego por nombre
            if (a.products_count !== b.products_count) {
                return b.products_count - a.products_count;
            }
            return a.name.localeCompare(b.name);
        });
        const response = {
            data: brands,
            success: true,
            message: `${brands.length} marcas encontradas`
        };
        return _server.NextResponse.json(response);
    } catch (error) {
        console.error('Error en GET /api/brands:', error);
        const errorResponse = {
            data: null,
            success: false,
            error: error.message || 'Error interno del servidor'
        };
        return _server.NextResponse.json(errorResponse, {
            status: 500
        });
    }
}
async function POST(request) {
    try {
        const supabase = (0, _supabase.getSupabaseClient)();
        if (!supabase) {
            console.error('Cliente de Supabase no disponible en POST /api/brands');
            const errorResponse = {
                data: null,
                success: false,
                error: 'Servicio de base de datos no disponible'
            };
            return _server.NextResponse.json(errorResponse, {
                status: 503
            });
        }
        // Obtener estadísticas detalladas de marcas
        const { data: products, error } = await supabase.from('products').select('brand, price, discounted_price, stock, category_id').not('brand', 'is', null);
        if (error) {
            (0, _supabase.handleSupabaseError)(error, 'POST /api/brands (stats)');
        }
        // Calcular estadísticas por marca
        const brandStats = {};
        products?.forEach((product)=>{
            if (product.brand) {
                if (!brandStats[product.brand]) {
                    brandStats[product.brand] = {
                        name: product.brand,
                        products_count: 0,
                        total_stock: 0,
                        avg_price: 0,
                        min_price: Infinity,
                        max_price: 0,
                        discounted_products: 0
                    };
                }
                const stats = brandStats[product.brand];
                const currentPrice = product.discounted_price || product.price;
                stats.products_count++;
                stats.total_stock += product.stock || 0;
                stats.min_price = Math.min(stats.min_price, currentPrice);
                stats.max_price = Math.max(stats.max_price, currentPrice);
                if (product.discounted_price && product.discounted_price < product.price) {
                    stats.discounted_products++;
                }
            }
        });
        // Calcular precio promedio y finalizar estadísticas
        const finalStats = Object.values(brandStats).map((stats)=>{
            const brandProducts = products?.filter((p)=>p.brand === stats.name) || [];
            const totalPrice = brandProducts.reduce((sum, p)=>sum + (p.discounted_price || p.price), 0);
            return {
                ...stats,
                avg_price: Math.round(totalPrice / stats.products_count),
                min_price: stats.min_price === Infinity ? 0 : stats.min_price
            };
        }).sort((a, b)=>b.products_count - a.products_count);
        const response = {
            data: finalStats,
            success: true,
            message: `Estadísticas de ${finalStats.length} marcas calculadas`
        };
        return _server.NextResponse.json(response);
    } catch (error) {
        console.error('Error en POST /api/brands (stats):', error);
        const errorResponse = {
            data: null,
            success: false,
            error: error.message || 'Error interno del servidor'
        };
        return _server.NextResponse.json(errorResponse, {
            status: 500
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcYXBwXFxhcGlcXGJyYW5kc1xccm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUElOVEVZQSBFLUNPTU1FUkNFIC0gQVBJIERFIE1BUkNBU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHsgZ2V0U3VwYWJhc2VDbGllbnQsIGhhbmRsZVN1cGFiYXNlRXJyb3IgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSc7XHJcbmltcG9ydCB7IEFwaVJlc3BvbnNlIH0gZnJvbSAnQC90eXBlcy9hcGknO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVElQT1MgUEFSQSBNQVJDQVNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuZXhwb3J0IGludGVyZmFjZSBCcmFuZCB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIHByb2R1Y3RzX2NvdW50OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQnJhbmRGaWx0ZXJzIHtcclxuICBzZWFyY2g/OiBzdHJpbmc7XHJcbiAgbWluUHJvZHVjdHM/OiBudW1iZXI7XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEdFVCAvYXBpL2JyYW5kcyAtIE9idGVuZXIgbWFyY2FzIGRpc3BvbmlibGVzXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWVyIHBhcsOhbWV0cm9zIGRlIHF1ZXJ5XHJcbiAgICBjb25zdCBmaWx0ZXJzOiBCcmFuZEZpbHRlcnMgPSB7XHJcbiAgICAgIHNlYXJjaDogc2VhcmNoUGFyYW1zLmdldCgnc2VhcmNoJykgfHwgdW5kZWZpbmVkLFxyXG4gICAgICBtaW5Qcm9kdWN0czogc2VhcmNoUGFyYW1zLmdldCgnbWluUHJvZHVjdHMnKSA/IE51bWJlcihzZWFyY2hQYXJhbXMuZ2V0KCdtaW5Qcm9kdWN0cycpKSA6IDEsXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlQ2xpZW50KCk7XHJcblxyXG4gICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBjbGllbnRlIGRlIFN1cGFiYXNlIGVzdMOpIGRpc3BvbmlibGVcclxuICAgIGlmICghc3VwYWJhc2UpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQ2xpZW50ZSBkZSBTdXBhYmFzZSBubyBkaXNwb25pYmxlIGVuIEdFVCAvYXBpL2JyYW5kcycpO1xyXG4gICAgICBjb25zdCBlcnJvclJlc3BvbnNlOiBBcGlSZXNwb25zZTxudWxsPiA9IHtcclxuICAgICAgICBkYXRhOiBudWxsLFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIGVycm9yOiAnU2VydmljaW8gZGUgYmFzZSBkZSBkYXRvcyBubyBkaXNwb25pYmxlJyxcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKGVycm9yUmVzcG9uc2UsIHsgc3RhdHVzOiA1MDMgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29uc3RydWlyIHF1ZXJ5IHBhcmEgb2J0ZW5lciBtYXJjYXMgY29uIGNvbnRlbyBkZSBwcm9kdWN0b3NcclxuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAgIC5mcm9tKCdwcm9kdWN0cycpXHJcbiAgICAgIC5zZWxlY3QoJ2JyYW5kJylcclxuICAgICAgLm5vdCgnYnJhbmQnLCAnaXMnLCBudWxsKVxyXG4gICAgICAuZ3QoJ3N0b2NrJywgMCk7IC8vIFNvbG8gcHJvZHVjdG9zIGNvbiBzdG9ja1xyXG5cclxuICAgIC8vIEFwbGljYXIgZmlsdHJvIGRlIGLDunNxdWVkYSBzaSBleGlzdGVcclxuICAgIGlmIChmaWx0ZXJzLnNlYXJjaCkge1xyXG4gICAgICBxdWVyeSA9IHF1ZXJ5LmlsaWtlKCdicmFuZCcsIGAlJHtmaWx0ZXJzLnNlYXJjaH0lYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRWplY3V0YXIgcXVlcnlcclxuICAgIGNvbnN0IHsgZGF0YTogcHJvZHVjdHMsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgaGFuZGxlU3VwYWJhc2VFcnJvcihlcnJvciwgJ0dFVCAvYXBpL2JyYW5kcycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByb2Nlc2FyIGRhdG9zIHBhcmEgb2J0ZW5lciBtYXJjYXMgw7puaWNhcyBjb24gY29udGVvXHJcbiAgICBjb25zdCBicmFuZENvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xyXG4gICAgXHJcbiAgICBwcm9kdWN0cz8uZm9yRWFjaChwcm9kdWN0ID0+IHtcclxuICAgICAgaWYgKHByb2R1Y3QuYnJhbmQpIHtcclxuICAgICAgICBicmFuZENvdW50c1twcm9kdWN0LmJyYW5kXSA9IChicmFuZENvdW50c1twcm9kdWN0LmJyYW5kXSB8fCAwKSArIDE7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENvbnZlcnRpciBhIGFycmF5IHkgZmlsdHJhciBwb3IgbcOtbmltbyBkZSBwcm9kdWN0b3NcclxuICAgIGNvbnN0IGJyYW5kczogQnJhbmRbXSA9IE9iamVjdC5lbnRyaWVzKGJyYW5kQ291bnRzKVxyXG4gICAgICAuZmlsdGVyKChbXywgY291bnRdKSA9PiBjb3VudCA+PSAoZmlsdGVycy5taW5Qcm9kdWN0cyB8fCAxKSlcclxuICAgICAgLm1hcCgoW25hbWUsIHByb2R1Y3RzX2NvdW50XSkgPT4gKHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHByb2R1Y3RzX2NvdW50LFxyXG4gICAgICB9KSlcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAvLyBPcmRlbmFyIHBvciBuw7ptZXJvIGRlIHByb2R1Y3RvcyAoZGVzY2VuZGVudGUpIHkgbHVlZ28gcG9yIG5vbWJyZVxyXG4gICAgICAgIGlmIChhLnByb2R1Y3RzX2NvdW50ICE9PSBiLnByb2R1Y3RzX2NvdW50KSB7XHJcbiAgICAgICAgICByZXR1cm4gYi5wcm9kdWN0c19jb3VudCAtIGEucHJvZHVjdHNfY291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZTogQXBpUmVzcG9uc2U8QnJhbmRbXT4gPSB7XHJcbiAgICAgIGRhdGE6IGJyYW5kcyxcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogYCR7YnJhbmRzLmxlbmd0aH0gbWFyY2FzIGVuY29udHJhZGFzYCxcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHJlc3BvbnNlKTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZW4gR0VUIC9hcGkvYnJhbmRzOicsIGVycm9yKTtcclxuICAgIFxyXG4gICAgY29uc3QgZXJyb3JSZXNwb25zZTogQXBpUmVzcG9uc2U8bnVsbD4gPSB7XHJcbiAgICAgIGRhdGE6IG51bGwsXHJcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRXJyb3IgaW50ZXJubyBkZWwgc2Vydmlkb3InLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oZXJyb3JSZXNwb25zZSwgeyBzdGF0dXM6IDUwMCB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEdFVCAvYXBpL2JyYW5kcy9zdGF0cyAtIEVzdGFkw61zdGljYXMgZGUgbWFyY2FzXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHN1cGFiYXNlID0gZ2V0U3VwYWJhc2VDbGllbnQoKTtcclxuXHJcbiAgICBpZiAoIXN1cGFiYXNlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NsaWVudGUgZGUgU3VwYWJhc2Ugbm8gZGlzcG9uaWJsZSBlbiBQT1NUIC9hcGkvYnJhbmRzJyk7XHJcbiAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2U6IEFwaVJlc3BvbnNlPG51bGw+ID0ge1xyXG4gICAgICAgIGRhdGE6IG51bGwsXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgZXJyb3I6ICdTZXJ2aWNpbyBkZSBiYXNlIGRlIGRhdG9zIG5vIGRpc3BvbmlibGUnLFxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oZXJyb3JSZXNwb25zZSwgeyBzdGF0dXM6IDUwMyB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPYnRlbmVyIGVzdGFkw61zdGljYXMgZGV0YWxsYWRhcyBkZSBtYXJjYXNcclxuICAgIGNvbnN0IHsgZGF0YTogcHJvZHVjdHMsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgncHJvZHVjdHMnKVxyXG4gICAgICAuc2VsZWN0KCdicmFuZCwgcHJpY2UsIGRpc2NvdW50ZWRfcHJpY2UsIHN0b2NrLCBjYXRlZ29yeV9pZCcpXHJcbiAgICAgIC5ub3QoJ2JyYW5kJywgJ2lzJywgbnVsbCk7XHJcblxyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIGhhbmRsZVN1cGFiYXNlRXJyb3IoZXJyb3IsICdQT1NUIC9hcGkvYnJhbmRzIChzdGF0cyknKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhciBlc3RhZMOtc3RpY2FzIHBvciBtYXJjYVxyXG4gICAgY29uc3QgYnJhbmRTdGF0czogUmVjb3JkPHN0cmluZywge1xyXG4gICAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICAgIHByb2R1Y3RzX2NvdW50OiBudW1iZXI7XHJcbiAgICAgIHRvdGFsX3N0b2NrOiBudW1iZXI7XHJcbiAgICAgIGF2Z19wcmljZTogbnVtYmVyO1xyXG4gICAgICBtaW5fcHJpY2U6IG51bWJlcjtcclxuICAgICAgbWF4X3ByaWNlOiBudW1iZXI7XHJcbiAgICAgIGRpc2NvdW50ZWRfcHJvZHVjdHM6IG51bWJlcjtcclxuICAgIH0+ID0ge307XHJcblxyXG4gICAgcHJvZHVjdHM/LmZvckVhY2gocHJvZHVjdCA9PiB7XHJcbiAgICAgIGlmIChwcm9kdWN0LmJyYW5kKSB7XHJcbiAgICAgICAgaWYgKCFicmFuZFN0YXRzW3Byb2R1Y3QuYnJhbmRdKSB7XHJcbiAgICAgICAgICBicmFuZFN0YXRzW3Byb2R1Y3QuYnJhbmRdID0ge1xyXG4gICAgICAgICAgICBuYW1lOiBwcm9kdWN0LmJyYW5kLFxyXG4gICAgICAgICAgICBwcm9kdWN0c19jb3VudDogMCxcclxuICAgICAgICAgICAgdG90YWxfc3RvY2s6IDAsXHJcbiAgICAgICAgICAgIGF2Z19wcmljZTogMCxcclxuICAgICAgICAgICAgbWluX3ByaWNlOiBJbmZpbml0eSxcclxuICAgICAgICAgICAgbWF4X3ByaWNlOiAwLFxyXG4gICAgICAgICAgICBkaXNjb3VudGVkX3Byb2R1Y3RzOiAwLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YXRzID0gYnJhbmRTdGF0c1twcm9kdWN0LmJyYW5kXTtcclxuICAgICAgICBjb25zdCBjdXJyZW50UHJpY2UgPSBwcm9kdWN0LmRpc2NvdW50ZWRfcHJpY2UgfHwgcHJvZHVjdC5wcmljZTtcclxuXHJcbiAgICAgICAgc3RhdHMucHJvZHVjdHNfY291bnQrKztcclxuICAgICAgICBzdGF0cy50b3RhbF9zdG9jayArPSBwcm9kdWN0LnN0b2NrIHx8IDA7XHJcbiAgICAgICAgc3RhdHMubWluX3ByaWNlID0gTWF0aC5taW4oc3RhdHMubWluX3ByaWNlLCBjdXJyZW50UHJpY2UpO1xyXG4gICAgICAgIHN0YXRzLm1heF9wcmljZSA9IE1hdGgubWF4KHN0YXRzLm1heF9wcmljZSwgY3VycmVudFByaWNlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocHJvZHVjdC5kaXNjb3VudGVkX3ByaWNlICYmIHByb2R1Y3QuZGlzY291bnRlZF9wcmljZSA8IHByb2R1Y3QucHJpY2UpIHtcclxuICAgICAgICAgIHN0YXRzLmRpc2NvdW50ZWRfcHJvZHVjdHMrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENhbGN1bGFyIHByZWNpbyBwcm9tZWRpbyB5IGZpbmFsaXphciBlc3RhZMOtc3RpY2FzXHJcbiAgICBjb25zdCBmaW5hbFN0YXRzID0gT2JqZWN0LnZhbHVlcyhicmFuZFN0YXRzKS5tYXAoc3RhdHMgPT4ge1xyXG4gICAgICBjb25zdCBicmFuZFByb2R1Y3RzID0gcHJvZHVjdHM/LmZpbHRlcihwID0+IHAuYnJhbmQgPT09IHN0YXRzLm5hbWUpIHx8IFtdO1xyXG4gICAgICBjb25zdCB0b3RhbFByaWNlID0gYnJhbmRQcm9kdWN0cy5yZWR1Y2UoKHN1bSwgcCkgPT4gc3VtICsgKHAuZGlzY291bnRlZF9wcmljZSB8fCBwLnByaWNlKSwgMCk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLnN0YXRzLFxyXG4gICAgICAgIGF2Z19wcmljZTogTWF0aC5yb3VuZCh0b3RhbFByaWNlIC8gc3RhdHMucHJvZHVjdHNfY291bnQpLFxyXG4gICAgICAgIG1pbl9wcmljZTogc3RhdHMubWluX3ByaWNlID09PSBJbmZpbml0eSA/IDAgOiBzdGF0cy5taW5fcHJpY2UsXHJcbiAgICAgIH07XHJcbiAgICB9KS5zb3J0KChhLCBiKSA9PiBiLnByb2R1Y3RzX2NvdW50IC0gYS5wcm9kdWN0c19jb3VudCk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2U6IEFwaVJlc3BvbnNlPHR5cGVvZiBmaW5hbFN0YXRzPiA9IHtcclxuICAgICAgZGF0YTogZmluYWxTdGF0cyxcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogYEVzdGFkw61zdGljYXMgZGUgJHtmaW5hbFN0YXRzLmxlbmd0aH0gbWFyY2FzIGNhbGN1bGFkYXNgLFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocmVzcG9uc2UpO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbiBQT1NUIC9hcGkvYnJhbmRzIChzdGF0cyk6JywgZXJyb3IpO1xyXG4gICAgXHJcbiAgICBjb25zdCBlcnJvclJlc3BvbnNlOiBBcGlSZXNwb25zZTxudWxsPiA9IHtcclxuICAgICAgZGF0YTogbnVsbCxcclxuICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBpbnRlcm5vIGRlbCBzZXJ2aWRvcicsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihlcnJvclJlc3BvbnNlLCB7IHN0YXR1czogNTAwIH0pO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiR0VUIiwiUE9TVCIsInJlcXVlc3QiLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJ1cmwiLCJmaWx0ZXJzIiwic2VhcmNoIiwiZ2V0IiwidW5kZWZpbmVkIiwibWluUHJvZHVjdHMiLCJOdW1iZXIiLCJzdXBhYmFzZSIsImdldFN1cGFiYXNlQ2xpZW50IiwiY29uc29sZSIsImVycm9yIiwiZXJyb3JSZXNwb25zZSIsImRhdGEiLCJzdWNjZXNzIiwiTmV4dFJlc3BvbnNlIiwianNvbiIsInN0YXR1cyIsInF1ZXJ5IiwiZnJvbSIsInNlbGVjdCIsIm5vdCIsImd0IiwiaWxpa2UiLCJwcm9kdWN0cyIsImhhbmRsZVN1cGFiYXNlRXJyb3IiLCJicmFuZENvdW50cyIsImZvckVhY2giLCJwcm9kdWN0IiwiYnJhbmQiLCJicmFuZHMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyIiwiXyIsImNvdW50IiwibWFwIiwibmFtZSIsInByb2R1Y3RzX2NvdW50Iiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsInJlc3BvbnNlIiwibWVzc2FnZSIsImxlbmd0aCIsImJyYW5kU3RhdHMiLCJ0b3RhbF9zdG9jayIsImF2Z19wcmljZSIsIm1pbl9wcmljZSIsIkluZmluaXR5IiwibWF4X3ByaWNlIiwiZGlzY291bnRlZF9wcm9kdWN0cyIsInN0YXRzIiwiY3VycmVudFByaWNlIiwiZGlzY291bnRlZF9wcmljZSIsInByaWNlIiwic3RvY2siLCJNYXRoIiwibWluIiwibWF4IiwiZmluYWxTdGF0cyIsInZhbHVlcyIsImJyYW5kUHJvZHVjdHMiLCJwIiwidG90YWxQcmljZSIsInJlZHVjZSIsInN1bSIsInJvdW5kIl0sIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDLHNDQUFzQzs7Ozs7Ozs7Ozs7O1FBc0JoQkE7ZUFBQUE7O1FBMEZBQztlQUFBQTs7O3dCQTlHb0I7MEJBQ2E7QUFtQmhELGVBQWVELElBQUlFLE9BQW9CO0lBQzVDLElBQUk7UUFDRixNQUFNLEVBQUVDLFlBQVksRUFBRSxHQUFHLElBQUlDLElBQUlG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