6936d8fa499f9cd03af1ca05d43919f5
/**
 * Tests para la migración de autenticación de headers a getAuth(req)
 * Verifica que el sistema migrado funciona correctamente
 */ // Mock de Clerk
"use strict";
jest.mock('@clerk/nextjs/server', ()=>({
        getAuth: jest.fn(),
        auth: jest.fn()
    }));
// Mock de Supabase
jest.mock('@/lib/supabase', ()=>({
        supabaseAdmin: {
            from: jest.fn(()=>({
                    select: jest.fn(()=>({
                            eq: jest.fn(()=>({
                                    single: jest.fn()
                                }))
                        }))
                }))
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _adminauth = require("../lib/auth/admin-auth");
const _server = require("@clerk/nextjs/server");
describe('Migración de Autenticación', ()=>{
    let mockGetAuth;
    let mockAuth;
    beforeEach(()=>{
        mockGetAuth = _server.getAuth;
        mockAuth = _server.auth;
        jest.clearAllMocks();
    });
    describe('getAuthenticatedUser (migrado)', ()=>{
        it('debe usar getAuth para NextApiRequest', async ()=>{
            const mockRequest = {
                query: {},
                headers: {}
            };
            mockGetAuth.mockReturnValue({
                userId: 'user_123',
                sessionId: 'sess_123',
                getToken: jest.fn().mockResolvedValue('mock_token')
            });
            const result = await (0, _adminauth.getAuthenticatedUser)(mockRequest);
            expect(mockGetAuth).toHaveBeenCalledWith(mockRequest);
            expect(result.userId).toBe('user_123');
            expect(result.sessionId).toBe('sess_123');
        });
        it('debe usar auth() para App Router', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_456',
                sessionId: 'sess_456',
                sessionClaims: {
                    metadata: {
                        role: 'admin'
                    }
                }
            });
            const result = await (0, _adminauth.getAuthenticatedUser)();
            expect(mockAuth).toHaveBeenCalled();
            expect(result.userId).toBe('user_456');
            expect(result.sessionId).toBe('sess_456');
            expect(result.isAdmin).toBe(true);
        });
        it('debe manejar usuarios no autenticados', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null,
                sessionId: null
            });
            const result = await (0, _adminauth.getAuthenticatedUser)();
            expect(result.userId).toBeNull();
            expect(result.error).toBe('Usuario no autenticado');
        });
        it('debe manejar errores de autenticación', async ()=>{
            mockAuth.mockRejectedValue(new Error('Auth error'));
            const result = await (0, _adminauth.getAuthenticatedUser)();
            expect(result.userId).toBeNull();
            expect(result.error).toContain('Error de autenticación');
        });
    });
    describe('getAuthenticatedAdmin (nueva función)', ()=>{
        it('debe combinar autenticación y verificación de admin', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'admin_123',
                sessionId: 'sess_123',
                sessionClaims: {
                    metadata: {
                        role: 'admin'
                    }
                }
            });
            const result = await (0, _adminauth.getAuthenticatedAdmin)();
            expect(result.userId).toBe('admin_123');
            expect(result.isAdmin).toBe(true);
            expect(result.sessionId).toBe('sess_123');
        });
        it('debe rechazar usuarios no admin', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123',
                sessionId: 'sess_123',
                sessionClaims: {
                    metadata: {
                        role: 'user'
                    }
                }
            });
            const result = await (0, _adminauth.getAuthenticatedAdmin)();
            expect(result.userId).toBe('user_123');
            expect(result.isAdmin).toBe(false);
            expect(result.error).toBe('Permisos de administrador requeridos');
            expect(result.status).toBe(403);
        });
        it('debe manejar usuarios no autenticados', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null,
                sessionId: null
            });
            const result = await (0, _adminauth.getAuthenticatedAdmin)();
            expect(result.userId).toBeNull();
            expect(result.isAdmin).toBe(false);
            expect(result.error).toBe('Usuario no autenticado');
            expect(result.status).toBe(401);
        });
    });
    describe('getAuthFromHeaders (deprecada)', ()=>{
        it('debe marcar como deprecada y funcionar', async ()=>{
            const mockRequest = {
                headers: {
                    get: jest.fn().mockReturnValue('user_123')
                }
            };
            const result = await (0, _adminauth.getAuthFromHeaders)(mockRequest);
            expect(result.userId).toBe('user_123');
            expect(result.deprecated).toBe(true);
        });
        it('debe manejar headers faltantes', async ()=>{
            const mockRequest = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            const result = await (0, _adminauth.getAuthFromHeaders)(mockRequest);
            expect(result.userId).toBeNull();
            expect(result.deprecated).toBe(true);
            expect(result.error).toBe('Header x-clerk-user-id no encontrado');
        });
    });
    describe('Migración completa', ()=>{
        it('debe tener todas las funciones definidas', ()=>{
            expect(typeof _adminauth.getAuthenticatedUser).toBe('function');
            expect(typeof _adminauth.getAuthenticatedAdmin).toBe('function');
            expect(typeof _adminauth.getAuthFromHeaders).toBe('function');
        });
        it('debe retornar estructuras correctas', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123',
                sessionId: 'sess_123',
                sessionClaims: {
                    metadata: {
                        role: 'admin'
                    }
                }
            });
            const userResult = await (0, _adminauth.getAuthenticatedUser)();
            const adminResult = await (0, _adminauth.getAuthenticatedAdmin)();
            // Verificar estructura de getAuthenticatedUser
            expect(userResult).toHaveProperty('userId');
            expect(userResult).toHaveProperty('sessionId');
            expect(userResult).toHaveProperty('isAdmin');
            // Verificar estructura de getAuthenticatedAdmin
            expect(adminResult).toHaveProperty('userId');
            expect(adminResult).toHaveProperty('sessionId');
            expect(adminResult).toHaveProperty('isAdmin');
            expect(adminResult).toHaveProperty('status');
        });
        it('debe manejar diferentes tipos de request', async ()=>{
            // Test con NextApiRequest
            const apiRequest = {
                query: {},
                headers: {}
            };
            mockGetAuth.mockReturnValue({
                userId: 'user_api',
                sessionId: 'sess_api',
                getToken: jest.fn()
            });
            const apiResult = await (0, _adminauth.getAuthenticatedUser)(apiRequest);
            expect(mockGetAuth).toHaveBeenCalledWith(apiRequest);
            expect(apiResult.userId).toBe('user_api');
            // Test sin request (App Router)
            mockAuth.mockResolvedValue({
                userId: 'user_app',
                sessionId: 'sess_app'
            });
            const appResult = await (0, _adminauth.getAuthenticatedUser)();
            expect(mockAuth).toHaveBeenCalled();
            expect(appResult.userId).toBe('user_app');
        });
    });
    describe('Compatibilidad y migración', ()=>{
        it('debe mantener compatibilidad con APIs existentes', async ()=>{
            // Test que verifica que las APIs migradas siguen funcionando
            mockAuth.mockResolvedValue({
                userId: 'user_123',
                sessionId: 'sess_123'
            });
            const result = await (0, _adminauth.getAuthenticatedUser)();
            // Debe retornar la misma estructura que antes
            expect(result).toHaveProperty('userId');
            expect(result).toHaveProperty('sessionId');
            expect(typeof result.userId).toBe('string');
        });
        it('debe proporcionar información de migración', async ()=>{
            const mockRequest = {
                headers: {
                    get: jest.fn().mockReturnValue('user_123')
                }
            };
            const deprecatedResult = await (0, _adminauth.getAuthFromHeaders)(mockRequest);
            expect(deprecatedResult.deprecated).toBe(true);
            expect(deprecatedResult.userId).toBe('user_123');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxhdXRoLW1pZ3JhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgcGFyYSBsYSBtaWdyYWNpw7NuIGRlIGF1dGVudGljYWNpw7NuIGRlIGhlYWRlcnMgYSBnZXRBdXRoKHJlcSlcbiAqIFZlcmlmaWNhIHF1ZSBlbCBzaXN0ZW1hIG1pZ3JhZG8gZnVuY2lvbmEgY29ycmVjdGFtZW50ZVxuICovXG5cbi8vIE1vY2sgZGUgQ2xlcmtcbmplc3QubW9jaygnQGNsZXJrL25leHRqcy9zZXJ2ZXInLCAoKSA9PiAoe1xuICBnZXRBdXRoOiBqZXN0LmZuKCksXG4gIGF1dGg6IGplc3QuZm4oKVxufSkpO1xuXG4vLyBNb2NrIGRlIFN1cGFiYXNlXG5qZXN0Lm1vY2soJ0AvbGliL3N1cGFiYXNlJywgKCkgPT4gKHtcbiAgc3VwYWJhc2VBZG1pbjoge1xuICAgIGZyb206IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBlcTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpXG4gICAgICAgIH0pKVxuICAgICAgfSkpXG4gICAgfSkpXG4gIH1cbn0pKTtcblxuaW1wb3J0IHtcbiAgZ2V0QXV0aGVudGljYXRlZFVzZXIsXG4gIGdldEF1dGhlbnRpY2F0ZWRBZG1pbixcbiAgZ2V0QXV0aEZyb21IZWFkZXJzXG59IGZyb20gJ0AvbGliL2F1dGgvYWRtaW4tYXV0aCc7XG5pbXBvcnQgeyBnZXRBdXRoLCBhdXRoIH0gZnJvbSAnQGNsZXJrL25leHRqcy9zZXJ2ZXInO1xuXG5kZXNjcmliZSgnTWlncmFjacOzbiBkZSBBdXRlbnRpY2FjacOzbicsICgpID0+IHtcbiAgbGV0IG1vY2tHZXRBdXRoOiBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBnZXRBdXRoPjtcbiAgbGV0IG1vY2tBdXRoOiBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBhdXRoPjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrR2V0QXV0aCA9IGdldEF1dGggYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZ2V0QXV0aD47XG4gICAgbW9ja0F1dGggPSBhdXRoIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGF1dGg+O1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0QXV0aGVudGljYXRlZFVzZXIgKG1pZ3JhZG8pJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIHVzYXIgZ2V0QXV0aCBwYXJhIE5leHRBcGlSZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgaGVhZGVyczoge31cbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBtb2NrR2V0QXV0aC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2VySWQ6ICd1c2VyXzEyMycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3NfMTIzJyxcbiAgICAgICAgZ2V0VG9rZW46IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnbW9ja190b2tlbicpXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZFVzZXIobW9ja1JlcXVlc3QpO1xuXG4gICAgICBleHBlY3QobW9ja0dldEF1dGgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tSZXF1ZXN0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCd1c2VyXzEyMycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zZXNzaW9uSWQpLnRvQmUoJ3Nlc3NfMTIzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSB1c2FyIGF1dGgoKSBwYXJhIEFwcCBSb3V0ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogJ3VzZXJfNDU2JyxcbiAgICAgICAgc2Vzc2lvbklkOiAnc2Vzc180NTYnLFxuICAgICAgICBzZXNzaW9uQ2xhaW1zOiB7XG4gICAgICAgICAgbWV0YWRhdGE6IHsgcm9sZTogJ2FkbWluJyB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBdXRoZW50aWNhdGVkVXNlcigpO1xuXG4gICAgICBleHBlY3QobW9ja0F1dGgpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCd1c2VyXzQ1NicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zZXNzaW9uSWQpLnRvQmUoJ3Nlc3NfNDU2Jyk7XG4gICAgICBleHBlY3QocmVzdWx0LmlzQWRtaW4pLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIHVzdWFyaW9zIG5vIGF1dGVudGljYWRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgdXNlcklkOiBudWxsLFxuICAgICAgICBzZXNzaW9uSWQ6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBdXRoZW50aWNhdGVkVXNlcigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnVzZXJJZCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoJ1VzdWFyaW8gbm8gYXV0ZW50aWNhZG8nKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIG1hbmVqYXIgZXJyb3JlcyBkZSBhdXRlbnRpY2FjacOzbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBdXRoLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQXV0aCBlcnJvcicpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZFVzZXIoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC51c2VySWQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oJ0Vycm9yIGRlIGF1dGVudGljYWNpw7NuJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRBdXRoZW50aWNhdGVkQWRtaW4gKG51ZXZhIGZ1bmNpw7NuKScsICgpID0+IHtcbiAgICBpdCgnZGViZSBjb21iaW5hciBhdXRlbnRpY2FjacOzbiB5IHZlcmlmaWNhY2nDs24gZGUgYWRtaW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogJ2FkbWluXzEyMycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3NfMTIzJyxcbiAgICAgICAgc2Vzc2lvbkNsYWltczoge1xuICAgICAgICAgIG1ldGFkYXRhOiB7IHJvbGU6ICdhZG1pbicgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZEFkbWluKCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCdhZG1pbl8xMjMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuaXNBZG1pbikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc2Vzc2lvbklkKS50b0JlKCdzZXNzXzEyMycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgcmVjaGF6YXIgdXN1YXJpb3Mgbm8gYWRtaW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgc2Vzc2lvbklkOiAnc2Vzc18xMjMnLFxuICAgICAgICBzZXNzaW9uQ2xhaW1zOiB7XG4gICAgICAgICAgbWV0YWRhdGE6IHsgcm9sZTogJ3VzZXInIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEF1dGhlbnRpY2F0ZWRBZG1pbigpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnVzZXJJZCkudG9CZSgndXNlcl8xMjMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuaXNBZG1pbikudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKCdQZXJtaXNvcyBkZSBhZG1pbmlzdHJhZG9yIHJlcXVlcmlkb3MnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKDQwMyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIHVzdWFyaW9zIG5vIGF1dGVudGljYWRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgdXNlcklkOiBudWxsLFxuICAgICAgICBzZXNzaW9uSWQ6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBdXRoZW50aWNhdGVkQWRtaW4oKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC51c2VySWQpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmlzQWRtaW4pLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZSgnVXN1YXJpbyBubyBhdXRlbnRpY2FkbycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEF1dGhGcm9tSGVhZGVycyAoZGVwcmVjYWRhKScsICgpID0+IHtcbiAgICBpdCgnZGViZSBtYXJjYXIgY29tbyBkZXByZWNhZGEgeSBmdW5jaW9uYXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgndXNlcl8xMjMnKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXV0aEZyb21IZWFkZXJzKG1vY2tSZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC51c2VySWQpLnRvQmUoJ3VzZXJfMTIzJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmRlcHJlY2F0ZWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIGhlYWRlcnMgZmFsdGFudGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobnVsbClcbiAgICAgICAgfVxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEF1dGhGcm9tSGVhZGVycyhtb2NrUmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kZXByZWNhdGVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZSgnSGVhZGVyIHgtY2xlcmstdXNlci1pZCBubyBlbmNvbnRyYWRvJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNaWdyYWNpw7NuIGNvbXBsZXRhJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIHRlbmVyIHRvZGFzIGxhcyBmdW5jaW9uZXMgZGVmaW5pZGFzJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KHR5cGVvZiBnZXRBdXRoZW50aWNhdGVkVXNlcikudG9CZSgnZnVuY3Rpb24nKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgZ2V0QXV0aGVudGljYXRlZEFkbWluKS50b0JlKCdmdW5jdGlvbicpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBnZXRBdXRoRnJvbUhlYWRlcnMpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSByZXRvcm5hciBlc3RydWN0dXJhcyBjb3JyZWN0YXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgc2Vzc2lvbklkOiAnc2Vzc18xMjMnLFxuICAgICAgICBzZXNzaW9uQ2xhaW1zOiB7XG4gICAgICAgICAgbWV0YWRhdGE6IHsgcm9sZTogJ2FkbWluJyB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1c2VyUmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZFVzZXIoKTtcbiAgICAgIGNvbnN0IGFkbWluUmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZEFkbWluKCk7XG5cbiAgICAgIC8vIFZlcmlmaWNhciBlc3RydWN0dXJhIGRlIGdldEF1dGhlbnRpY2F0ZWRVc2VyXG4gICAgICBleHBlY3QodXNlclJlc3VsdCkudG9IYXZlUHJvcGVydHkoJ3VzZXJJZCcpO1xuICAgICAgZXhwZWN0KHVzZXJSZXN1bHQpLnRvSGF2ZVByb3BlcnR5KCdzZXNzaW9uSWQnKTtcbiAgICAgIGV4cGVjdCh1c2VyUmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgnaXNBZG1pbicpO1xuXG4gICAgICAvLyBWZXJpZmljYXIgZXN0cnVjdHVyYSBkZSBnZXRBdXRoZW50aWNhdGVkQWRtaW5cbiAgICAgIGV4cGVjdChhZG1pblJlc3VsdCkudG9IYXZlUHJvcGVydHkoJ3VzZXJJZCcpO1xuICAgICAgZXhwZWN0KGFkbWluUmVzdWx0KS50b0hhdmVQcm9wZXJ0eSgnc2Vzc2lvbklkJyk7XG4gICAgICBleHBlY3QoYWRtaW5SZXN1bHQpLnRvSGF2ZVByb3BlcnR5KCdpc0FkbWluJyk7XG4gICAgICBleHBlY3QoYWRtaW5SZXN1bHQpLnRvSGF2ZVByb3BlcnR5KCdzdGF0dXMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIG1hbmVqYXIgZGlmZXJlbnRlcyB0aXBvcyBkZSByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBjb24gTmV4dEFwaVJlcXVlc3RcbiAgICAgIGNvbnN0IGFwaVJlcXVlc3QgPSB7IHF1ZXJ5OiB7fSwgaGVhZGVyczoge30gfSBhcyBhbnk7XG4gICAgICBtb2NrR2V0QXV0aC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2VySWQ6ICd1c2VyX2FwaScsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3NfYXBpJyxcbiAgICAgICAgZ2V0VG9rZW46IGplc3QuZm4oKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFwaVJlc3VsdCA9IGF3YWl0IGdldEF1dGhlbnRpY2F0ZWRVc2VyKGFwaVJlcXVlc3QpO1xuICAgICAgZXhwZWN0KG1vY2tHZXRBdXRoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChhcGlSZXF1ZXN0KTtcbiAgICAgIGV4cGVjdChhcGlSZXN1bHQudXNlcklkKS50b0JlKCd1c2VyX2FwaScpO1xuXG4gICAgICAvLyBUZXN0IHNpbiByZXF1ZXN0IChBcHAgUm91dGVyKVxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICB1c2VySWQ6ICd1c2VyX2FwcCcsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3NfYXBwJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFwcFJlc3VsdCA9IGF3YWl0IGdldEF1dGhlbnRpY2F0ZWRVc2VyKCk7XG4gICAgICBleHBlY3QobW9ja0F1dGgpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChhcHBSZXN1bHQudXNlcklkKS50b0JlKCd1c2VyX2FwcCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcGF0aWJpbGlkYWQgeSBtaWdyYWNpw7NuJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIG1hbnRlbmVyIGNvbXBhdGliaWxpZGFkIGNvbiBBUElzIGV4aXN0ZW50ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBUZXN0IHF1ZSB2ZXJpZmljYSBxdWUgbGFzIEFQSXMgbWlncmFkYXMgc2lndWVuIGZ1bmNpb25hbmRvXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgc2Vzc2lvbklkOiAnc2Vzc18xMjMnXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZFVzZXIoKTtcbiAgICAgIFxuICAgICAgLy8gRGViZSByZXRvcm5hciBsYSBtaXNtYSBlc3RydWN0dXJhIHF1ZSBhbnRlc1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlUHJvcGVydHkoJ3VzZXJJZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlUHJvcGVydHkoJ3Nlc3Npb25JZCcpO1xuICAgICAgZXhwZWN0KHR5cGVvZiByZXN1bHQudXNlcklkKS50b0JlKCdzdHJpbmcnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIHByb3BvcmNpb25hciBpbmZvcm1hY2nDs24gZGUgbWlncmFjacOzbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCd1c2VyXzEyMycpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBjb25zdCBkZXByZWNhdGVkUmVzdWx0ID0gYXdhaXQgZ2V0QXV0aEZyb21IZWFkZXJzKG1vY2tSZXF1ZXN0KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGRlcHJlY2F0ZWRSZXN1bHQuZGVwcmVjYXRlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChkZXByZWNhdGVkUmVzdWx0LnVzZXJJZCkudG9CZSgndXNlcl8xMjMnKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImdldEF1dGgiLCJmbiIsImF1dGgiLCJzdXBhYmFzZUFkbWluIiwiZnJvbSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwiZGVzY3JpYmUiLCJtb2NrR2V0QXV0aCIsIm1vY2tBdXRoIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsIm1vY2tSZXF1ZXN0IiwicXVlcnkiLCJoZWFkZXJzIiwibW9ja1JldHVyblZhbHVlIiwidXNlcklkIiwic2Vzc2lvbklkIiwiZ2V0VG9rZW4iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInJlc3VsdCIsImdldEF1dGhlbnRpY2F0ZWRVc2VyIiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0JlIiwic2Vzc2lvbkNsYWltcyIsIm1ldGFkYXRhIiwicm9sZSIsInRvSGF2ZUJlZW5DYWxsZWQiLCJpc0FkbWluIiwidG9CZU51bGwiLCJlcnJvciIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJ0b0NvbnRhaW4iLCJnZXRBdXRoZW50aWNhdGVkQWRtaW4iLCJzdGF0dXMiLCJnZXQiLCJnZXRBdXRoRnJvbUhlYWRlcnMiLCJkZXByZWNhdGVkIiwidXNlclJlc3VsdCIsImFkbWluUmVzdWx0IiwidG9IYXZlUHJvcGVydHkiLCJhcGlSZXF1ZXN0IiwiYXBpUmVzdWx0IiwiYXBwUmVzdWx0IiwiZGVwcmVjYXRlZFJlc3VsdCJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQsZ0JBQWdCOztBQUNoQkEsS0FBS0MsSUFBSSxDQUFDLHdCQUF3QixJQUFPLENBQUE7UUFDdkNDLFNBQVNGLEtBQUtHLEVBQUU7UUFDaEJDLE1BQU1KLEtBQUtHLEVBQUU7SUFDZixDQUFBO0FBRUEsbUJBQW1CO0FBQ25CSCxLQUFLQyxJQUFJLENBQUMsa0JBQWtCLElBQU8sQ0FBQTtRQUNqQ0ksZUFBZTtZQUNiQyxNQUFNTixL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