{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\auth\\session-management.ts"],"sourcesContent":["/**\n * Sistema de Gestión Avanzada de Sesiones\n * Maneja sincronización entre Clerk y Supabase, invalidación automática y cleanup\n */\n\nimport { clerkClient } from '@clerk/nextjs/server';\nimport { supabaseAdmin } from '@/lib/supabase';\nimport { logSecurityEvent, logAdminAction } from './security-audit';\nimport { CacheManager, CACHE_CONFIGS } from '@/lib/cache-manager';\n\n// =====================================================\n// TIPOS Y INTERFACES\n// =====================================================\n\nexport interface SessionData {\n  id: string;\n  user_id: string;\n  clerk_session_id: string;\n  status: SessionStatus;\n  created_at: string;\n  updated_at: string;\n  expires_at: string;\n  last_activity: string;\n  ip_address?: string;\n  user_agent?: string;\n  device_info?: DeviceInfo;\n  metadata?: SessionMetadata;\n}\n\nexport interface DeviceInfo {\n  type: 'desktop' | 'mobile' | 'tablet' | 'unknown';\n  os?: string;\n  browser?: string;\n  version?: string;\n}\n\nexport interface SessionMetadata {\n  login_method?: string;\n  location?: string;\n  timezone?: string;\n  language?: string;\n  features_used?: string[];\n  last_page?: string;\n  session_duration?: number;\n}\n\nexport type SessionStatus = 'active' | 'expired' | 'revoked' | 'invalid';\n\nexport interface SessionSyncResult {\n  success: boolean;\n  action: 'created' | 'updated' | 'deleted' | 'found_existing' | 'error';\n  sessionId?: string;\n  error?: string;\n  details?: Record<string, any>;\n}\n\nexport interface SessionCleanupResult {\n  success: boolean;\n  cleaned: number;\n  errors: number;\n  details: {\n    expired: number;\n    orphaned: number;\n    invalid: number;\n  };\n}\n\n// =====================================================\n// CONFIGURACIÓN\n// =====================================================\n\nconst SESSION_CONFIG = {\n  maxSessionsPerUser: 5,\n  sessionTimeout: 24 * 60 * 60 * 1000, // 24 horas\n  cleanupInterval: 60 * 60 * 1000, // 1 hora\n  maxInactiveTime: 2 * 60 * 60 * 1000, // 2 horas\n  cacheTimeout: 10 * 60 * 1000 // 10 minutos\n};\n\n// =====================================================\n// FUNCIONES DE UTILIDAD\n// =====================================================\n\n/**\n * Extrae información del dispositivo desde User-Agent\n */\nfunction parseDeviceInfo(userAgent?: string): DeviceInfo {\n  if (!userAgent) {\n    return { type: 'unknown' };\n  }\n\n  const ua = userAgent.toLowerCase();\n  \n  // Detectar tipo de dispositivo\n  let type: DeviceInfo['type'] = 'desktop';\n  if (ua.includes('mobile')) type = 'mobile';\n  else if (ua.includes('tablet') || ua.includes('ipad')) type = 'tablet';\n\n  // Detectar OS\n  let os: string | undefined;\n  if (ua.includes('windows')) os = 'Windows';\n  else if (ua.includes('mac')) os = 'macOS';\n  else if (ua.includes('linux')) os = 'Linux';\n  else if (ua.includes('android')) os = 'Android';\n  else if (ua.includes('ios') || ua.includes('iphone')) os = 'iOS';\n\n  // Detectar browser\n  let browser: string | undefined;\n  if (ua.includes('chrome')) browser = 'Chrome';\n  else if (ua.includes('firefox')) browser = 'Firefox';\n  else if (ua.includes('safari')) browser = 'Safari';\n  else if (ua.includes('edge')) browser = 'Edge';\n\n  return { type, os, browser };\n}\n\n/**\n * Genera ID único para sesión\n */\nfunction generateSessionId(): string {\n  return `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Calcula fecha de expiración\n */\nfunction calculateExpirationDate(): string {\n  return new Date(Date.now() + SESSION_CONFIG.sessionTimeout).toISOString();\n}\n\n// =====================================================\n// FUNCIONES PRINCIPALES DE GESTIÓN DE SESIONES\n// =====================================================\n\n/**\n * Crea una nueva sesión en Supabase\n */\nexport async function createSession(\n  userId: string,\n  clerkSessionId: string,\n  request?: Request\n): Promise<SessionSyncResult> {\n  try {\n    console.log(`[SESSION] Creando sesión para usuario ${userId}`);\n\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    // Extraer información de la request\n    const ipAddress = request?.headers.get('x-forwarded-for') || \n                     request?.headers.get('x-real-ip') || \n                     'unknown';\n    const userAgent = request?.headers.get('user-agent') || 'unknown';\n    const deviceInfo = parseDeviceInfo(userAgent);\n\n    // Verificar límite de sesiones por usuario\n    const { data: existingSessions, error: countError } = await supabaseAdmin\n      .from('user_sessions')\n      .select('id')\n      .eq('user_id', userId)\n      .eq('status', 'active');\n\n    if (countError) {\n      throw new Error(`Error verificando sesiones existentes: ${countError.message}`);\n    }\n\n    // Si hay demasiadas sesiones, eliminar las más antiguas\n    if (existingSessions && existingSessions.length >= SESSION_CONFIG.maxSessionsPerUser) {\n      console.log(`[SESSION] Usuario ${userId} tiene ${existingSessions.length} sesiones, limpiando...`);\n      await cleanupOldSessions(userId, SESSION_CONFIG.maxSessionsPerUser - 1);\n    }\n\n    // Crear nueva sesión\n    const sessionData: Omit<SessionData, 'id'> = {\n      user_id: userId,\n      clerk_session_id: clerkSessionId,\n      status: 'active',\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n      expires_at: calculateExpirationDate(),\n      last_activity: new Date().toISOString(),\n      ip_address: ipAddress,\n      user_agent: userAgent,\n      device_info: deviceInfo,\n      metadata: {\n        login_method: 'clerk',\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        session_duration: 0\n      }\n    };\n\n    const { data: newSession, error: insertError } = await supabaseAdmin\n      .from('user_sessions')\n      .insert(sessionData)\n      .select('*')\n      .single();\n\n    if (insertError) {\n      throw new Error(`Error creando sesión: ${insertError.message}`);\n    }\n\n    // Log evento de seguridad\n    await logSecurityEvent({\n      user_id: userId,\n      event_type: 'AUTH_SUCCESS',\n      event_category: 'authentication',\n      severity: 'low',\n      description: 'Nueva sesión creada',\n      metadata: {\n        session_id: newSession.id,\n        clerk_session_id: clerkSessionId,\n        device_info: deviceInfo,\n        ip_address: ipAddress\n      }\n    });\n\n    // Invalidar cache de sesiones del usuario\n    const cache = CacheManager.getInstance();\n    await cache.delete(CACHE_CONFIGS.USER_SESSION, `sessions_${userId}`);\n\n    return {\n      success: true,\n      action: 'created',\n      sessionId: newSession.id,\n      details: { sessionData: newSession }\n    };\n  } catch (error) {\n    console.error('[SESSION] Error creando sesión:', error);\n    \n    await logSecurityEvent({\n      user_id: userId,\n      event_type: 'SECURITY_VIOLATION',\n      event_category: 'authentication',\n      severity: 'medium',\n      description: 'Error creando sesión',\n      metadata: {\n        error: error.message,\n        clerk_session_id: clerkSessionId\n      }\n    });\n\n    return {\n      success: false,\n      action: 'error',\n      error: error.message\n    };\n  }\n}\n\n/**\n * Actualiza una sesión existente\n */\nexport async function updateSession(\n  clerkSessionId: string,\n  updates: Partial<SessionData>\n): Promise<SessionSyncResult> {\n  try {\n    console.log(`[SESSION] Actualizando sesión ${clerkSessionId}`);\n\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    const updateData = {\n      ...updates,\n      updated_at: new Date().toISOString(),\n      last_activity: new Date().toISOString()\n    };\n\n    const { data: updatedSession, error: updateError } = await supabaseAdmin\n      .from('user_sessions')\n      .update(updateData)\n      .eq('clerk_session_id', clerkSessionId)\n      .eq('status', 'active')\n      .select('*')\n      .single();\n\n    if (updateError) {\n      if (updateError.code === 'PGRST116') {\n        return {\n          success: false,\n          action: 'error',\n          error: 'Sesión no encontrada o inactiva'\n        };\n      }\n      throw new Error(`Error actualizando sesión: ${updateError.message}`);\n    }\n\n    // Invalidar cache\n    const cache = CacheManager.getInstance();\n    await cache.delete(CACHE_CONFIGS.USER_SESSION, `sessions_${updatedSession.user_id}`);\n\n    return {\n      success: true,\n      action: 'updated',\n      sessionId: updatedSession.id,\n      details: { sessionData: updatedSession }\n    };\n  } catch (error) {\n    console.error('[SESSION] Error actualizando sesión:', error);\n    return {\n      success: false,\n      action: 'error',\n      error: error.message\n    };\n  }\n}\n\n/**\n * Limpia sesiones antiguas de un usuario\n */\nexport async function cleanupOldSessions(\n  userId: string,\n  keepCount: number = SESSION_CONFIG.maxSessionsPerUser - 1\n): Promise<SessionCleanupResult> {\n  try {\n    console.log(`[SESSION] Limpiando sesiones antiguas para usuario ${userId}`);\n\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    // Obtener sesiones activas ordenadas por última actividad\n    const { data: sessions, error: fetchError } = await supabaseAdmin\n      .from('user_sessions')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('status', 'active')\n      .order('last_activity', { ascending: false });\n\n    if (fetchError) {\n      throw new Error(`Error obteniendo sesiones: ${fetchError.message}`);\n    }\n\n    if (!sessions || sessions.length <= keepCount) {\n      return {\n        success: true,\n        cleaned: 0,\n        errors: 0,\n        details: { expired: 0, orphaned: 0, invalid: 0 }\n      };\n    }\n\n    // Sesiones a eliminar (las más antiguas)\n    const sessionsToRemove = sessions.slice(keepCount);\n    let cleaned = 0;\n    let errors = 0;\n\n    for (const session of sessionsToRemove) {\n      try {\n        const { error: deleteError } = await supabaseAdmin\n          .from('user_sessions')\n          .update({\n            status: 'expired',\n            updated_at: new Date().toISOString(),\n            metadata: {\n              ...session.metadata,\n              expired_at: new Date().toISOString(),\n              expired_reason: 'max_sessions_exceeded'\n            }\n          })\n          .eq('id', session.id);\n\n        if (deleteError) {\n          console.error(`[SESSION] Error eliminando sesión ${session.id}:`, deleteError);\n          errors++;\n        } else {\n          cleaned++;\n        }\n      } catch (error) {\n        console.error(`[SESSION] Error procesando sesión ${session.id}:`, error);\n        errors++;\n      }\n    }\n\n    // Invalidar cache\n    const cache = CacheManager.getInstance();\n    await cache.delete(CACHE_CONFIGS.USER_SESSION, `sessions_${userId}`);\n\n    return {\n      success: errors === 0,\n      cleaned,\n      errors,\n      details: { expired: cleaned, orphaned: 0, invalid: 0 }\n    };\n  } catch (error) {\n    console.error('[SESSION] Error en cleanup de sesiones:', error);\n    return {\n      success: false,\n      cleaned: 0,\n      errors: 1,\n      details: { expired: 0, orphaned: 0, invalid: 0 }\n    };\n  }\n}\n\n/**\n * Cleanup global de sesiones expiradas\n */\nexport async function cleanupExpiredSessions(): Promise<SessionCleanupResult> {\n  try {\n    console.log('[SESSION] Iniciando cleanup global de sesiones expiradas');\n\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    const now = new Date().toISOString();\n    const inactiveThreshold = new Date(Date.now() - SESSION_CONFIG.maxInactiveTime).toISOString();\n\n    // Buscar sesiones expiradas o inactivas\n    const { data: expiredSessions, error: fetchError } = await supabaseAdmin\n      .from('user_sessions')\n      .select('*')\n      .eq('status', 'active')\n      .or(`expires_at.lt.${now},last_activity.lt.${inactiveThreshold}`);\n\n    if (fetchError) {\n      throw new Error(`Error obteniendo sesiones expiradas: ${fetchError.message}`);\n    }\n\n    if (!expiredSessions || expiredSessions.length === 0) {\n      return {\n        success: true,\n        cleaned: 0,\n        errors: 0,\n        details: { expired: 0, orphaned: 0, invalid: 0 }\n      };\n    }\n\n    console.log(`[SESSION] Encontradas ${expiredSessions.length} sesiones para limpiar`);\n\n    let expired = 0;\n    let orphaned = 0;\n    let invalid = 0;\n    let errors = 0;\n\n    for (const session of expiredSessions) {\n      try {\n        // Verificar si la sesión existe en Clerk\n        let isOrphaned = false;\n        try {\n          const client = await clerkClient();\n          await client.sessions.getSession(session.clerk_session_id);\n        } catch (clerkError) {\n          // Sesión no existe en Clerk, es huérfana\n          isOrphaned = true;\n        }\n\n        const reason = isOrphaned ? 'orphaned' :\n                      session.expires_at < now ? 'expired' : 'inactive';\n\n        const { error: updateError } = await supabaseAdmin\n          .from('user_sessions')\n          .update({\n            status: reason === 'orphaned' ? 'invalid' : 'expired',\n            updated_at: new Date().toISOString(),\n            metadata: {\n              ...session.metadata,\n              cleanup_at: new Date().toISOString(),\n              cleanup_reason: reason\n            }\n          })\n          .eq('id', session.id);\n\n        if (updateError) {\n          console.error(`[SESSION] Error actualizando sesión ${session.id}:`, updateError);\n          errors++;\n        } else {\n          if (reason === 'orphaned') orphaned++;\n          else if (reason === 'expired') expired++;\n          else invalid++;\n\n          // Log evento de limpieza\n          await logSecurityEvent({\n            user_id: session.user_id,\n            event_type: 'ADMIN_ACTION',\n            event_category: 'admin_operations',\n            severity: 'low',\n            description: `Sesión limpiada: ${reason}`,\n            metadata: {\n              session_id: session.id,\n              clerk_session_id: session.clerk_session_id,\n              cleanup_reason: reason\n            }\n          });\n        }\n      } catch (error) {\n        console.error(`[SESSION] Error procesando sesión ${session.id}:`, error);\n        errors++;\n      }\n    }\n\n    console.log(`[SESSION] Cleanup completado: ${expired + orphaned + invalid} sesiones limpiadas, ${errors} errores`);\n\n    return {\n      success: errors === 0,\n      cleaned: expired + orphaned + invalid,\n      errors,\n      details: { expired, orphaned, invalid }\n    };\n  } catch (error) {\n    console.error('[SESSION] Error en cleanup global:', error);\n    return {\n      success: false,\n      cleaned: 0,\n      errors: 1,\n      details: { expired: 0, orphaned: 0, invalid: 0 }\n    };\n  }\n}\n\n/**\n * Sincroniza sesiones entre Clerk y Supabase\n */\nexport async function syncSessionsWithClerk(userId: string): Promise<SessionSyncResult> {\n  try {\n    console.log(`[SESSION] Sincronizando sesiones de Clerk para usuario ${userId}`);\n\n    const client = await clerkClient();\n    const clerkSessions = await client.users.getUserList({\n      userId: [userId]\n    });\n\n    if (!clerkSessions || clerkSessions.length === 0) {\n      return {\n        success: false,\n        action: 'error',\n        error: 'Usuario no encontrado en Clerk'\n      };\n    }\n\n    const user = clerkSessions[0];\n    const activeSessions = user.sessions?.filter(s => s.status === 'active') || [];\n\n    // Obtener sesiones de Supabase\n    const { data: supabaseSessions, error: fetchError } = await supabaseAdmin\n      .from('user_sessions')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('status', 'active');\n\n    if (fetchError) {\n      throw new Error(`Error obteniendo sesiones de Supabase: ${fetchError.message}`);\n    }\n\n    const supabaseSessionIds = new Set(\n      supabaseSessions?.map(s => s.clerk_session_id) || []\n    );\n    const clerkSessionIds = new Set(activeSessions.map(s => s.id));\n\n    // Invalidar sesiones que no existen en Clerk\n    const orphanedSessions = supabaseSessions?.filter(\n      s => !clerkSessionIds.has(s.clerk_session_id)\n    ) || [];\n\n    for (const session of orphanedSessions) {\n      await invalidateSession(session.clerk_session_id, 'clerk_sync_orphaned');\n    }\n\n    // Crear sesiones que existen en Clerk pero no en Supabase\n    const missingSessions = activeSessions.filter(\n      s => !supabaseSessionIds.has(s.id)\n    );\n\n    for (const session of missingSessions) {\n      await createSession(userId, session.id);\n    }\n\n    return {\n      success: true,\n      action: 'updated',\n      details: {\n        orphaned_cleaned: orphanedSessions.length,\n        missing_created: missingSessions.length,\n        total_active: activeSessions.length\n      }\n    };\n  } catch (error) {\n    console.error('[SESSION] Error sincronizando con Clerk:', error);\n    return {\n      success: false,\n      action: 'error',\n      error: error.message\n    };\n  }\n}\n\n// =====================================================\n// FUNCIONES DE CONSULTA Y UTILIDADES\n// =====================================================\n\n/**\n * Obtiene sesiones activas de un usuario\n */\nexport async function getUserSessions(userId: string): Promise<SessionData[]> {\n  try {\n    const cache = CacheManager.getInstance();\n    const cacheKey = `sessions_${userId}`;\n\n    // Intentar obtener desde cache\n    const cached = await cache.get(CACHE_CONFIGS.USER_SESSION, cacheKey);\n    if (cached) {\n      return cached as SessionData[];\n    }\n\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    const { data: sessions, error } = await supabaseAdmin\n      .from('user_sessions')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('status', 'active')\n      .order('last_activity', { ascending: false });\n\n    if (error) {\n      throw new Error(`Error obteniendo sesiones: ${error.message}`);\n    }\n\n    const sessionsData = sessions || [];\n\n    // Guardar en cache\n    await cache.set(CACHE_CONFIGS.USER_SESSION, cacheKey, sessionsData);\n\n    return sessionsData;\n  } catch (error) {\n    console.error('[SESSION] Error obteniendo sesiones de usuario:', error);\n    return [];\n  }\n}\n\n/**\n * Obtiene información de una sesión específica\n */\nexport async function getSessionInfo(clerkSessionId: string): Promise<SessionData | null> {\n  try {\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    const { data: session, error } = await supabaseAdmin\n      .from('user_sessions')\n      .select('*')\n      .eq('clerk_session_id', clerkSessionId)\n      .single();\n\n    if (error) {\n      if (error.code === 'PGRST116') {\n        return null; // Sesión no encontrada\n      }\n      throw new Error(`Error obteniendo sesión: ${error.message}`);\n    }\n\n    return session;\n  } catch (error) {\n    console.error('[SESSION] Error obteniendo información de sesión:', error);\n    return null;\n  }\n}\n\n/**\n * Verifica si una sesión es válida\n */\nexport async function isSessionValid(clerkSessionId: string): Promise<boolean> {\n  try {\n    const session = await getSessionInfo(clerkSessionId);\n\n    if (!session || session.status !== 'active') {\n      return false;\n    }\n\n    const now = new Date();\n    const expiresAt = new Date(session.expires_at);\n    const lastActivity = new Date(session.last_activity);\n    const maxInactive = new Date(now.getTime() - SESSION_CONFIG.maxInactiveTime);\n\n    // Verificar expiración y actividad\n    if (expiresAt < now || lastActivity < maxInactive) {\n      // Invalidar sesión automáticamente\n      await invalidateSession(clerkSessionId, 'auto_expired');\n      return false;\n    }\n\n    return true;\n  } catch (error) {\n    console.error('[SESSION] Error verificando validez de sesión:', error);\n    return false;\n  }\n}\n\n/**\n * Actualiza la última actividad de una sesión\n */\nexport async function updateSessionActivity(\n  clerkSessionId: string,\n  metadata?: Partial<SessionMetadata>\n): Promise<boolean> {\n  try {\n    const updateData: Partial<SessionData> = {\n      last_activity: new Date().toISOString()\n    };\n\n    if (metadata) {\n      const session = await getSessionInfo(clerkSessionId);\n      if (session) {\n        updateData.metadata = {\n          ...session.metadata,\n          ...metadata\n        };\n      }\n    }\n\n    const result = await updateSession(clerkSessionId, updateData);\n    return result.success;\n  } catch (error) {\n    console.error('[SESSION] Error actualizando actividad de sesión:', error);\n    return false;\n  }\n}\n\n/**\n * Invalida todas las sesiones de un usuario\n */\nexport async function invalidateAllUserSessions(\n  userId: string,\n  reason: string = 'security_action'\n): Promise<SessionCleanupResult> {\n  try {\n    console.log(`[SESSION] Invalidando todas las sesiones del usuario ${userId}`);\n\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    const { data: sessions, error: fetchError } = await supabaseAdmin\n      .from('user_sessions')\n      .select('*')\n      .eq('user_id', userId)\n      .eq('status', 'active');\n\n    if (fetchError) {\n      throw new Error(`Error obteniendo sesiones: ${fetchError.message}`);\n    }\n\n    if (!sessions || sessions.length === 0) {\n      return {\n        success: true,\n        cleaned: 0,\n        errors: 0,\n        details: { expired: 0, orphaned: 0, invalid: 0 }\n      };\n    }\n\n    let cleaned = 0;\n    let errors = 0;\n\n    for (const session of sessions) {\n      const result = await invalidateSession(session.clerk_session_id, reason);\n      if (result.success) {\n        cleaned++;\n      } else {\n        errors++;\n      }\n    }\n\n    // Log acción administrativa\n    await logAdminAction(\n      userId,\n      'INVALIDATE_ALL_SESSIONS',\n      'user_sessions',\n      {\n        userId,\n        userRole: 'system',\n        permissions: {},\n        metadata: { source: 'session_management' }\n      },\n      {\n        reason,\n        sessions_invalidated: cleaned,\n        errors\n      }\n    );\n\n    return {\n      success: errors === 0,\n      cleaned,\n      errors,\n      details: { expired: 0, orphaned: 0, invalid: cleaned }\n    };\n  } catch (error) {\n    console.error('[SESSION] Error invalidando todas las sesiones:', error);\n    return {\n      success: false,\n      cleaned: 0,\n      errors: 1,\n      details: { expired: 0, orphaned: 0, invalid: 0 }\n    };\n  }\n}\n\n/**\n * Obtiene estadísticas de sesiones\n */\nexport async function getSessionStats(): Promise<{\n  total: number;\n  active: number;\n  expired: number;\n  revoked: number;\n  invalid: number;\n  byDevice: Record<string, number>;\n}> {\n  try {\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    const { data: sessions, error } = await supabaseAdmin\n      .from('user_sessions')\n      .select('status, device_info');\n\n    if (error) {\n      throw new Error(`Error obteniendo estadísticas: ${error.message}`);\n    }\n\n    const stats = {\n      total: sessions?.length || 0,\n      active: 0,\n      expired: 0,\n      revoked: 0,\n      invalid: 0,\n      byDevice: {} as Record<string, number>\n    };\n\n    sessions?.forEach(session => {\n      // Contar por status\n      switch (session.status) {\n        case 'active':\n          stats.active++;\n          break;\n        case 'expired':\n          stats.expired++;\n          break;\n        case 'revoked':\n          stats.revoked++;\n          break;\n        case 'invalid':\n          stats.invalid++;\n          break;\n      }\n\n      // Contar por dispositivo\n      const deviceType = session.device_info?.type || 'unknown';\n      stats.byDevice[deviceType] = (stats.byDevice[deviceType] || 0) + 1;\n    });\n\n    return stats;\n  } catch (error) {\n    console.error('[SESSION] Error obteniendo estadísticas:', error);\n    return {\n      total: 0,\n      active: 0,\n      expired: 0,\n      revoked: 0,\n      invalid: 0,\n      byDevice: {}\n    };\n  }\n}\n\n// =====================================================\n// FUNCIONES DE INICIALIZACIÓN Y CLEANUP AUTOMÁTICO\n// =====================================================\n\n/**\n * Inicia el cleanup automático de sesiones\n */\nexport function startSessionCleanup(): NodeJS.Timeout {\n  console.log('[SESSION] Iniciando cleanup automático de sesiones');\n\n  return setInterval(async () => {\n    try {\n      const result = await cleanupExpiredSessions();\n      if (result.cleaned > 0) {\n        console.log(`[SESSION] Cleanup automático: ${result.cleaned} sesiones limpiadas`);\n      }\n    } catch (error) {\n      console.error('[SESSION] Error en cleanup automático:', error);\n    }\n  }, SESSION_CONFIG.cleanupInterval);\n}\n\n/**\n * Detiene el cleanup automático\n */\nexport function stopSessionCleanup(intervalId: NodeJS.Timeout): void {\n  clearInterval(intervalId);\n  console.log('[SESSION] Cleanup automático detenido');\n}\n\n/**\n * Invalida una sesión específica\n */\nexport async function invalidateSession(\n  clerkSessionId: string,\n  reason: string = 'manual_logout'\n): Promise<SessionSyncResult> {\n  try {\n    console.log(`[SESSION] Invalidando sesión ${clerkSessionId} - Razón: ${reason}`);\n\n    if (!supabaseAdmin) {\n      throw new Error('Supabase admin client no disponible');\n    }\n\n    const { data: invalidatedSession, error: updateError } = await supabaseAdmin\n      .from('user_sessions')\n      .update({\n        status: 'revoked',\n        updated_at: new Date().toISOString(),\n        metadata: {\n          revoked_at: new Date().toISOString(),\n          revoked_reason: reason\n        }\n      })\n      .eq('clerk_session_id', clerkSessionId)\n      .select('*')\n      .single();\n\n    if (updateError) {\n      if (updateError.code === 'PGRST116') {\n        return {\n          success: true,\n          action: 'found_existing',\n          details: { message: 'Sesión ya invalidada o no encontrada' }\n        };\n      }\n      throw new Error(`Error invalidando sesión: ${updateError.message}`);\n    }\n\n    // Log evento de seguridad\n    await logSecurityEvent({\n      user_id: invalidatedSession.user_id,\n      event_type: 'AUTH_SUCCESS',\n      event_category: 'authentication',\n      severity: 'low',\n      description: 'Sesión invalidada',\n      metadata: {\n        session_id: invalidatedSession.id,\n        clerk_session_id: clerkSessionId,\n        reason\n      }\n    });\n\n    // Invalidar cache\n    const cache = CacheManager.getInstance();\n    await cache.delete(CACHE_CONFIGS.USER_SESSION, `sessions_${invalidatedSession.user_id}`);\n\n    return {\n      success: true,\n      action: 'deleted',\n      sessionId: invalidatedSession.id,\n      details: { sessionData: invalidatedSession }\n    };\n  } catch (error) {\n    console.error('[SESSION] Error invalidando sesión:', error);\n    return {\n      success: false,\n      action: 'error',\n      error: error.message\n    };\n  }\n}\n"],"names":["cleanupExpiredSessions","cleanupOldSessions","createSession","getSessionInfo","getSessionStats","getUserSessions","invalidateAllUserSessions","invalidateSession","isSessionValid","startSessionCleanup","stopSessionCleanup","syncSessionsWithClerk","updateSession","updateSessionActivity","SESSION_CONFIG","maxSessionsPerUser","sessionTimeout","cleanupInterval","maxInactiveTime","cacheTimeout","parseDeviceInfo","userAgent","type","ua","toLowerCase","includes","os","browser","generateSessionId","Date","now","Math","random","toString","substr","calculateExpirationDate","toISOString","userId","clerkSessionId","request","console","log","supabaseAdmin","Error","ipAddress","headers","get","deviceInfo","data","existingSessions","error","countError","from","select","eq","message","length","sessionData","user_id","clerk_session_id","status","created_at","updated_at","expires_at","last_activity","ip_address","user_agent","device_info","metadata","login_method","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","session_duration","newSession","insertError","insert","single","logSecurityEvent","event_type","event_category","severity","description","session_id","id","cache","CacheManager","getInstance","delete","CACHE_CONFIGS","USER_SESSION","success","action","sessionId","details","updates","updateData","updatedSession","updateError","update","code","keepCount","sessions","fetchError","order","ascending","cleaned","errors","expired","orphaned","invalid","sessionsToRemove","slice","session","deleteError","expired_at","expired_reason","inactiveThreshold","expiredSessions","or","isOrphaned","client","clerkClient","getSession","clerkError","reason","cleanup_at","cleanup_reason","clerkSessions","users","getUserList","user","activeSessions","filter","s","supabaseSessions","supabaseSessionIds","Set","map","clerkSessionIds","orphanedSessions","has","missingSessions","orphaned_cleaned","missing_created","total_active","cacheKey","cached","sessionsData","set","expiresAt","lastActivity","maxInactive","getTime","result","logAdminAction","userRole","permissions","source","sessions_invalidated","stats","total","active","revoked","byDevice","forEach","deviceType","setInterval","intervalId","clearInterval","invalidatedSession","revoked_at","revoked_reason"],"mappings":"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"}