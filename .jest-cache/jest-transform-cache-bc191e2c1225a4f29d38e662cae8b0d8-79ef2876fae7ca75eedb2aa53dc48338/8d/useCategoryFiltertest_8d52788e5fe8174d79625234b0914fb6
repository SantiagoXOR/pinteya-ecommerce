381d1871409959a760feee47ced6972f
/**
 * useCategoryFilter Hook Tests
 * Enterprise-ready test suite for category filter logic
 * Pinteya E-commerce
 */ "use strict";
// Mock Next.js navigation hooks
jest.mock('next/navigation', ()=>({
        useSearchParams: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _navigation = require("next/navigation");
const _useCategoryFilter = require("../../hooks/useCategoryFilter");
// Mock analytics
const mockGtag = jest.fn();
Object.defineProperty(window, 'gtag', {
    value: mockGtag,
    writable: true
});
describe('useCategoryFilter Hook', ()=>{
    const mockGet = jest.fn();
    const mockOnCategoryChange = jest.fn();
    beforeEach(()=>{
        jest.clearAllMocks();
        // Setup search params mock
        _navigation.useSearchParams.mockReturnValue({
            get: mockGet,
            forEach: jest.fn()
        });
        // Reset analytics mock
        mockGtag.mockClear();
    });
    describe('Initialization', ()=>{
        it('initializes with empty array by default', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)());
            expect(result.current.selectedCategories).toEqual([]);
            expect(result.current.selectedCount).toBe(0);
        });
        it('initializes with provided initial categories', ()=>{
            mockGet.mockReturnValue(null);
            const initialCategories = [
                'cat1',
                'cat2'
            ];
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    initialCategories,
                    syncWithUrl: false
                }));
            expect(result.current.selectedCategories).toEqual(initialCategories);
            expect(result.current.selectedCount).toBe(2);
        });
        it('initializes from URL when syncWithUrl is enabled', ()=>{
            const urlCategories = 'cat1,cat2,cat3';
            mockGet.mockReturnValue(urlCategories);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: true
                }));
            expect(result.current.selectedCategories).toEqual([
                'cat1',
                'cat2',
                'cat3'
            ]);
            expect(result.current.selectedCount).toBe(3);
        });
        it('filters out empty categories from URL', ()=>{
            const urlCategories = 'cat1,,cat2,';
            mockGet.mockReturnValue(urlCategories);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: true
                }));
            expect(result.current.selectedCategories).toEqual([
                'cat1',
                'cat2'
            ]);
        });
    });
    describe('Category Selection', ()=>{
        it('toggles category selection correctly', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: false,
                    onCategoryChange: mockOnCategoryChange
                }));
            // Select category
            (0, _react.act)(()=>{
                result.current.toggleCategory('cat1');
            });
            expect(result.current.selectedCategories).toEqual([
                'cat1'
            ]);
            expect(result.current.isSelected('cat1')).toBe(true);
            expect(result.current.selectedCount).toBe(1);
            // Verify callback was called
            expect(mockOnCategoryChange).toHaveBeenCalledWith(expect.objectContaining({
                type: 'select',
                categoryId: 'cat1',
                selectedCategories: [
                    'cat1'
                ],
                previousCategories: []
            }));
        });
        it('deselects already selected category', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    initialCategories: [
                        'cat1'
                    ],
                    syncWithUrl: false,
                    onCategoryChange: mockOnCategoryChange
                }));
            // Deselect category
            (0, _react.act)(()=>{
                result.current.toggleCategory('cat1');
            });
            expect(result.current.selectedCategories).toEqual([]);
            expect(result.current.isSelected('cat1')).toBe(false);
            expect(result.current.selectedCount).toBe(0);
            // Verify callback was called
            expect(mockOnCategoryChange).toHaveBeenCalledWith(expect.objectContaining({
                type: 'deselect',
                categoryId: 'cat1',
                selectedCategories: [],
                previousCategories: [
                    'cat1'
                ]
            }));
        });
        it('respects maximum selections limit', ()=>{
            mockGet.mockReturnValue(null);
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    maxSelections: 2,
                    syncWithUrl: false
                }));
            // Select up to limit
            (0, _react.act)(()=>{
                result.current.toggleCategory('cat1');
                result.current.toggleCategory('cat2');
            });
            expect(result.current.selectedCategories).toEqual([
                'cat1',
                'cat2'
            ]);
            // Try to exceed limit
            (0, _react.act)(()=>{
                result.current.toggleCategory('cat3');
            });
            expect(result.current.selectedCategories).toEqual([
                'cat1',
                'cat2'
            ]);
            expect(consoleSpy).toHaveBeenCalledWith('Maximum 2 categories can be selected');
            consoleSpy.mockRestore();
        });
        it('checks if category is selected correctly', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    initialCategories: [
                        'cat1',
                        'cat2'
                    ],
                    syncWithUrl: false
                }));
            expect(result.current.isSelected('cat1')).toBe(true);
            expect(result.current.isSelected('cat2')).toBe(true);
            expect(result.current.isSelected('cat3')).toBe(false);
        });
    });
    describe('Bulk Operations', ()=>{
        it('clears all selections', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    initialCategories: [
                        'cat1',
                        'cat2'
                    ],
                    syncWithUrl: false,
                    onCategoryChange: mockOnCategoryChange
                }));
            (0, _react.act)(()=>{
                result.current.clearAll();
            });
            expect(result.current.selectedCategories).toEqual([]);
            expect(result.current.selectedCount).toBe(0);
            // Verify callback was called
            expect(mockOnCategoryChange).toHaveBeenCalledWith(expect.objectContaining({
                type: 'clear',
                categoryId: undefined,
                selectedCategories: [],
                previousCategories: [
                    'cat1',
                    'cat2'
                ]
            }));
        });
        it('does not call callback when clearing empty selection', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: false,
                    onCategoryChange: mockOnCategoryChange
                }));
            (0, _react.act)(()=>{
                result.current.clearAll();
            });
            expect(mockOnCategoryChange).not.toHaveBeenCalled();
        });
        it('selects all provided categories', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: false,
                    onCategoryChange: mockOnCategoryChange
                }));
            const categoriesToSelect = [
                'cat1',
                'cat2',
                'cat3'
            ];
            (0, _react.act)(()=>{
                result.current.selectAll(categoriesToSelect);
            });
            expect(result.current.selectedCategories).toEqual(categoriesToSelect);
            expect(result.current.selectedCount).toBe(3);
            // Verify callback was called
            expect(mockOnCategoryChange).toHaveBeenCalledWith(expect.objectContaining({
                type: 'selectAll',
                categoryId: undefined,
                selectedCategories: categoriesToSelect,
                previousCategories: []
            }));
        });
        it('respects max selections when selecting all', ()=>{
            mockGet.mockReturnValue(null);
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    maxSelections: 2,
                    syncWithUrl: false
                }));
            const categoriesToSelect = [
                'cat1',
                'cat2',
                'cat3',
                'cat4'
            ];
            (0, _react.act)(()=>{
                result.current.selectAll(categoriesToSelect);
            });
            expect(result.current.selectedCategories).toEqual([
                'cat1',
                'cat2'
            ]);
            expect(consoleSpy).toHaveBeenCalledWith('Only first 2 categories will be selected');
            consoleSpy.mockRestore();
        });
    });
    describe('Analytics Tracking', ()=>{
        it('tracks analytics when enabled', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: false,
                    enableAnalytics: true
                }));
            (0, _react.act)(()=>{
                result.current.toggleCategory('cat1');
            });
            expect(mockGtag).toHaveBeenCalledWith('event', 'category_filter_change', expect.objectContaining({
                event_category: 'filters',
                event_label: 'cat1',
                value: 1
            }));
        });
        it('does not track analytics when disabled', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: false,
                    enableAnalytics: false
                }));
            (0, _react.act)(()=>{
                result.current.toggleCategory('cat1');
            });
            expect(mockGtag).not.toHaveBeenCalled();
        });
    });
    describe('Performance', ()=>{
        it('maintains referential equality for stable functions', ()=>{
            mockGet.mockReturnValue(null);
            const { result, rerender } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: false
                }));
            const firstRender = {
                toggleCategory: result.current.toggleCategory,
                clearAll: result.current.clearAll,
                selectAll: result.current.selectAll,
                isSelected: result.current.isSelected
            };
            rerender();
            const secondRender = {
                toggleCategory: result.current.toggleCategory,
                clearAll: result.current.clearAll,
                selectAll: result.current.selectAll,
                isSelected: result.current.isSelected
            };
            // Functions should maintain referential equality
            expect(firstRender.toggleCategory).toBe(secondRender.toggleCategory);
            expect(firstRender.clearAll).toBe(secondRender.clearAll);
            expect(firstRender.selectAll).toBe(secondRender.selectAll);
            expect(firstRender.isSelected).toBe(secondRender.isSelected);
        });
    });
    describe('Edge Cases', ()=>{
        it('handles invalid URL parameters gracefully', ()=>{
            mockGet.mockReturnValue('');
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: true
                }));
            expect(result.current.selectedCategories).toEqual([]);
        });
        it('handles null URL parameters', ()=>{
            mockGet.mockReturnValue(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryFilter.useCategoryFilter)({
                    syncWithUrl: true
                }));
            expect(result.current.selectedCategories).toEqual([]);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlQ2F0ZWdvcnlGaWx0ZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHVzZUNhdGVnb3J5RmlsdGVyIEhvb2sgVGVzdHNcbiAqIEVudGVycHJpc2UtcmVhZHkgdGVzdCBzdWl0ZSBmb3IgY2F0ZWdvcnkgZmlsdGVyIGxvZ2ljXG4gKiBQaW50ZXlhIEUtY29tbWVyY2VcbiAqL1xuXG5pbXBvcnQgeyByZW5kZXJIb29rLCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyB1c2VDYXRlZ29yeUZpbHRlciB9IGZyb20gJ0AvaG9va3MvdXNlQ2F0ZWdvcnlGaWx0ZXInO1xuaW1wb3J0IHR5cGUgeyBDYXRlZ29yeUNoYW5nZUV2ZW50IH0gZnJvbSAnQC90eXBlcy9jYXRlZ29yaWVzJztcblxuLy8gTW9jayBOZXh0LmpzIG5hdmlnYXRpb24gaG9va3Ncbmplc3QubW9jaygnbmV4dC9uYXZpZ2F0aW9uJywgKCkgPT4gKHtcbiAgdXNlU2VhcmNoUGFyYW1zOiBqZXN0LmZuKCksXG59KSk7XG5cbi8vIE1vY2sgYW5hbHl0aWNzXG5jb25zdCBtb2NrR3RhZyA9IGplc3QuZm4oKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdndGFnJywge1xuICB2YWx1ZTogbW9ja0d0YWcsXG4gIHdyaXRhYmxlOiB0cnVlLFxufSk7XG5cbmRlc2NyaWJlKCd1c2VDYXRlZ29yeUZpbHRlciBIb29rJywgKCkgPT4ge1xuICBjb25zdCBtb2NrR2V0ID0gamVzdC5mbigpO1xuICBjb25zdCBtb2NrT25DYXRlZ29yeUNoYW5nZSA9IGplc3QuZm4oKTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBcbiAgICAvLyBTZXR1cCBzZWFyY2ggcGFyYW1zIG1vY2tcbiAgICAodXNlU2VhcmNoUGFyYW1zIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIGdldDogbW9ja0dldCxcbiAgICAgIGZvckVhY2g6IGplc3QuZm4oKSxcbiAgICB9KTtcblxuICAgIC8vIFJlc2V0IGFuYWx5dGljcyBtb2NrXG4gICAgbW9ja0d0YWcubW9ja0NsZWFyKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbml0aWFsaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnaW5pdGlhbGl6ZXMgd2l0aCBlbXB0eSBhcnJheSBieSBkZWZhdWx0JywgKCkgPT4ge1xuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUNhdGVnb3J5RmlsdGVyKCkpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDYXRlZ29yaWVzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZWxlY3RlZENvdW50KS50b0JlKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ2luaXRpYWxpemVzIHdpdGggcHJvdmlkZWQgaW5pdGlhbCBjYXRlZ29yaWVzJywgKCkgPT4ge1xuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGluaXRpYWxDYXRlZ29yaWVzID0gWydjYXQxJywgJ2NhdDInXTtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VDYXRlZ29yeUZpbHRlcih7IFxuICAgICAgICAgIGluaXRpYWxDYXRlZ29yaWVzLFxuICAgICAgICAgIHN5bmNXaXRoVXJsOiBmYWxzZSBcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZWxlY3RlZENhdGVnb3JpZXMpLnRvRXF1YWwoaW5pdGlhbENhdGVnb3JpZXMpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnNlbGVjdGVkQ291bnQpLnRvQmUoMik7XG4gICAgfSk7XG5cbiAgICBpdCgnaW5pdGlhbGl6ZXMgZnJvbSBVUkwgd2hlbiBzeW5jV2l0aFVybCBpcyBlbmFibGVkJywgKCkgPT4ge1xuICAgICAgY29uc3QgdXJsQ2F0ZWdvcmllcyA9ICdjYXQxLGNhdDIsY2F0Myc7XG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZSh1cmxDYXRlZ29yaWVzKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RmlsdGVyKHsgc3luY1dpdGhVcmw6IHRydWUgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZWxlY3RlZENhdGVnb3JpZXMpLnRvRXF1YWwoWydjYXQxJywgJ2NhdDInLCAnY2F0MyddKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZWxlY3RlZENvdW50KS50b0JlKDMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ZpbHRlcnMgb3V0IGVtcHR5IGNhdGVnb3JpZXMgZnJvbSBVUkwnLCAoKSA9PiB7XG4gICAgICBjb25zdCB1cmxDYXRlZ29yaWVzID0gJ2NhdDEsLGNhdDIsJztcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKHVybENhdGVnb3JpZXMpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlGaWx0ZXIoeyBzeW5jV2l0aFVybDogdHJ1ZSB9KVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnNlbGVjdGVkQ2F0ZWdvcmllcykudG9FcXVhbChbJ2NhdDEnLCAnY2F0MiddKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhdGVnb3J5IFNlbGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgndG9nZ2xlcyBjYXRlZ29yeSBzZWxlY3Rpb24gY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VDYXRlZ29yeUZpbHRlcih7IFxuICAgICAgICAgIHN5bmNXaXRoVXJsOiBmYWxzZSxcbiAgICAgICAgICBvbkNhdGVnb3J5Q2hhbmdlOiBtb2NrT25DYXRlZ29yeUNoYW5nZSBcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFNlbGVjdCBjYXRlZ29yeVxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQudG9nZ2xlQ2F0ZWdvcnkoJ2NhdDEnKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDYXRlZ29yaWVzKS50b0VxdWFsKFsnY2F0MSddKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1NlbGVjdGVkKCdjYXQxJykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDb3VudCkudG9CZSgxKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGNhbGxiYWNrIHdhcyBjYWxsZWRcbiAgICAgIGV4cGVjdChtb2NrT25DYXRlZ29yeUNoYW5nZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgICBjYXRlZ29yeUlkOiAnY2F0MScsXG4gICAgICAgICAgc2VsZWN0ZWRDYXRlZ29yaWVzOiBbJ2NhdDEnXSxcbiAgICAgICAgICBwcmV2aW91c0NhdGVnb3JpZXM6IFtdLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZXNlbGVjdHMgYWxyZWFkeSBzZWxlY3RlZCBjYXRlZ29yeScsICgpID0+IHtcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKG51bGwpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlGaWx0ZXIoeyBcbiAgICAgICAgICBpbml0aWFsQ2F0ZWdvcmllczogWydjYXQxJ10sXG4gICAgICAgICAgc3luY1dpdGhVcmw6IGZhbHNlLFxuICAgICAgICAgIG9uQ2F0ZWdvcnlDaGFuZ2U6IG1vY2tPbkNhdGVnb3J5Q2hhbmdlIFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gRGVzZWxlY3QgY2F0ZWdvcnlcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnRvZ2dsZUNhdGVnb3J5KCdjYXQxJyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnNlbGVjdGVkQ2F0ZWdvcmllcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTZWxlY3RlZCgnY2F0MScpKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZWxlY3RlZENvdW50KS50b0JlKDApO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgY2FsbGJhY2sgd2FzIGNhbGxlZFxuICAgICAgZXhwZWN0KG1vY2tPbkNhdGVnb3J5Q2hhbmdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6ICdkZXNlbGVjdCcsXG4gICAgICAgICAgY2F0ZWdvcnlJZDogJ2NhdDEnLFxuICAgICAgICAgIHNlbGVjdGVkQ2F0ZWdvcmllczogW10sXG4gICAgICAgICAgcHJldmlvdXNDYXRlZ29yaWVzOiBbJ2NhdDEnXSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVzcGVjdHMgbWF4aW11bSBzZWxlY3Rpb25zIGxpbWl0JywgKCkgPT4ge1xuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlGaWx0ZXIoeyBcbiAgICAgICAgICBtYXhTZWxlY3Rpb25zOiAyLFxuICAgICAgICAgIHN5bmNXaXRoVXJsOiBmYWxzZSBcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFNlbGVjdCB1cCB0byBsaW1pdFxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQudG9nZ2xlQ2F0ZWdvcnkoJ2NhdDEnKTtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQudG9nZ2xlQ2F0ZWdvcnkoJ2NhdDInKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDYXRlZ29yaWVzKS50b0VxdWFsKFsnY2F0MScsICdjYXQyJ10pO1xuICAgICAgXG4gICAgICAvLyBUcnkgdG8gZXhjZWVkIGxpbWl0XG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC50b2dnbGVDYXRlZ29yeSgnY2F0MycpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZWxlY3RlZENhdGVnb3JpZXMpLnRvRXF1YWwoWydjYXQxJywgJ2NhdDInXSk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ01heGltdW0gMiBjYXRlZ29yaWVzIGNhbiBiZSBzZWxlY3RlZCcpO1xuICAgICAgXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnY2hlY2tzIGlmIGNhdGVnb3J5IGlzIHNlbGVjdGVkIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKG51bGwpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlGaWx0ZXIoeyBcbiAgICAgICAgICBpbml0aWFsQ2F0ZWdvcmllczogWydjYXQxJywgJ2NhdDInXSxcbiAgICAgICAgICBzeW5jV2l0aFVybDogZmFsc2UgXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNTZWxlY3RlZCgnY2F0MScpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzU2VsZWN0ZWQoJ2NhdDInKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1NlbGVjdGVkKCdjYXQzJykpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQnVsayBPcGVyYXRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdjbGVhcnMgYWxsIHNlbGVjdGlvbnMnLCAoKSA9PiB7XG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RmlsdGVyKHsgXG4gICAgICAgICAgaW5pdGlhbENhdGVnb3JpZXM6IFsnY2F0MScsICdjYXQyJ10sXG4gICAgICAgICAgc3luY1dpdGhVcmw6IGZhbHNlLFxuICAgICAgICAgIG9uQ2F0ZWdvcnlDaGFuZ2U6IG1vY2tPbkNhdGVnb3J5Q2hhbmdlIFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuY2xlYXJBbGwoKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDYXRlZ29yaWVzKS50b0VxdWFsKFtdKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zZWxlY3RlZENvdW50KS50b0JlKDApO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgY2FsbGJhY2sgd2FzIGNhbGxlZFxuICAgICAgZXhwZWN0KG1vY2tPbkNhdGVnb3J5Q2hhbmdlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6ICdjbGVhcicsXG4gICAgICAgICAgY2F0ZWdvcnlJZDogdW5kZWZpbmVkLFxuICAgICAgICAgIHNlbGVjdGVkQ2F0ZWdvcmllczogW10sXG4gICAgICAgICAgcHJldmlvdXNDYXRlZ29yaWVzOiBbJ2NhdDEnLCAnY2F0MiddLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdkb2VzIG5vdCBjYWxsIGNhbGxiYWNrIHdoZW4gY2xlYXJpbmcgZW1wdHkgc2VsZWN0aW9uJywgKCkgPT4ge1xuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VDYXRlZ29yeUZpbHRlcih7IFxuICAgICAgICAgIHN5bmNXaXRoVXJsOiBmYWxzZSxcbiAgICAgICAgICBvbkNhdGVnb3J5Q2hhbmdlOiBtb2NrT25DYXRlZ29yeUNoYW5nZSBcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmNsZWFyQWxsKCk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tPbkNhdGVnb3J5Q2hhbmdlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3NlbGVjdHMgYWxsIHByb3ZpZGVkIGNhdGVnb3JpZXMnLCAoKSA9PiB7XG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RmlsdGVyKHsgXG4gICAgICAgICAgc3luY1dpdGhVcmw6IGZhbHNlLFxuICAgICAgICAgIG9uQ2F0ZWdvcnlDaGFuZ2U6IG1vY2tPbkNhdGVnb3J5Q2hhbmdlIFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc3QgY2F0ZWdvcmllc1RvU2VsZWN0ID0gWydjYXQxJywgJ2NhdDInLCAnY2F0MyddO1xuICAgICAgXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5zZWxlY3RBbGwoY2F0ZWdvcmllc1RvU2VsZWN0KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDYXRlZ29yaWVzKS50b0VxdWFsKGNhdGVnb3JpZXNUb1NlbGVjdCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDb3VudCkudG9CZSgzKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGNhbGxiYWNrIHdhcyBjYWxsZWRcbiAgICAgIGV4cGVjdChtb2NrT25DYXRlZ29yeUNoYW5nZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICB0eXBlOiAnc2VsZWN0QWxsJyxcbiAgICAgICAgICBjYXRlZ29yeUlkOiB1bmRlZmluZWQsXG4gICAgICAgICAgc2VsZWN0ZWRDYXRlZ29yaWVzOiBjYXRlZ29yaWVzVG9TZWxlY3QsXG4gICAgICAgICAgcHJldmlvdXNDYXRlZ29yaWVzOiBbXSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVzcGVjdHMgbWF4IHNlbGVjdGlvbnMgd2hlbiBzZWxlY3RpbmcgYWxsJywgKCkgPT4ge1xuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlGaWx0ZXIoeyBcbiAgICAgICAgICBtYXhTZWxlY3Rpb25zOiAyLFxuICAgICAgICAgIHN5bmNXaXRoVXJsOiBmYWxzZSBcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNhdGVnb3JpZXNUb1NlbGVjdCA9IFsnY2F0MScsICdjYXQyJywgJ2NhdDMnLCAnY2F0NCddO1xuICAgICAgXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5zZWxlY3RBbGwoY2F0ZWdvcmllc1RvU2VsZWN0KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDYXRlZ29yaWVzKS50b0VxdWFsKFsnY2F0MScsICdjYXQyJ10pO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdPbmx5IGZpcnN0IDIgY2F0ZWdvcmllcyB3aWxsIGJlIHNlbGVjdGVkJyk7XG4gICAgICBcbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FuYWx5dGljcyBUcmFja2luZycsICgpID0+IHtcbiAgICBpdCgndHJhY2tzIGFuYWx5dGljcyB3aGVuIGVuYWJsZWQnLCAoKSA9PiB7XG4gICAgICBtb2NrR2V0Lm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RmlsdGVyKHsgXG4gICAgICAgICAgc3luY1dpdGhVcmw6IGZhbHNlLFxuICAgICAgICAgIGVuYWJsZUFuYWx5dGljczogdHJ1ZSBcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnRvZ2dsZUNhdGVnb3J5KCdjYXQxJyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tHdGFnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ2V2ZW50JyxcbiAgICAgICAgJ2NhdGVnb3J5X2ZpbHRlcl9jaGFuZ2UnLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdmaWx0ZXJzJyxcbiAgICAgICAgICBldmVudF9sYWJlbDogJ2NhdDEnLFxuICAgICAgICAgIHZhbHVlOiAxLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdkb2VzIG5vdCB0cmFjayBhbmFseXRpY3Mgd2hlbiBkaXNhYmxlZCcsICgpID0+IHtcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKG51bGwpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlGaWx0ZXIoeyBcbiAgICAgICAgICBzeW5jV2l0aFVybDogZmFsc2UsXG4gICAgICAgICAgZW5hYmxlQW5hbHl0aWNzOiBmYWxzZSBcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnRvZ2dsZUNhdGVnb3J5KCdjYXQxJyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tHdGFnKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgaXQoJ21haW50YWlucyByZWZlcmVudGlhbCBlcXVhbGl0eSBmb3Igc3RhYmxlIGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgIG1vY2tHZXQubW9ja1JldHVyblZhbHVlKG51bGwpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCwgcmVyZW5kZXIgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RmlsdGVyKHsgc3luY1dpdGhVcmw6IGZhbHNlIH0pXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCBmaXJzdFJlbmRlciA9IHtcbiAgICAgICAgdG9nZ2xlQ2F0ZWdvcnk6IHJlc3VsdC5jdXJyZW50LnRvZ2dsZUNhdGVnb3J5LFxuICAgICAgICBjbGVhckFsbDogcmVzdWx0LmN1cnJlbnQuY2xlYXJBbGwsXG4gICAgICAgIHNlbGVjdEFsbDogcmVzdWx0LmN1cnJlbnQuc2VsZWN0QWxsLFxuICAgICAgICBpc1NlbGVjdGVkOiByZXN1bHQuY3VycmVudC5pc1NlbGVjdGVkLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmVyZW5kZXIoKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2Vjb25kUmVuZGVyID0ge1xuICAgICAgICB0b2dnbGVDYXRlZ29yeTogcmVzdWx0LmN1cnJlbnQudG9nZ2xlQ2F0ZWdvcnksXG4gICAgICAgIGNsZWFyQWxsOiByZXN1bHQuY3VycmVudC5jbGVhckFsbCxcbiAgICAgICAgc2VsZWN0QWxsOiByZXN1bHQuY3VycmVudC5zZWxlY3RBbGwsXG4gICAgICAgIGlzU2VsZWN0ZWQ6IHJlc3VsdC5jdXJyZW50LmlzU2VsZWN0ZWQsXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBGdW5jdGlvbnMgc2hvdWxkIG1haW50YWluIHJlZmVyZW50aWFsIGVxdWFsaXR5XG4gICAgICBleHBlY3QoZmlyc3RSZW5kZXIudG9nZ2xlQ2F0ZWdvcnkpLnRvQmUoc2Vjb25kUmVuZGVyLnRvZ2dsZUNhdGVnb3J5KTtcbiAgICAgIGV4cGVjdChmaXJzdFJlbmRlci5jbGVhckFsbCkudG9CZShzZWNvbmRSZW5kZXIuY2xlYXJBbGwpO1xuICAgICAgZXhwZWN0KGZpcnN0UmVuZGVyLnNlbGVjdEFsbCkudG9CZShzZWNvbmRSZW5kZXIuc2VsZWN0QWxsKTtcbiAgICAgIGV4cGVjdChmaXJzdFJlbmRlci5pc1NlbGVjdGVkKS50b0JlKHNlY29uZFJlbmRlci5pc1NlbGVjdGVkKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgaXQoJ2hhbmRsZXMgaW52YWxpZCBVUkwgcGFyYW1ldGVycyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUoJycpO1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlGaWx0ZXIoeyBzeW5jV2l0aFVybDogdHJ1ZSB9KVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnNlbGVjdGVkQ2F0ZWdvcmllcykudG9FcXVhbChbXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBudWxsIFVSTCBwYXJhbWV0ZXJzJywgKCkgPT4ge1xuICAgICAgbW9ja0dldC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VDYXRlZ29yeUZpbHRlcih7IHN5bmNXaXRoVXJsOiB0cnVlIH0pXG4gICAgICApO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc2VsZWN0ZWRDYXRlZ29yaWVzKS50b0VxdWFsKFtdKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZVNlYXJjaFBhcmFtcyIsImZuIiwibW9ja0d0YWciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndpbmRvdyIsInZhbHVlIiwid3JpdGFibGUiLCJkZXNjcmliZSIsIm1vY2tHZXQiLCJtb2NrT25DYXRlZ29yeUNoYW5nZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja1JldHVyblZhbHVlIiwiZ2V0IiwiZm9yRWFjaCIsIm1vY2tDbGVhciIsIml0IiwicmVzdWx0IiwicmVuZGVySG9vayIsInVzZUNhdGVnb3J5RmlsdGVyIiwiZXhwZWN0IiwiY3VycmVudCIsInNlbGVjdGVkQ2F0ZWdvcmllcyIsInRvRXF1YWwiLCJzZWxlY3RlZENvdW50IiwidG9CZSIsImluaXRpYWxDYXRlZ29yaWVzIiwic3luY1dpdGhVcmwiLCJ1cmxDYXRlZ29yaWVzIiwib25DYXRlZ29yeUNoYW5nZSIsImFjdCIsInRvZ2dsZUNhdGVnb3J5IiwiaXNTZWxlY3RlZCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib2JqZWN0Q29udGFpbmluZyIsInR5cGUiLCJjYXRlZ29yeUlkIiwicHJldmlvdXNDYXRlZ29yaWVzIiwiY29uc29sZVNweSIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIm1heFNlbGVjdGlvbnMiLCJtb2NrUmVzdG9yZSIsImNsZWFyQWxsIiwidW5kZWZpbmVkIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsImNhdGVnb3JpZXNUb1NlbGVjdCIsInNlbGVjdEFsbCIsImVuYWJsZUFuYWx5dGljcyIsImV2ZW50X2NhdGVnb3J5IiwiZXZlbnRfbGFiZWwiLCJyZXJlbmRlciIsImZpcnN0UmVuZGVyIiwic2Vjb25kUmVuZGVyIl0sIm1h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