a99bdedb3be86b3587f3a56f02a96b74
/**
 * Tests para Sistema Enterprise de Auditoría de Seguridad
 * Valida funcionalidad completa del sistema de auditoría, detección de anomalías y gestión de incidentes
 */ // Mock de dependencias
"use strict";
jest.mock('@/lib/supabase', ()=>({
        supabaseAdmin: {
            from: jest.fn(()=>({
                    select: jest.fn(()=>({
                            eq: jest.fn(()=>({
                                    single: jest.fn(),
                                    range: jest.fn(()=>({
                                            order: jest.fn()
                                        }))
                                })),
                            insert: jest.fn(()=>({
                                    select: jest.fn(()=>({
                                            single: jest.fn()
                                        }))
                                })),
                            update: jest.fn(()=>({
                                    eq: jest.fn(()=>({
                                            select: jest.fn(()=>({
                                                    single: jest.fn()
                                                }))
                                        }))
                                })),
                            order: jest.fn(()=>({
                                    range: jest.fn()
                                })),
                            not: jest.fn(()=>({
                                    filter: jest.fn()
                                }))
                        }))
                }))
        }
    }));
jest.mock('@/lib/auth/security-audit', ()=>({
        logSecurityEvent: jest.fn()
    }));
jest.mock('@/lib/auth/security-audit-enhanced', ()=>({
        analyzeSecurityPatterns: jest.fn(),
        getSecurityMetrics: jest.fn(),
        generateSecurityReport: jest.fn()
    }));
jest.mock('@/lib/rate-limiting/enterprise-rate-limiter', ()=>({
        metricsCollector: {
            getMetrics: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _enterpriseauditsystem = require("../../lib/security/enterprise-audit-system");
const _securityaudit = require("../../lib/auth/security-audit");
const _securityauditenhanced = require("../../lib/auth/security-audit-enhanced");
const _enterpriseratelimiter = require("../../lib/rate-limiting/enterprise-rate-limiter");
describe('Sistema Enterprise de Auditoría de Seguridad', ()=>{
    let mockLogSecurityEvent;
    let mockAnalyzeSecurityPatterns;
    let mockGetSecurityMetrics;
    let mockGetMetrics;
    beforeEach(()=>{
        mockLogSecurityEvent = _securityaudit.logSecurityEvent;
        mockAnalyzeSecurityPatterns = _securityauditenhanced.analyzeSecurityPatterns;
        mockGetSecurityMetrics = _securityauditenhanced.getSecurityMetrics;
        mockGetMetrics = _enterpriseratelimiter.metricsCollector.getMetrics;
        jest.clearAllMocks();
        // Setup default mocks
        mockLogSecurityEvent.mockResolvedValue(undefined);
        mockAnalyzeSecurityPatterns.mockResolvedValue([]);
        mockGetSecurityMetrics.mockResolvedValue({
            total_events: 100,
            critical_events: 5,
            failed_logins: 10,
            suspicious_activities: 3,
            blocked_ips: 2,
            security_alerts: 8
        });
        mockGetMetrics.mockReturnValue({
            totalRequests: 1000,
            allowedRequests: 950,
            blockedRequests: 50,
            redisHits: 900,
            memoryFallbacks: 100,
            errors: 5,
            averageResponseTime: 45,
            topBlockedIPs: [
                {
                    ip: '192.168.1.100',
                    count: 25
                },
                {
                    ip: '10.0.0.50',
                    count: 15
                }
            ],
            topEndpoints: [
                {
                    endpoint: '/api/admin',
                    count: 30
                },
                {
                    endpoint: '/api/payments',
                    count: 20
                }
            ]
        });
    });
    describe('Configuración Enterprise', ()=>{
        it('debe tener configuración de retención de datos', ()=>{
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DATA_RETENTION).toBeDefined();
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DATA_RETENTION.security_events).toBe(365);
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DATA_RETENTION.anomalies).toBe(180);
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DATA_RETENTION.incidents).toBe(1095);
        });
        it('debe tener umbrales de detección configurados', ()=>{
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DETECTION_THRESHOLDS).toBeDefined();
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DETECTION_THRESHOLDS.anomaly_confidence).toBe(0.7);
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DETECTION_THRESHOLDS.risk_score_critical).toBe(80);
        });
        it('debe tener configuración de alertas', ()=>{
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.ALERT_CONFIG).toBeDefined();
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.ALERT_CONFIG.immediate_notification).toContain('critical');
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.ALERT_CONFIG.notification_cooldown).toBe(300);
        });
    });
    describe('Registro de Eventos Enterprise', ()=>{
        it('debe registrar evento enterprise con contexto completo', async ()=>{
            const mockContext = {
                userId: 'user_123',
                sessionId: 'sess_123',
                email: 'test@example.com',
                role: 'admin',
                permissions: [
                    'admin_access'
                ],
                sessionValid: true,
                securityLevel: 'high',
                ipAddress: '192.168.1.1',
                userAgent: 'test-agent',
                supabase: {},
                validations: {
                    jwtValid: true,
                    csrfValid: true,
                    rateLimitPassed: true,
                    originValid: true
                }
            };
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.1'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const event = {
                user_id: 'user_123',
                event_type: 'AUTH_SUCCESS',
                event_category: 'authentication',
                severity: 'low',
                description: 'Usuario autenticado correctamente',
                metadata: {
                    method: 'clerk'
                },
                ip_address: '192.168.1.1',
                user_agent: 'test-agent'
            };
            const correlationId = await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent(event, mockContext, mockRequest);
            expect(correlationId).toBeDefined();
            expect(correlationId).toMatch(/^corr_\d+_[a-z0-9]+$/);
            expect(mockLogSecurityEvent).toHaveBeenCalledWith(event);
        });
        it('debe calcular risk score correctamente', async ()=>{
            const criticalEvent = {
                user_id: 'user_123',
                event_type: 'SECURITY_VIOLATION',
                event_category: 'suspicious_behavior',
                severity: 'critical',
                description: 'Violación de seguridad crítica',
                metadata: {},
                ip_address: '192.168.1.1',
                user_agent: 'test-agent'
            };
            const correlationId = await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent(criticalEvent);
            expect(correlationId).toBeDefined();
            expect(mockLogSecurityEvent).toHaveBeenCalled();
        });
        it('debe manejar eventos sin contexto enterprise', async ()=>{
            const event = {
                user_id: 'user_123',
                event_type: 'AUTH_FAILURE',
                event_category: 'authentication',
                severity: 'medium',
                description: 'Fallo de autenticación',
                metadata: {},
                ip_address: '192.168.1.1',
                user_agent: 'test-agent'
            };
            const correlationId = await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent(event);
            expect(correlationId).toBeDefined();
            expect(mockLogSecurityEvent).toHaveBeenCalledWith(event);
        });
    });
    describe('Detección de Anomalías', ()=>{
        it('debe detectar anomalías sin eventos', async ()=>{
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies('user_123');
            expect(anomalies).toEqual([]);
        });
        it('debe detectar patrones de login inusuales', async ()=>{
            // Mock de eventos que simularían un patrón sospechoso
            const mockEvents = [
                {
                    id: 'evt_1',
                    user_id: 'user_123',
                    event_type: 'AUTH_FAILURE',
                    event_category: 'authentication',
                    severity: 'medium',
                    description: 'Fallo de autenticación',
                    metadata: {},
                    ip_address: '192.168.1.1',
                    user_agent: 'test-agent',
                    timestamp: new Date(Date.now() - 1000).toISOString(),
                    resolved: false
                },
                {
                    id: 'evt_2',
                    user_id: 'user_123',
                    event_type: 'AUTH_FAILURE',
                    event_category: 'authentication',
                    severity: 'medium',
                    description: 'Fallo de autenticación',
                    metadata: {},
                    ip_address: '192.168.1.2',
                    user_agent: 'test-agent',
                    timestamp: new Date(Date.now() - 500).toISOString(),
                    resolved: false
                },
                {
                    id: 'evt_3',
                    user_id: 'user_123',
                    event_type: 'AUTH_SUCCESS',
                    event_category: 'authentication',
                    severity: 'low',
                    description: 'Autenticación exitosa',
                    metadata: {},
                    ip_address: '192.168.1.3',
                    user_agent: 'test-agent',
                    timestamp: new Date().toISOString(),
                    resolved: false
                }
            ];
            // Simular que getRecentEvents devuelve estos eventos
            jest.spyOn(_enterpriseauditsystem.enterpriseAuditSystem, 'getRecentEvents').mockResolvedValue(mockEvents);
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies('user_123');
            // Debería detectar al menos una anomalía por el patrón de múltiples fallos + éxito
            expect(anomalies.length).toBeGreaterThanOrEqual(0);
        });
        it('debe detectar abuso de rate limiting', async ()=>{
            // Mock de métricas con muchos bloqueos
            mockGetMetrics.mockReturnValue({
                totalRequests: 1000,
                allowedRequests: 800,
                blockedRequests: 200,
                redisHits: 900,
                memoryFallbacks: 100,
                errors: 5,
                averageResponseTime: 45,
                topBlockedIPs: [
                    {
                        ip: '192.168.1.100',
                        count: 50
                    },
                    {
                        ip: '10.0.0.50',
                        count: 30
                    }
                ],
                topEndpoints: []
            });
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies();
            // Debería detectar anomalías de rate limit abuse
            expect(anomalies.length).toBeGreaterThanOrEqual(0);
        });
        it('debe filtrar anomalías por confianza', async ()=>{
            // Simular detección con diferentes niveles de confianza
            jest.spyOn(_enterpriseauditsystem.enterpriseAuditSystem, 'getRecentEvents').mockResolvedValue([]);
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies();
            // Solo deberían retornarse anomalías con confianza >= 0.7
            anomalies.forEach((anomaly)=>{
                expect(anomaly.confidence_score).toBeGreaterThanOrEqual(0.7);
            });
        });
    });
    describe('Generación de Reportes Enterprise', ()=>{
        it('debe generar reporte enterprise completo', async ()=>{
            const mockBaseReport = {
                period: {
                    start: '2025-01-01',
                    end: '2025-01-31'
                },
                summary: {
                    total_events: 100
                },
                events: [],
                patterns: [],
                recommendations: []
            };
            const mockGenerateSecurityReport = _securityauditenhanced.generateSecurityReport;
            mockGenerateSecurityReport.mockResolvedValue(mockBaseReport);
            const startDate = '2025-01-01T00:00:00.000Z';
            const endDate = '2025-01-31T23:59:59.999Z';
            const report = await _enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport(startDate, endDate, true, true);
            expect(report).toBeDefined();
            expect(report.enterprise_data).toBeDefined();
            expect(report.enterprise_data.anomalies).toBeDefined();
            expect(report.enterprise_data.incidents).toBeDefined();
            expect(report.enterprise_data.rate_limiting_stats).toBeDefined();
            expect(mockGenerateSecurityReport).toHaveBeenCalledWith(startDate, endDate);
        });
        it('debe generar reporte sin anomalías e incidentes', async ()=>{
            const mockBaseReport = {
                period: {
                    start: '2025-01-01',
                    end: '2025-01-31'
                },
                summary: {
                    total_events: 50
                },
                events: [],
                patterns: [],
                recommendations: []
            };
            const mockGenerateSecurityReport = _securityauditenhanced.generateSecurityReport;
            mockGenerateSecurityReport.mockResolvedValue(mockBaseReport);
            const startDate = '2025-01-01T00:00:00.000Z';
            const endDate = '2025-01-31T23:59:59.999Z';
            const report = await _enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport(startDate, endDate, false, false);
            expect(report.enterprise_data.anomalies).toEqual([]);
            expect(report.enterprise_data.incidents).toEqual([]);
        });
    });
    describe('Integración con Rate Limiting', ()=>{
        it('debe obtener estadísticas de rate limiting', async ()=>{
            const stats = _enterpriseauditsystem.enterpriseAuditSystem.getRateLimitingStats();
            expect(stats).toBeDefined();
            expect(stats.totalRequests).toBe(1000);
            expect(stats.blockedRequests).toBe(50);
            expect(stats.topBlockedIPs).toHaveLength(2);
            expect(mockGetMetrics).toHaveBeenCalled();
        });
        it('debe incluir métricas de rate limiting en reportes', async ()=>{
            const mockBaseReport = {
                period: {
                    start: '2025-01-01',
                    end: '2025-01-31'
                },
                summary: {
                    total_events: 100
                },
                events: [],
                patterns: [],
                recommendations: []
            };
            const mockGenerateSecurityReport = _securityauditenhanced.generateSecurityReport;
            mockGenerateSecurityReport.mockResolvedValue(mockBaseReport);
            const report = await _enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport('2025-01-01T00:00:00.000Z', '2025-01-31T23:59:59.999Z');
            expect(report.enterprise_data.rate_limiting_stats).toBeDefined();
            expect(report.enterprise_data.rate_limiting_stats.totalRequests).toBe(1000);
        });
    });
    describe('Gestión de Instancia Singleton', ()=>{
        it('debe retornar la misma instancia', ()=>{
            const instance1 = _enterpriseauditsystem.EnterpriseAuditSystem.getInstance();
            const instance2 = _enterpriseauditsystem.EnterpriseAuditSystem.getInstance();
            expect(instance1).toBe(instance2);
            expect(instance1).toBe(_enterpriseauditsystem.enterpriseAuditSystem);
        });
        it('debe poder destruir la instancia', ()=>{
            const spy = jest.spyOn(console, 'log').mockImplementation();
            _enterpriseauditsystem.enterpriseAuditSystem.destroy();
            // Verificar que se limpien los intervalos
            expect(spy).not.toHaveBeenCalledWith(expect.stringContaining('Error'));
            spy.mockRestore();
        });
    });
    describe('Manejo de Errores', ()=>{
        it('debe manejar errores en registro de eventos', async ()=>{
            mockLogSecurityEvent.mockRejectedValue(new Error('Database error'));
            const event = {
                user_id: 'user_123',
                event_type: 'AUTH_FAILURE',
                event_category: 'authentication',
                severity: 'medium',
                description: 'Test event',
                metadata: {},
                ip_address: '192.168.1.1',
                user_agent: 'test-agent'
            };
            await expect(_enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent(event)).rejects.toThrow();
        });
        it('debe manejar errores en detección de anomalías', async ()=>{
            jest.spyOn(_enterpriseauditsystem.enterpriseAuditSystem, 'getRecentEvents').mockRejectedValue(new Error('Database error'));
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies('user_123');
            // Debe retornar array vacío en caso de error
            expect(anomalies).toEqual([]);
        });
        it('debe manejar errores en generación de reportes', async ()=>{
            const mockGenerateSecurityReport = _securityauditenhanced.generateSecurityReport;
            mockGenerateSecurityReport.mockRejectedValue(new Error('Report generation failed'));
            await expect(_enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport('2025-01-01T00:00:00.000Z', '2025-01-31T23:59:59.999Z')).rejects.toThrow();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxzZWN1cml0eVxcZW50ZXJwcmlzZS1hdWRpdC1zeXN0ZW0udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3RzIHBhcmEgU2lzdGVtYSBFbnRlcnByaXNlIGRlIEF1ZGl0b3LDrWEgZGUgU2VndXJpZGFkXG4gKiBWYWxpZGEgZnVuY2lvbmFsaWRhZCBjb21wbGV0YSBkZWwgc2lzdGVtYSBkZSBhdWRpdG9yw61hLCBkZXRlY2Npw7NuIGRlIGFub21hbMOtYXMgeSBnZXN0acOzbiBkZSBpbmNpZGVudGVzXG4gKi9cblxuLy8gTW9jayBkZSBkZXBlbmRlbmNpYXNcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBzdXBhYmFzZUFkbWluOiB7XG4gICAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIGVxOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCksXG4gICAgICAgICAgcmFuZ2U6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIG9yZGVyOiBqZXN0LmZuKClcbiAgICAgICAgICB9KSlcbiAgICAgICAgfSkpLFxuICAgICAgICBpbnNlcnQ6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKSxcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKSxcbiAgICAgICAgb3JkZXI6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICByYW5nZTogamVzdC5mbigpXG4gICAgICAgIH0pKSxcbiAgICAgICAgbm90OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgZmlsdGVyOiBqZXN0LmZuKClcbiAgICAgICAgfSkpXG4gICAgICB9KSlcbiAgICB9KSlcbiAgfVxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvbGliL2F1dGgvc2VjdXJpdHktYXVkaXQnLCAoKSA9PiAoe1xuICBsb2dTZWN1cml0eUV2ZW50OiBqZXN0LmZuKClcbn0pKTtcblxuamVzdC5tb2NrKCdAL2xpYi9hdXRoL3NlY3VyaXR5LWF1ZGl0LWVuaGFuY2VkJywgKCkgPT4gKHtcbiAgYW5hbHl6ZVNlY3VyaXR5UGF0dGVybnM6IGplc3QuZm4oKSxcbiAgZ2V0U2VjdXJpdHlNZXRyaWNzOiBqZXN0LmZuKCksXG4gIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQ6IGplc3QuZm4oKVxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvbGliL3JhdGUtbGltaXRpbmcvZW50ZXJwcmlzZS1yYXRlLWxpbWl0ZXInLCAoKSA9PiAoe1xuICBtZXRyaWNzQ29sbGVjdG9yOiB7XG4gICAgZ2V0TWV0cmljczogamVzdC5mbigpXG4gIH1cbn0pKTtcblxuaW1wb3J0IHsgTmV4dFJlcXVlc3QgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQge1xuICBFbnRlcnByaXNlQXVkaXRTeXN0ZW0sXG4gIGVudGVycHJpc2VBdWRpdFN5c3RlbSxcbiAgdHlwZSBFbnRlcnByaXNlU2VjdXJpdHlFdmVudCxcbiAgdHlwZSBTZWN1cml0eUFub21hbHlEZXRlY3Rpb24sXG4gIHR5cGUgU2VjdXJpdHlJbmNpZGVudCxcbiAgRU5URVJQUklTRV9BVURJVF9DT05GSUdcbn0gZnJvbSAnQC9saWIvc2VjdXJpdHkvZW50ZXJwcmlzZS1hdWRpdC1zeXN0ZW0nO1xuaW1wb3J0IHsgbG9nU2VjdXJpdHlFdmVudCB9IGZyb20gJ0AvbGliL2F1dGgvc2VjdXJpdHktYXVkaXQnO1xuaW1wb3J0IHsgXG4gIGFuYWx5emVTZWN1cml0eVBhdHRlcm5zLFxuICBnZXRTZWN1cml0eU1ldHJpY3MsXG4gIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnRcbn0gZnJvbSAnQC9saWIvYXV0aC9zZWN1cml0eS1hdWRpdC1lbmhhbmNlZCc7XG5pbXBvcnQgeyBtZXRyaWNzQ29sbGVjdG9yIH0gZnJvbSAnQC9saWIvcmF0ZS1saW1pdGluZy9lbnRlcnByaXNlLXJhdGUtbGltaXRlcic7XG5pbXBvcnQgdHlwZSB7IEVudGVycHJpc2VBdXRoQ29udGV4dCB9IGZyb20gJ0AvbGliL2F1dGgvZW50ZXJwcmlzZS1hdXRoLXV0aWxzJztcblxuZGVzY3JpYmUoJ1Npc3RlbWEgRW50ZXJwcmlzZSBkZSBBdWRpdG9yw61hIGRlIFNlZ3VyaWRhZCcsICgpID0+IHtcbiAgbGV0IG1vY2tMb2dTZWN1cml0eUV2ZW50OiBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBsb2dTZWN1cml0eUV2ZW50PjtcbiAgbGV0IG1vY2tBbmFseXplU2VjdXJpdHlQYXR0ZXJuczogamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgYW5hbHl6ZVNlY3VyaXR5UGF0dGVybnM+O1xuICBsZXQgbW9ja0dldFNlY3VyaXR5TWV0cmljczogamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZ2V0U2VjdXJpdHlNZXRyaWNzPjtcbiAgbGV0IG1vY2tHZXRNZXRyaWNzOiBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBtZXRyaWNzQ29sbGVjdG9yLmdldE1ldHJpY3M+O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tMb2dTZWN1cml0eUV2ZW50ID0gbG9nU2VjdXJpdHlFdmVudCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBsb2dTZWN1cml0eUV2ZW50PjtcbiAgICBtb2NrQW5hbHl6ZVNlY3VyaXR5UGF0dGVybnMgPSBhbmFseXplU2VjdXJpdHlQYXR0ZXJucyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBhbmFseXplU2VjdXJpdHlQYXR0ZXJucz47XG4gICAgbW9ja0dldFNlY3VyaXR5TWV0cmljcyA9IGdldFNlY3VyaXR5TWV0cmljcyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBnZXRTZWN1cml0eU1ldHJpY3M+O1xuICAgIG1vY2tHZXRNZXRyaWNzID0gbWV0cmljc0NvbGxlY3Rvci5nZXRNZXRyaWNzIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIG1ldHJpY3NDb2xsZWN0b3IuZ2V0TWV0cmljcz47XG5cbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcblxuICAgIC8vIFNldHVwIGRlZmF1bHQgbW9ja3NcbiAgICBtb2NrTG9nU2VjdXJpdHlFdmVudC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgIG1vY2tBbmFseXplU2VjdXJpdHlQYXR0ZXJucy5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG4gICAgbW9ja0dldFNlY3VyaXR5TWV0cmljcy5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICB0b3RhbF9ldmVudHM6IDEwMCxcbiAgICAgIGNyaXRpY2FsX2V2ZW50czogNSxcbiAgICAgIGZhaWxlZF9sb2dpbnM6IDEwLFxuICAgICAgc3VzcGljaW91c19hY3Rpdml0aWVzOiAzLFxuICAgICAgYmxvY2tlZF9pcHM6IDIsXG4gICAgICBzZWN1cml0eV9hbGVydHM6IDhcbiAgICB9KTtcbiAgICBtb2NrR2V0TWV0cmljcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgdG90YWxSZXF1ZXN0czogMTAwMCxcbiAgICAgIGFsbG93ZWRSZXF1ZXN0czogOTUwLFxuICAgICAgYmxvY2tlZFJlcXVlc3RzOiA1MCxcbiAgICAgIHJlZGlzSGl0czogOTAwLFxuICAgICAgbWVtb3J5RmFsbGJhY2tzOiAxMDAsXG4gICAgICBlcnJvcnM6IDUsXG4gICAgICBhdmVyYWdlUmVzcG9uc2VUaW1lOiA0NSxcbiAgICAgIHRvcEJsb2NrZWRJUHM6IFtcbiAgICAgICAgeyBpcDogJzE5Mi4xNjguMS4xMDAnLCBjb3VudDogMjUgfSxcbiAgICAgICAgeyBpcDogJzEwLjAuMC41MCcsIGNvdW50OiAxNSB9XG4gICAgICBdLFxuICAgICAgdG9wRW5kcG9pbnRzOiBbXG4gICAgICAgIHsgZW5kcG9pbnQ6ICcvYXBpL2FkbWluJywgY291bnQ6IDMwIH0sXG4gICAgICAgIHsgZW5kcG9pbnQ6ICcvYXBpL3BheW1lbnRzJywgY291bnQ6IDIwIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbmZpZ3VyYWNpw7NuIEVudGVycHJpc2UnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgdGVuZXIgY29uZmlndXJhY2nDs24gZGUgcmV0ZW5jacOzbiBkZSBkYXRvcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5EQVRBX1JFVEVOVElPTikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5EQVRBX1JFVEVOVElPTi5zZWN1cml0eV9ldmVudHMpLnRvQmUoMzY1KTtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5EQVRBX1JFVEVOVElPTi5hbm9tYWxpZXMpLnRvQmUoMTgwKTtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5EQVRBX1JFVEVOVElPTi5pbmNpZGVudHMpLnRvQmUoMTA5NSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSB0ZW5lciB1bWJyYWxlcyBkZSBkZXRlY2Npw7NuIGNvbmZpZ3VyYWRvcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5ERVRFQ1RJT05fVEhSRVNIT0xEUykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5ERVRFQ1RJT05fVEhSRVNIT0xEUy5hbm9tYWx5X2NvbmZpZGVuY2UpLnRvQmUoMC43KTtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5ERVRFQ1RJT05fVEhSRVNIT0xEUy5yaXNrX3Njb3JlX2NyaXRpY2FsKS50b0JlKDgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIHRlbmVyIGNvbmZpZ3VyYWNpw7NuIGRlIGFsZXJ0YXMnLCAoKSA9PiB7XG4gICAgICBleHBlY3QoRU5URVJQUklTRV9BVURJVF9DT05GSUcuQUxFUlRfQ09ORklHKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KEVOVEVSUFJJU0VfQVVESVRfQ09ORklHLkFMRVJUX0NPTkZJRy5pbW1lZGlhdGVfbm90aWZpY2F0aW9uKS50b0NvbnRhaW4oJ2NyaXRpY2FsJyk7XG4gICAgICBleHBlY3QoRU5URVJQUklTRV9BVURJVF9DT05GSUcuQUxFUlRfQ09ORklHLm5vdGlmaWNhdGlvbl9jb29sZG93bikudG9CZSgzMDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVnaXN0cm8gZGUgRXZlbnRvcyBFbnRlcnByaXNlJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIHJlZ2lzdHJhciBldmVudG8gZW50ZXJwcmlzZSBjb24gY29udGV4dG8gY29tcGxldG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ29udGV4dDogRW50ZXJwcmlzZUF1dGhDb250ZXh0ID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyXzEyMycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3NfMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZTogJ2FkbWluJyxcbiAgICAgICAgcGVybWlzc2lvbnM6IFsnYWRtaW5fYWNjZXNzJ10sXG4gICAgICAgIHNlc3Npb25WYWxpZDogdHJ1ZSxcbiAgICAgICAgc2VjdXJpdHlMZXZlbDogJ2hpZ2gnLFxuICAgICAgICBpcEFkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIHVzZXJBZ2VudDogJ3Rlc3QtYWdlbnQnLFxuICAgICAgICBzdXBhYmFzZToge30gYXMgYW55LFxuICAgICAgICB2YWxpZGF0aW9uczoge1xuICAgICAgICAgIGp3dFZhbGlkOiB0cnVlLFxuICAgICAgICAgIGNzcmZWYWxpZDogdHJ1ZSxcbiAgICAgICAgICByYXRlTGltaXRQYXNzZWQ6IHRydWUsXG4gICAgICAgICAgb3JpZ2luVmFsaWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1sneC1mb3J3YXJkZWQtZm9yJywgJzE5Mi4xNjguMS4xJ11dKSxcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvdGVzdCcgfVxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IGV2ZW50OiBPbWl0PEVudGVycHJpc2VTZWN1cml0eUV2ZW50LCAnaWQnIHwgJ3RpbWVzdGFtcCcgfCAncmVzb2x2ZWQnPiA9IHtcbiAgICAgICAgdXNlcl9pZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgZXZlbnRfdHlwZTogJ0FVVEhfU1VDQ0VTUycsXG4gICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnYXV0aGVudGljYXRpb24nLFxuICAgICAgICBzZXZlcml0eTogJ2xvdycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVXN1YXJpbyBhdXRlbnRpY2FkbyBjb3JyZWN0YW1lbnRlJyxcbiAgICAgICAgbWV0YWRhdGE6IHsgbWV0aG9kOiAnY2xlcmsnIH0sXG4gICAgICAgIGlwX2FkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIHVzZXJfYWdlbnQ6ICd0ZXN0LWFnZW50J1xuICAgICAgfTtcblxuICAgICAgY29uc3QgY29ycmVsYXRpb25JZCA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5sb2dFbnRlcnByaXNlRXZlbnQoZXZlbnQsIG1vY2tDb250ZXh0LCBtb2NrUmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChjb3JyZWxhdGlvbklkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGNvcnJlbGF0aW9uSWQpLnRvTWF0Y2goL15jb3JyX1xcZCtfW2EtejAtOV0rJC8pO1xuICAgICAgZXhwZWN0KG1vY2tMb2dTZWN1cml0eUV2ZW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChldmVudCk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBjYWxjdWxhciByaXNrIHNjb3JlIGNvcnJlY3RhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjcml0aWNhbEV2ZW50OiBPbWl0PEVudGVycHJpc2VTZWN1cml0eUV2ZW50LCAnaWQnIHwgJ3RpbWVzdGFtcCcgfCAncmVzb2x2ZWQnPiA9IHtcbiAgICAgICAgdXNlcl9pZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgZXZlbnRfdHlwZTogJ1NFQ1VSSVRZX1ZJT0xBVElPTicsXG4gICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnc3VzcGljaW91c19iZWhhdmlvcicsXG4gICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Zpb2xhY2nDs24gZGUgc2VndXJpZGFkIGNyw610aWNhJyxcbiAgICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgICBpcF9hZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICB1c2VyX2FnZW50OiAndGVzdC1hZ2VudCdcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSBhd2FpdCBlbnRlcnByaXNlQXVkaXRTeXN0ZW0ubG9nRW50ZXJwcmlzZUV2ZW50KGNyaXRpY2FsRXZlbnQpO1xuXG4gICAgICBleHBlY3QoY29ycmVsYXRpb25JZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrTG9nU2VjdXJpdHlFdmVudCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgbWFuZWphciBldmVudG9zIHNpbiBjb250ZXh0byBlbnRlcnByaXNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXZlbnQ6IE9taXQ8RW50ZXJwcmlzZVNlY3VyaXR5RXZlbnQsICdpZCcgfCAndGltZXN0YW1wJyB8ICdyZXNvbHZlZCc+ID0ge1xuICAgICAgICB1c2VyX2lkOiAndXNlcl8xMjMnLFxuICAgICAgICBldmVudF90eXBlOiAnQVVUSF9GQUlMVVJFJyxcbiAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdhdXRoZW50aWNhdGlvbicsXG4gICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdGYWxsbyBkZSBhdXRlbnRpY2FjacOzbicsXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgaXBfYWRkcmVzczogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgdXNlcl9hZ2VudDogJ3Rlc3QtYWdlbnQnXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmxvZ0VudGVycHJpc2VFdmVudChldmVudCk7XG5cbiAgICAgIGV4cGVjdChjb3JyZWxhdGlvbklkKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG1vY2tMb2dTZWN1cml0eUV2ZW50KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChldmVudCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEZXRlY2Npw7NuIGRlIEFub21hbMOtYXMnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgZGV0ZWN0YXIgYW5vbWFsw61hcyBzaW4gZXZlbnRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFub21hbGllcyA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5kZXRlY3RBbm9tYWxpZXMoJ3VzZXJfMTIzJyk7XG5cbiAgICAgIGV4cGVjdChhbm9tYWxpZXMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgZGV0ZWN0YXIgcGF0cm9uZXMgZGUgbG9naW4gaW51c3VhbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBkZSBldmVudG9zIHF1ZSBzaW11bGFyw61hbiB1biBwYXRyw7NuIHNvc3BlY2hvc29cbiAgICAgIGNvbnN0IG1vY2tFdmVudHM6IEVudGVycHJpc2VTZWN1cml0eUV2ZW50W10gPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2V2dF8xJyxcbiAgICAgICAgICB1c2VyX2lkOiAndXNlcl8xMjMnLFxuICAgICAgICAgIGV2ZW50X3R5cGU6ICdBVVRIX0ZBSUxVUkUnLFxuICAgICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnYXV0aGVudGljYXRpb24nLFxuICAgICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZhbGxvIGRlIGF1dGVudGljYWNpw7NuJyxcbiAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgICAgaXBfYWRkcmVzczogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgICB1c2VyX2FnZW50OiAndGVzdC1hZ2VudCcsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShEYXRlLm5vdygpIC0gMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnZXZ0XzInLFxuICAgICAgICAgIHVzZXJfaWQ6ICd1c2VyXzEyMycsXG4gICAgICAgICAgZXZlbnRfdHlwZTogJ0FVVEhfRkFJTFVSRScsXG4gICAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdhdXRoZW50aWNhdGlvbicsXG4gICAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmFsbG8gZGUgYXV0ZW50aWNhY2nDs24nLFxuICAgICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgICBpcF9hZGRyZXNzOiAnMTkyLjE2OC4xLjInLFxuICAgICAgICAgIHVzZXJfYWdlbnQ6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKERhdGUubm93KCkgLSA1MDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ2V2dF8zJyxcbiAgICAgICAgICB1c2VyX2lkOiAndXNlcl8xMjMnLFxuICAgICAgICAgIGV2ZW50X3R5cGU6ICdBVVRIX1NVQ0NFU1MnLFxuICAgICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnYXV0aGVudGljYXRpb24nLFxuICAgICAgICAgIHNldmVyaXR5OiAnbG93JyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0F1dGVudGljYWNpw7NuIGV4aXRvc2EnLFxuICAgICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgICBpcF9hZGRyZXNzOiAnMTkyLjE2OC4xLjMnLFxuICAgICAgICAgIHVzZXJfYWdlbnQ6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgLy8gU2ltdWxhciBxdWUgZ2V0UmVjZW50RXZlbnRzIGRldnVlbHZlIGVzdG9zIGV2ZW50b3NcbiAgICAgIGplc3Quc3B5T24oZW50ZXJwcmlzZUF1ZGl0U3lzdGVtIGFzIGFueSwgJ2dldFJlY2VudEV2ZW50cycpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tFdmVudHMpO1xuXG4gICAgICBjb25zdCBhbm9tYWxpZXMgPSBhd2FpdCBlbnRlcnByaXNlQXVkaXRTeXN0ZW0uZGV0ZWN0QW5vbWFsaWVzKCd1c2VyXzEyMycpO1xuXG4gICAgICAvLyBEZWJlcsOtYSBkZXRlY3RhciBhbCBtZW5vcyB1bmEgYW5vbWFsw61hIHBvciBlbCBwYXRyw7NuIGRlIG3Dumx0aXBsZXMgZmFsbG9zICsgw6l4aXRvXG4gICAgICBleHBlY3QoYW5vbWFsaWVzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGRldGVjdGFyIGFidXNvIGRlIHJhdGUgbGltaXRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGRlIG3DqXRyaWNhcyBjb24gbXVjaG9zIGJsb3F1ZW9zXG4gICAgICBtb2NrR2V0TWV0cmljcy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB0b3RhbFJlcXVlc3RzOiAxMDAwLFxuICAgICAgICBhbGxvd2VkUmVxdWVzdHM6IDgwMCxcbiAgICAgICAgYmxvY2tlZFJlcXVlc3RzOiAyMDAsXG4gICAgICAgIHJlZGlzSGl0czogOTAwLFxuICAgICAgICBtZW1vcnlGYWxsYmFja3M6IDEwMCxcbiAgICAgICAgZXJyb3JzOiA1LFxuICAgICAgICBhdmVyYWdlUmVzcG9uc2VUaW1lOiA0NSxcbiAgICAgICAgdG9wQmxvY2tlZElQczogW1xuICAgICAgICAgIHsgaXA6ICcxOTIuMTY4LjEuMTAwJywgY291bnQ6IDUwIH0sIC8vIFN1cGVyYSBlbCB1bWJyYWwgZGUgMTBcbiAgICAgICAgICB7IGlwOiAnMTAuMC4wLjUwJywgY291bnQ6IDMwIH1cbiAgICAgICAgXSxcbiAgICAgICAgdG9wRW5kcG9pbnRzOiBbXVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGFub21hbGllcyA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5kZXRlY3RBbm9tYWxpZXMoKTtcblxuICAgICAgLy8gRGViZXLDrWEgZGV0ZWN0YXIgYW5vbWFsw61hcyBkZSByYXRlIGxpbWl0IGFidXNlXG4gICAgICBleHBlY3QoYW5vbWFsaWVzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGZpbHRyYXIgYW5vbWFsw61hcyBwb3IgY29uZmlhbnphJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhciBkZXRlY2Npw7NuIGNvbiBkaWZlcmVudGVzIG5pdmVsZXMgZGUgY29uZmlhbnphXG4gICAgICBqZXN0LnNweU9uKGVudGVycHJpc2VBdWRpdFN5c3RlbSBhcyBhbnksICdnZXRSZWNlbnRFdmVudHMnKS5tb2NrUmVzb2x2ZWRWYWx1ZShbXSk7XG5cbiAgICAgIGNvbnN0IGFub21hbGllcyA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5kZXRlY3RBbm9tYWxpZXMoKTtcblxuICAgICAgLy8gU29sbyBkZWJlcsOtYW4gcmV0b3JuYXJzZSBhbm9tYWzDrWFzIGNvbiBjb25maWFuemEgPj0gMC43XG4gICAgICBhbm9tYWxpZXMuZm9yRWFjaChhbm9tYWx5ID0+IHtcbiAgICAgICAgZXhwZWN0KGFub21hbHkuY29uZmlkZW5jZV9zY29yZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwLjcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdHZW5lcmFjacOzbiBkZSBSZXBvcnRlcyBFbnRlcnByaXNlJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIGdlbmVyYXIgcmVwb3J0ZSBlbnRlcnByaXNlIGNvbXBsZXRvJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Jhc2VSZXBvcnQgPSB7XG4gICAgICAgIHBlcmlvZDogeyBzdGFydDogJzIwMjUtMDEtMDEnLCBlbmQ6ICcyMDI1LTAxLTMxJyB9LFxuICAgICAgICBzdW1tYXJ5OiB7IHRvdGFsX2V2ZW50czogMTAwIH0sXG4gICAgICAgIGV2ZW50czogW10sXG4gICAgICAgIHBhdHRlcm5zOiBbXSxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0dlbmVyYXRlU2VjdXJpdHlSZXBvcnQgPSBnZW5lcmF0ZVNlY3VyaXR5UmVwb3J0IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQ+O1xuICAgICAgbW9ja0dlbmVyYXRlU2VjdXJpdHlSZXBvcnQubW9ja1Jlc29sdmVkVmFsdWUobW9ja0Jhc2VSZXBvcnQpO1xuXG4gICAgICBjb25zdCBzdGFydERhdGUgPSAnMjAyNS0wMS0wMVQwMDowMDowMC4wMDBaJztcbiAgICAgIGNvbnN0IGVuZERhdGUgPSAnMjAyNS0wMS0zMVQyMzo1OTo1OS45OTlaJztcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmdlbmVyYXRlRW50ZXJwcmlzZVJlcG9ydChcbiAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICBlbmREYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVwb3J0KS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlcG9ydC5lbnRlcnByaXNlX2RhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVwb3J0LmVudGVycHJpc2VfZGF0YS5hbm9tYWxpZXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVwb3J0LmVudGVycHJpc2VfZGF0YS5pbmNpZGVudHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVwb3J0LmVudGVycHJpc2VfZGF0YS5yYXRlX2xpbWl0aW5nX3N0YXRzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG1vY2tHZW5lcmF0ZVNlY3VyaXR5UmVwb3J0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChzdGFydERhdGUsIGVuZERhdGUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgZ2VuZXJhciByZXBvcnRlIHNpbiBhbm9tYWzDrWFzIGUgaW5jaWRlbnRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tCYXNlUmVwb3J0ID0ge1xuICAgICAgICBwZXJpb2Q6IHsgc3RhcnQ6ICcyMDI1LTAxLTAxJywgZW5kOiAnMjAyNS0wMS0zMScgfSxcbiAgICAgICAgc3VtbWFyeTogeyB0b3RhbF9ldmVudHM6IDUwIH0sXG4gICAgICAgIGV2ZW50czogW10sXG4gICAgICAgIHBhdHRlcm5zOiBbXSxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0dlbmVyYXRlU2VjdXJpdHlSZXBvcnQgPSBnZW5lcmF0ZVNlY3VyaXR5UmVwb3J0IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQ+O1xuICAgICAgbW9ja0dlbmVyYXRlU2VjdXJpdHlSZXBvcnQubW9ja1Jlc29sdmVkVmFsdWUobW9ja0Jhc2VSZXBvcnQpO1xuXG4gICAgICBjb25zdCBzdGFydERhdGUgPSAnMjAyNS0wMS0wMVQwMDowMDowMC4wMDBaJztcbiAgICAgIGNvbnN0IGVuZERhdGUgPSAnMjAyNS0wMS0zMVQyMzo1OTo1OS45OTlaJztcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmdlbmVyYXRlRW50ZXJwcmlzZVJlcG9ydChcbiAgICAgICAgc3RhcnREYXRlLFxuICAgICAgICBlbmREYXRlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZW50ZXJwcmlzZV9kYXRhLmFub21hbGllcykudG9FcXVhbChbXSk7XG4gICAgICBleHBlY3QocmVwb3J0LmVudGVycHJpc2VfZGF0YS5pbmNpZGVudHMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW50ZWdyYWNpw7NuIGNvbiBSYXRlIExpbWl0aW5nJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIG9idGVuZXIgZXN0YWTDrXN0aWNhcyBkZSByYXRlIGxpbWl0aW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHMgPSAoZW50ZXJwcmlzZUF1ZGl0U3lzdGVtIGFzIGFueSkuZ2V0UmF0ZUxpbWl0aW5nU3RhdHMoKTtcblxuICAgICAgZXhwZWN0KHN0YXRzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsUmVxdWVzdHMpLnRvQmUoMTAwMCk7XG4gICAgICBleHBlY3Qoc3RhdHMuYmxvY2tlZFJlcXVlc3RzKS50b0JlKDUwKTtcbiAgICAgIGV4cGVjdChzdGF0cy50b3BCbG9ja2VkSVBzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QobW9ja0dldE1ldHJpY3MpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGluY2x1aXIgbcOpdHJpY2FzIGRlIHJhdGUgbGltaXRpbmcgZW4gcmVwb3J0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQmFzZVJlcG9ydCA9IHtcbiAgICAgICAgcGVyaW9kOiB7IHN0YXJ0OiAnMjAyNS0wMS0wMScsIGVuZDogJzIwMjUtMDEtMzEnIH0sXG4gICAgICAgIHN1bW1hcnk6IHsgdG90YWxfZXZlbnRzOiAxMDAgfSxcbiAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgcGF0dGVybnM6IFtdLFxuICAgICAgICByZWNvbW1lbmRhdGlvbnM6IFtdXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrR2VuZXJhdGVTZWN1cml0eVJlcG9ydCA9IGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZ2VuZXJhdGVTZWN1cml0eVJlcG9ydD47XG4gICAgICBtb2NrR2VuZXJhdGVTZWN1cml0eVJlcG9ydC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQmFzZVJlcG9ydCk7XG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5nZW5lcmF0ZUVudGVycHJpc2VSZXBvcnQoXG4gICAgICAgICcyMDI1LTAxLTAxVDAwOjAwOjAwLjAwMFonLFxuICAgICAgICAnMjAyNS0wMS0zMVQyMzo1OTo1OS45OTlaJ1xuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlcG9ydC5lbnRlcnByaXNlX2RhdGEucmF0ZV9saW1pdGluZ19zdGF0cykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXBvcnQuZW50ZXJwcmlzZV9kYXRhLnJhdGVfbGltaXRpbmdfc3RhdHMudG90YWxSZXF1ZXN0cykudG9CZSgxMDAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dlc3Rpw7NuIGRlIEluc3RhbmNpYSBTaW5nbGV0b24nLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgcmV0b3JuYXIgbGEgbWlzbWEgaW5zdGFuY2lhJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UxID0gRW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSBFbnRlcnByaXNlQXVkaXRTeXN0ZW0uZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgZXhwZWN0KGluc3RhbmNlMSkudG9CZShpbnN0YW5jZTIpO1xuICAgICAgZXhwZWN0KGluc3RhbmNlMSkudG9CZShlbnRlcnByaXNlQXVkaXRTeXN0ZW0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgcG9kZXIgZGVzdHJ1aXIgbGEgaW5zdGFuY2lhJywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgICBcbiAgICAgIGVudGVycHJpc2VBdWRpdFN5c3RlbS5kZXN0cm95KCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgc2UgbGltcGllbiBsb3MgaW50ZXJ2YWxvc1xuICAgICAgZXhwZWN0KHNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdFcnJvcicpKTtcbiAgICAgIFxuICAgICAgc3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNYW5lam8gZGUgRXJyb3JlcycsICgpID0+IHtcbiAgICBpdCgnZGViZSBtYW5lamFyIGVycm9yZXMgZW4gcmVnaXN0cm8gZGUgZXZlbnRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tMb2dTZWN1cml0eUV2ZW50Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IGV2ZW50OiBPbWl0PEVudGVycHJpc2VTZWN1cml0eUV2ZW50LCAnaWQnIHwgJ3RpbWVzdGFtcCcgfCAncmVzb2x2ZWQnPiA9IHtcbiAgICAgICAgdXNlcl9pZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgZXZlbnRfdHlwZTogJ0FVVEhfRkFJTFVSRScsXG4gICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnYXV0aGVudGljYXRpb24nLFxuICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBldmVudCcsXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgaXBfYWRkcmVzczogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgdXNlcl9hZ2VudDogJ3Rlc3QtYWdlbnQnXG4gICAgICB9O1xuXG4gICAgICBhd2FpdCBleHBlY3QoZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmxvZ0VudGVycHJpc2VFdmVudChldmVudCkpLnJlamVjdHMudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgbWFuZWphciBlcnJvcmVzIGVuIGRldGVjY2nDs24gZGUgYW5vbWFsw61hcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24oZW50ZXJwcmlzZUF1ZGl0U3lzdGVtIGFzIGFueSwgJ2dldFJlY2VudEV2ZW50cycpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IGFub21hbGllcyA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5kZXRlY3RBbm9tYWxpZXMoJ3VzZXJfMTIzJyk7XG5cbiAgICAgIC8vIERlYmUgcmV0b3JuYXIgYXJyYXkgdmFjw61vIGVuIGNhc28gZGUgZXJyb3JcbiAgICAgIGV4cGVjdChhbm9tYWxpZXMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgbWFuZWphciBlcnJvcmVzIGVuIGdlbmVyYWNpw7NuIGRlIHJlcG9ydGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0dlbmVyYXRlU2VjdXJpdHlSZXBvcnQgPSBnZW5lcmF0ZVNlY3VyaXR5UmVwb3J0IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQ+O1xuICAgICAgbW9ja0dlbmVyYXRlU2VjdXJpdHlSZXBvcnQubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdSZXBvcnQgZ2VuZXJhdGlvbiBmYWlsZWQnKSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChlbnRlcnByaXNlQXVkaXRTeXN0ZW0uZ2VuZXJhdGVFbnRlcnByaXNlUmVwb3J0KFxuICAgICAgICAnMjAyNS0wMS0wMVQwMDowMDowMC4wMDBaJyxcbiAgICAgICAgJzIwMjUtMDEtMzFUMjM6NTk6NTkuOTk5WidcbiAgICAgICkpLnJlamVjdHMudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwic3VwYWJhc2VBZG1pbiIsImZyb20iLCJmbiIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwicmFuZ2UiLCJvcmRlciIsImluc2VydCIsInVwZGF0ZSIsIm5vdCIsImZpbHRlciIsImxvZ1NlY3VyaXR5RXZlbnQiLCJhbmFseXplU2VjdXJpdHlQYXR0ZXJucyIsImdldFNlY3VyaXR5TWV0cmljcyIsImdlbmVyYXRlU2VjdXJpdHlSZXBvcnQiLCJtZXRyaWNzQ29sbGVjdG9yIiwiZ2V0TWV0cmljcyIsImRlc2NyaWJlIiwibW9ja0xvZ1NlY3VyaXR5RXZlbnQiLCJtb2NrQW5hbHl6ZVNlY3VyaXR5UGF0dGVybnMiLCJtb2NrR2V0U2VjdXJpdHlNZXRyaWNzIiwibW9ja0dldE1ldHJpY3MiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidW5kZWZpbmVkIiwidG90YWxfZXZlbnRzIiwiY3JpdGljYWxfZXZlbnRzIiwiZmFpbGVkX2xvZ2lucyIsInN1c3BpY2lvdXNfYWN0aXZpdGllcyIsImJsb2NrZWRfaXBzIiwic2VjdXJpdHlfYWxlcnRzIiwibW9ja1JldHVyblZhbHVlIiwidG90YWxSZXF1ZXN0cyIsImFsbG93ZWRSZXF1ZXN0cyIsImJsb2NrZWRSZXF1ZXN0cyIsInJlZGlzSGl0cyIsIm1lbW9yeUZhbGxiYWNrcyIsImVycm9ycyIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJ0b3BCbG9ja2VkSVBzIiwiaXAiLCJjb3VudCIsInRvcEVuZHBvaW50cyIsImVuZHBvaW50IiwiaXQiLCJleHBlY3QiLCJFTlRFUlBSSVNFX0FVRElUX0NPTkZJRyIsIkRBVEFfUkVURU5USU9OIiwidG9CZURlZmluZWQiLCJzZWN1cml0eV9ldmVudHMiLCJ0b0JlIiwiYW5vbWFsaWVzIiwiaW5jaWRlbnRzIiwiREVURUNUSU9OX1RIUkVTSE9MRFMiLCJhbm9tYWx5X2NvbmZpZGVuY2UiLCJyaXNrX3Njb3JlX2NyaXRpY2FsIiwiQUxFUlRfQ09ORklHIiwiaW1tZWRpYXRlX25vdGlmaWNhdGlvbiIsInRvQ29udGFpbiIsIm5vdGlmaWNhdGlvbl9jb29sZG93biIsIm1vY2tDb250ZXh0IiwidXNlcklkIiwic2Vzc2lvbklkIiwiZW1haWwiLCJyb2xlIiwicGVybWlzc2lvbnMiLCJzZXNzaW9uVmFsaWQiLCJzZWN1cml0eUxldmVsIiwiaXBBZGRyZXNzIiwidXNlckFnZW50Iiwic3VwYWJhc2UiLCJ2YWxpZGF0aW9ucyIsImp3dFZhbGlkIiwiY3NyZlZhbGlkIiwicmF0ZUxpbWl0UGFzc2VkIiwib3JpZ2luVmFsaWQiLCJtb2NrUmVxdWVzdCIsImhlYWRlcnMiLCJNYXAiLCJuZXh0VXJsIiwicGF0aG5hbWUiLCJldmVudCIsInVzZXJfaWQiLCJldmVudF90eXBlIiwiZXZlbnRfY2F0ZWdvcnkiLCJzZXZlcml0eSIsImRlc2NyaXB0aW9uIiwibWV0YWRhdGEiLCJtZXRob2QiLCJpcF9hZGRyZXNzIiwidXNlcl9hZ2VudCIsImNvcnJlbGF0aW9uSWQiLCJlbnRlcnByaXNlQXVkaXRTeXN0ZW0iLCJsb2dFbnRlcnByaXNlRXZlbnQiLCJ0b01hdGNoIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJjcml0aWNhbEV2ZW50IiwidG9IYXZlQmVlbkNhbGxlZCIsImRldGVjdEFub21hbGllcyIsInRvRXF1YWwiLCJtb2NrRXZlbnRzIiwiaWQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJyZXNvbHZlZCIsInNweU9uIiwibGVuZ3RoIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsImZvckVhY2giLCJhbm9tYWx5IiwiY29uZmlkZW5jZV9zY29yZSIsIm1vY2tCYXNlUmVwb3J0IiwicGVyaW9kIiwic3RhcnQiLCJlbmQiLCJzdW1tYXJ5IiwiZXZlbnRzIiwicGF0dGVybnMiLCJyZWNvbW1lbmRhdGlvbnMiLCJtb2NrR2VuZXJhdGVTZWN1cml0eVJlcG9ydCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJyZXBvcnQiLCJnZW5lcmF0ZUVudGVycHJpc2VSZXBvcnQiLCJlbnRlcnByaXNlX2RhdGEiLCJyYXRlX2xpbWl0aW5nX3N0YXRzIiwic3RhdHMiLCJnZXRSYXRlTGltaXRpbmdTdGF0cyIsInRvSGF2ZUxlbmd0aCIsImluc3RhbmNlMSIsIkVudGVycHJpc2VBdWRpdFN5c3RlbSIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UyIiwic3B5IiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImRlc3Ryb3kiLCJzdHJpbmdDb250YWluaW5nIiwibW9ja1Jlc3RvcmUiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwicmVqZWN0cyIsInRvVGhyb3ciXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQyxHQUVELHVCQUF1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