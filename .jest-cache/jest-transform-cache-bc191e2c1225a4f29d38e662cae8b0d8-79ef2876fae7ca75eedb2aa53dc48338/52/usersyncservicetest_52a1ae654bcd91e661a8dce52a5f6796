6daa7bb56ad609f32fe54b831976e6af
/**
 * Tests para el servicio de sincronización automática de usuarios
 * Verifica la sincronización robusta entre Clerk y Supabase
 */ "use strict";
// Mock de Clerk
jest.mock('@clerk/nextjs/server', ()=>({
        clerkClient: jest.fn(()=>({
                users: {
                    getUser: jest.fn(),
                    getUserList: jest.fn()
                }
            }))
    }));
jest.mock('@/lib/supabase', ()=>({
        supabaseAdmin: {
            from: jest.fn(()=>mockSupabaseChain)
        }
    }));
// Mock de security audit
jest.mock('@/lib/auth/security-audit', ()=>({
        logSecurityEvent: jest.fn(),
        logAdminAction: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _usersyncservice = require("../lib/auth/user-sync-service");
const _server = require("@clerk/nextjs/server");
// Mock de Supabase
const mockSupabaseChain = {
    single: jest.fn(),
    eq: jest.fn(()=>mockSupabaseChain),
    or: jest.fn(()=>mockSupabaseChain),
    select: jest.fn(()=>mockSupabaseChain),
    insert: jest.fn(()=>mockSupabaseChain),
    update: jest.fn(()=>mockSupabaseChain)
};
describe('Servicio de Sincronización de Usuarios', ()=>{
    let mockClerkClient;
    beforeEach(()=>{
        mockClerkClient = _server.clerkClient;
        jest.clearAllMocks();
        // Reset mock chain
        mockSupabaseChain.single.mockReset();
        mockSupabaseChain.eq.mockReturnValue(mockSupabaseChain);
        mockSupabaseChain.or.mockReturnValue(mockSupabaseChain);
        mockSupabaseChain.select.mockReturnValue(mockSupabaseChain);
        mockSupabaseChain.insert.mockReturnValue(mockSupabaseChain);
        mockSupabaseChain.update.mockReturnValue(mockSupabaseChain);
    });
    const mockClerkUserData = {
        id: 'user_123',
        email_addresses: [
            {
                email_address: 'test@example.com',
                id: 'email_123',
                verification: {
                    status: 'verified',
                    strategy: 'email_code'
                }
            }
        ],
        first_name: 'John',
        last_name: 'Doe',
        created_at: Date.now(),
        updated_at: Date.now(),
        image_url: 'https://example.com/avatar.jpg',
        public_metadata: {
            role: 'customer'
        }
    };
    describe('syncUserToSupabase', ()=>{
        it('debe crear un nuevo usuario exitosamente', async ()=>{
            // Mock: usuario no existe
            mockSupabaseChain.single.mockResolvedValueOnce({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            })// Mock: rol por defecto existe
            .mockResolvedValueOnce({
                data: {
                    id: 1
                },
                error: null
            })// Mock: inserción exitosa
            .mockResolvedValueOnce({
                data: {
                    id: 'user_456',
                    email: 'test@example.com'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData);
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
            expect(result.userId).toBe('user_456');
        });
        it('debe actualizar un usuario existente', async ()=>{
            const existingUser = {
                id: 'user_456',
                email: 'test@example.com',
                first_name: 'Jane'
            };
            // Mock: usuario existe y actualización exitosa
            mockSupabaseChain.single.mockResolvedValueOnce({
                data: existingUser,
                error: null
            }).mockResolvedValueOnce({
                data: {
                    ...existingUser,
                    first_name: 'John'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData);
            expect(result.success).toBe(true);
            expect(result.action).toBe('updated');
        });
        it('debe manejar errores de validación', async ()=>{
            const invalidUserData = {
                ...mockClerkUserData,
                email_addresses: []
            };
            const result = await (0, _usersyncservice.syncUserToSupabase)(invalidUserData);
            expect(result.success).toBe(false);
            expect(result.action).toBe('error');
            expect(result.error).toContain('Al menos un email es requerido');
        });
        it('debe reintentar en caso de error temporal', async ()=>{
            // Mock: primer intento falla, luego éxito
            mockSupabaseChain.single.mockRejectedValueOnce(new Error('Conexión temporal perdida')).mockResolvedValueOnce({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            }).mockResolvedValueOnce({
                data: {
                    id: 1
                },
                error: null
            }).mockResolvedValueOnce({
                data: {
                    id: 'user_456'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData, {
                retryAttempts: 2,
                retryDelay: 100
            });
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
        });
        it('debe fallar después de agotar reintentos', async ()=>{
            // Mock: todos los intentos fallan
            mockSupabaseChain.single.mockRejectedValue(new Error('Error persistente'));
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData, {
                retryAttempts: 2,
                retryDelay: 100
            });
            expect(result.success).toBe(false);
            expect(result.action).toBe('error');
            expect(result.error).toContain('Error después de 2 intentos');
        });
    });
    describe('deleteUserFromSupabase', ()=>{
        it('debe eliminar usuario exitosamente (soft delete)', async ()=>{
            const existingUser = {
                id: 'user_456',
                email: 'test@example.com',
                is_active: true
            };
            // Mock: actualización exitosa (soft delete)
            mockSupabase.from().update().eq().select().single.mockResolvedValue({
                data: {
                    ...existingUser,
                    is_active: false
                },
                error: null
            });
            const result = await (0, _usersyncservice.deleteUserFromSupabase)('user_123');
            expect(result.success).toBe(true);
            expect(result.action).toBe('deleted');
        });
        it('debe manejar usuario no encontrado', async ()=>{
            // Mock: usuario no encontrado
            mockSupabase.from().update().eq().select().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            const result = await (0, _usersyncservice.deleteUserFromSupabase)('user_not_found');
            expect(result.success).toBe(true);
            expect(result.action).toBe('deleted');
            expect(result.details?.message).toContain('Usuario no encontrado');
        });
    });
    describe('syncUserFromClerk', ()=>{
        it('debe sincronizar usuario desde Clerk exitosamente', async ()=>{
            const mockClerkUser = {
                id: 'user_123',
                emailAddresses: [
                    {
                        emailAddress: 'test@example.com',
                        id: 'email_123',
                        verification: {
                            status: 'verified',
                            strategy: 'email_code'
                        }
                    }
                ],
                firstName: 'John',
                lastName: 'Doe',
                createdAt: Date.now(),
                updatedAt: Date.now(),
                imageUrl: 'https://example.com/avatar.jpg',
                phoneNumbers: [],
                publicMetadata: {
                    role: 'customer'
                },
                privateMetadata: {}
            };
            mockClerkClient.mockReturnValue({
                users: {
                    getUser: jest.fn().mockResolvedValue(mockClerkUser)
                }
            });
            // Mock: usuario no existe, crear nuevo
            mockSupabase.from().select().or().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            mockSupabase.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            mockSupabase.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'user_456'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserFromClerk)('user_123');
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
        });
        it('debe manejar usuario no encontrado en Clerk', async ()=>{
            mockClerkClient.mockReturnValue({
                users: {
                    getUser: jest.fn().mockResolvedValue(null)
                }
            });
            const result = await (0, _usersyncservice.syncUserFromClerk)('user_not_found');
            expect(result.success).toBe(false);
            expect(result.error).toContain('Usuario no encontrado en Clerk');
        });
    });
    describe('bulkSyncUsersFromClerk', ()=>{
        it('debe sincronizar múltiples usuarios exitosamente', async ()=>{
            const mockClerkUsers = [
                {
                    id: 'user_1',
                    emailAddresses: [
                        {
                            emailAddress: 'user1@example.com',
                            id: 'email_1',
                            verification: {
                                status: 'verified'
                            }
                        }
                    ],
                    firstName: 'User',
                    lastName: 'One',
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    imageUrl: '',
                    phoneNumbers: [],
                    publicMetadata: {},
                    privateMetadata: {}
                },
                {
                    id: 'user_2',
                    emailAddresses: [
                        {
                            emailAddress: 'user2@example.com',
                            id: 'email_2',
                            verification: {
                                status: 'verified'
                            }
                        }
                    ],
                    firstName: 'User',
                    lastName: 'Two',
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    imageUrl: '',
                    phoneNumbers: [],
                    publicMetadata: {},
                    privateMetadata: {}
                }
            ];
            mockClerkClient.mockReturnValue({
                users: {
                    getUserList: jest.fn().mockResolvedValue(mockClerkUsers)
                }
            });
            // Mock: usuarios no existen, crear nuevos
            mockSupabase.from().select().or().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            mockSupabase.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            mockSupabase.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'new_user'
                },
                error: null
            });
            const result = await (0, _usersyncservice.bulkSyncUsersFromClerk)({
                batchSize: 2,
                maxUsers: 2
            });
            expect(result.success).toBe(true);
            expect(result.totalProcessed).toBe(2);
            expect(result.successful).toBe(2);
            expect(result.failed).toBe(0);
        });
        it('debe manejar errores en sincronización masiva', async ()=>{
            mockClerkClient.mockReturnValue({
                users: {
                    getUserList: jest.fn().mockRejectedValue(new Error('Error de Clerk'))
                }
            });
            const result = await (0, _usersyncservice.bulkSyncUsersFromClerk)();
            expect(result.success).toBe(false);
            expect(result.failed).toBe(1);
            expect(result.results[0].error).toContain('Error en sincronización masiva');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFx1c2VyLXN5bmMtc2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgcGFyYSBlbCBzZXJ2aWNpbyBkZSBzaW5jcm9uaXphY2nDs24gYXV0b23DoXRpY2EgZGUgdXN1YXJpb3NcbiAqIFZlcmlmaWNhIGxhIHNpbmNyb25pemFjacOzbiByb2J1c3RhIGVudHJlIENsZXJrIHkgU3VwYWJhc2VcbiAqL1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcblxuLy8gTW9jayBkZSBDbGVya1xuamVzdC5tb2NrKCdAY2xlcmsvbmV4dGpzL3NlcnZlcicsICgpID0+ICh7XG4gIGNsZXJrQ2xpZW50OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgdXNlcnM6IHtcbiAgICAgIGdldFVzZXI6IGplc3QuZm4oKSxcbiAgICAgIGdldFVzZXJMaXN0OiBqZXN0LmZuKClcbiAgICB9XG4gIH0pKVxufSkpO1xuXG4vLyBNb2NrIGRlIFN1cGFiYXNlXG5jb25zdCBtb2NrU3VwYWJhc2VDaGFpbiA9IHtcbiAgc2luZ2xlOiBqZXN0LmZuKCksXG4gIGVxOiBqZXN0LmZuKCgpID0+IG1vY2tTdXBhYmFzZUNoYWluKSxcbiAgb3I6IGplc3QuZm4oKCkgPT4gbW9ja1N1cGFiYXNlQ2hhaW4pLFxuICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gbW9ja1N1cGFiYXNlQ2hhaW4pLFxuICBpbnNlcnQ6IGplc3QuZm4oKCkgPT4gbW9ja1N1cGFiYXNlQ2hhaW4pLFxuICB1cGRhdGU6IGplc3QuZm4oKCkgPT4gbW9ja1N1cGFiYXNlQ2hhaW4pXG59O1xuXG5qZXN0Lm1vY2soJ0AvbGliL3N1cGFiYXNlJywgKCkgPT4gKHtcbiAgc3VwYWJhc2VBZG1pbjoge1xuICAgIGZyb206IGplc3QuZm4oKCkgPT4gbW9ja1N1cGFiYXNlQ2hhaW4pXG4gIH1cbn0pKTtcblxuLy8gTW9jayBkZSBzZWN1cml0eSBhdWRpdFxuamVzdC5tb2NrKCdAL2xpYi9hdXRoL3NlY3VyaXR5LWF1ZGl0JywgKCkgPT4gKHtcbiAgbG9nU2VjdXJpdHlFdmVudDogamVzdC5mbigpLFxuICBsb2dBZG1pbkFjdGlvbjogamVzdC5mbigpXG59KSk7XG5cbmltcG9ydCB7XG4gIHN5bmNVc2VyVG9TdXBhYmFzZSxcbiAgc3luY1VzZXJGcm9tQ2xlcmssXG4gIGRlbGV0ZVVzZXJGcm9tU3VwYWJhc2UsXG4gIGJ1bGtTeW5jVXNlcnNGcm9tQ2xlcmssXG4gIHR5cGUgQ2xlcmtVc2VyRGF0YSxcbiAgdHlwZSBTeW5jT3B0aW9uc1xufSBmcm9tICdAL2xpYi9hdXRoL3VzZXItc3luYy1zZXJ2aWNlJztcbmltcG9ydCB7IGNsZXJrQ2xpZW50IH0gZnJvbSAnQGNsZXJrL25leHRqcy9zZXJ2ZXInO1xuaW1wb3J0IHsgc3VwYWJhc2VBZG1pbiB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcblxuZGVzY3JpYmUoJ1NlcnZpY2lvIGRlIFNpbmNyb25pemFjacOzbiBkZSBVc3VhcmlvcycsICgpID0+IHtcbiAgbGV0IG1vY2tDbGVya0NsaWVudDogamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgY2xlcmtDbGllbnQ+O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tDbGVya0NsaWVudCA9IGNsZXJrQ2xpZW50IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGNsZXJrQ2xpZW50PjtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcblxuICAgIC8vIFJlc2V0IG1vY2sgY2hhaW5cbiAgICBtb2NrU3VwYWJhc2VDaGFpbi5zaW5nbGUubW9ja1Jlc2V0KCk7XG4gICAgbW9ja1N1cGFiYXNlQ2hhaW4uZXEubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZUNoYWluKTtcbiAgICBtb2NrU3VwYWJhc2VDaGFpbi5vci5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlQ2hhaW4pO1xuICAgIG1vY2tTdXBhYmFzZUNoYWluLnNlbGVjdC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlQ2hhaW4pO1xuICAgIG1vY2tTdXBhYmFzZUNoYWluLmluc2VydC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlQ2hhaW4pO1xuICAgIG1vY2tTdXBhYmFzZUNoYWluLnVwZGF0ZS5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlQ2hhaW4pO1xuICB9KTtcblxuICBjb25zdCBtb2NrQ2xlcmtVc2VyRGF0YTogQ2xlcmtVc2VyRGF0YSA9IHtcbiAgICBpZDogJ3VzZXJfMTIzJyxcbiAgICBlbWFpbF9hZGRyZXNzZXM6IFt7XG4gICAgICBlbWFpbF9hZGRyZXNzOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICBpZDogJ2VtYWlsXzEyMycsXG4gICAgICB2ZXJpZmljYXRpb246IHtcbiAgICAgICAgc3RhdHVzOiAndmVyaWZpZWQnLFxuICAgICAgICBzdHJhdGVneTogJ2VtYWlsX2NvZGUnXG4gICAgICB9XG4gICAgfV0sXG4gICAgZmlyc3RfbmFtZTogJ0pvaG4nLFxuICAgIGxhc3RfbmFtZTogJ0RvZScsXG4gICAgY3JlYXRlZF9hdDogRGF0ZS5ub3coKSxcbiAgICB1cGRhdGVkX2F0OiBEYXRlLm5vdygpLFxuICAgIGltYWdlX3VybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vYXZhdGFyLmpwZycsXG4gICAgcHVibGljX21ldGFkYXRhOiB7IHJvbGU6ICdjdXN0b21lcicgfVxuICB9O1xuXG4gIGRlc2NyaWJlKCdzeW5jVXNlclRvU3VwYWJhc2UnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgY3JlYXIgdW4gbnVldm8gdXN1YXJpbyBleGl0b3NhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrOiB1c3VhcmlvIG5vIGV4aXN0ZVxuICAgICAgbW9ja1N1cGFiYXNlQ2hhaW4uc2luZ2xlXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgZXJyb3I6IHsgY29kZTogJ1BHUlNUMTE2JyB9XG4gICAgICAgIH0pXG4gICAgICAgIC8vIE1vY2s6IHJvbCBwb3IgZGVmZWN0byBleGlzdGVcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgZGF0YTogeyBpZDogMSB9LFxuICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgIH0pXG4gICAgICAgIC8vIE1vY2s6IGluc2VyY2nDs24gZXhpdG9zYVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBkYXRhOiB7IGlkOiAndXNlcl80NTYnLCBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nIH0sXG4gICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN5bmNVc2VyVG9TdXBhYmFzZShtb2NrQ2xlcmtVc2VyRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdjcmVhdGVkJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnVzZXJJZCkudG9CZSgndXNlcl80NTYnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGFjdHVhbGl6YXIgdW4gdXN1YXJpbyBleGlzdGVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ1VzZXIgPSB7XG4gICAgICAgIGlkOiAndXNlcl80NTYnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBmaXJzdF9uYW1lOiAnSmFuZSdcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2s6IHVzdWFyaW8gZXhpc3RlIHkgYWN0dWFsaXphY2nDs24gZXhpdG9zYVxuICAgICAgbW9ja1N1cGFiYXNlQ2hhaW4uc2luZ2xlXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGRhdGE6IGV4aXN0aW5nVXNlcixcbiAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBkYXRhOiB7IC4uLmV4aXN0aW5nVXNlciwgZmlyc3RfbmFtZTogJ0pvaG4nIH0sXG4gICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN5bmNVc2VyVG9TdXBhYmFzZShtb2NrQ2xlcmtVc2VyRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCd1cGRhdGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIGVycm9yZXMgZGUgdmFsaWRhY2nDs24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVXNlckRhdGEgPSB7XG4gICAgICAgIC4uLm1vY2tDbGVya1VzZXJEYXRhLFxuICAgICAgICBlbWFpbF9hZGRyZXNzZXM6IFtdXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzeW5jVXNlclRvU3VwYWJhc2UoaW52YWxpZFVzZXJEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdlcnJvcicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdBbCBtZW5vcyB1biBlbWFpbCBlcyByZXF1ZXJpZG8nKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIHJlaW50ZW50YXIgZW4gY2FzbyBkZSBlcnJvciB0ZW1wb3JhbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2s6IHByaW1lciBpbnRlbnRvIGZhbGxhLCBsdWVnbyDDqXhpdG9cbiAgICAgIG1vY2tTdXBhYmFzZUNoYWluLnNpbmdsZVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignQ29uZXhpw7NuIHRlbXBvcmFsIHBlcmRpZGEnKSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgZGF0YTogeyBpZDogMSB9LFxuICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGRhdGE6IHsgaWQ6ICd1c2VyXzQ1NicgfSxcbiAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJUb1N1cGFiYXNlKG1vY2tDbGVya1VzZXJEYXRhLCB7XG4gICAgICAgIHJldHJ5QXR0ZW1wdHM6IDIsXG4gICAgICAgIHJldHJ5RGVsYXk6IDEwMFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdjcmVhdGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBmYWxsYXIgZGVzcHXDqXMgZGUgYWdvdGFyIHJlaW50ZW50b3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrOiB0b2RvcyBsb3MgaW50ZW50b3MgZmFsbGFuXG4gICAgICBtb2NrU3VwYWJhc2VDaGFpbi5zaW5nbGUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdFcnJvciBwZXJzaXN0ZW50ZScpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJUb1N1cGFiYXNlKG1vY2tDbGVya1VzZXJEYXRhLCB7XG4gICAgICAgIHJldHJ5QXR0ZW1wdHM6IDIsXG4gICAgICAgIHJldHJ5RGVsYXk6IDEwMFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFjdGlvbikudG9CZSgnZXJyb3InKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbignRXJyb3IgZGVzcHXDqXMgZGUgMiBpbnRlbnRvcycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZGVsZXRlVXNlckZyb21TdXBhYmFzZScsICgpID0+IHtcbiAgICBpdCgnZGViZSBlbGltaW5hciB1c3VhcmlvIGV4aXRvc2FtZW50ZSAoc29mdCBkZWxldGUpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXJfNDU2JyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICAvLyBNb2NrOiBhY3R1YWxpemFjacOzbiBleGl0b3NhIChzb2Z0IGRlbGV0ZSlcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkudXBkYXRlKCkuZXEoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IC4uLmV4aXN0aW5nVXNlciwgaXNfYWN0aXZlOiBmYWxzZSB9LFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlbGV0ZVVzZXJGcm9tU3VwYWJhc2UoJ3VzZXJfMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdkZWxldGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIHVzdWFyaW8gbm8gZW5jb250cmFkbycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2s6IHVzdWFyaW8gbm8gZW5jb250cmFkb1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20oKS51cGRhdGUoKS5lcSgpLnNlbGVjdCgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlbGV0ZVVzZXJGcm9tU3VwYWJhc2UoJ3VzZXJfbm90X2ZvdW5kJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdkZWxldGVkJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmRldGFpbHM/Lm1lc3NhZ2UpLnRvQ29udGFpbignVXN1YXJpbyBubyBlbmNvbnRyYWRvJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzeW5jVXNlckZyb21DbGVyaycsICgpID0+IHtcbiAgICBpdCgnZGViZSBzaW5jcm9uaXphciB1c3VhcmlvIGRlc2RlIENsZXJrIGV4aXRvc2FtZW50ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDbGVya1VzZXIgPSB7XG4gICAgICAgIGlkOiAndXNlcl8xMjMnLFxuICAgICAgICBlbWFpbEFkZHJlc3NlczogW3tcbiAgICAgICAgICBlbWFpbEFkZHJlc3M6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBpZDogJ2VtYWlsXzEyMycsXG4gICAgICAgICAgdmVyaWZpY2F0aW9uOiB7IHN0YXR1czogJ3ZlcmlmaWVkJywgc3RyYXRlZ3k6ICdlbWFpbF9jb2RlJyB9XG4gICAgICAgIH1dLFxuICAgICAgICBmaXJzdE5hbWU6ICdKb2huJyxcbiAgICAgICAgbGFzdE5hbWU6ICdEb2UnLFxuICAgICAgICBjcmVhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgaW1hZ2VVcmw6ICdodHRwczovL2V4YW1wbGUuY29tL2F2YXRhci5qcGcnLFxuICAgICAgICBwaG9uZU51bWJlcnM6IFtdLFxuICAgICAgICBwdWJsaWNNZXRhZGF0YTogeyByb2xlOiAnY3VzdG9tZXInIH0sXG4gICAgICAgIHByaXZhdGVNZXRhZGF0YToge31cbiAgICAgIH07XG5cbiAgICAgIG1vY2tDbGVya0NsaWVudC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2Vyczoge1xuICAgICAgICAgIGdldFVzZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ2xlcmtVc2VyKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIC8vIE1vY2s6IHVzdWFyaW8gbm8gZXhpc3RlLCBjcmVhciBudWV2b1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20oKS5zZWxlY3QoKS5vcigpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkuc2VsZWN0KCkuZXEoKS5lcSgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6IDEgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbSgpLmluc2VydCgpLnNlbGVjdCgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6ICd1c2VyXzQ1NicgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzeW5jVXNlckZyb21DbGVyaygndXNlcl8xMjMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hY3Rpb24pLnRvQmUoJ2NyZWF0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIG1hbmVqYXIgdXN1YXJpbyBubyBlbmNvbnRyYWRvIGVuIENsZXJrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NsZXJrQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHVzZXJzOiB7XG4gICAgICAgICAgZ2V0VXNlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJGcm9tQ2xlcmsoJ3VzZXJfbm90X2ZvdW5kJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oJ1VzdWFyaW8gbm8gZW5jb250cmFkbyBlbiBDbGVyaycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnYnVsa1N5bmNVc2Vyc0Zyb21DbGVyaycsICgpID0+IHtcbiAgICBpdCgnZGViZSBzaW5jcm9uaXphciBtw7psdGlwbGVzIHVzdWFyaW9zIGV4aXRvc2FtZW50ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tDbGVya1VzZXJzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd1c2VyXzEnLFxuICAgICAgICAgIGVtYWlsQWRkcmVzc2VzOiBbeyBlbWFpbEFkZHJlc3M6ICd1c2VyMUBleGFtcGxlLmNvbScsIGlkOiAnZW1haWxfMScsIHZlcmlmaWNhdGlvbjogeyBzdGF0dXM6ICd2ZXJpZmllZCcgfSB9XSxcbiAgICAgICAgICBmaXJzdE5hbWU6ICdVc2VyJyxcbiAgICAgICAgICBsYXN0TmFtZTogJ09uZScsXG4gICAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBpbWFnZVVybDogJycsXG4gICAgICAgICAgcGhvbmVOdW1iZXJzOiBbXSxcbiAgICAgICAgICBwdWJsaWNNZXRhZGF0YToge30sXG4gICAgICAgICAgcHJpdmF0ZU1ldGFkYXRhOiB7fVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICd1c2VyXzInLFxuICAgICAgICAgIGVtYWlsQWRkcmVzc2VzOiBbeyBlbWFpbEFkZHJlc3M6ICd1c2VyMkBleGFtcGxlLmNvbScsIGlkOiAnZW1haWxfMicsIHZlcmlmaWNhdGlvbjogeyBzdGF0dXM6ICd2ZXJpZmllZCcgfSB9XSxcbiAgICAgICAgICBmaXJzdE5hbWU6ICdVc2VyJyxcbiAgICAgICAgICBsYXN0TmFtZTogJ1R3bycsXG4gICAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICBpbWFnZVVybDogJycsXG4gICAgICAgICAgcGhvbmVOdW1iZXJzOiBbXSxcbiAgICAgICAgICBwdWJsaWNNZXRhZGF0YToge30sXG4gICAgICAgICAgcHJpdmF0ZU1ldGFkYXRhOiB7fVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBtb2NrQ2xlcmtDbGllbnQubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdXNlcnM6IHtcbiAgICAgICAgICBnZXRVc2VyTGlzdDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tDbGVya1VzZXJzKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIC8vIE1vY2s6IHVzdWFyaW9zIG5vIGV4aXN0ZW4sIGNyZWFyIG51ZXZvc1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20oKS5zZWxlY3QoKS5vcigpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkuc2VsZWN0KCkuZXEoKS5lcSgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6IDEgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbSgpLmluc2VydCgpLnNlbGVjdCgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6ICduZXdfdXNlcicgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBidWxrU3luY1VzZXJzRnJvbUNsZXJrKHtcbiAgICAgICAgYmF0Y2hTaXplOiAyLFxuICAgICAgICBtYXhVc2VyczogMlxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudG90YWxQcm9jZXNzZWQpLnRvQmUoMik7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3NmdWwpLnRvQmUoMik7XG4gICAgICBleHBlY3QocmVzdWx0LmZhaWxlZCkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIG1hbmVqYXIgZXJyb3JlcyBlbiBzaW5jcm9uaXphY2nDs24gbWFzaXZhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0NsZXJrQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHVzZXJzOiB7XG4gICAgICAgICAgZ2V0VXNlckxpc3Q6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0Vycm9yIGRlIENsZXJrJykpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYnVsa1N5bmNVc2Vyc0Zyb21DbGVyaygpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LnJlc3VsdHNbMF0uZXJyb3IpLnRvQ29udGFpbignRXJyb3IgZW4gc2luY3Jvbml6YWNpw7NuIG1hc2l2YScpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiY2xlcmtDbGllbnQiLCJmbiIsInVzZXJzIiwiZ2V0VXNlciIsImdldFVzZXJMaXN0Iiwic3VwYWJhc2VBZG1pbiIsImZyb20iLCJtb2NrU3VwYWJhc2VDaGFpbiIsImxvZ1NlY3VyaXR5RXZlbnQiLCJsb2dBZG1pbkFjdGlvbiIsInNpbmdsZSIsImVxIiwib3IiLCJzZWxlY3QiLCJpbnNlcnQiLCJ1cGRhdGUiLCJkZXNjcmliZSIsIm1vY2tDbGVya0NsaWVudCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja1Jlc2V0IiwibW9ja1JldHVyblZhbHVlIiwibW9ja0NsZXJrVXNlckRhdGEiLCJpZCIsImVtYWlsX2FkZHJlc3NlcyIsImVtYWlsX2FkZHJlc3MiLCJ2ZXJpZmljYXRpb24iLCJzdGF0dXMiLCJzdHJhdGVneSIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsIm5vdyIsInVwZGF0ZWRfYXQiLCJpbWFnZV91cmwiLCJwdWJsaWNfbWV0YWRhdGEiLCJyb2xlIiwiaXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJkYXRhIiwiZXJyb3IiLCJjb2RlIiwiZW1haWwiLCJyZXN1bHQiLCJzeW5jVXNlclRvU3VwYWJhc2UiLCJleHBlY3QiLCJzdWNjZXNzIiwidG9CZSIsImFjdGlvbiIsInVzZXJJZCIsImV4aXN0aW5nVXNlciIsImludmFsaWRVc2VyRGF0YSIsInRvQ29udGFpbiIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwicmV0cnlBdHRlbXB0cyIsInJldHJ5RGVsYXkiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsImlzX2FjdGl2ZSIsIm1vY2tTdXBhYmFzZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGVsZXRlVXNlckZyb21TdXBhYmFzZSIsImRldGFpbHMiLCJtZXNzYWdlIiwibW9ja0NsZXJrVXNlciIsImVtYWlsQWRkcmVzc2VzIiwiZW1haWxBZGRyZXNzIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJpbWFnZVVybCIsInBob25lTnVtYmVycyIsInB1YmxpY01ldGFkYXRhIiwicHJpdmF0ZU1ldGFkYXRhIiwic3luY1VzZXJGcm9tQ2xlcmsiLCJtb2NrQ2xlcmtVc2VycyIsImJ1bGtTeW5jVXNlcnNGcm9tQ2xlcmsiLCJiYXRjaFNpemUiLCJtYXhVc2VycyIsInRvdGFsUHJvY2Vzc2VkIiwic3VjY2Vzc2Z1bCIsImZhaWxlZCIsInJlc3VsdHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQztBQUlELGdCQUFnQjtBQUNoQkEsS0FBS0MsSUFBSSxDQUFDLHdCQUF3QixJQUFPLENBQUE7UUFDdkNDLGFBQWFGLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQzFCQyxPQUFPO29CQUNMQyxTQUFTTCxLQUFLRyxFQUFFO29CQUNoQkcsYUFBYU4sS0FBS0csRUFBRTtnQkFDdEI7WUFDRixDQUFBO0lBQ0YsQ0FBQTtBQVlBSCxLQUFLQyxJQUFJLENBQUMsa0JBQWtCLElBQU8sQ0FBQTtRQUNqQ00sZUFBZTtZQUNiQyxNQUFNUixLQUFLRyxFQUFFLENBQUMsSUFBTU07UUFDdEI7SUFDRixDQUFBO0FBRUEseUJBQXlCO0FBQ3pCVCxLQUFLQyxJQUFJLENBQUMsNkJBQTZCLElBQU8sQ0FBQTtRQUM1Q1Msa0JBQWtCVixLQUFLRyxFQUFFO1FBQ3pCUSxnQkFBZ0JYLEtBQUtHLEVBQUU7SUFDekIsQ0FBQTs7OztpQ0FTTzt3QkFDcUI7QUE5QjVCLG1CQUFtQjtBQUNuQixNQUFN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