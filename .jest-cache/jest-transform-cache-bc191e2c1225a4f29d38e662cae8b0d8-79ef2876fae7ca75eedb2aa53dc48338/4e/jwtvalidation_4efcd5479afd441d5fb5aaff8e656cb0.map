{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\auth\\jwt-validation.ts"],"sourcesContent":["/**\n * Validaciones Avanzadas de JWT para Seguridad\n * Implementa verificación de integridad, autenticidad y validez de tokens\n */\n\nimport { auth, getAuth } from '@clerk/nextjs/server';\nimport { NextRequest } from 'next/server';\nimport type { NextApiRequest } from 'next';\n\n// =====================================================\n// TIPOS Y INTERFACES\n// =====================================================\n\nexport interface JWTValidationResult {\n  valid: boolean;\n  payload?: any;\n  error?: string;\n  code?: string;\n  severity?: 'low' | 'medium' | 'high' | 'critical';\n  details?: {\n    issuer?: string;\n    audience?: string;\n    expiresAt?: number;\n    issuedAt?: number;\n    notBefore?: number;\n    subject?: string;\n    sessionId?: string;\n    metadata?: any;\n  };\n}\n\nexport interface TokenSecurityChecks {\n  signatureValid: boolean;\n  notExpired: boolean;\n  notBeforeValid: boolean;\n  issuerValid: boolean;\n  audienceValid: boolean;\n  subjectValid: boolean;\n  metadataValid: boolean;\n  sessionValid: boolean;\n}\n\n// =====================================================\n// CONFIGURACIÓN DE SEGURIDAD\n// =====================================================\n\nconst JWT_SECURITY_CONFIG = {\n  // Tiempo máximo de vida del token (24 horas)\n  maxTokenAge: 24 * 60 * 60 * 1000,\n  \n  // Tiempo mínimo antes de expiración para considerar válido (5 minutos)\n  minTimeBeforeExpiry: 5 * 60 * 1000,\n  \n  // Issuer esperado de Clerk\n  expectedIssuer: process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY?.split('_')[1] || 'clerk',\n  \n  // Audience esperada\n  expectedAudience: process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY || '',\n  \n  // Algoritmos permitidos\n  allowedAlgorithms: ['RS256', 'HS256'],\n  \n  // Claims requeridos\n  requiredClaims: ['sub', 'iat', 'exp', 'iss', 'aud']\n};\n\n// =====================================================\n// FUNCIONES DE VALIDACIÓN DE JWT\n// =====================================================\n\n/**\n * Valida la integridad y autenticidad de un token JWT\n */\nexport async function validateJWTIntegrity(\n  request?: NextRequest | NextApiRequest\n): Promise<JWTValidationResult> {\n  try {\n    let token: string | null = null;\n    let payload: any = null;\n\n    // Obtener token usando métodos oficiales de Clerk\n    if (request && 'query' in request) {\n      // Pages Router\n      const { getToken } = getAuth(request as NextApiRequest);\n      try {\n        token = await getToken();\n      } catch (error) {\n        return {\n          valid: false,\n          error: 'Error obteniendo token desde Pages Router',\n          code: 'TOKEN_RETRIEVAL_ERROR',\n          severity: 'medium'\n        };\n      }\n    } else {\n      // App Router\n      try {\n        const { getToken } = await auth();\n        if (getToken) {\n          token = await getToken();\n        }\n      } catch (error) {\n        return {\n          valid: false,\n          error: 'Error obteniendo token desde App Router',\n          code: 'TOKEN_RETRIEVAL_ERROR',\n          severity: 'medium'\n        };\n      }\n    }\n\n    if (!token) {\n      return {\n        valid: false,\n        error: 'Token JWT no encontrado',\n        code: 'TOKEN_NOT_FOUND',\n        severity: 'high'\n      };\n    }\n\n    // Decodificar token (sin verificar firma - solo para inspección)\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) {\n        return {\n          valid: false,\n          error: 'Formato de token JWT inválido',\n          code: 'INVALID_TOKEN_FORMAT',\n          severity: 'high'\n        };\n      }\n\n      const header = JSON.parse(atob(parts[0]));\n      payload = JSON.parse(atob(parts[1]));\n\n      // Validar algoritmo\n      if (!JWT_SECURITY_CONFIG.allowedAlgorithms.includes(header.alg)) {\n        return {\n          valid: false,\n          error: `Algoritmo de token no permitido: ${header.alg}`,\n          code: 'INVALID_ALGORITHM',\n          severity: 'critical'\n        };\n      }\n\n    } catch (decodeError) {\n      return {\n        valid: false,\n        error: 'Error decodificando token JWT',\n        code: 'TOKEN_DECODE_ERROR',\n        severity: 'high'\n      };\n    }\n\n    // Ejecutar verificaciones de seguridad\n    const securityChecks = await performTokenSecurityChecks(payload, token);\n    \n    if (!securityChecks.signatureValid) {\n      return {\n        valid: false,\n        error: 'Firma del token inválida',\n        code: 'INVALID_SIGNATURE',\n        severity: 'critical'\n      };\n    }\n\n    if (!securityChecks.notExpired) {\n      return {\n        valid: false,\n        error: 'Token expirado',\n        code: 'TOKEN_EXPIRED',\n        severity: 'high'\n      };\n    }\n\n    if (!securityChecks.issuerValid) {\n      return {\n        valid: false,\n        error: 'Issuer del token inválido',\n        code: 'INVALID_ISSUER',\n        severity: 'high'\n      };\n    }\n\n    // Token válido\n    return {\n      valid: true,\n      payload,\n      details: {\n        issuer: payload.iss,\n        audience: payload.aud,\n        expiresAt: payload.exp,\n        issuedAt: payload.iat,\n        notBefore: payload.nbf,\n        subject: payload.sub,\n        sessionId: payload.sid,\n        metadata: payload.metadata\n      }\n    };\n\n  } catch (error) {\n    console.error('[JWT] Error en validación de integridad:', error);\n    return {\n      valid: false,\n      error: 'Error interno en validación de JWT',\n      code: 'VALIDATION_ERROR',\n      severity: 'critical'\n    };\n  }\n}\n\n/**\n * Realiza verificaciones de seguridad específicas del token\n */\nasync function performTokenSecurityChecks(\n  payload: any,\n  token: string\n): Promise<TokenSecurityChecks> {\n  const now = Math.floor(Date.now() / 1000);\n\n  return {\n    // Verificar que el token no esté expirado\n    notExpired: payload.exp && payload.exp > now,\n    \n    // Verificar notBefore si existe\n    notBeforeValid: !payload.nbf || payload.nbf <= now,\n    \n    // Verificar issuer\n    issuerValid: payload.iss && payload.iss.includes('clerk'),\n    \n    // Verificar audience\n    audienceValid: payload.aud && typeof payload.aud === 'string',\n    \n    // Verificar subject (userId)\n    subjectValid: payload.sub && typeof payload.sub === 'string',\n    \n    // Verificar metadata básica\n    metadataValid: true, // Clerk maneja esto internamente\n    \n    // Verificar sesión\n    sessionValid: payload.sid && typeof payload.sid === 'string',\n    \n    // Nota: La verificación de firma la hace Clerk internamente\n    signatureValid: true\n  };\n}\n\n/**\n * Valida permisos específicos en el token JWT\n */\nexport async function validateJWTPermissions(\n  requiredRole: string,\n  requiredPermissions: string[] = [],\n  request?: NextRequest | NextApiRequest\n): Promise<JWTValidationResult> {\n  try {\n    const jwtValidation = await validateJWTIntegrity(request);\n    \n    if (!jwtValidation.valid) {\n      return jwtValidation;\n    }\n\n    const payload = jwtValidation.payload;\n    \n    // Verificar rol en metadata\n    const userRole = payload.metadata?.role || payload.role;\n    if (requiredRole && userRole !== requiredRole) {\n      return {\n        valid: false,\n        error: `Rol requerido: ${requiredRole}, rol actual: ${userRole}`,\n        code: 'INSUFFICIENT_ROLE',\n        severity: 'high'\n      };\n    }\n\n    // Verificar permisos específicos si se proporcionan\n    if (requiredPermissions.length > 0) {\n      const userPermissions = payload.metadata?.permissions || [];\n      const hasAllPermissions = requiredPermissions.every(\n        permission => userPermissions.includes(permission)\n      );\n      \n      if (!hasAllPermissions) {\n        return {\n          valid: false,\n          error: `Permisos insuficientes. Requeridos: ${requiredPermissions.join(', ')}`,\n          code: 'INSUFFICIENT_PERMISSIONS',\n          severity: 'high'\n        };\n      }\n    }\n\n    return {\n      valid: true,\n      payload,\n      details: jwtValidation.details\n    };\n\n  } catch (error) {\n    console.error('[JWT] Error en validación de permisos:', error);\n    return {\n      valid: false,\n      error: 'Error interno en validación de permisos JWT',\n      code: 'PERMISSION_VALIDATION_ERROR',\n      severity: 'critical'\n    };\n  }\n}\n\n/**\n * Middleware para validación automática de JWT\n */\nexport function withJWTValidation(\n  requiredRole?: string,\n  requiredPermissions?: string[]\n) {\n  return function (handler: Function) {\n    return async (request: NextRequest | NextApiRequest, ...args: any[]) => {\n      try {\n        // Validar integridad del JWT\n        const jwtValidation = await validateJWTIntegrity(request);\n        \n        if (!jwtValidation.valid) {\n          const errorResponse = {\n            success: false,\n            error: jwtValidation.error,\n            code: jwtValidation.code,\n            severity: jwtValidation.severity\n          };\n\n          if ('query' in request) {\n            // Pages Router\n            const res = args[0] as any;\n            return res.status(401).json(errorResponse);\n          } else {\n            // App Router\n            return new Response(JSON.stringify(errorResponse), {\n              status: 401,\n              headers: { 'Content-Type': 'application/json' }\n            });\n          }\n        }\n\n        // Validar permisos si se especifican\n        if (requiredRole || requiredPermissions) {\n          const permissionValidation = await validateJWTPermissions(\n            requiredRole || '',\n            requiredPermissions || [],\n            request\n          );\n          \n          if (!permissionValidation.valid) {\n            const errorResponse = {\n              success: false,\n              error: permissionValidation.error,\n              code: permissionValidation.code,\n              severity: permissionValidation.severity\n            };\n\n            if ('query' in request) {\n              // Pages Router\n              const res = args[0] as any;\n              return res.status(403).json(errorResponse);\n            } else {\n              // App Router\n              return new Response(JSON.stringify(errorResponse), {\n                status: 403,\n                headers: { 'Content-Type': 'application/json' }\n              });\n            }\n          }\n        }\n\n        // Añadir información del JWT al request\n        (request as any).jwtPayload = jwtValidation.payload;\n        (request as any).jwtDetails = jwtValidation.details;\n\n        return handler(request, ...args);\n\n      } catch (error) {\n        console.error('[JWT] Error en middleware de validación:', error);\n        \n        const errorResponse = {\n          success: false,\n          error: 'Error interno en validación JWT',\n          code: 'JWT_MIDDLEWARE_ERROR'\n        };\n\n        if ('query' in request) {\n          // Pages Router\n          const res = args[0] as any;\n          return res.status(500).json(errorResponse);\n        } else {\n          // App Router\n          return new Response(JSON.stringify(errorResponse), {\n            status: 500,\n            headers: { 'Content-Type': 'application/json' }\n          });\n        }\n      }\n    };\n  };\n}\n"],"names":["validateJWTIntegrity","validateJWTPermissions","withJWTValidation","JWT_SECURITY_CONFIG","maxTokenAge","minTimeBeforeExpiry","expectedIssuer","process","env","NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY","split","expectedAudience","allowedAlgorithms","requiredClaims","request","token","payload","getToken","getAuth","error","valid","code","severity","auth","parts","length","header","JSON","parse","atob","includes","alg","decodeError","securityChecks","performTokenSecurityChecks","signatureValid","notExpired","issuerValid","details","issuer","iss","audience","aud","expiresAt","exp","issuedAt","iat","notBefore","nbf","subject","sub","sessionId","sid","metadata","console","now","Math","floor","Date","notBeforeValid","audienceValid","subjectValid","metadataValid","sessionValid","requiredRole","requiredPermissions","jwtValidation","userRole","role","userPermissions","permissions","hasAllPermissions","every","permission","join","handler","args","errorResponse","success","res","status","json","Response","stringify","headers","permissionValidation","jwtPayload","jwtDetails"],"mappings":"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"}