07a6753ed3f3a21362f58fcce93b8573
"use strict";
// Mock dependencies
jest.mock('@clerk/nextjs/server');
jest.mock('@/lib/supabase', ()=>({
        getSupabaseClient: jest.fn()
    }));
jest.mock('@/lib/rate-limiter', ()=>({
        checkRateLimit: jest.fn(),
        addRateLimitHeaders: jest.fn(),
        RATE_LIMIT_CONFIGS: {
            PAYMENT_CREATION: {
                requests: 10,
                window: 3600
            },
            ANALYTICS: {
                requests: 100,
                window: 3600
            }
        }
    }));
jest.mock('@/lib/metrics', ()=>({
        metricsCollector: {
            recordApiCall: jest.fn()
        }
    }));
jest.mock('@/lib/logger', ()=>({
        logger: {
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            INFO: 'info',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            API: 'api',
            PAYMENT: 'payment'
        }
    }));
jest.mock('@/lib/mercadopago', ()=>({
        createMercadoPagoClient: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../../app/api/payments/refunds/route");
const _server1 = require("@clerk/nextjs/server");
const mockAuth = _server1.auth;
describe('/api/payments/refunds', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock environment variables
        process.env.MERCADOPAGO_ACCESS_TOKEN = 'APP_USR_test_token';
        process.env.NODE_ENV = 'test';
    });
    describe('POST', ()=>{
        it('should return 401 when user is not authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'payment_123',
                    amount: 1000
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('No autorizado');
        });
        it('should process refund when user is authenticated and payment exists', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                single: jest.fn().mockResolvedValue({
                    data: {
                        id: 1,
                        total_amount: 1000,
                        payment_status: 'approved',
                        external_reference: 'payment_123'
                    },
                    error: null
                }),
                update: jest.fn().mockReturnThis(),
                insert: jest.fn().mockResolvedValue({
                    data: null,
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const requestBody = {
                payment_id: 'payment_123',
                amount: 500,
                reason: 'Customer request'
            };
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify(requestBody)
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data).toBeDefined();
            expect(data.data.payment_id).toBe('payment_123');
            expect(data.data.amount).toBe(500);
            expect(data.data.status).toBeDefined();
        });
        it('should validate required payment_id', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    amount: 500
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('payment_id es requerido');
        });
        it('should return 404 when payment is not found', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock Supabase to return no order
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                single: jest.fn().mockResolvedValue({
                    data: null,
                    error: {
                        message: 'Not found'
                    }
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'nonexistent_payment'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(404);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Pago no encontrado');
        });
        it('should validate payment status is approved', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock Supabase to return pending payment
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                single: jest.fn().mockResolvedValue({
                    data: {
                        id: 1,
                        total_amount: 1000,
                        payment_status: 'pending',
                        external_reference: 'payment_123'
                    },
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'payment_123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Solo se pueden reembolsar pagos aprobados');
        });
        it('should validate refund amount does not exceed original payment', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                eq: jest.fn().mockReturnThis(),
                single: jest.fn().mockResolvedValue({
                    data: {
                        id: 1,
                        total_amount: 1000,
                        payment_status: 'approved',
                        external_reference: 'payment_123'
                    },
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'payment_123',
                    amount: 1500 // More than original payment
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('El monto del reembolso no puede ser mayor al pago original');
        });
        it('should handle rate limiting', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter to return failure
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: false,
                remaining: 0,
                resetTime: Date.now() + 60000
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds', {
                method: 'POST',
                body: JSON.stringify({
                    payment_id: 'payment_123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(429);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Demasiadas solicitudes');
        });
    });
    describe('GET', ()=>{
        it('should return 401 when user is not authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null
            });
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('No autorizado');
        });
        it('should return refunds list when user is authenticated', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                order: jest.fn().mockReturnThis(),
                range: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({
                    data: [
                        {
                            id: 1,
                            payment_id: 'payment_123',
                            refund_id: 'refund_456',
                            amount: 500,
                            status: 'approved',
                            created_at: '2024-01-01T00:00:00Z',
                            orders: {
                                id: 1,
                                total_amount: 1000,
                                created_at: '2024-01-01T00:00:00Z'
                            }
                        }
                    ],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.success).toBe(true);
            expect(data.data).toBeDefined();
            expect(Array.isArray(data.data)).toBe(true);
            expect(data.pagination).toBeDefined();
        });
        it('should handle pagination parameters', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                order: jest.fn().mockReturnThis(),
                range: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({
                    data: [],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds?limit=5&offset=10');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(data.pagination.limit).toBe(5);
            expect(data.pagination.offset).toBe(10);
        });
        it('should filter by status when provided', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'user_123'
            });
            // Mock rate limiter
            const { checkRateLimit } = require('@/lib/rate-limiter');
            checkRateLimit.mockResolvedValue({
                success: true,
                remaining: 10
            });
            // Mock metrics collector
            const { metricsCollector } = require('@/lib/metrics');
            metricsCollector.recordApiCall.mockResolvedValue(undefined);
            // Mock Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            const mockSupabase = {
                from: jest.fn().mockReturnThis(),
                select: jest.fn().mockReturnThis(),
                order: jest.fn().mockReturnThis(),
                range: jest.fn().mockReturnThis(),
                eq: jest.fn().mockResolvedValue({
                    data: [],
                    error: null
                })
            };
            getSupabaseClient.mockReturnValue(mockSupabase);
            const request = new _server.NextRequest('http://localhost:3000/api/payments/refunds?status=approved');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(200);
            expect(mockSupabase.eq).toHaveBeenCalledWith('status', 'approved');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxhcGlcXHBheW1lbnRzXFxyZWZ1bmRzLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QgfSBmcm9tICduZXh0L3NlcnZlcic7XHJcbmltcG9ydCB7IEdFVCwgUE9TVCB9IGZyb20gJ0AvYXBwL2FwaS9wYXltZW50cy9yZWZ1bmRzL3JvdXRlJztcclxuaW1wb3J0IHsgYXV0aCB9IGZyb20gJ0BjbGVyay9uZXh0anMvc2VydmVyJztcclxuXHJcbi8vIE1vY2sgZGVwZW5kZW5jaWVzXHJcbmplc3QubW9jaygnQGNsZXJrL25leHRqcy9zZXJ2ZXInKTtcclxuamVzdC5tb2NrKCdAL2xpYi9zdXBhYmFzZScsICgpID0+ICh7XHJcbiAgZ2V0U3VwYWJhc2VDbGllbnQ6IGplc3QuZm4oKVxyXG59KSk7XHJcbmplc3QubW9jaygnQC9saWIvcmF0ZS1saW1pdGVyJywgKCkgPT4gKHtcclxuICBjaGVja1JhdGVMaW1pdDogamVzdC5mbigpLFxyXG4gIGFkZFJhdGVMaW1pdEhlYWRlcnM6IGplc3QuZm4oKSxcclxuICBSQVRFX0xJTUlUX0NPTkZJR1M6IHtcclxuICAgIFBBWU1FTlRfQ1JFQVRJT046IHsgcmVxdWVzdHM6IDEwLCB3aW5kb3c6IDM2MDAgfSxcclxuICAgIEFOQUxZVElDUzogeyByZXF1ZXN0czogMTAwLCB3aW5kb3c6IDM2MDAgfVxyXG4gIH1cclxufSkpO1xyXG5qZXN0Lm1vY2soJ0AvbGliL21ldHJpY3MnLCAoKSA9PiAoe1xyXG4gIG1ldHJpY3NDb2xsZWN0b3I6IHtcclxuICAgIHJlY29yZEFwaUNhbGw6IGplc3QuZm4oKVxyXG4gIH1cclxufSkpO1xyXG5qZXN0Lm1vY2soJ0AvbGliL2xvZ2dlcicsICgpID0+ICh7XHJcbiAgbG9nZ2VyOiB7XHJcbiAgICBpbmZvOiBqZXN0LmZuKCksXHJcbiAgICB3YXJuOiBqZXN0LmZuKCksXHJcbiAgICBlcnJvcjogamVzdC5mbigpXHJcbiAgfSxcclxuICBMb2dMZXZlbDoge1xyXG4gICAgSU5GTzogJ2luZm8nLFxyXG4gICAgV0FSTjogJ3dhcm4nLFxyXG4gICAgRVJST1I6ICdlcnJvcidcclxuICB9LFxyXG4gIExvZ0NhdGVnb3J5OiB7XHJcbiAgICBBUEk6ICdhcGknLFxyXG4gICAgUEFZTUVOVDogJ3BheW1lbnQnXHJcbiAgfVxyXG59KSk7XHJcbmplc3QubW9jaygnQC9saWIvbWVyY2Fkb3BhZ28nLCAoKSA9PiAoe1xyXG4gIGNyZWF0ZU1lcmNhZG9QYWdvQ2xpZW50OiBqZXN0LmZuKClcclxufSkpO1xyXG5cclxuY29uc3QgbW9ja0F1dGggPSBhdXRoIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGF1dGg+O1xyXG5cclxuZGVzY3JpYmUoJy9hcGkvcGF5bWVudHMvcmVmdW5kcycsICgpID0+IHtcclxuICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gICAgXHJcbiAgICAvLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlc1xyXG4gICAgcHJvY2Vzcy5lbnYuTUVSQ0FET1BBR09fQUNDRVNTX1RPS0VOID0gJ0FQUF9VU1JfdGVzdF90b2tlbic7XHJcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9ICd0ZXN0JztcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1BPU1QnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgd2hlbiB1c2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogbnVsbCB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVmdW5kcycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBwYXltZW50X2lkOiAncGF5bWVudF8xMjMnLFxyXG4gICAgICAgICAgYW1vdW50OiAxMDAwXHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdObyBhdXRvcml6YWRvJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHByb2Nlc3MgcmVmdW5kIHdoZW4gdXNlciBpcyBhdXRoZW50aWNhdGVkIGFuZCBwYXltZW50IGV4aXN0cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6ICd1c2VyXzEyMycgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIHJhdGUgbGltaXRlclxyXG4gICAgICBjb25zdCB7IGNoZWNrUmF0ZUxpbWl0IH0gPSByZXF1aXJlKCdAL2xpYi9yYXRlLWxpbWl0ZXInKTtcclxuICAgICAgY2hlY2tSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCByZW1haW5pbmc6IDEwIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayBtZXRyaWNzIGNvbGxlY3RvclxyXG4gICAgICBjb25zdCB7IG1ldHJpY3NDb2xsZWN0b3IgfSA9IHJlcXVpcmUoJ0AvbGliL21ldHJpY3MnKTtcclxuICAgICAgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRBcGlDYWxsLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAvLyBNb2NrIFN1cGFiYXNlXHJcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJyk7XHJcbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcclxuICAgICAgICBmcm9tOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIGlkOiAxLFxyXG4gICAgICAgICAgICB0b3RhbF9hbW91bnQ6IDEwMDAsXHJcbiAgICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiAnYXBwcm92ZWQnLFxyXG4gICAgICAgICAgICBleHRlcm5hbF9yZWZlcmVuY2U6ICdwYXltZW50XzEyMydcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBlcnJvcjogbnVsbFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgaW5zZXJ0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xyXG4gICAgICAgIHBheW1lbnRfaWQ6ICdwYXltZW50XzEyMycsXHJcbiAgICAgICAgYW1vdW50OiA1MDAsXHJcbiAgICAgICAgcmVhc29uOiAnQ3VzdG9tZXIgcmVxdWVzdCdcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVmdW5kcycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSlcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YSkudG9CZURlZmluZWQoKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZGF0YS5wYXltZW50X2lkKS50b0JlKCdwYXltZW50XzEyMycpO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhLmFtb3VudCkudG9CZSg1MDApO1xyXG4gICAgICBleHBlY3QoZGF0YS5kYXRhLnN0YXR1cykudG9CZURlZmluZWQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgcmVxdWlyZWQgcGF5bWVudF9pZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6ICd1c2VyXzEyMycgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIHJhdGUgbGltaXRlclxyXG4gICAgICBjb25zdCB7IGNoZWNrUmF0ZUxpbWl0IH0gPSByZXF1aXJlKCdAL2xpYi9yYXRlLWxpbWl0ZXInKTtcclxuICAgICAgY2hlY2tSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCByZW1haW5pbmc6IDEwIH0pO1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZWZ1bmRzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIGFtb3VudDogNTAwXHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdwYXltZW50X2lkIGVzIHJlcXVlcmlkbycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gNDA0IHdoZW4gcGF5bWVudCBpcyBub3QgZm91bmQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXJcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgcmVtYWluaW5nOiAxMCB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2UgdG8gcmV0dXJuIG5vIG9yZGVyXHJcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJyk7XHJcbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcclxuICAgICAgICBmcm9tOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgICBkYXRhOiBudWxsLFxyXG4gICAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH07XHJcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZWZ1bmRzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHBheW1lbnRfaWQ6ICdub25leGlzdGVudF9wYXltZW50J1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwNCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnUGFnbyBubyBlbmNvbnRyYWRvJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHBheW1lbnQgc3RhdHVzIGlzIGFwcHJvdmVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIHRvIHJldHVybiBwZW5kaW5nIHBheW1lbnRcclxuICAgICAgY29uc3QgeyBnZXRTdXBhYmFzZUNsaWVudCB9ID0gcmVxdWlyZSgnQC9saWIvc3VwYWJhc2UnKTtcclxuICAgICAgY29uc3QgbW9ja1N1cGFiYXNlID0ge1xyXG4gICAgICAgIGZyb206IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIHNpbmdsZTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcclxuICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgaWQ6IDEsXHJcbiAgICAgICAgICAgIHRvdGFsX2Ftb3VudDogMTAwMCxcclxuICAgICAgICAgICAgcGF5bWVudF9zdGF0dXM6ICdwZW5kaW5nJyxcclxuICAgICAgICAgICAgZXh0ZXJuYWxfcmVmZXJlbmNlOiAncGF5bWVudF8xMjMnXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWUobW9ja1N1cGFiYXNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVmdW5kcycsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBwYXltZW50X2lkOiAncGF5bWVudF8xMjMnXHJcbiAgICAgICAgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdTb2xvIHNlIHB1ZWRlbiByZWVtYm9sc2FyIHBhZ29zIGFwcm9iYWRvcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSByZWZ1bmQgYW1vdW50IGRvZXMgbm90IGV4Y2VlZCBvcmlnaW5hbCBwYXltZW50JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogJ3VzZXJfMTIzJyB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgcmF0ZSBsaW1pdGVyXHJcbiAgICAgIGNvbnN0IHsgY2hlY2tSYXRlTGltaXQgfSA9IHJlcXVpcmUoJ0AvbGliL3JhdGUtbGltaXRlcicpO1xyXG4gICAgICBjaGVja1JhdGVMaW1pdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHJlbWFpbmluZzogMTAgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIFN1cGFiYXNlXHJcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJyk7XHJcbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcclxuICAgICAgICBmcm9tOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzaW5nbGU6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgIGlkOiAxLFxyXG4gICAgICAgICAgICB0b3RhbF9hbW91bnQ6IDEwMDAsXHJcbiAgICAgICAgICAgIHBheW1lbnRfc3RhdHVzOiAnYXBwcm92ZWQnLFxyXG4gICAgICAgICAgICBleHRlcm5hbF9yZWZlcmVuY2U6ICdwYXltZW50XzEyMydcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBlcnJvcjogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH07XHJcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZWZ1bmRzJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHBheW1lbnRfaWQ6ICdwYXltZW50XzEyMycsXHJcbiAgICAgICAgICBhbW91bnQ6IDE1MDAgLy8gTW9yZSB0aGFuIG9yaWdpbmFsIHBheW1lbnRcclxuICAgICAgICB9KVxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xyXG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcclxuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0VsIG1vbnRvIGRlbCByZWVtYm9sc28gbm8gcHVlZGUgc2VyIG1heW9yIGFsIHBhZ28gb3JpZ2luYWwnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJhdGUgbGltaXRpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXIgdG8gcmV0dXJuIGZhaWx1cmVcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgXHJcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxyXG4gICAgICAgIHJlbWFpbmluZzogMCxcclxuICAgICAgICByZXNldFRpbWU6IERhdGUubm93KCkgKyA2MDAwMCBcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlZnVuZHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgcGF5bWVudF9pZDogJ3BheW1lbnRfMTIzJ1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQyOSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnRGVtYXNpYWRhcyBzb2xpY2l0dWRlcycpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdHRVQnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiA0MDEgd2hlbiB1c2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJJZDogbnVsbCB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcGF5bWVudHMvcmVmdW5kcycpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcclxuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdObyBhdXRvcml6YWRvJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiByZWZ1bmRzIGxpc3Qgd2hlbiB1c2VyIGlzIGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXJcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgcmVtYWluaW5nOiAxMCB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgbWV0cmljcyBjb2xsZWN0b3JcclxuICAgICAgY29uc3QgeyBtZXRyaWNzQ29sbGVjdG9yIH0gPSByZXF1aXJlKCdAL2xpYi9tZXRyaWNzJyk7XHJcbiAgICAgIG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkQXBpQ2FsbC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xyXG5cclxuICAgICAgLy8gTW9jayBTdXBhYmFzZVxyXG4gICAgICBjb25zdCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xyXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2UgPSB7XHJcbiAgICAgICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgcmFuZ2U6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgaWQ6IDEsXHJcbiAgICAgICAgICAgICAgcGF5bWVudF9pZDogJ3BheW1lbnRfMTIzJyxcclxuICAgICAgICAgICAgICByZWZ1bmRfaWQ6ICdyZWZ1bmRfNDU2JyxcclxuICAgICAgICAgICAgICBhbW91bnQ6IDUwMCxcclxuICAgICAgICAgICAgICBzdGF0dXM6ICdhcHByb3ZlZCcsXHJcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJyxcclxuICAgICAgICAgICAgICBvcmRlcnM6IHtcclxuICAgICAgICAgICAgICAgIGlkOiAxLFxyXG4gICAgICAgICAgICAgICAgdG90YWxfYW1vdW50OiAxMDAwLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogJzIwMjQtMDEtMDFUMDA6MDA6MDBaJ1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXSxcclxuICAgICAgICAgIGVycm9yOiBudWxsXHJcbiAgICAgICAgfSlcclxuICAgICAgfTtcclxuICAgICAgZ2V0U3VwYWJhc2VDbGllbnQubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlZnVuZHMnKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KGRhdGEuZGF0YSkpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChkYXRhLnBhZ2luYXRpb24pLnRvQmVEZWZpbmVkKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBwYWdpbmF0aW9uIHBhcmFtZXRlcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHsgdXNlcklkOiAndXNlcl8xMjMnIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayByYXRlIGxpbWl0ZXJcclxuICAgICAgY29uc3QgeyBjaGVja1JhdGVMaW1pdCB9ID0gcmVxdWlyZSgnQC9saWIvcmF0ZS1saW1pdGVyJyk7XHJcbiAgICAgIGNoZWNrUmF0ZUxpbWl0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgcmVtYWluaW5nOiAxMCB9KTtcclxuXHJcbiAgICAgIC8vIE1vY2sgbWV0cmljcyBjb2xsZWN0b3JcclxuICAgICAgY29uc3QgeyBtZXRyaWNzQ29sbGVjdG9yIH0gPSByZXF1aXJlKCdAL2xpYi9tZXRyaWNzJyk7XHJcbiAgICAgIG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkQXBpQ2FsbC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xyXG5cclxuICAgICAgLy8gTW9jayBTdXBhYmFzZVxyXG4gICAgICBjb25zdCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xyXG4gICAgICBjb25zdCBtb2NrU3VwYWJhc2UgPSB7XHJcbiAgICAgICAgZnJvbTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBvcmRlcjogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgcmFuZ2U6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xyXG4gICAgICAgICAgZGF0YTogW10sXHJcbiAgICAgICAgICBlcnJvcjogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH07XHJcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZShtb2NrU3VwYWJhc2UpO1xyXG5cclxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9wYXltZW50cy9yZWZ1bmRzP2xpbWl0PTUmb2Zmc2V0PTEwJyk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xyXG4gICAgICBleHBlY3QoZGF0YS5wYWdpbmF0aW9uLmxpbWl0KS50b0JlKDUpO1xyXG4gICAgICBleHBlY3QoZGF0YS5wYWdpbmF0aW9uLm9mZnNldCkudG9CZSgxMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGZpbHRlciBieSBzdGF0dXMgd2hlbiBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VySWQ6ICd1c2VyXzEyMycgfSk7XHJcblxyXG4gICAgICAvLyBNb2NrIHJhdGUgbGltaXRlclxyXG4gICAgICBjb25zdCB7IGNoZWNrUmF0ZUxpbWl0IH0gPSByZXF1aXJlKCdAL2xpYi9yYXRlLWxpbWl0ZXInKTtcclxuICAgICAgY2hlY2tSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCByZW1haW5pbmc6IDEwIH0pO1xyXG5cclxuICAgICAgLy8gTW9jayBtZXRyaWNzIGNvbGxlY3RvclxyXG4gICAgICBjb25zdCB7IG1ldHJpY3NDb2xsZWN0b3IgfSA9IHJlcXVpcmUoJ0AvbGliL21ldHJpY3MnKTtcclxuICAgICAgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRBcGlDYWxsLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAvLyBNb2NrIFN1cGFiYXNlXHJcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJyk7XHJcbiAgICAgIGNvbnN0IG1vY2tTdXBhYmFzZSA9IHtcclxuICAgICAgICBmcm9tOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gICAgICAgIG9yZGVyOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgICAgICByYW5nZTogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XHJcbiAgICAgICAgICBkYXRhOiBbXSxcclxuICAgICAgICAgIGVycm9yOiBudWxsXHJcbiAgICAgICAgfSlcclxuICAgICAgfTtcclxuICAgICAgZ2V0U3VwYWJhc2VDbGllbnQubW9ja1JldHVyblZhbHVlKG1vY2tTdXBhYmFzZSk7XHJcblxyXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL3BheW1lbnRzL3JlZnVuZHM/c3RhdHVzPWFwcHJvdmVkJyk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xyXG4gICAgICBleHBlY3QobW9ja1N1cGFiYXNlLmVxKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnc3RhdHVzJywgJ2FwcHJvdmVkJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImdldFN1cGFiYXNlQ2xpZW50IiwiZm4iLCJjaGVja1JhdGVMaW1pdCIsImFkZFJhdGVMaW1pdEhlYWRlcnMiLCJSQVRFX0xJTUlUX0NPTkZJR1MiLCJQQVlNRU5UX0NSRUFUSU9OIiwicmVxdWVzdHMiLCJ3aW5kb3ciLCJBTkFMWVRJQ1MiLCJtZXRyaWNzQ29sbGVjdG9yIiwicmVjb3JkQXBpQ2FsbCIsImxvZ2dlciIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJMb2dMZXZlbCIsIklORk8iLCJXQVJOIiwiRVJST1IiLCJMb2dDYXRlZ29yeSIsIkFQSSIsIlBBWU1FTlQiLCJjcmVhdGVNZXJjYWRvUGFnb0NsaWVudCIsIm1vY2tBdXRoIiwiYXV0aCIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJwcm9jZXNzIiwiZW52IiwiTUVSQ0FET1BBR09fQUNDRVNTX1RPS0VOIiwiTk9ERV9FTlYiLCJpdCIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidXNlcklkIiwicmVxdWVzdCIsIk5leHRSZXF1ZXN0IiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXltZW50X2lkIiwiYW1vdW50IiwicmVzcG9uc2UiLCJQT1NUIiwiZGF0YSIsImpzb24iLCJleHBlY3QiLCJzdGF0dXMiLCJ0b0JlIiwic3VjY2VzcyIsInJlcXVpcmUiLCJyZW1haW5pbmciLCJ1bmRlZmluZWQiLCJtb2NrU3VwYWJhc2UiLCJmcm9tIiwibW9ja1JldHVyblRoaXMiLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsImlkIiwidG90YWxfYW1vdW50IiwicGF5bWVudF9zdGF0dXMiLCJleHRlcm5hbF9yZWZlcmVuY2UiLCJ1cGRhdGUiLCJpbnNlcnQiLCJtb2NrUmV0dXJuVmFsdWUiLCJyZXF1ZXN0Qm9keSIsInJlYXNvbiIsInRvQmVEZWZpbmVkIiwibWVzc2FnZSIsInJlc2V0VGltZSIsIkRhdGUiLCJub3ciLCJHRVQiLCJvcmRlciIsInJhbmdlIiwicmVmdW5kX2lkIiwiY3JlYXRlZF9hdCIsIm9yZGVycyIsIkFycmF5IiwiaXNBcnJheSIsInBhZ2luYXRpb24iLCJsaW1pdCIsIm9mZnNldCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIl0sIm1hcHBpbmdzIjoiO0FBSUEsb0JBQW9CO0FBQ3BCQSxLQUFLQyxJQUFJLENBQUM7QUFDVkQsS0FBS0MsSUFBSSxDQUFDLGtCQUFrQixJQUFPLENBQUE7UUFDakNDLG1CQUFtQkYsS0FBS0csRUFBRTtJQUM1QixDQUFBO0FBQ0FILEtBQUtDLElBQUksQ0FBQyxzQkFBc0IsSUFBTyxD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