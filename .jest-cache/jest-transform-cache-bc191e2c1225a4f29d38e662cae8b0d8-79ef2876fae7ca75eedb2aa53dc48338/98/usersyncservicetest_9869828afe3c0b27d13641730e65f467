ff134b263ae4898a40acf2e1c79e9e1e
/**
 * Tests para el servicio de sincronización automática de usuarios
 * Verifica la sincronización robusta entre Clerk y Supabase
 */ "use strict";
// Mock de Clerk
jest.mock('@clerk/nextjs/server', ()=>({
        clerkClient: jest.fn(()=>({
                users: {
                    getUser: jest.fn(),
                    getUserList: jest.fn()
                }
            }))
    }));
// Mock de Supabase
jest.mock('@/lib/supabase', ()=>({
        supabaseAdmin: {
            from: jest.fn(()=>({
                    select: jest.fn(()=>({
                            eq: jest.fn(()=>({
                                    single: jest.fn(),
                                    or: jest.fn(()=>({
                                            single: jest.fn()
                                        }))
                                })),
                            or: jest.fn(()=>({
                                    single: jest.fn()
                                }))
                        })),
                    insert: jest.fn(()=>({
                            select: jest.fn(()=>({
                                    single: jest.fn()
                                }))
                        })),
                    update: jest.fn(()=>({
                            eq: jest.fn(()=>({
                                    select: jest.fn(()=>({
                                            single: jest.fn()
                                        }))
                                }))
                        }))
                }))
        }
    }));
// Mock de security audit
jest.mock('@/lib/auth/security-audit', ()=>({
        logSecurityEvent: jest.fn(),
        logAdminAction: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _usersyncservice = require("../lib/auth/user-sync-service");
const _server = require("@clerk/nextjs/server");
const _supabase = require("../lib/supabase");
describe('Servicio de Sincronización de Usuarios', ()=>{
    let mockClerkClient;
    let mockSupabase;
    beforeEach(()=>{
        mockClerkClient = _server.clerkClient;
        mockSupabase = _supabase.supabaseAdmin;
        jest.clearAllMocks();
    });
    const mockClerkUserData = {
        id: 'user_123',
        email_addresses: [
            {
                email_address: 'test@example.com',
                id: 'email_123',
                verification: {
                    status: 'verified',
                    strategy: 'email_code'
                }
            }
        ],
        first_name: 'John',
        last_name: 'Doe',
        created_at: Date.now(),
        updated_at: Date.now(),
        image_url: 'https://example.com/avatar.jpg',
        public_metadata: {
            role: 'customer'
        }
    };
    describe('syncUserToSupabase', ()=>{
        it('debe crear un nuevo usuario exitosamente', async ()=>{
            // Mock: usuario no existe
            mockSupabase.from().select().or().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            // Mock: rol por defecto existe
            mockSupabase.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            // Mock: inserción exitosa
            mockSupabase.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'user_456',
                    email: 'test@example.com'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData);
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
            expect(result.userId).toBe('user_456');
        });
        it('debe actualizar un usuario existente', async ()=>{
            const existingUser = {
                id: 'user_456',
                email: 'test@example.com',
                first_name: 'Jane'
            };
            // Mock: usuario existe
            mockSupabase.from().select().or().single.mockResolvedValue({
                data: existingUser,
                error: null
            });
            // Mock: actualización exitosa
            mockSupabase.from().update().eq().select().single.mockResolvedValue({
                data: {
                    ...existingUser,
                    first_name: 'John'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData);
            expect(result.success).toBe(true);
            expect(result.action).toBe('updated');
            expect(result.details?.newData.first_name).toBe('John');
        });
        it('debe manejar errores de validación', async ()=>{
            const invalidUserData = {
                ...mockClerkUserData,
                email_addresses: []
            };
            const result = await (0, _usersyncservice.syncUserToSupabase)(invalidUserData);
            expect(result.success).toBe(false);
            expect(result.action).toBe('error');
            expect(result.error).toContain('Al menos un email es requerido');
        });
        it('debe reintentar en caso de error temporal', async ()=>{
            // Mock: primer intento falla, segundo intento exitoso
            mockSupabase.from().select().or().single.mockRejectedValueOnce(new Error('Conexión temporal perdida')).mockResolvedValueOnce({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            mockSupabase.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            mockSupabase.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'user_456'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData, {
                retryAttempts: 2,
                retryDelay: 100
            });
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
        });
        it('debe fallar después de agotar reintentos', async ()=>{
            // Mock: todos los intentos fallan
            mockSupabase.from().select().or().single.mockRejectedValue(new Error('Error persistente'));
            const result = await (0, _usersyncservice.syncUserToSupabase)(mockClerkUserData, {
                retryAttempts: 2,
                retryDelay: 100
            });
            expect(result.success).toBe(false);
            expect(result.action).toBe('error');
            expect(result.error).toContain('Error después de 2 intentos');
        });
    });
    describe('deleteUserFromSupabase', ()=>{
        it('debe eliminar usuario exitosamente (soft delete)', async ()=>{
            const existingUser = {
                id: 'user_456',
                email: 'test@example.com',
                is_active: true
            };
            // Mock: actualización exitosa (soft delete)
            mockSupabase.from().update().eq().select().single.mockResolvedValue({
                data: {
                    ...existingUser,
                    is_active: false
                },
                error: null
            });
            const result = await (0, _usersyncservice.deleteUserFromSupabase)('user_123');
            expect(result.success).toBe(true);
            expect(result.action).toBe('deleted');
        });
        it('debe manejar usuario no encontrado', async ()=>{
            // Mock: usuario no encontrado
            mockSupabase.from().update().eq().select().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            const result = await (0, _usersyncservice.deleteUserFromSupabase)('user_not_found');
            expect(result.success).toBe(true);
            expect(result.action).toBe('deleted');
            expect(result.details?.message).toContain('Usuario no encontrado');
        });
    });
    describe('syncUserFromClerk', ()=>{
        it('debe sincronizar usuario desde Clerk exitosamente', async ()=>{
            const mockClerkUser = {
                id: 'user_123',
                emailAddresses: [
                    {
                        emailAddress: 'test@example.com',
                        id: 'email_123',
                        verification: {
                            status: 'verified',
                            strategy: 'email_code'
                        }
                    }
                ],
                firstName: 'John',
                lastName: 'Doe',
                createdAt: Date.now(),
                updatedAt: Date.now(),
                imageUrl: 'https://example.com/avatar.jpg',
                phoneNumbers: [],
                publicMetadata: {
                    role: 'customer'
                },
                privateMetadata: {}
            };
            mockClerkClient.mockReturnValue({
                users: {
                    getUser: jest.fn().mockResolvedValue(mockClerkUser)
                }
            });
            // Mock: usuario no existe, crear nuevo
            mockSupabase.from().select().or().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            mockSupabase.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            mockSupabase.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'user_456'
                },
                error: null
            });
            const result = await (0, _usersyncservice.syncUserFromClerk)('user_123');
            expect(result.success).toBe(true);
            expect(result.action).toBe('created');
        });
        it('debe manejar usuario no encontrado en Clerk', async ()=>{
            mockClerkClient.mockReturnValue({
                users: {
                    getUser: jest.fn().mockResolvedValue(null)
                }
            });
            const result = await (0, _usersyncservice.syncUserFromClerk)('user_not_found');
            expect(result.success).toBe(false);
            expect(result.error).toContain('Usuario no encontrado en Clerk');
        });
    });
    describe('bulkSyncUsersFromClerk', ()=>{
        it('debe sincronizar múltiples usuarios exitosamente', async ()=>{
            const mockClerkUsers = [
                {
                    id: 'user_1',
                    emailAddresses: [
                        {
                            emailAddress: 'user1@example.com',
                            id: 'email_1',
                            verification: {
                                status: 'verified'
                            }
                        }
                    ],
                    firstName: 'User',
                    lastName: 'One',
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    imageUrl: '',
                    phoneNumbers: [],
                    publicMetadata: {},
                    privateMetadata: {}
                },
                {
                    id: 'user_2',
                    emailAddresses: [
                        {
                            emailAddress: 'user2@example.com',
                            id: 'email_2',
                            verification: {
                                status: 'verified'
                            }
                        }
                    ],
                    firstName: 'User',
                    lastName: 'Two',
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                    imageUrl: '',
                    phoneNumbers: [],
                    publicMetadata: {},
                    privateMetadata: {}
                }
            ];
            mockClerkClient.mockReturnValue({
                users: {
                    getUserList: jest.fn().mockResolvedValue(mockClerkUsers)
                }
            });
            // Mock: usuarios no existen, crear nuevos
            mockSupabase.from().select().or().single.mockResolvedValue({
                data: null,
                error: {
                    code: 'PGRST116'
                }
            });
            mockSupabase.from().select().eq().eq().single.mockResolvedValue({
                data: {
                    id: 1
                },
                error: null
            });
            mockSupabase.from().insert().select().single.mockResolvedValue({
                data: {
                    id: 'new_user'
                },
                error: null
            });
            const result = await (0, _usersyncservice.bulkSyncUsersFromClerk)({
                batchSize: 2,
                maxUsers: 2
            });
            expect(result.success).toBe(true);
            expect(result.totalProcessed).toBe(2);
            expect(result.successful).toBe(2);
            expect(result.failed).toBe(0);
        });
        it('debe manejar errores en sincronización masiva', async ()=>{
            mockClerkClient.mockReturnValue({
                users: {
                    getUserList: jest.fn().mockRejectedValue(new Error('Error de Clerk'))
                }
            });
            const result = await (0, _usersyncservice.bulkSyncUsersFromClerk)();
            expect(result.success).toBe(false);
            expect(result.failed).toBe(1);
            expect(result.results[0].error).toContain('Error en sincronización masiva');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFx1c2VyLXN5bmMtc2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgcGFyYSBlbCBzZXJ2aWNpbyBkZSBzaW5jcm9uaXphY2nDs24gYXV0b23DoXRpY2EgZGUgdXN1YXJpb3NcbiAqIFZlcmlmaWNhIGxhIHNpbmNyb25pemFjacOzbiByb2J1c3RhIGVudHJlIENsZXJrIHkgU3VwYWJhc2VcbiAqL1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcblxuLy8gTW9jayBkZSBDbGVya1xuamVzdC5tb2NrKCdAY2xlcmsvbmV4dGpzL3NlcnZlcicsICgpID0+ICh7XG4gIGNsZXJrQ2xpZW50OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgdXNlcnM6IHtcbiAgICAgIGdldFVzZXI6IGplc3QuZm4oKSxcbiAgICAgIGdldFVzZXJMaXN0OiBqZXN0LmZuKClcbiAgICB9XG4gIH0pKVxufSkpO1xuXG4vLyBNb2NrIGRlIFN1cGFiYXNlXG5qZXN0Lm1vY2soJ0AvbGliL3N1cGFiYXNlJywgKCkgPT4gKHtcbiAgc3VwYWJhc2VBZG1pbjoge1xuICAgIGZyb206IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBlcTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpLFxuICAgICAgICAgIG9yOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSksXG4gICAgICAgIG9yOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKClcbiAgICAgICAgfSkpXG4gICAgICB9KSksXG4gICAgICBpbnNlcnQ6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKClcbiAgICAgICAgfSkpXG4gICAgICB9KSksXG4gICAgICB1cGRhdGU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIHNpbmdsZTogamVzdC5mbigpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKVxuICAgICAgfSkpXG4gICAgfSkpXG4gIH1cbn0pKTtcblxuLy8gTW9jayBkZSBzZWN1cml0eSBhdWRpdFxuamVzdC5tb2NrKCdAL2xpYi9hdXRoL3NlY3VyaXR5LWF1ZGl0JywgKCkgPT4gKHtcbiAgbG9nU2VjdXJpdHlFdmVudDogamVzdC5mbigpLFxuICBsb2dBZG1pbkFjdGlvbjogamVzdC5mbigpXG59KSk7XG5cbmltcG9ydCB7XG4gIHN5bmNVc2VyVG9TdXBhYmFzZSxcbiAgc3luY1VzZXJGcm9tQ2xlcmssXG4gIGRlbGV0ZVVzZXJGcm9tU3VwYWJhc2UsXG4gIGJ1bGtTeW5jVXNlcnNGcm9tQ2xlcmssXG4gIHR5cGUgQ2xlcmtVc2VyRGF0YSxcbiAgdHlwZSBTeW5jT3B0aW9uc1xufSBmcm9tICdAL2xpYi9hdXRoL3VzZXItc3luYy1zZXJ2aWNlJztcbmltcG9ydCB7IGNsZXJrQ2xpZW50IH0gZnJvbSAnQGNsZXJrL25leHRqcy9zZXJ2ZXInO1xuaW1wb3J0IHsgc3VwYWJhc2VBZG1pbiB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcblxuZGVzY3JpYmUoJ1NlcnZpY2lvIGRlIFNpbmNyb25pemFjacOzbiBkZSBVc3VhcmlvcycsICgpID0+IHtcbiAgbGV0IG1vY2tDbGVya0NsaWVudDogamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgY2xlcmtDbGllbnQ+O1xuICBsZXQgbW9ja1N1cGFiYXNlOiBhbnk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja0NsZXJrQ2xpZW50ID0gY2xlcmtDbGllbnQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgY2xlcmtDbGllbnQ+O1xuICAgIG1vY2tTdXBhYmFzZSA9IHN1cGFiYXNlQWRtaW4gYXMgYW55O1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBjb25zdCBtb2NrQ2xlcmtVc2VyRGF0YTogQ2xlcmtVc2VyRGF0YSA9IHtcbiAgICBpZDogJ3VzZXJfMTIzJyxcbiAgICBlbWFpbF9hZGRyZXNzZXM6IFt7XG4gICAgICBlbWFpbF9hZGRyZXNzOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICBpZDogJ2VtYWlsXzEyMycsXG4gICAgICB2ZXJpZmljYXRpb246IHtcbiAgICAgICAgc3RhdHVzOiAndmVyaWZpZWQnLFxuICAgICAgICBzdHJhdGVneTogJ2VtYWlsX2NvZGUnXG4gICAgICB9XG4gICAgfV0sXG4gICAgZmlyc3RfbmFtZTogJ0pvaG4nLFxuICAgIGxhc3RfbmFtZTogJ0RvZScsXG4gICAgY3JlYXRlZF9hdDogRGF0ZS5ub3coKSxcbiAgICB1cGRhdGVkX2F0OiBEYXRlLm5vdygpLFxuICAgIGltYWdlX3VybDogJ2h0dHBzOi8vZXhhbXBsZS5jb20vYXZhdGFyLmpwZycsXG4gICAgcHVibGljX21ldGFkYXRhOiB7IHJvbGU6ICdjdXN0b21lcicgfVxuICB9O1xuXG4gIGRlc2NyaWJlKCdzeW5jVXNlclRvU3VwYWJhc2UnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgY3JlYXIgdW4gbnVldm8gdXN1YXJpbyBleGl0b3NhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrOiB1c3VhcmlvIG5vIGV4aXN0ZVxuICAgICAgbW9ja1N1cGFiYXNlLmZyb20oKS5zZWxlY3QoKS5vcigpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IGNvZGU6ICdQR1JTVDExNicgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2s6IHJvbCBwb3IgZGVmZWN0byBleGlzdGVcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkuc2VsZWN0KCkuZXEoKS5lcSgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6IDEgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrOiBpbnNlcmNpw7NuIGV4aXRvc2FcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkuaW5zZXJ0KCkuc2VsZWN0KCkuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyBpZDogJ3VzZXJfNDU2JywgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyB9LFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN5bmNVc2VyVG9TdXBhYmFzZShtb2NrQ2xlcmtVc2VyRGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdjcmVhdGVkJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnVzZXJJZCkudG9CZSgndXNlcl80NTYnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGFjdHVhbGl6YXIgdW4gdXN1YXJpbyBleGlzdGVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ1VzZXIgPSB7XG4gICAgICAgIGlkOiAndXNlcl80NTYnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBmaXJzdF9uYW1lOiAnSmFuZSdcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vY2s6IHVzdWFyaW8gZXhpc3RlXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbSgpLnNlbGVjdCgpLm9yKCkuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogZXhpc3RpbmdVc2VyLFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2s6IGFjdHVhbGl6YWNpw7NuIGV4aXRvc2FcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkudXBkYXRlKCkuZXEoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IC4uLmV4aXN0aW5nVXNlciwgZmlyc3RfbmFtZTogJ0pvaG4nIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJUb1N1cGFiYXNlKG1vY2tDbGVya1VzZXJEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hY3Rpb24pLnRvQmUoJ3VwZGF0ZWQnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGV0YWlscz8ubmV3RGF0YS5maXJzdF9uYW1lKS50b0JlKCdKb2huJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIGVycm9yZXMgZGUgdmFsaWRhY2nDs24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVXNlckRhdGEgPSB7XG4gICAgICAgIC4uLm1vY2tDbGVya1VzZXJEYXRhLFxuICAgICAgICBlbWFpbF9hZGRyZXNzZXM6IFtdXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzeW5jVXNlclRvU3VwYWJhc2UoaW52YWxpZFVzZXJEYXRhKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdlcnJvcicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdBbCBtZW5vcyB1biBlbWFpbCBlcyByZXF1ZXJpZG8nKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIHJlaW50ZW50YXIgZW4gY2FzbyBkZSBlcnJvciB0ZW1wb3JhbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2s6IHByaW1lciBpbnRlbnRvIGZhbGxhLCBzZWd1bmRvIGludGVudG8gZXhpdG9zb1xuICAgICAgbW9ja1N1cGFiYXNlLmZyb20oKS5zZWxlY3QoKS5vcigpLnNpbmdsZVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignQ29uZXhpw7NuIHRlbXBvcmFsIHBlcmRpZGEnKSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkuc2VsZWN0KCkuZXEoKS5lcSgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6IDEgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbSgpLmluc2VydCgpLnNlbGVjdCgpLnNpbmdsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IHsgaWQ6ICd1c2VyXzQ1NicgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzeW5jVXNlclRvU3VwYWJhc2UobW9ja0NsZXJrVXNlckRhdGEsIHtcbiAgICAgICAgcmV0cnlBdHRlbXB0czogMixcbiAgICAgICAgcmV0cnlEZWxheTogMTAwXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hY3Rpb24pLnRvQmUoJ2NyZWF0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGZhbGxhciBkZXNwdcOpcyBkZSBhZ290YXIgcmVpbnRlbnRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2s6IHRvZG9zIGxvcyBpbnRlbnRvcyBmYWxsYW5cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkuc2VsZWN0KCkub3IoKS5zaW5nbGVcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRXJyb3IgcGVyc2lzdGVudGUnKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN5bmNVc2VyVG9TdXBhYmFzZShtb2NrQ2xlcmtVc2VyRGF0YSwge1xuICAgICAgICByZXRyeUF0dGVtcHRzOiAyLFxuICAgICAgICByZXRyeURlbGF5OiAxMDBcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hY3Rpb24pLnRvQmUoJ2Vycm9yJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oJ0Vycm9yIGRlc3B1w6lzIGRlIDIgaW50ZW50b3MnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2RlbGV0ZVVzZXJGcm9tU3VwYWJhc2UnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgZWxpbWluYXIgdXN1YXJpbyBleGl0b3NhbWVudGUgKHNvZnQgZGVsZXRlKScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IHtcbiAgICAgICAgaWQ6ICd1c2VyXzQ1NicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZVxuICAgICAgfTtcblxuICAgICAgLy8gTW9jazogYWN0dWFsaXphY2nDs24gZXhpdG9zYSAoc29mdCBkZWxldGUpXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbSgpLnVwZGF0ZSgpLmVxKCkuc2VsZWN0KCkuc2luZ2xlLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogeyAuLi5leGlzdGluZ1VzZXIsIGlzX2FjdGl2ZTogZmFsc2UgfSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWxldGVVc2VyRnJvbVN1cGFiYXNlKCd1c2VyXzEyMycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFjdGlvbikudG9CZSgnZGVsZXRlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgbWFuZWphciB1c3VhcmlvIG5vIGVuY29udHJhZG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrOiB1c3VhcmlvIG5vIGVuY29udHJhZG9cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkudXBkYXRlKCkuZXEoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWxldGVVc2VyRnJvbVN1cGFiYXNlKCd1c2VyX25vdF9mb3VuZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmFjdGlvbikudG9CZSgnZGVsZXRlZCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kZXRhaWxzPy5tZXNzYWdlKS50b0NvbnRhaW4oJ1VzdWFyaW8gbm8gZW5jb250cmFkbycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnc3luY1VzZXJGcm9tQ2xlcmsnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgc2luY3Jvbml6YXIgdXN1YXJpbyBkZXNkZSBDbGVyayBleGl0b3NhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ2xlcmtVc2VyID0ge1xuICAgICAgICBpZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgZW1haWxBZGRyZXNzZXM6IFt7XG4gICAgICAgICAgZW1haWxBZGRyZXNzOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgaWQ6ICdlbWFpbF8xMjMnLFxuICAgICAgICAgIHZlcmlmaWNhdGlvbjogeyBzdGF0dXM6ICd2ZXJpZmllZCcsIHN0cmF0ZWd5OiAnZW1haWxfY29kZScgfVxuICAgICAgICB9XSxcbiAgICAgICAgZmlyc3ROYW1lOiAnSm9obicsXG4gICAgICAgIGxhc3ROYW1lOiAnRG9lJyxcbiAgICAgICAgY3JlYXRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIGltYWdlVXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbS9hdmF0YXIuanBnJyxcbiAgICAgICAgcGhvbmVOdW1iZXJzOiBbXSxcbiAgICAgICAgcHVibGljTWV0YWRhdGE6IHsgcm9sZTogJ2N1c3RvbWVyJyB9LFxuICAgICAgICBwcml2YXRlTWV0YWRhdGE6IHt9XG4gICAgICB9O1xuXG4gICAgICBtb2NrQ2xlcmtDbGllbnQubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdXNlcnM6IHtcbiAgICAgICAgICBnZXRVc2VyOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NsZXJrVXNlcilcbiAgICAgICAgfVxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAvLyBNb2NrOiB1c3VhcmlvIG5vIGV4aXN0ZSwgY3JlYXIgbnVldm9cbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkuc2VsZWN0KCkub3IoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH1cbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbSgpLnNlbGVjdCgpLmVxKCkuZXEoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAxIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlLmZyb20oKS5pbnNlcnQoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAndXNlcl80NTYnIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3luY1VzZXJGcm9tQ2xlcmsoJ3VzZXJfMTIzJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYWN0aW9uKS50b0JlKCdjcmVhdGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIHVzdWFyaW8gbm8gZW5jb250cmFkbyBlbiBDbGVyaycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDbGVya0NsaWVudC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2Vyczoge1xuICAgICAgICAgIGdldFVzZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN5bmNVc2VyRnJvbUNsZXJrKCd1c2VyX25vdF9mb3VuZCcpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdVc3VhcmlvIG5vIGVuY29udHJhZG8gZW4gQ2xlcmsnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2J1bGtTeW5jVXNlcnNGcm9tQ2xlcmsnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgc2luY3Jvbml6YXIgbcO6bHRpcGxlcyB1c3VhcmlvcyBleGl0b3NhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ2xlcmtVc2VycyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndXNlcl8xJyxcbiAgICAgICAgICBlbWFpbEFkZHJlc3NlczogW3sgZW1haWxBZGRyZXNzOiAndXNlcjFAZXhhbXBsZS5jb20nLCBpZDogJ2VtYWlsXzEnLCB2ZXJpZmljYXRpb246IHsgc3RhdHVzOiAndmVyaWZpZWQnIH0gfV0sXG4gICAgICAgICAgZmlyc3ROYW1lOiAnVXNlcicsXG4gICAgICAgICAgbGFzdE5hbWU6ICdPbmUnLFxuICAgICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgaW1hZ2VVcmw6ICcnLFxuICAgICAgICAgIHBob25lTnVtYmVyczogW10sXG4gICAgICAgICAgcHVibGljTWV0YWRhdGE6IHt9LFxuICAgICAgICAgIHByaXZhdGVNZXRhZGF0YToge31cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAndXNlcl8yJyxcbiAgICAgICAgICBlbWFpbEFkZHJlc3NlczogW3sgZW1haWxBZGRyZXNzOiAndXNlcjJAZXhhbXBsZS5jb20nLCBpZDogJ2VtYWlsXzInLCB2ZXJpZmljYXRpb246IHsgc3RhdHVzOiAndmVyaWZpZWQnIH0gfV0sXG4gICAgICAgICAgZmlyc3ROYW1lOiAnVXNlcicsXG4gICAgICAgICAgbGFzdE5hbWU6ICdUd28nLFxuICAgICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICAgICAgaW1hZ2VVcmw6ICcnLFxuICAgICAgICAgIHBob25lTnVtYmVyczogW10sXG4gICAgICAgICAgcHVibGljTWV0YWRhdGE6IHt9LFxuICAgICAgICAgIHByaXZhdGVNZXRhZGF0YToge31cbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgbW9ja0NsZXJrQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHVzZXJzOiB7XG4gICAgICAgICAgZ2V0VXNlckxpc3Q6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ2xlcmtVc2VycylcbiAgICAgICAgfVxuICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAvLyBNb2NrOiB1c3VhcmlvcyBubyBleGlzdGVuLCBjcmVhciBudWV2b3NcbiAgICAgIG1vY2tTdXBhYmFzZS5mcm9tKCkuc2VsZWN0KCkub3IoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBjb2RlOiAnUEdSU1QxMTYnIH1cbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2UuZnJvbSgpLnNlbGVjdCgpLmVxKCkuZXEoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAxIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlLmZyb20oKS5pbnNlcnQoKS5zZWxlY3QoKS5zaW5nbGUubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiB7IGlkOiAnbmV3X3VzZXInIH0sXG4gICAgICAgIGVycm9yOiBudWxsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYnVsa1N5bmNVc2Vyc0Zyb21DbGVyayh7XG4gICAgICAgIGJhdGNoU2l6ZTogMixcbiAgICAgICAgbWF4VXNlcnM6IDJcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnRvdGFsUHJvY2Vzc2VkKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzZnVsKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5mYWlsZWQpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBtYW5lamFyIGVycm9yZXMgZW4gc2luY3Jvbml6YWNpw7NuIG1hc2l2YScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDbGVya0NsaWVudC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2Vyczoge1xuICAgICAgICAgIGdldFVzZXJMaXN0OiBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdFcnJvciBkZSBDbGVyaycpKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJ1bGtTeW5jVXNlcnNGcm9tQ2xlcmsoKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZmFpbGVkKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5yZXN1bHRzWzBdLmVycm9yKS50b0NvbnRhaW4oJ0Vycm9yIGVuIHNpbmNyb25pemFjacOzbiBtYXNpdmEnKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNsZXJrQ2xpZW50IiwiZm4iLCJ1c2VycyIsImdldFVzZXIiLCJnZXRVc2VyTGlzdCIsInN1cGFiYXNlQWRtaW4iLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJvciIsImluc2VydCIsInVwZGF0ZSIsImxvZ1NlY3VyaXR5RXZlbnQiLCJsb2dBZG1pbkFjdGlvbiIsImRlc2NyaWJlIiwibW9ja0NsZXJrQ2xpZW50IiwibW9ja1N1cGFiYXNlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlcmtVc2VyRGF0YSIsImlkIiwiZW1haWxfYWRkcmVzc2VzIiwiZW1haWxfYWRkcmVzcyIsInZlcmlmaWNhdGlvbiIsInN0YXR1cyIsInN0cmF0ZWd5IiwiZmlyc3RfbmFtZSIsImxhc3RfbmFtZSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwibm93IiwidXBkYXRlZF9hdCIsImltYWdlX3VybCIsInB1YmxpY19tZXRhZGF0YSIsInJvbGUiLCJpdCIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsImVycm9yIiwiY29kZSIsImVtYWlsIiwicmVzdWx0Iiwic3luY1VzZXJUb1N1cGFiYXNlIiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJhY3Rpb24iLCJ1c2VySWQiLCJleGlzdGluZ1VzZXIiLCJkZXRhaWxzIiwibmV3RGF0YSIsImludmFsaWRVc2VyRGF0YSIsInRvQ29udGFpbiIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwicmV0cnlBdHRlbXB0cyIsInJldHJ5RGVsYXkiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsImlzX2FjdGl2ZSIsImRlbGV0ZVVzZXJGcm9tU3VwYWJhc2UiLCJtZXNzYWdlIiwibW9ja0NsZXJrVXNlciIsImVtYWlsQWRkcmVzc2VzIiwiZW1haWxBZGRyZXNzIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJpbWFnZVVybCIsInBob25lTnVtYmVycyIsInB1YmxpY01ldGFkYXRhIiwicHJpdmF0ZU1ldGFkYXRhIiwibW9ja1JldHVyblZhbHVlIiwic3luY1VzZXJGcm9tQ2xlcmsiLCJtb2NrQ2xlcmtVc2VycyIsImJ1bGtTeW5jVXNlcnNGcm9tQ2xlcmsiLCJiYXRjaFNpemUiLCJtYXhVc2VycyIsInRvdGFsUHJvY2Vzc2VkIiwic3VjY2Vzc2Z1bCIsImZhaWxlZCIsInJlc3VsdHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQztBQUlELGdCQUFnQjtBQUNoQkEsS0FBS0MsSUFBSSxDQUFDLHdCQUF3QixJQUFPLENBQUE7UUFDdkNDLGFBQWFGLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQzFCQyxPQUFPO29CQUNMQyxTQUFTTCxLQUFLRyxFQUFFO29CQUNoQkcsYUFBYU4sS0FBS0csRUFBRTtnQkFDdEI7WUFDRixDQUFBO0lBQ0YsQ0FBQTtBQUVBLG1CQUFtQjtBQUNuQkgsS0FBS0Ms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