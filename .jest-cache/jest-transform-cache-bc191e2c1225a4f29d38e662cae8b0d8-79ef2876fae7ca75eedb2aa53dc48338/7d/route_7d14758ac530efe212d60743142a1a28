b46a638f8231150d7b98364306b7c9e9
// ===================================
// PINTEYA E-COMMERCE - MERCADOPAGO REFUNDS API
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    GET: function() {
        return GET;
    },
    POST: function() {
        return POST;
    }
});
const _server = require("next/server");
const _server1 = require("@clerk/nextjs/server");
const _supabase = require("../../../../lib/supabase");
const _logger = require("../../../../lib/logger");
const _ratelimiter = require("../../../../lib/rate-limiter");
const _metrics = require("../../../../lib/metrics");
const _mercadopago = require("../../../../lib/mercadopago");
const _mercadopago1 = require("mercadopago");
async function POST(request) {
    const startTime = Date.now();
    const clientIP = request.headers.get('x-forwarded-for') || 'unknown';
    const userAgent = request.headers.get('user-agent') || 'unknown';
    try {
        // Verificar autenticación
        const { userId } = await (0, _server1.auth)();
        if (!userId) {
            return _server.NextResponse.json({
                success: false,
                error: 'No autorizado'
            }, {
                status: 401
            });
        }
        // Rate limiting
        const rateLimitResult = await (0, _ratelimiter.checkRateLimit)(request, _ratelimiter.RATE_LIMIT_CONFIGS.PAYMENT_API);
        if (!rateLimitResult.success) {
            _logger.logger.warn(_logger.LogCategory.API, 'Rate limit exceeded for refunds', {
                clientIP,
                userId
            });
            const response = _server.NextResponse.json({
                success: false,
                error: 'Demasiadas solicitudes'
            }, {
                status: 429
            });
            (0, _ratelimiter.addRateLimitHeaders)(response, rateLimitResult, _ratelimiter.RATE_LIMIT_CONFIGS.PAYMENT_API);
            return response;
        }
        const body = await request.json();
        const { payment_id, amount, reason, metadata } = body;
        // Validar datos requeridos
        if (!payment_id) {
            return _server.NextResponse.json({
                success: false,
                error: 'payment_id es requerido'
            }, {
                status: 400
            });
        }
        _logger.logger.info(_logger.LogCategory.PAYMENT, 'Refund request started', {
            userId,
            payment_id,
            amount,
            reason,
            clientIP
        });
        // Verificar que el pago existe y pertenece al usuario
        const supabase = (0, _supabase.getSupabaseClient)();
        if (!supabase) {
            return _server.NextResponse.json({
                success: false,
                error: 'Error de configuración de base de datos'
            }, {
                status: 500
            });
        }
        const { data: order, error: orderError } = await supabase.from('orders').select('id, total_amount, payment_status, external_reference').eq('external_reference', payment_id).single();
        if (orderError || !order) {
            return _server.NextResponse.json({
                success: false,
                error: 'Pago no encontrado'
            }, {
                status: 404
            });
        }
        if (order.payment_status !== 'approved') {
            return _server.NextResponse.json({
                success: false,
                error: 'Solo se pueden reembolsar pagos aprobados'
            }, {
                status: 400
            });
        }
        // Validar monto del reembolso
        const refundAmount = amount || order.total_amount;
        if (refundAmount > order.total_amount) {
            return _server.NextResponse.json({
                success: false,
                error: 'El monto del reembolso no puede ser mayor al pago original'
            }, {
                status: 400
            });
        }
        // Procesar reembolso con MercadoPago
        const refundResult = await processRefund(payment_id, refundAmount, reason, metadata);
        // Actualizar estado en base de datos
        await supabase.from('orders').update({
            payment_status: refundResult.status === 'approved' ? 'refunded' : 'refund_pending',
            updated_at: new Date().toISOString()
        }).eq('id', order.id);
        // Registrar reembolso en tabla de refunds (si existe)
        try {
            await supabase.from('refunds').insert({
                order_id: order.id,
                payment_id,
                refund_id: refundResult.id,
                amount: refundAmount,
                status: refundResult.status,
                reason: reason || 'Reembolso solicitado por el cliente',
                metadata: metadata || {},
                created_at: new Date().toISOString()
            });
        } catch (refundInsertError) {
            // Si la tabla refunds no existe, solo loggeamos el warning
            _logger.logger.warn(_logger.LogCategory.PAYMENT, 'Refunds table not found, skipping insert', {
                payment_id,
                refund_id: refundResult.id
            });
        }
        // Registrar métricas
        await _metrics.metricsCollector.recordRequest('/api/payments/refunds', 'POST', 200, Date.now() - startTime, {
            userId,
            payment_id,
            amount: refundAmount
        });
        _logger.logger.info(_logger.LogCategory.PAYMENT, 'Refund processed successfully', {
            userId,
            payment_id,
            refund_id: refundResult.id,
            amount: refundAmount,
            status: refundResult.status,
            processingTime: Date.now() - startTime
        });
        const response = _server.NextResponse.json({
            success: true,
            data: refundResult,
            timestamp: Date.now(),
            processing_time: Date.now() - startTime
        });
        (0, _ratelimiter.addRateLimitHeaders)(response, rateLimitResult, _ratelimiter.RATE_LIMIT_CONFIGS.PAYMENT_API);
        return response;
    } catch (error) {
        const processingTime = Date.now() - startTime;
        _logger.logger.performance(_logger.LogLevel.ERROR, 'Refund processing failed', {
            operation: 'refund-processing-api',
            duration: processingTime,
            statusCode: 500
        }, {
            clientIP,
            userAgent
        });
        await _metrics.metricsCollector.recordRequest('/api/payments/refunds', 'POST', 500, processingTime, {
            error: error.message
        });
        return _server.NextResponse.json({
            success: false,
            error: 'Error interno del servidor'
        }, {
            status: 500
        });
    }
}
async function GET(request) {
    const startTime = Date.now();
    const clientIP = request.headers.get('x-forwarded-for') || 'unknown';
    try {
        // Verificar autenticación
        const { userId } = await (0, _server1.auth)();
        if (!userId) {
            return _server.NextResponse.json({
                success: false,
                error: 'No autorizado'
            }, {
                status: 401
            });
        }
        // Rate limiting
        const rateLimitResult = await (0, _ratelimiter.checkRateLimit)(request, _ratelimiter.RATE_LIMIT_CONFIGS.QUERY_API);
        if (!rateLimitResult.success) {
            const response = _server.NextResponse.json({
                success: false,
                error: 'Demasiadas solicitudes'
            }, {
                status: 429
            });
            (0, _ratelimiter.addRateLimitHeaders)(response, rateLimitResult, _ratelimiter.RATE_LIMIT_CONFIGS.QUERY_API);
            return response;
        }
        // Obtener parámetros de consulta
        const url = new URL(request.url);
        const limit = parseInt(url.searchParams.get('limit') || '10');
        const offset = parseInt(url.searchParams.get('offset') || '0');
        const status = url.searchParams.get('status');
        const supabase = (0, _supabase.getSupabaseClient)();
        if (!supabase) {
            return _server.NextResponse.json({
                success: false,
                error: 'Error de configuración de base de datos'
            }, {
                status: 500
            });
        }
        // Construir query
        let query = supabase.from('refunds').select(`
        *,
        orders (
          id,
          total_amount,
          created_at
        )
      `).order('created_at', {
            ascending: false
        }).range(offset, offset + limit - 1);
        if (status) {
            query = query.eq('status', status);
        }
        const { data: refunds, error } = await query;
        if (error) {
            throw new Error(`Error al obtener reembolsos: ${error.message}`);
        }
        // Registrar métricas
        await _metrics.metricsCollector.recordRequest('/api/payments/refunds', 'GET', 200, Date.now() - startTime, {
            userId,
            count: (refunds?.length || 0).toString()
        });
        _logger.logger.info(_logger.LogCategory.API, 'Refunds list retrieved', {
            userId,
            count: refunds?.length || 0,
            processingTime: Date.now() - startTime
        });
        const response = _server.NextResponse.json({
            success: true,
            data: refunds || [],
            pagination: {
                limit,
                offset,
                total: refunds?.length || 0
            },
            timestamp: Date.now(),
            processing_time: Date.now() - startTime
        });
        (0, _ratelimiter.addRateLimitHeaders)(response, rateLimitResult, _ratelimiter.RATE_LIMIT_CONFIGS.QUERY_API);
        return response;
    } catch (error) {
        const processingTime = Date.now() - startTime;
        _logger.logger.performance(_logger.LogLevel.ERROR, 'Refunds list failed', {
            operation: 'refunds-list-api',
            duration: processingTime,
            statusCode: 500
        }, {
            clientIP
        });
        return _server.NextResponse.json({
            success: false,
            error: 'Error interno del servidor'
        }, {
            status: 500
        });
    }
}
/**
 * Procesa reembolso con MercadoPago
 */ async function processRefund(paymentId, amount, reason, metadata) {
    try {
        // Crear cliente de MercadoPago
        const client = (0, _mercadopago.createMercadoPagoClient)();
        const payment = new _mercadopago1.Payment(client);
        // En una implementación real, aquí se haría la llamada a la API de MercadoPago
        // Por ahora simulamos el reembolso
        const refundId = `refund_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        // Simular respuesta de MercadoPago
        const refundResponse = {
            id: refundId,
            payment_id: paymentId,
            amount,
            status: 'approved',
            reason: reason || 'Reembolso solicitado',
            created_at: new Date().toISOString(),
            metadata: metadata || {}
        };
        _logger.logger.info(_logger.LogCategory.PAYMENT, 'MercadoPago refund simulated', {
            payment_id: paymentId,
            refund_id: refundId,
            amount,
            status: refundResponse.status
        });
        return refundResponse;
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.PAYMENT, 'MercadoPago refund failed', error);
        // En caso de error, devolver estado pendiente
        return {
            id: `refund_error_${Date.now()}`,
            payment_id: paymentId,
            amount,
            status: 'pending',
            reason: 'Error al procesar reembolso, se procesará manualmente',
            created_at: new Date().toISOString(),
            metadata: metadata || {}
        };
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcYXBwXFxhcGlcXHBheW1lbnRzXFxyZWZ1bmRzXFxyb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBNRVJDQURPUEFHTyBSRUZVTkRTIEFQSVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHsgYXV0aCB9IGZyb20gJ0BjbGVyay9uZXh0anMvc2VydmVyJztcclxuaW1wb3J0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSc7XHJcbmltcG9ydCB7IGxvZ2dlciwgTG9nTGV2ZWwsIExvZ0NhdGVnb3J5IH0gZnJvbSAnQC9saWIvbG9nZ2VyJztcclxuaW1wb3J0IHsgY2hlY2tSYXRlTGltaXQsIGFkZFJhdGVMaW1pdEhlYWRlcnMsIFJBVEVfTElNSVRfQ09ORklHUyB9IGZyb20gJ0AvbGliL3JhdGUtbGltaXRlcic7XHJcbmltcG9ydCB7IG1ldHJpY3NDb2xsZWN0b3IgfSBmcm9tICdAL2xpYi9tZXRyaWNzJztcclxuaW1wb3J0IHsgY3JlYXRlTWVyY2Fkb1BhZ29DbGllbnQgfSBmcm9tICdAL2xpYi9tZXJjYWRvcGFnbyc7XHJcbmltcG9ydCB7IFBheW1lbnQgfSBmcm9tICdtZXJjYWRvcGFnbyc7XHJcblxyXG5pbnRlcmZhY2UgUmVmdW5kUmVxdWVzdCB7XHJcbiAgcGF5bWVudF9pZDogc3RyaW5nO1xyXG4gIGFtb3VudD86IG51bWJlcjtcclxuICByZWFzb24/OiBzdHJpbmc7XHJcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgUmVmdW5kUmVzcG9uc2Uge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgcGF5bWVudF9pZDogc3RyaW5nO1xyXG4gIGFtb3VudDogbnVtYmVyO1xyXG4gIHN0YXR1czogJ3BlbmRpbmcnIHwgJ2FwcHJvdmVkJyB8ICdyZWplY3RlZCc7XHJcbiAgcmVhc29uPzogc3RyaW5nO1xyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZztcclxuICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQT1NUIC9hcGkvcGF5bWVudHMvcmVmdW5kc1xyXG4gKiBQcm9jZXNhIHJlZW1ib2xzb3Mgc2Vnw7puIGRvY3VtZW50YWNpw7NuIG9maWNpYWwgZGUgTWVyY2Fkb1BhZ29cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XHJcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICBjb25zdCBjbGllbnRJUCA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ3gtZm9yd2FyZGVkLWZvcicpIHx8ICd1bmtub3duJztcclxuICBjb25zdCB1c2VyQWdlbnQgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCd1c2VyLWFnZW50JykgfHwgJ3Vua25vd24nO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gVmVyaWZpY2FyIGF1dGVudGljYWNpw7NuXHJcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gYXdhaXQgYXV0aCgpO1xyXG4gICAgaWYgKCF1c2VySWQpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnTm8gYXV0b3JpemFkbycgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAxIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSYXRlIGxpbWl0aW5nXHJcbiAgICBjb25zdCByYXRlTGltaXRSZXN1bHQgPSBhd2FpdCBjaGVja1JhdGVMaW1pdChcclxuICAgICAgcmVxdWVzdCxcclxuICAgICAgUkFURV9MSU1JVF9DT05GSUdTLlBBWU1FTlRfQVBJXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghcmF0ZUxpbWl0UmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgbG9nZ2VyLndhcm4oTG9nQ2F0ZWdvcnkuQVBJLCAnUmF0ZSBsaW1pdCBleGNlZWRlZCBmb3IgcmVmdW5kcycsIHtcclxuICAgICAgICBjbGllbnRJUCxcclxuICAgICAgICB1c2VySWQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0RlbWFzaWFkYXMgc29saWNpdHVkZXMnIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQyOSB9XHJcbiAgICAgICk7XHJcbiAgICAgIGFkZFJhdGVMaW1pdEhlYWRlcnMocmVzcG9uc2UsIHJhdGVMaW1pdFJlc3VsdCwgUkFURV9MSU1JVF9DT05GSUdTLlBBWU1FTlRfQVBJKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJvZHk6IFJlZnVuZFJlcXVlc3QgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcclxuICAgIGNvbnN0IHsgcGF5bWVudF9pZCwgYW1vdW50LCByZWFzb24sIG1ldGFkYXRhIH0gPSBib2R5O1xyXG5cclxuICAgIC8vIFZhbGlkYXIgZGF0b3MgcmVxdWVyaWRvc1xyXG4gICAgaWYgKCFwYXltZW50X2lkKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ3BheW1lbnRfaWQgZXMgcmVxdWVyaWRvJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LlBBWU1FTlQsICdSZWZ1bmQgcmVxdWVzdCBzdGFydGVkJywge1xyXG4gICAgICB1c2VySWQsXHJcbiAgICAgIHBheW1lbnRfaWQsXHJcbiAgICAgIGFtb3VudCxcclxuICAgICAgcmVhc29uLFxyXG4gICAgICBjbGllbnRJUCxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgcGFnbyBleGlzdGUgeSBwZXJ0ZW5lY2UgYWwgdXN1YXJpb1xyXG4gICAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZUNsaWVudCgpO1xyXG4gICAgaWYgKCFzdXBhYmFzZSkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdFcnJvciBkZSBjb25maWd1cmFjacOzbiBkZSBiYXNlIGRlIGRhdG9zJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgZGF0YTogb3JkZXIsIGVycm9yOiBvcmRlckVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxyXG4gICAgICAuZnJvbSgnb3JkZXJzJylcclxuICAgICAgLnNlbGVjdCgnaWQsIHRvdGFsX2Ftb3VudCwgcGF5bWVudF9zdGF0dXMsIGV4dGVybmFsX3JlZmVyZW5jZScpXHJcbiAgICAgIC5lcSgnZXh0ZXJuYWxfcmVmZXJlbmNlJywgcGF5bWVudF9pZClcclxuICAgICAgLnNpbmdsZSgpO1xyXG5cclxuICAgIGlmIChvcmRlckVycm9yIHx8ICFvcmRlcikge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdQYWdvIG5vIGVuY29udHJhZG8nIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwNCB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9yZGVyLnBheW1lbnRfc3RhdHVzICE9PSAnYXBwcm92ZWQnKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1NvbG8gc2UgcHVlZGVuIHJlZW1ib2xzYXIgcGFnb3MgYXByb2JhZG9zJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkYXIgbW9udG8gZGVsIHJlZW1ib2xzb1xyXG4gICAgY29uc3QgcmVmdW5kQW1vdW50ID0gYW1vdW50IHx8IG9yZGVyLnRvdGFsX2Ftb3VudDtcclxuICAgIGlmIChyZWZ1bmRBbW91bnQgPiBvcmRlci50b3RhbF9hbW91bnQpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRWwgbW9udG8gZGVsIHJlZW1ib2xzbyBubyBwdWVkZSBzZXIgbWF5b3IgYWwgcGFnbyBvcmlnaW5hbCcgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAwIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm9jZXNhciByZWVtYm9sc28gY29uIE1lcmNhZG9QYWdvXHJcbiAgICBjb25zdCByZWZ1bmRSZXN1bHQgPSBhd2FpdCBwcm9jZXNzUmVmdW5kKHBheW1lbnRfaWQsIHJlZnVuZEFtb3VudCwgcmVhc29uLCBtZXRhZGF0YSk7XHJcblxyXG4gICAgLy8gQWN0dWFsaXphciBlc3RhZG8gZW4gYmFzZSBkZSBkYXRvc1xyXG4gICAgYXdhaXQgc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ29yZGVycycpXHJcbiAgICAgIC51cGRhdGUoeyBcclxuICAgICAgICBwYXltZW50X3N0YXR1czogcmVmdW5kUmVzdWx0LnN0YXR1cyA9PT0gJ2FwcHJvdmVkJyA/ICdyZWZ1bmRlZCcgOiAncmVmdW5kX3BlbmRpbmcnLFxyXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgICB9KVxyXG4gICAgICAuZXEoJ2lkJywgb3JkZXIuaWQpO1xyXG5cclxuICAgIC8vIFJlZ2lzdHJhciByZWVtYm9sc28gZW4gdGFibGEgZGUgcmVmdW5kcyAoc2kgZXhpc3RlKVxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgc3VwYWJhc2VcclxuICAgICAgICAuZnJvbSgncmVmdW5kcycpXHJcbiAgICAgICAgLmluc2VydCh7XHJcbiAgICAgICAgICBvcmRlcl9pZDogb3JkZXIuaWQsXHJcbiAgICAgICAgICBwYXltZW50X2lkLFxyXG4gICAgICAgICAgcmVmdW5kX2lkOiByZWZ1bmRSZXN1bHQuaWQsXHJcbiAgICAgICAgICBhbW91bnQ6IHJlZnVuZEFtb3VudCxcclxuICAgICAgICAgIHN0YXR1czogcmVmdW5kUmVzdWx0LnN0YXR1cyxcclxuICAgICAgICAgIHJlYXNvbjogcmVhc29uIHx8ICdSZWVtYm9sc28gc29saWNpdGFkbyBwb3IgZWwgY2xpZW50ZScsXHJcbiAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEgfHwge30sXHJcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChyZWZ1bmRJbnNlcnRFcnJvcikge1xyXG4gICAgICAvLyBTaSBsYSB0YWJsYSByZWZ1bmRzIG5vIGV4aXN0ZSwgc29sbyBsb2dnZWFtb3MgZWwgd2FybmluZ1xyXG4gICAgICBsb2dnZXIud2FybihMb2dDYXRlZ29yeS5QQVlNRU5ULCAnUmVmdW5kcyB0YWJsZSBub3QgZm91bmQsIHNraXBwaW5nIGluc2VydCcsIHtcclxuICAgICAgICBwYXltZW50X2lkLFxyXG4gICAgICAgIHJlZnVuZF9pZDogcmVmdW5kUmVzdWx0LmlkLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWdpc3RyYXIgbcOpdHJpY2FzXHJcbiAgICBhd2FpdCBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZFJlcXVlc3QoXHJcbiAgICAgICcvYXBpL3BheW1lbnRzL3JlZnVuZHMnLFxyXG4gICAgICAnUE9TVCcsXHJcbiAgICAgIDIwMCxcclxuICAgICAgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcclxuICAgICAgeyB1c2VySWQsIHBheW1lbnRfaWQsIGFtb3VudDogcmVmdW5kQW1vdW50IH1cclxuICAgICk7XHJcblxyXG4gICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuUEFZTUVOVCwgJ1JlZnVuZCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5Jywge1xyXG4gICAgICB1c2VySWQsXHJcbiAgICAgIHBheW1lbnRfaWQsXHJcbiAgICAgIHJlZnVuZF9pZDogcmVmdW5kUmVzdWx0LmlkLFxyXG4gICAgICBhbW91bnQ6IHJlZnVuZEFtb3VudCxcclxuICAgICAgc3RhdHVzOiByZWZ1bmRSZXN1bHQuc3RhdHVzLFxyXG4gICAgICBwcm9jZXNzaW5nVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICBkYXRhOiByZWZ1bmRSZXN1bHQsXHJcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgcHJvY2Vzc2luZ190aW1lOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxyXG4gICAgfSk7XHJcblxyXG4gICAgYWRkUmF0ZUxpbWl0SGVhZGVycyhyZXNwb25zZSwgcmF0ZUxpbWl0UmVzdWx0LCBSQVRFX0xJTUlUX0NPTkZJR1MuUEFZTUVOVF9BUEkpO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG4gICAgXHJcbiAgICBsb2dnZXIucGVyZm9ybWFuY2UoTG9nTGV2ZWwuRVJST1IsICdSZWZ1bmQgcHJvY2Vzc2luZyBmYWlsZWQnLCB7XHJcbiAgICAgIG9wZXJhdGlvbjogJ3JlZnVuZC1wcm9jZXNzaW5nLWFwaScsXHJcbiAgICAgIGR1cmF0aW9uOiBwcm9jZXNzaW5nVGltZSxcclxuICAgICAgc3RhdHVzQ29kZTogNTAwLFxyXG4gICAgfSwge1xyXG4gICAgICBjbGllbnRJUCxcclxuICAgICAgdXNlckFnZW50LFxyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRSZXF1ZXN0KFxyXG4gICAgICAnL2FwaS9wYXltZW50cy9yZWZ1bmRzJyxcclxuICAgICAgJ1BPU1QnLFxyXG4gICAgICA1MDAsXHJcbiAgICAgIHByb2Nlc3NpbmdUaW1lLFxyXG4gICAgICB7IGVycm9yOiAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRXJyb3IgaW50ZXJubyBkZWwgc2Vydmlkb3InIH0sXHJcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHRVQgL2FwaS9wYXltZW50cy9yZWZ1bmRzXHJcbiAqIExpc3RhIHJlZW1ib2xzb3MgZGVsIHVzdWFyaW9cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcclxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gIGNvbnN0IGNsaWVudElQID0gcmVxdWVzdC5oZWFkZXJzLmdldCgneC1mb3J3YXJkZWQtZm9yJykgfHwgJ3Vua25vd24nO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gVmVyaWZpY2FyIGF1dGVudGljYWNpw7NuXHJcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gYXdhaXQgYXV0aCgpO1xyXG4gICAgaWYgKCF1c2VySWQpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnTm8gYXV0b3JpemFkbycgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAxIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSYXRlIGxpbWl0aW5nXHJcbiAgICBjb25zdCByYXRlTGltaXRSZXN1bHQgPSBhd2FpdCBjaGVja1JhdGVMaW1pdChcclxuICAgICAgcmVxdWVzdCxcclxuICAgICAgUkFURV9MSU1JVF9DT05GSUdTLlFVRVJZX0FQSVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIXJhdGVMaW1pdFJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdEZW1hc2lhZGFzIHNvbGljaXR1ZGVzJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA0MjkgfVxyXG4gICAgICApO1xyXG4gICAgICBhZGRSYXRlTGltaXRIZWFkZXJzKHJlc3BvbnNlLCByYXRlTGltaXRSZXN1bHQsIFJBVEVfTElNSVRfQ09ORklHUy5RVUVSWV9BUEkpO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT2J0ZW5lciBwYXLDoW1ldHJvcyBkZSBjb25zdWx0YVxyXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XHJcbiAgICBjb25zdCBsaW1pdCA9IHBhcnNlSW50KHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdsaW1pdCcpIHx8ICcxMCcpO1xyXG4gICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQodXJsLnNlYXJjaFBhcmFtcy5nZXQoJ29mZnNldCcpIHx8ICcwJyk7XHJcbiAgICBjb25zdCBzdGF0dXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgnc3RhdHVzJyk7XHJcblxyXG4gICAgY29uc3Qgc3VwYWJhc2UgPSBnZXRTdXBhYmFzZUNsaWVudCgpO1xyXG4gICAgaWYgKCFzdXBhYmFzZSkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdFcnJvciBkZSBjb25maWd1cmFjacOzbiBkZSBiYXNlIGRlIGRhdG9zJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnN0cnVpciBxdWVyeVxyXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2VcclxuICAgICAgLmZyb20oJ3JlZnVuZHMnKVxyXG4gICAgICAuc2VsZWN0KGBcclxuICAgICAgICAqLFxyXG4gICAgICAgIG9yZGVycyAoXHJcbiAgICAgICAgICBpZCxcclxuICAgICAgICAgIHRvdGFsX2Ftb3VudCxcclxuICAgICAgICAgIGNyZWF0ZWRfYXRcclxuICAgICAgICApXHJcbiAgICAgIGApXHJcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxyXG4gICAgICAucmFuZ2Uob2Zmc2V0LCBvZmZzZXQgKyBsaW1pdCAtIDEpO1xyXG5cclxuICAgIGlmIChzdGF0dXMpIHtcclxuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnc3RhdHVzJywgc3RhdHVzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IGRhdGE6IHJlZnVuZHMsIGVycm9yIH0gPSBhd2FpdCBxdWVyeTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBvYnRlbmVyIHJlZW1ib2xzb3M6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZWdpc3RyYXIgbcOpdHJpY2FzXHJcbiAgICBhd2FpdCBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZFJlcXVlc3QoXHJcbiAgICAgICcvYXBpL3BheW1lbnRzL3JlZnVuZHMnLFxyXG4gICAgICAnR0VUJyxcclxuICAgICAgMjAwLFxyXG4gICAgICBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxyXG4gICAgICB7IHVzZXJJZCwgY291bnQ6IChyZWZ1bmRzPy5sZW5ndGggfHwgMCkudG9TdHJpbmcoKSB9XHJcbiAgICApO1xyXG5cclxuICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgJ1JlZnVuZHMgbGlzdCByZXRyaWV2ZWQnLCB7XHJcbiAgICAgIHVzZXJJZCxcclxuICAgICAgY291bnQ6IHJlZnVuZHM/Lmxlbmd0aCB8fCAwLFxyXG4gICAgICBwcm9jZXNzaW5nVGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gTmV4dFJlc3BvbnNlLmpzb24oe1xyXG4gICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICBkYXRhOiByZWZ1bmRzIHx8IFtdLFxyXG4gICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgbGltaXQsXHJcbiAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgIHRvdGFsOiByZWZ1bmRzPy5sZW5ndGggfHwgMCxcclxuICAgICAgfSxcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICBwcm9jZXNzaW5nX3RpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRSYXRlTGltaXRIZWFkZXJzKHJlc3BvbnNlLCByYXRlTGltaXRSZXN1bHQsIFJBVEVfTElNSVRfQ09ORklHUy5RVUVSWV9BUEkpO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG4gICAgXHJcbiAgICBsb2dnZXIucGVyZm9ybWFuY2UoTG9nTGV2ZWwuRVJST1IsICdSZWZ1bmRzIGxpc3QgZmFpbGVkJywge1xyXG4gICAgICBvcGVyYXRpb246ICdyZWZ1bmRzLWxpc3QtYXBpJyxcclxuICAgICAgZHVyYXRpb246IHByb2Nlc3NpbmdUaW1lLFxyXG4gICAgICBzdGF0dXNDb2RlOiA1MDAsXHJcbiAgICB9LCB7XHJcbiAgICAgIGNsaWVudElQLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0Vycm9yIGludGVybm8gZGVsIHNlcnZpZG9yJyB9LFxyXG4gICAgICB7IHN0YXR1czogNTAwIH1cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUHJvY2VzYSByZWVtYm9sc28gY29uIE1lcmNhZG9QYWdvXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzUmVmdW5kKFxyXG4gIHBheW1lbnRJZDogc3RyaW5nLFxyXG4gIGFtb3VudDogbnVtYmVyLFxyXG4gIHJlYXNvbj86IHN0cmluZyxcclxuICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cclxuKTogUHJvbWlzZTxSZWZ1bmRSZXNwb25zZT4ge1xyXG4gIHRyeSB7XHJcbiAgICAvLyBDcmVhciBjbGllbnRlIGRlIE1lcmNhZG9QYWdvXHJcbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVNZXJjYWRvUGFnb0NsaWVudCgpO1xyXG4gICAgY29uc3QgcGF5bWVudCA9IG5ldyBQYXltZW50KGNsaWVudCk7XHJcblxyXG4gICAgLy8gRW4gdW5hIGltcGxlbWVudGFjacOzbiByZWFsLCBhcXXDrSBzZSBoYXLDrWEgbGEgbGxhbWFkYSBhIGxhIEFQSSBkZSBNZXJjYWRvUGFnb1xyXG4gICAgLy8gUG9yIGFob3JhIHNpbXVsYW1vcyBlbCByZWVtYm9sc29cclxuICAgIGNvbnN0IHJlZnVuZElkID0gYHJlZnVuZF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XHJcbiAgICBcclxuICAgIC8vIFNpbXVsYXIgcmVzcHVlc3RhIGRlIE1lcmNhZG9QYWdvXHJcbiAgICBjb25zdCByZWZ1bmRSZXNwb25zZTogUmVmdW5kUmVzcG9uc2UgPSB7XHJcbiAgICAgIGlkOiByZWZ1bmRJZCxcclxuICAgICAgcGF5bWVudF9pZDogcGF5bWVudElkLFxyXG4gICAgICBhbW91bnQsXHJcbiAgICAgIHN0YXR1czogJ2FwcHJvdmVkJywgLy8gRW4gcHJvZHVjY2nDs24gZXN0byB2ZW5kcsOtYSBkZSBNZXJjYWRvUGFnb1xyXG4gICAgICByZWFzb246IHJlYXNvbiB8fCAnUmVlbWJvbHNvIHNvbGljaXRhZG8nLFxyXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSB8fCB7fSxcclxuICAgIH07XHJcblxyXG4gICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuUEFZTUVOVCwgJ01lcmNhZG9QYWdvIHJlZnVuZCBzaW11bGF0ZWQnLCB7XHJcbiAgICAgIHBheW1lbnRfaWQ6IHBheW1lbnRJZCxcclxuICAgICAgcmVmdW5kX2lkOiByZWZ1bmRJZCxcclxuICAgICAgYW1vdW50LFxyXG4gICAgICBzdGF0dXM6IHJlZnVuZFJlc3BvbnNlLnN0YXR1cyxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZWZ1bmRSZXNwb25zZTtcclxuXHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5QQVlNRU5ULCAnTWVyY2Fkb1BhZ28gcmVmdW5kIGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuXHJcbiAgICAvLyBFbiBjYXNvIGRlIGVycm9yLCBkZXZvbHZlciBlc3RhZG8gcGVuZGllbnRlXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogYHJlZnVuZF9lcnJvcl8ke0RhdGUubm93KCl9YCxcclxuICAgICAgcGF5bWVudF9pZDogcGF5bWVudElkLFxyXG4gICAgICBhbW91bnQsXHJcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxyXG4gICAgICByZWFzb246ICdFcnJvciBhbCBwcm9jZXNhciByZWVtYm9sc28sIHNlIHByb2Nlc2Fyw6EgbWFudWFsbWVudGUnLFxyXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSB8fCB7fSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJHRVQiLCJQT1NUIiwicmVxdWVzdCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJjbGllbnRJUCIsImhlYWRlcnMiLCJnZXQiLCJ1c2VyQWdlbnQiLCJ1c2VySWQiLCJhdXRoIiwiTmV4dFJlc3BvbnNlIiwianNvbiIsInN1Y2Nlc3MiLCJlcnJvciIsInN0YXR1cyIsInJhdGVMaW1pdFJlc3VsdCIsImNoZWNrUmF0ZUxpbWl0IiwiUkFURV9MSU1JVF9DT05GSUdTIiwiUEFZTUVOVF9BUEkiLCJsb2dnZXIiLCJ3YXJuIiwiTG9nQ2F0ZWdvcnkiLCJBUEkiLCJyZXNwb25zZSIsImFkZFJhdGVMaW1pdEhlYWRlcnMiLCJib2R5IiwicGF5bWVudF9pZCIsImFtb3VudCIsInJlYXNvbiIsIm1ldGFkYXRhIiwiaW5mbyIsIlBBWU1FTlQiLCJzdXBhYmFzZSIsImdldFN1cGFiYXNlQ2xpZW50IiwiZGF0YSIsIm9yZGVyIiwib3JkZXJFcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsInBheW1lbnRfc3RhdHVzIiwicmVmdW5kQW1vdW50IiwidG90YWxfYW1vdW50IiwicmVmdW5kUmVzdWx0IiwicHJvY2Vzc1JlZnVuZCIsInVwZGF0ZSIsInVwZGF0ZWRfYXQiLCJ0b0lTT1N0cmluZyIsImlkIiwiaW5zZXJ0Iiwib3JkZXJfaWQiLCJyZWZ1bmRfaWQiLCJjcmVhdGVkX2F0IiwicmVmdW5kSW5zZXJ0RXJyb3IiLCJtZXRyaWNzQ29sbGVjdG9yIiwicmVjb3JkUmVxdWVzdCIsInByb2Nlc3NpbmdUaW1lIiwidGltZXN0YW1wIiwicHJvY2Vzc2luZ190aW1lIiwicGVyZm9ybWFuY2UiLCJMb2dMZXZlbCIsIkVSUk9SIiwib3BlcmF0aW9uIiwiZHVyYXRpb24iLCJzdGF0dXNDb2RlIiwibWVzc2FnZSIsIlFVRVJZX0FQSSIsInVybCIsIlVSTCIsImxpbWl0IiwicGFyc2VJbnQiLCJzZWFyY2hQYXJhbXMiLCJvZmZzZXQiLCJxdWVyeSIsImFzY2VuZGluZyIsInJhbmdlIiwicmVmdW5kcyIsIkVycm9yIiwiY291bnQiLCJsZW5ndGgiLCJ0b1N0cmluZyIsInBhZ2luYXRpb24iLCJ0b3RhbCIsInBheW1lbnRJZCIsImNsaWVudCIsImNyZWF0ZU1lcmNhZG9QYWdvQ2xpZW50IiwicGF5bWVudCIsIlBheW1lbnQiLCJyZWZ1bmRJZCIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHIiLCJyZWZ1bmRSZXNwb25zZSJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLCtDQUErQztBQUMvQyxzQ0FBc0M7Ozs7Ozs7Ozs7OztJQXlOaEJBLEdBQUc7ZUFBSEE7O0lBekxBQyxJQUFJO2VBQUpBOzs7d0JBOUJvQjt5QkFDckI7MEJBQ2E7d0JBQ1k7NkJBQzBCO3lCQUN2Qzs2QkFDTzs4QkFDaEI7QUF1QmpCLGVBQWVBLEtBQUtDLE9BQW9CO0lBQzdDLE1BQU1DLFlBQVlDLEtBQUtDLEdBQUc7SUFDMUIsTUFBTUMsV0FBV0osUUFBUUssT0FBTyxDQUFDQyxHQUFHLENBQUMsc0JBQXNCO0lBQzNELE1BQU1DLFlBQVlQLFFBQVFLLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGlCQUFpQjtJQUV2RCxJQUFJO1FBQ0YsMEJBQTBCO1FBQzFCLE1BQU0sRUFBRUUsTUFBTSxFQUFFLEdBQUcsTUFBTUMsSUFBQUEsYUFBSTtRQUM3QixJQUFJLENBQUNELFFBQVE7WUFDWCxPQUFPRSxvQkFBWSxDQUFDQyxJQUFJLENBQ3RCO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQWdCLEdBQ3pDO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxnQkFBZ0I7UUFDaEIsTUFBTUMsa0JBQWtCLE1BQU1DLElBQUFBLDJCQUFjLEVBQzFDaEIsU0FDQWlCLCtCQUFrQixDQUFDQyxXQUFXO1FBR2hDLElBQUksQ0FBQ0gsZ0JBQWdCSCxPQUFPLEVBQUU7WUFDNUJPLGNBQU0sQ0FBQ0MsSUFBSSxDQUFDQyxtQkFBVyxDQUFDQyxHQUFHLEVBQUUsbUNBQW1DO2dCQUM5RGxCO2dCQUNBSTtZQUNGO1lBRUEsTUFBTWUsV0FBV2Isb0JBQVksQ0FBQ0MsSUFBSSxDQUNoQztnQkFBRUMsU0FBUztnQkFBT0MsT0FBTztZQUF5QixHQUNsRDtnQkFBRUMsUUFBUTtZQUFJO1lBRWhCVSxJQUFBQSxnQ0FBbUIsRUFBQ0QsVUFBVVIsaUJBQWlCRSwrQkFBa0IsQ0FBQ0MsV0FBVztZQUM3RSxPQUFPSztRQUNUO1FBRUEsTUFBTUUsT0FBc0IsTUFBTXpCLFFBQVFXLElBQUk7UUFDOUMsTUFBTSxFQUFFZSxVQUFVLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0o7UUFFakQsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0MsWUFBWTtZQUNmLE9BQU9oQixvQkFBWSxDQUFDQyxJQUFJLENBQ3RCO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQTBCLEdBQ25EO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQUssY0FBTSxDQUFDVyxJQUFJLENBQUNULG1CQUFXLENBQUNVLE9BQU8sRUFBRSwwQkFBMEI7WUFDekR2QjtZQUNBa0I7WUFDQUM7WUFDQUM7WUFDQXhCO1FBQ0Y7UUFFQSxzREFBc0Q7UUFDdEQsTUFBTTRCLFdBQVdDLElBQUFBLDJCQUFpQjtRQUNsQyxJQUFJLENBQUNELFVBQVU7WUFDYixPQUFPdEIsb0JBQVksQ0FBQ0MsSUFBSSxDQUN0QjtnQkFBRUMsU0FBUztnQkFBT0MsT0FBTztZQUEwQyxHQUNuRTtnQkFBRUMsUUFBUTtZQUFJO1FBRWxCO1FBRUEsTUFBTSxFQUFFb0IsTUFBTUMsS0FBSyxFQUFFdEIsT0FBT3VCLFVBQVUsRUFBRSxHQUFHLE1BQU1KLFNBQzlDSyxJQUFJLENBQUMsVUFDTEMsTUFBTSxDQUFDLHdEQUNQQyxFQUFFLENBQUMsc0JBQXNCYixZQUN6QmMsTUFBTTtRQUVULElBQUlKLGNBQWMsQ0FBQ0QsT0FBTztZQUN4QixPQUFPekIsb0JBQVksQ0FBQ0MsSUFBSSxDQUN0QjtnQkFBRUMsU0FBUztnQkFBT0MsT0FBTztZQUFxQixHQUM5QztnQkFBRUMsUUFBUTtZQUFJO1FBRWxCO1FBRUEsSUFBSXFCLE1BQU1NLGNBQWMsS0FBSyxZQUFZO1lBQ3ZDLE9BQU8vQixvQkFBWSxDQUFDQyxJQUFJLENBQ3RCO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQTRDLEdBQ3JFO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSw4QkFBOEI7UUFDOUIsTUFBTTRCLGVBQWVmLFVBQVVRLE1BQU1RLFlBQVk7UUFDakQsSUFBSUQsZUFBZVAsTUFBTVEsWUFBWSxFQUFFO1lBQ3JDLE9BQU9qQyxvQkFBWSxDQUFDQyxJQUFJLENBQ3RCO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQTZELEdBQ3RGO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxxQ0FBcUM7UUFDckMsTUFBTThCLGVBQWUsTUFBTUMsY0FBY25CLFlBQVlnQixjQUFjZCxRQUFRQztRQUUzRSxxQ0FBcUM7UUFDckMsTUFBTUcsU0FDSEssSUFBSSxDQUFDLFVBQ0xTLE1BQU0sQ0FBQztZQUNOTCxnQkFBZ0JHLGFBQWE5QixNQUFNLEtBQUssYUFBYSxhQUFhO1lBQ2xFaUMsWUFBWSxJQUFJN0MsT0FBTzhDLFdBQVc7UUFDcEMsR0FDQ1QsRUFBRSxDQUFDLE1BQU1KLE1BQU1jLEVBQUU7UUFFcEIsc0RBQXNEO1FBQ3RELElBQUk7WUFDRixNQUFNakIsU0FDSEssSUFBSSxDQUFDLFdBQ0xhLE1BQU0sQ0FBQztnQkFDTkMsVUFBVWhCLE1BQU1jLEVBQUU7Z0JBQ2xCdkI7Z0JBQ0EwQixXQUFXUixhQUFhSyxFQUFFO2dCQUMxQnRCLFFBQVFlO2dCQUNSNUIsUUFBUThCLGFBQWE5QixNQUFNO2dCQUMzQmMsUUFBUUEsVUFBVTtnQkFDbEJDLFVBQVVBLFlBQVksQ0FBQztnQkFDdkJ3QixZQUFZLElBQUluRCxPQUFPOEMsV0FBVztZQUNwQztRQUNKLEVBQUUsT0FBT00sbUJBQW1CO1lBQzFCLDJEQUEyRDtZQUMzRG5DLGNBQU0sQ0FBQ0MsSUFBSSxDQUFDQyxtQkFBVyxDQUFDVSxPQUFPLEVBQUUsNENBQTRDO2dCQUMzRUw7Z0JBQ0EwQixXQUFXUixhQUFhSyxFQUFFO1lBQzVCO1FBQ0Y7UUFFQSxxQkFBcUI7UUFDckIsTUFBTU0seUJBQWdCLENBQUNDLGFBQWEsQ0FDbEMseUJBQ0EsUUFDQSxLQUNBdEQsS0FBS0MsR0FBRyxLQUFLRixXQUNiO1lBQUVPO1lBQVFrQjtZQUFZQyxRQUFRZTtRQUFhO1FBRzdDdkIsY0FBTSxDQUFDVyxJQUFJLENBQUNULG1CQUFXLENBQUNVLE9BQU8sRUFBRSxpQ0FBaUM7WUFDaEV2QjtZQUNBa0I7WUFDQTBCLFdBQVdSLGFBQWFLLEVBQUU7WUFDMUJ0QixRQUFRZTtZQUNSNUIsUUFBUThCLGFBQWE5QixNQUFNO1lBQzNCMkMsZ0JBQWdCdkQsS0FBS0MsR0FBRyxLQUFLRjtRQUMvQjtRQUVBLE1BQU1zQixXQUFXYixvQkFBWSxDQUFDQyxJQUFJLENBQUM7WUFDakNDLFNBQVM7WUFDVHNCLE1BQU1VO1lBQ05jLFdBQVd4RCxLQUFLQyxHQUFHO1lBQ25Cd0QsaUJBQWlCekQsS0FBS0MsR0FBRyxLQUFLRjtRQUNoQztRQUVBdUIsSUFBQUEsZ0NBQW1CLEVBQUNELFVBQVVSLGlCQUFpQkUsK0JBQWtCLENBQUNDLFdBQVc7UUFDN0UsT0FBT0s7SUFFVCxFQUFFLE9BQU9WLE9BQU87UUFDZCxNQUFNNEMsaUJBQWlCdkQsS0FBS0MsR0FBRyxLQUFLRjtRQUVwQ2tCLGNBQU0sQ0FBQ3lDLFdBQVcsQ0FBQ0MsZ0JBQVEsQ0FBQ0MsS0FBSyxFQUFFLDRCQUE0QjtZQUM3REMsV0FBVztZQUNYQyxVQUFVUDtZQUNWUSxZQUFZO1FBQ2QsR0FBRztZQUNEN0Q7WUFDQUc7UUFDRjtRQUVBLE1BQU1nRCx5QkFBZ0IsQ0FBQ0MsYUFBYSxDQUNsQyx5QkFDQSxRQUNBLEtBQ0FDLGdCQUNBO1lBQUU1QyxPQUFPLEFBQUNBLE1BQWdCcUQsT0FBTztRQUFDO1FBR3BDLE9BQU94RCxvQkFBWSxDQUFDQyxJQUFJLENBQ3RCO1lBQUVDLFNBQVM7WUFBT0MsT0FBTztRQUE2QixHQUN0RDtZQUFFQyxRQUFRO1FBQUk7SUFFbEI7QUFDRjtBQU1PLGVBQWVoQixJQUFJRSxPQUFvQjtJQUM1QyxNQUFNQyxZQUFZQyxLQUFLQyxHQUFHO0lBQzFCLE1BQU1DLFdBQVdKLFFBQVFLLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHNCQUFzQjtJQUUzRCxJQUFJO1FBQ0YsMEJBQTBCO1FBQzFCLE1BQU0sRUFBRUUsTUFBTSxFQUFFLEdBQUcsTUFBTUMsSUFBQUEsYUFBSTtRQUM3QixJQUFJLENBQUNELFFBQVE7WUFDWCxPQUFPRSxvQkFBWSxDQUFDQyxJQUFJLENBQ3RCO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQWdCLEdBQ3pDO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxnQkFBZ0I7UUFDaEIsTUFBTUMsa0JBQWtCLE1BQU1DLElBQUFBLDJCQUFjLEVBQzFDaEIsU0FDQWlCLCtCQUFrQixDQUFDa0QsU0FBUztRQUc5QixJQUFJLENBQUNwRCxnQkFBZ0JILE9BQU8sRUFBRTtZQUM1QixNQUFNVyxXQUFXYixvQkFBWSxDQUFDQyxJQUFJLENBQ2hDO2dCQUFFQyxTQUFTO2dCQUFPQyxPQUFPO1lBQXlCLEdBQ2xEO2dCQUFFQyxRQUFRO1lBQUk7WUFFaEJVLElBQUFBLGdDQUFtQixFQUFDRCxVQUFVUixpQkFBaUJFLCtCQUFrQixDQUFDa0QsU0FBUztZQUMzRSxPQUFPNUM7UUFDVDtRQUVBLGlDQUFpQztRQUNqQyxNQUFNNkMsTUFBTSxJQUFJQyxJQUFJckUsUUFBUW9FLEdBQUc7UUFDL0IsTUFBTUUsUUFBUUMsU0FBU0gsSUFBSUksWUFBWSxDQUFDbEUsR0FBRyxDQUFDLFlBQVk7UUFDeEQsTUFBTW1FLFNBQVNGLFNBQVNILElBQUlJLFlBQVksQ0FBQ2xFLEdBQUcsQ0FBQyxhQUFhO1FBQzFELE1BQU1RLFNBQVNzRCxJQUFJSSxZQUFZLENBQUNsRSxHQUFHLENBQUM7UUFFcEMsTUFBTTBCLFdBQVdDLElBQUFBLDJCQUFpQjtRQUNsQyxJQUFJLENBQUNELFVBQVU7WUFDYixPQUFPdEIsb0JBQVksQ0FBQ0MsSUFBSSxDQUN0QjtnQkFBRUMsU0FBUztnQkFBT0MsT0FBTztZQUEwQyxHQUNuRTtnQkFBRUMsUUFBUTtZQUFJO1FBRWxCO1FBRUEsa0JBQWtCO1FBQ2xCLElBQUk0RCxRQUFRMUMsU0FDVEssSUFBSSxDQUFDLFdBQ0xDLE1BQU0sQ0FBQyxDQUFDOzs7Ozs7O01BT1QsQ0FBQyxFQUNBSCxLQUFLLENBQUMsY0FBYztZQUFFd0MsV0FBVztRQUFNLEdBQ3ZDQyxLQUFLLENBQUNILFFBQVFBLFNBQVNILFFBQVE7UUFFbEMsSUFBSXhELFFBQVE7WUFDVjRELFFBQVFBLE1BQU1uQyxFQUFFLENBQUMsVUFBVXpCO1FBQzdCO1FBRUEsTUFBTSxFQUFFb0IsTUFBTTJDLE9BQU8sRUFBRWhFLEtBQUssRUFBRSxHQUFHLE1BQU02RDtRQUV2QyxJQUFJN0QsT0FBTztZQUNULE1BQU0sSUFBSWlFLE1BQU0sQ0FBQyw2QkFBNkIsRUFBRWpFLE1BQU1xRCxPQUFPLEVBQUU7UUFDakU7UUFFQSxxQkFBcUI7UUFDckIsTUFBTVgseUJBQWdCLENBQUNDLGFBQWEsQ0FDbEMseUJBQ0EsT0FDQSxLQUNBdEQsS0FBS0MsR0FBRyxLQUFLRixXQUNiO1lBQUVPO1lBQVF1RSxPQUFPLEFBQUNGLENBQUFBLFNBQVNHLFVBQVUsQ0FBQSxFQUFHQyxRQUFRO1FBQUc7UUFHckQ5RCxjQUFNLENBQUNXLElBQUksQ0FBQ1QsbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFLDBCQUEwQjtZQUNyRGQ7WUFDQXVFLE9BQU9GLFNBQVNHLFVBQVU7WUFDMUJ2QixnQkFBZ0J2RCxLQUFLQyxHQUFHLEtBQUtGO1FBQy9CO1FBRUEsTUFBTXNCLFdBQVdiLG9CQUFZLENBQUNDLElBQUksQ0FBQztZQUNqQ0MsU0FBUztZQUNUc0IsTUFBTTJDLFdBQVcsRUFBRTtZQUNuQkssWUFBWTtnQkFDVlo7Z0JBQ0FHO2dCQUNBVSxPQUFPTixTQUFTRyxVQUFVO1lBQzVCO1lBQ0F0QixXQUFXeEQsS0FBS0MsR0FBRztZQUNuQndELGlCQUFpQnpELEtBQUtDLEdBQUcsS0FBS0Y7UUFDaEM7UUFFQXVCLElBQUFBLGdDQUFtQixFQUFDRCxVQUFVUixpQkFBaUJFLCtCQUFrQixDQUFDa0QsU0FBUztRQUMzRSxPQUFPNUM7SUFFVCxFQUFFLE9BQU9WLE9BQU87UUFDZCxNQUFNNEMsaUJBQWlCdkQsS0FBS0MsR0FBRyxLQUFLRjtRQUVwQ2tCLGNBQU0sQ0FBQ3lDLFdBQVcsQ0FBQ0MsZ0JBQVEsQ0FBQ0MsS0FBSyxFQUFFLHVCQUF1QjtZQUN4REMsV0FBVztZQUNYQyxVQUFVUDtZQUNWUSxZQUFZO1FBQ2QsR0FBRztZQUNEN0Q7UUFDRjtRQUVBLE9BQU9NLG9CQUFZLENBQUNDLElBQUksQ0FDdEI7WUFBRUMsU0FBUztZQUFPQyxPQUFPO1FBQTZCLEdBQ3REO1lBQUVDLFFBQVE7UUFBSTtJQUVsQjtBQUNGO0FBRUE7O0NBRUMsR0FDRCxlQUFlK0IsY0FDYnVDLFNBQWlCLEVBQ2pCekQsTUFBYyxFQUNkQyxNQUFlLEVBQ2ZDLFFBQThCO0lBRTlCLElBQUk7UUFDRiwrQkFBK0I7UUFDL0IsTUFBTXdELFNBQVNDLElBQUFBLG9DQUF1QjtRQUN0QyxNQUFNQyxVQUFVLElBQUlDLHFCQUFPLENBQUNIO1FBRTVCLCtFQUErRTtRQUMvRSxtQ0FBbUM7UUFDbkMsTUFBTUksV0FBVyxDQUFDLE9BQU8sRUFBRXZGLEtBQUtDLEdBQUcsR0FBRyxDQUFDLEVBQUV1RixLQUFLQyxNQUFNLEdBQUdWLFFBQVEsQ0FBQyxJQUFJVyxNQUFNLENBQUMsR0FBRyxJQUFJO1FBRWxGLG1DQUFtQztRQUNuQyxNQUFNQyxpQkFBaUM7WUFDckM1QyxJQUFJd0M7WUFDSi9ELFlBQVkwRDtZQUNaekQ7WUFDQWIsUUFBUTtZQUNSYyxRQUFRQSxVQUFVO1lBQ2xCeUIsWUFBWSxJQUFJbkQsT0FBTzhDLFdBQVc7WUFDbENuQixVQUFVQSxZQUFZLENBQUM7UUFDekI7UUFFQVYsY0FBTSxDQUFDVyxJQUFJLENBQUNULG1CQUFXLENBQUNVLE9BQU8sRUFBRSxnQ0FBZ0M7WUFDL0RMLFlBQVkwRDtZQUNaaEMsV0FBV3FDO1lBQ1g5RDtZQUNBYixRQUFRK0UsZUFBZS9FLE1BQU07UUFDL0I7UUFFQSxPQUFPK0U7SUFFVCxFQUFFLE9BQU9oRixPQUFPO1FBQ2RNLGNBQU0sQ0FBQ04sS0FBSyxDQUFDUSxtQkFBVyxDQUFDVSxPQUFPLEVBQUUsNkJBQTZCbEI7UUFFL0QsOENBQThDO1FBQzlDLE9BQU87WUFDTG9DLElBQUksQ0FBQyxhQUFhLEVBQUUvQyxLQUFLQyxHQUFHLElBQUk7WUFDaEN1QixZQUFZMEQ7WUFDWnpEO1lBQ0FiLFFBQVE7WUFDUmMsUUFBUTtZQUNSeUIsWUFBWSxJQUFJbkQsT0FBTzhDLFdBQVc7WUFDbENuQixVQUFVQSxZQUFZLENBQUM7UUFDekI7SUFDRjtBQUNGIn0=