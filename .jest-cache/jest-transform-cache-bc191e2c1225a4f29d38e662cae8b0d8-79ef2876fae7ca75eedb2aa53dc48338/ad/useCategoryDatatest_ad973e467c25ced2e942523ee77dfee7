3966036ec210a6ab47c8f578e11bbe44
/**
 * useCategoryData Hook Tests
 * Enterprise-ready test suite for category data management
 * Pinteya E-commerce
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useCategoryData = require("../../hooks/useCategoryData");
// Mock fetch
global.fetch = jest.fn();
// Mock analytics
const mockGtag = jest.fn();
Object.defineProperty(window, 'gtag', {
    value: mockGtag,
    writable: true
});
// Test data
const mockCategories = [
    {
        id: 'test-1',
        name: 'Test Category 1',
        icon: '/test-1.png',
        description: 'Test description 1',
        isAvailable: true
    },
    {
        id: 'test-2',
        name: 'Test Category 2',
        icon: '/test-2.png',
        description: 'Test description 2',
        isAvailable: true
    }
];
describe('useCategoryData Hook', ()=>{
    const mockFetch = fetch;
    beforeEach(()=>{
        jest.clearAllMocks();
        (0, _useCategoryData.clearCategoryCache)();
        mockGtag.mockClear();
    });
    afterEach(()=>{
        jest.clearAllTimers();
    });
    describe('Initialization', ()=>{
        it('initializes with fallback categories when autoFetch is false', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: false,
                    fallbackCategories: mockCategories
                }));
            expect(result.current.categories).toEqual(mockCategories);
            expect(result.current.loading).toBe(false);
            expect(result.current.error).toBe(null);
        });
        it('starts loading when autoFetch is true', ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockCategories
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true
                }));
            expect(result.current.loading).toBe(true);
        });
    });
    describe('Data Fetching', ()=>{
        it('fetches categories successfully', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockCategories
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.categories).toEqual(mockCategories);
            expect(result.current.error).toBe(null);
            expect(mockFetch).toHaveBeenCalledWith('/api/categories');
        });
        it('handles different API response formats', async ()=>{
            // Test with data wrapper
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        data: mockCategories
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.categories).toEqual(mockCategories);
        });
        it('handles categories wrapper format', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>({
                        categories: mockCategories
                    })
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.categories).toEqual(mockCategories);
        });
        it('handles fetch errors gracefully', async ()=>{
            const errorMessage = 'Network error';
            mockFetch.mockRejectedValueOnce(new Error(errorMessage));
            const fallbackCategories = [
                mockCategories[0]
            ];
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true,
                    fallbackCategories
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.error).toContain(errorMessage);
            expect(result.current.categories).toEqual(fallbackCategories);
        });
        it('handles HTTP errors', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: false,
                status: 404,
                statusText: 'Not Found'
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.error).toContain('HTTP 404');
        });
        it('validates and filters invalid categories', async ()=>{
            const invalidData = [
                mockCategories[0],
                {
                    id: 'invalid'
                },
                null,
                {
                    name: 'No ID'
                },
                mockCategories[1]
            ];
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>invalidData
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.categories).toEqual(mockCategories);
        });
        it('respects maxCategories limit', async ()=>{
            const manyCategories = Array.from({
                length: 10
            }, (_, i)=>({
                    id: `cat-${i}`,
                    name: `Category ${i}`,
                    icon: `/cat-${i}.png`
                }));
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>manyCategories
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true,
                    maxCategories: 5
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.categories).toHaveLength(5);
        });
    });
    describe('Caching', ()=>{
        it('uses cached data when available', async ()=>{
            // First call
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockCategories
            });
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true,
                    fallbackCategories: mockCategories
                }));
            await (0, _react.waitFor)(()=>{
                expect(result1.current.loading).toBe(false);
            });
            expect(result1.current.categories).toEqual(mockCategories);
            // Cache functionality is tested at the manager level
            expect(mockFetch).toHaveBeenCalledWith('/api/categories');
        });
        it('respects cache duration', async ()=>{
            mockFetch.mockResolvedValue({
                ok: true,
                json: async ()=>mockCategories
            });
            // First call
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true,
                    cacheDuration: 1000,
                    fallbackCategories: mockCategories
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            // Wait for cache to expire (simulate time passing)
            await new Promise((resolve)=>setTimeout(resolve, 1100));
            // Refresh should fetch again
            await (0, _react.act)(async ()=>{
                await result.current.refresh();
            });
            expect(mockFetch).toHaveBeenCalledTimes(2);
        });
    });
    describe('Manual Refresh', ()=>{
        it('refreshes data manually', async ()=>{
            mockFetch.mockResolvedValue({
                ok: true,
                json: async ()=>mockCategories
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: false
                }));
            await (0, _react.act)(async ()=>{
                await result.current.refresh();
            });
            expect(result.current.categories).toEqual(mockCategories);
            expect(mockFetch).toHaveBeenCalledTimes(1);
        });
        it('handles refresh errors', async ()=>{
            mockFetch.mockRejectedValueOnce(new Error('Refresh failed'));
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: false
                }));
            await (0, _react.act)(async ()=>{
                await result.current.refresh();
            });
            expect(result.current.error).toContain('Refresh failed');
        });
    });
    describe('Utility Functions', ()=>{
        it('finds category by ID', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockCategories
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            const category = result.current.getCategoryById('test-1');
            expect(category).toEqual(mockCategories[0]);
            const notFound = result.current.getCategoryById('not-found');
            expect(notFound).toBeUndefined();
        });
    });
    describe('Analytics', ()=>{
        it('tracks successful fetch', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockCategories
            });
            (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true,
                    enableAnalytics: true
                }));
            await (0, _react.waitFor)(()=>{
                expect(mockGtag).toHaveBeenCalledWith('event', 'category_data', expect.objectContaining({
                    event_category: 'data',
                    event_label: 'fetch_success'
                }));
            });
        });
        it('tracks fetch errors', async ()=>{
            mockFetch.mockRejectedValueOnce(new Error('Test error'));
            (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true,
                    enableAnalytics: true
                }));
            await (0, _react.waitFor)(()=>{
                expect(mockGtag).toHaveBeenCalledWith('event', 'category_data', expect.objectContaining({
                    event_category: 'data',
                    event_label: 'fetch_error'
                }));
            });
        });
        it('does not track when analytics disabled', async ()=>{
            mockFetch.mockResolvedValueOnce({
                ok: true,
                json: async ()=>mockCategories
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: true,
                    enableAnalytics: false,
                    fallbackCategories: mockCategories
                }));
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(mockGtag).not.toHaveBeenCalled();
        });
    });
    describe('Background Refresh', ()=>{
        it('sets up background refresh interval', ()=>{
            jest.useFakeTimers();
            const setIntervalSpy = jest.spyOn(global, 'setInterval');
            (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    autoFetch: false,
                    enableBackgroundRefresh: true,
                    refreshInterval: 5000
                }));
            expect(setIntervalSpy).toHaveBeenCalledWith(expect.any(Function), 5000);
            jest.useRealTimers();
        });
        it('cleans up interval on unmount', ()=>{
            jest.useFakeTimers();
            const clearIntervalSpy = jest.spyOn(global, 'clearInterval');
            const { unmount } = (0, _react.renderHook)(()=>(0, _useCategoryData.useCategoryData)({
                    enableBackgroundRefresh: true,
                    refreshInterval: 5000
                }));
            unmount();
            expect(clearIntervalSpy).toHaveBeenCalled();
            jest.useRealTimers();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlQ2F0ZWdvcnlEYXRhLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB1c2VDYXRlZ29yeURhdGEgSG9vayBUZXN0c1xuICogRW50ZXJwcmlzZS1yZWFkeSB0ZXN0IHN1aXRlIGZvciBjYXRlZ29yeSBkYXRhIG1hbmFnZW1lbnRcbiAqIFBpbnRleWEgRS1jb21tZXJjZVxuICovXG5cbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlQ2F0ZWdvcnlEYXRhLCBjbGVhckNhdGVnb3J5Q2FjaGUgfSBmcm9tICdAL2hvb2tzL3VzZUNhdGVnb3J5RGF0YSc7XG5pbXBvcnQgdHlwZSB7IENhdGVnb3J5IH0gZnJvbSAnQC90eXBlcy9jYXRlZ29yaWVzJztcblxuLy8gTW9jayBmZXRjaFxuZ2xvYmFsLmZldGNoID0gamVzdC5mbigpO1xuXG4vLyBNb2NrIGFuYWx5dGljc1xuY29uc3QgbW9ja0d0YWcgPSBqZXN0LmZuKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnZ3RhZycsIHtcbiAgdmFsdWU6IG1vY2tHdGFnLFxuICB3cml0YWJsZTogdHJ1ZSxcbn0pO1xuXG4vLyBUZXN0IGRhdGFcbmNvbnN0IG1vY2tDYXRlZ29yaWVzOiBDYXRlZ29yeVtdID0gW1xuICB7XG4gICAgaWQ6ICd0ZXN0LTEnLFxuICAgIG5hbWU6ICdUZXN0IENhdGVnb3J5IDEnLFxuICAgIGljb246ICcvdGVzdC0xLnBuZycsXG4gICAgZGVzY3JpcHRpb246ICdUZXN0IGRlc2NyaXB0aW9uIDEnLFxuICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICB9LFxuICB7XG4gICAgaWQ6ICd0ZXN0LTInLFxuICAgIG5hbWU6ICdUZXN0IENhdGVnb3J5IDInLFxuICAgIGljb246ICcvdGVzdC0yLnBuZycsXG4gICAgZGVzY3JpcHRpb246ICdUZXN0IGRlc2NyaXB0aW9uIDInLFxuICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICB9LFxuXTtcblxuZGVzY3JpYmUoJ3VzZUNhdGVnb3J5RGF0YSBIb29rJywgKCkgPT4ge1xuICBjb25zdCBtb2NrRmV0Y2ggPSBmZXRjaCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBmZXRjaD47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgY2xlYXJDYXRlZ29yeUNhY2hlKCk7XG4gICAgbW9ja0d0YWcubW9ja0NsZWFyKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbFRpbWVycygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW5pdGlhbGl6YXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ2luaXRpYWxpemVzIHdpdGggZmFsbGJhY2sgY2F0ZWdvcmllcyB3aGVuIGF1dG9GZXRjaCBpcyBmYWxzZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VDYXRlZ29yeURhdGEoeyBcbiAgICAgICAgICBhdXRvRmV0Y2g6IGZhbHNlLFxuICAgICAgICAgIGZhbGxiYWNrQ2F0ZWdvcmllczogbW9ja0NhdGVnb3JpZXMgXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuY2F0ZWdvcmllcykudG9FcXVhbChtb2NrQ2F0ZWdvcmllcyk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmUobnVsbCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc3RhcnRzIGxvYWRpbmcgd2hlbiBhdXRvRmV0Y2ggaXMgdHJ1ZScsICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja0NhdGVnb3JpZXMsXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RGF0YSh7IGF1dG9GZXRjaDogdHJ1ZSB9KVxuICAgICAgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdEYXRhIEZldGNoaW5nJywgKCkgPT4ge1xuICAgIGl0KCdmZXRjaGVzIGNhdGVnb3JpZXMgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrQ2F0ZWdvcmllcyxcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlEYXRhKHsgYXV0b0ZldGNoOiB0cnVlIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5jYXRlZ29yaWVzKS50b0VxdWFsKG1vY2tDYXRlZ29yaWVzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZShudWxsKTtcbiAgICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL2NhdGVnb3JpZXMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGRpZmZlcmVudCBBUEkgcmVzcG9uc2UgZm9ybWF0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRlc3Qgd2l0aCBkYXRhIHdyYXBwZXJcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gKHsgZGF0YTogbW9ja0NhdGVnb3JpZXMgfSksXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RGF0YSh7IGF1dG9GZXRjaDogdHJ1ZSB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuY2F0ZWdvcmllcykudG9FcXVhbChtb2NrQ2F0ZWdvcmllcyk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBjYXRlZ29yaWVzIHdyYXBwZXIgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIG9rOiB0cnVlLFxuICAgICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBjYXRlZ29yaWVzOiBtb2NrQ2F0ZWdvcmllcyB9KSxcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlEYXRhKHsgYXV0b0ZldGNoOiB0cnVlIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5jYXRlZ29yaWVzKS50b0VxdWFsKG1vY2tDYXRlZ29yaWVzKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGZldGNoIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ05ldHdvcmsgZXJyb3InO1xuICAgICAgbW9ja0ZldGNoLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XG5cbiAgICAgIGNvbnN0IGZhbGxiYWNrQ2F0ZWdvcmllcyA9IFttb2NrQ2F0ZWdvcmllc1swXV07XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlEYXRhKHsgXG4gICAgICAgICAgYXV0b0ZldGNoOiB0cnVlLFxuICAgICAgICAgIGZhbGxiYWNrQ2F0ZWdvcmllcyBcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0NvbnRhaW4oZXJyb3JNZXNzYWdlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5jYXRlZ29yaWVzKS50b0VxdWFsKGZhbGxiYWNrQ2F0ZWdvcmllcyk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBIVFRQIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBzdGF0dXNUZXh0OiAnTm90IEZvdW5kJyxcbiAgICAgIH0gYXMgUmVzcG9uc2UpO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcbiAgICAgICAgdXNlQ2F0ZWdvcnlEYXRhKHsgYXV0b0ZldGNoOiB0cnVlIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9Db250YWluKCdIVFRQIDQwNCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3ZhbGlkYXRlcyBhbmQgZmlsdGVycyBpbnZhbGlkIGNhdGVnb3JpZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkRGF0YSA9IFtcbiAgICAgICAgbW9ja0NhdGVnb3JpZXNbMF0sXG4gICAgICAgIHsgaWQ6ICdpbnZhbGlkJyB9LCAvLyBNaXNzaW5nIG5hbWVcbiAgICAgICAgbnVsbCxcbiAgICAgICAgeyBuYW1lOiAnTm8gSUQnIH0sIC8vIE1pc3NpbmcgaWRcbiAgICAgICAgbW9ja0NhdGVnb3JpZXNbMV0sXG4gICAgICBdO1xuXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IGludmFsaWREYXRhLFxuICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VDYXRlZ29yeURhdGEoeyBhdXRvRmV0Y2g6IHRydWUgfSlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmNhdGVnb3JpZXMpLnRvRXF1YWwobW9ja0NhdGVnb3JpZXMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Jlc3BlY3RzIG1heENhdGVnb3JpZXMgbGltaXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYW55Q2F0ZWdvcmllcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwIH0sIChfLCBpKSA9PiAoe1xuICAgICAgICBpZDogYGNhdC0ke2l9YCxcbiAgICAgICAgbmFtZTogYENhdGVnb3J5ICR7aX1gLFxuICAgICAgICBpY29uOiBgL2NhdC0ke2l9LnBuZ2AsXG4gICAgICB9KSk7XG5cbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbWFueUNhdGVnb3JpZXMsXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RGF0YSh7IFxuICAgICAgICAgIGF1dG9GZXRjaDogdHJ1ZSxcbiAgICAgICAgICBtYXhDYXRlZ29yaWVzOiA1IFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuY2F0ZWdvcmllcykudG9IYXZlTGVuZ3RoKDUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ2FjaGluZycsICgpID0+IHtcbiAgICBpdCgndXNlcyBjYWNoZWQgZGF0YSB3aGVuIGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEZpcnN0IGNhbGxcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja0NhdGVnb3JpZXMsXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQ6IHJlc3VsdDEgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlQ2F0ZWdvcnlEYXRhKHtcbiAgICAgICAgICBhdXRvRmV0Y2g6IHRydWUsXG4gICAgICAgICAgZmFsbGJhY2tDYXRlZ29yaWVzOiBtb2NrQ2F0ZWdvcmllc1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQxLmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdDEuY3VycmVudC5jYXRlZ29yaWVzKS50b0VxdWFsKG1vY2tDYXRlZ29yaWVzKTtcbiAgICAgIC8vIENhY2hlIGZ1bmN0aW9uYWxpdHkgaXMgdGVzdGVkIGF0IHRoZSBtYW5hZ2VyIGxldmVsXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9jYXRlZ29yaWVzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgncmVzcGVjdHMgY2FjaGUgZHVyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja0NhdGVnb3JpZXMsXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgLy8gRmlyc3QgY2FsbFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlQ2F0ZWdvcnlEYXRhKHtcbiAgICAgICAgICBhdXRvRmV0Y2g6IHRydWUsXG4gICAgICAgICAgY2FjaGVEdXJhdGlvbjogMTAwMCwgLy8gMSBzZWNvbmRcbiAgICAgICAgICBmYWxsYmFja0NhdGVnb3JpZXM6IG1vY2tDYXRlZ29yaWVzXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGNhY2hlIHRvIGV4cGlyZSAoc2ltdWxhdGUgdGltZSBwYXNzaW5nKVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDExMDApKTtcblxuICAgICAgLy8gUmVmcmVzaCBzaG91bGQgZmV0Y2ggYWdhaW5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnJlZnJlc2goKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNYW51YWwgUmVmcmVzaCcsICgpID0+IHtcbiAgICBpdCgncmVmcmVzaGVzIGRhdGEgbWFudWFsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja0NhdGVnb3JpZXMsXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RGF0YSh7IGF1dG9GZXRjaDogZmFsc2UgfSlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnJlZnJlc2goKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuY2F0ZWdvcmllcykudG9FcXVhbChtb2NrQ2F0ZWdvcmllcyk7XG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyByZWZyZXNoIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdSZWZyZXNoIGZhaWxlZCcpKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RGF0YSh7IGF1dG9GZXRjaDogZmFsc2UgfSlcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnJlZnJlc2goKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQ29udGFpbignUmVmcmVzaCBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1V0aWxpdHkgRnVuY3Rpb25zJywgKCkgPT4ge1xuICAgIGl0KCdmaW5kcyBjYXRlZ29yeSBieSBJRCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja0NhdGVnb3JpZXMsXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RGF0YSh7IGF1dG9GZXRjaDogdHJ1ZSB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjYXRlZ29yeSA9IHJlc3VsdC5jdXJyZW50LmdldENhdGVnb3J5QnlJZCgndGVzdC0xJyk7XG4gICAgICBleHBlY3QoY2F0ZWdvcnkpLnRvRXF1YWwobW9ja0NhdGVnb3JpZXNbMF0pO1xuXG4gICAgICBjb25zdCBub3RGb3VuZCA9IHJlc3VsdC5jdXJyZW50LmdldENhdGVnb3J5QnlJZCgnbm90LWZvdW5kJyk7XG4gICAgICBleHBlY3Qobm90Rm91bmQpLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FuYWx5dGljcycsICgpID0+IHtcbiAgICBpdCgndHJhY2tzIHN1Y2Nlc3NmdWwgZmV0Y2gnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tDYXRlZ29yaWVzLFxuICAgICAgfSBhcyBSZXNwb25zZSk7XG5cbiAgICAgIHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RGF0YSh7IFxuICAgICAgICAgIGF1dG9GZXRjaDogdHJ1ZSxcbiAgICAgICAgICBlbmFibGVBbmFseXRpY3M6IHRydWUgXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tHdGFnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnZXZlbnQnLFxuICAgICAgICAgICdjYXRlZ29yeV9kYXRhJyxcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBldmVudF9jYXRlZ29yeTogJ2RhdGEnLFxuICAgICAgICAgICAgZXZlbnRfbGFiZWw6ICdmZXRjaF9zdWNjZXNzJyxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgndHJhY2tzIGZldGNoIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdUZXN0IGVycm9yJykpO1xuXG4gICAgICByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VDYXRlZ29yeURhdGEoeyBcbiAgICAgICAgICBhdXRvRmV0Y2g6IHRydWUsXG4gICAgICAgICAgZW5hYmxlQW5hbHl0aWNzOiB0cnVlIFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrR3RhZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgJ2V2ZW50JyxcbiAgICAgICAgICAnY2F0ZWdvcnlfZGF0YScsXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdkYXRhJyxcbiAgICAgICAgICAgIGV2ZW50X2xhYmVsOiAnZmV0Y2hfZXJyb3InLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdkb2VzIG5vdCB0cmFjayB3aGVuIGFuYWx5dGljcyBkaXNhYmxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja0NhdGVnb3JpZXMsXG4gICAgICB9IGFzIFJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlQ2F0ZWdvcnlEYXRhKHtcbiAgICAgICAgICBhdXRvRmV0Y2g6IHRydWUsXG4gICAgICAgICAgZW5hYmxlQW5hbHl0aWNzOiBmYWxzZSxcbiAgICAgICAgICBmYWxsYmFja0NhdGVnb3JpZXM6IG1vY2tDYXRlZ29yaWVzXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrR3RhZykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0JhY2tncm91bmQgUmVmcmVzaCcsICgpID0+IHtcbiAgICBpdCgnc2V0cyB1cCBiYWNrZ3JvdW5kIHJlZnJlc2ggaW50ZXJ2YWwnLCAoKSA9PiB7XG4gICAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcbiAgICAgIGNvbnN0IHNldEludGVydmFsU3B5ID0gamVzdC5zcHlPbihnbG9iYWwsICdzZXRJbnRlcnZhbCcpO1xuXG4gICAgICByZW5kZXJIb29rKCgpID0+IFxuICAgICAgICB1c2VDYXRlZ29yeURhdGEoeyBcbiAgICAgICAgICBhdXRvRmV0Y2g6IGZhbHNlLFxuICAgICAgICAgIGVuYWJsZUJhY2tncm91bmRSZWZyZXNoOiB0cnVlLFxuICAgICAgICAgIHJlZnJlc2hJbnRlcnZhbDogNTAwMCBcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChzZXRJbnRlcnZhbFNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5hbnkoRnVuY3Rpb24pLFxuICAgICAgICA1MDAwXG4gICAgICApO1xuXG4gICAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtcbiAgICB9KTtcblxuICAgIGl0KCdjbGVhbnMgdXAgaW50ZXJ2YWwgb24gdW5tb3VudCcsICgpID0+IHtcbiAgICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xuICAgICAgY29uc3QgY2xlYXJJbnRlcnZhbFNweSA9IGplc3Quc3B5T24oZ2xvYmFsLCAnY2xlYXJJbnRlcnZhbCcpO1xuXG4gICAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlckhvb2soKCkgPT4gXG4gICAgICAgIHVzZUNhdGVnb3J5RGF0YSh7IFxuICAgICAgICAgIGVuYWJsZUJhY2tncm91bmRSZWZyZXNoOiB0cnVlLFxuICAgICAgICAgIHJlZnJlc2hJbnRlcnZhbDogNTAwMCBcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHVubW91bnQoKTtcblxuICAgICAgZXhwZWN0KGNsZWFySW50ZXJ2YWxTcHkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgamVzdC51c2VSZWFsVGltZXJzKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmV0Y2giLCJqZXN0IiwiZm4iLCJtb2NrR3RhZyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid2luZG93IiwidmFsdWUiLCJ3cml0YWJsZSIsIm1vY2tDYXRlZ29yaWVzIiwiaWQiLCJuYW1lIiwiaWNvbiIsImRlc2NyaXB0aW9uIiwiaXNBdmFpbGFibGUiLCJkZXNjcmliZSIsIm1vY2tGZXRjaCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiY2xlYXJDYXRlZ29yeUNhY2hlIiwibW9ja0NsZWFyIiwiYWZ0ZXJFYWNoIiwiY2xlYXJBbGxUaW1lcnMiLCJpdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VDYXRlZ29yeURhdGEiLCJhdXRvRmV0Y2giLCJmYWxsYmFja0NhdGVnb3JpZXMiLCJleHBlY3QiLCJjdXJyZW50IiwiY2F0ZWdvcmllcyIsInRvRXF1YWwiLCJsb2FkaW5nIiwidG9CZSIsImVycm9yIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwib2siLCJqc29uIiwid2FpdEZvciIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwiZGF0YSIsImVycm9yTWVzc2FnZSIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwidG9Db250YWluIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImludmFsaWREYXRhIiwibWFueUNhdGVnb3JpZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsIm1heENhdGVnb3JpZXMiLCJ0b0hhdmVMZW5ndGgiLCJyZXN1bHQxIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJjYWNoZUR1cmF0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiYWN0IiwicmVmcmVzaCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsImNhdGVnb3J5IiwiZ2V0Q2F0ZWdvcnlCeUlkIiwibm90Rm91bmQiLCJ0b0JlVW5kZWZpbmVkIiwiZW5hYmxlQW5hbHl0aWNzIiwib2JqZWN0Q29udGFpbmluZyIsImV2ZW50X2NhdGVnb3J5IiwiZXZlbnRfbGFiZWwiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwidXNlRmFrZVRpbWVycyIsInNldEludGVydmFsU3B5Iiwic3B5T24iLCJlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaCIsInJlZnJlc2hJbnRlcnZhbCIsImFueSIsIkZ1bmN0aW9uIiwidXNlUmVhbFRpbWVycyIsImNsZWFySW50ZXJ2YWxTcHkiLCJ1bm1vdW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDOzs7O3VCQUV3QztpQ0FDVztBQUdwRCxhQUFhO0FBQ2JBLE9BQU9DLEtBQUssR0FBR0MsS0FBS0MsRUFBRTtBQUV0QixpQkFBaUI7QUFDakIsTUFBTUMsV0FBV0YsS0FBS0MsRUFBRTtBQUN4QkUsT0FBT0MsY0FBYyxDQUFDQyxRQUFRLFFBQVE7SUFDcENDLE9BQU9KO0lBQ1BLLFVBQVU7QUFDWjtBQUVBLFlBQVk7QUFDWixNQUFNQyxpQkFBNkI7SUFDakM7UUFDRUMsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxhQUFhO0lBQ2Y7SUFDQTtRQUNFSixJQUFJO1FBQ0pDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLGFBQWE7SUFDZjtDQUNEO0FBRURDLFNBQVMsd0JBQXdCO0lBQy9CLE1BQU1DLFlBQVloQjtJQUVsQmlCLFdBQVc7UUFDVGhCLEtBQUtpQixhQUFhO1FBQ2xCQyxJQUFBQSxtQ0FBa0I7UUFDbEJoQixT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