{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\__tests__\\hooks\\useCategoryData.test.ts"],"sourcesContent":["/**\n * useCategoryData Hook Tests\n * Enterprise-ready test suite for category data management\n * Pinteya E-commerce\n */\n\nimport { renderHook, act, waitFor } from '@testing-library/react';\nimport { useCategoryData, clearCategoryCache } from '@/hooks/useCategoryData';\nimport type { Category } from '@/types/categories';\n\n// Mock fetch\nglobal.fetch = jest.fn();\n\n// Mock analytics\nconst mockGtag = jest.fn();\nObject.defineProperty(window, 'gtag', {\n  value: mockGtag,\n  writable: true,\n});\n\n// Test data\nconst mockCategories: Category[] = [\n  {\n    id: 'test-1',\n    name: 'Test Category 1',\n    icon: '/test-1.png',\n    description: 'Test description 1',\n    isAvailable: true,\n  },\n  {\n    id: 'test-2',\n    name: 'Test Category 2',\n    icon: '/test-2.png',\n    description: 'Test description 2',\n    isAvailable: true,\n  },\n];\n\ndescribe('useCategoryData Hook', () => {\n  const mockFetch = fetch as jest.MockedFunction<typeof fetch>;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    clearCategoryCache();\n    mockGtag.mockClear();\n  });\n\n  afterEach(() => {\n    jest.clearAllTimers();\n  });\n\n  describe('Initialization', () => {\n    it('initializes with fallback categories when autoFetch is false', () => {\n      const { result } = renderHook(() => \n        useCategoryData({ \n          autoFetch: false,\n          fallbackCategories: mockCategories \n        })\n      );\n\n      expect(result.current.categories).toEqual(mockCategories);\n      expect(result.current.loading).toBe(false);\n      expect(result.current.error).toBe(null);\n    });\n\n    it('starts loading when autoFetch is true', () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockCategories,\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: true })\n      );\n\n      expect(result.current.loading).toBe(true);\n    });\n  });\n\n  describe('Data Fetching', () => {\n    it('fetches categories successfully', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockCategories,\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: true })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.categories).toEqual(mockCategories);\n      expect(result.current.error).toBe(null);\n      expect(mockFetch).toHaveBeenCalledWith('/api/categories');\n    });\n\n    it('handles different API response formats', async () => {\n      // Test with data wrapper\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => ({ data: mockCategories }),\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: true })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.categories).toEqual(mockCategories);\n    });\n\n    it('handles categories wrapper format', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => ({ categories: mockCategories }),\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: true })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.categories).toEqual(mockCategories);\n    });\n\n    it('handles fetch errors gracefully', async () => {\n      const errorMessage = 'Network error';\n      mockFetch.mockRejectedValueOnce(new Error(errorMessage));\n\n      const fallbackCategories = [mockCategories[0]];\n      const { result } = renderHook(() => \n        useCategoryData({ \n          autoFetch: true,\n          fallbackCategories \n        })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toContain(errorMessage);\n      expect(result.current.categories).toEqual(fallbackCategories);\n    });\n\n    it('handles HTTP errors', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n        statusText: 'Not Found',\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: true })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toContain('HTTP 404');\n    });\n\n    it('validates and filters invalid categories', async () => {\n      const invalidData = [\n        mockCategories[0],\n        { id: 'invalid' }, // Missing name\n        null,\n        { name: 'No ID' }, // Missing id\n        mockCategories[1],\n      ];\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => invalidData,\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: true })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.categories).toEqual(mockCategories);\n    });\n\n    it('respects maxCategories limit', async () => {\n      const manyCategories = Array.from({ length: 10 }, (_, i) => ({\n        id: `cat-${i}`,\n        name: `Category ${i}`,\n        icon: `/cat-${i}.png`,\n      }));\n\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => manyCategories,\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ \n          autoFetch: true,\n          maxCategories: 5 \n        })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.categories).toHaveLength(5);\n    });\n  });\n\n  describe('Caching', () => {\n    it('uses cached data when available', async () => {\n      // First call\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockCategories,\n      } as Response);\n\n      const { result: result1 } = renderHook(() =>\n        useCategoryData({\n          autoFetch: true,\n          fallbackCategories: mockCategories\n        })\n      );\n\n      await waitFor(() => {\n        expect(result1.current.loading).toBe(false);\n      });\n\n      expect(result1.current.categories).toEqual(mockCategories);\n      // Cache functionality is tested at the manager level\n      expect(mockFetch).toHaveBeenCalledWith('/api/categories');\n    });\n\n    it('respects cache duration', async () => {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: async () => mockCategories,\n      } as Response);\n\n      // First call\n      const { result } = renderHook(() =>\n        useCategoryData({\n          autoFetch: true,\n          cacheDuration: 1000, // 1 second\n          fallbackCategories: mockCategories\n        })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      // Wait for cache to expire (simulate time passing)\n      await new Promise(resolve => setTimeout(resolve, 1100));\n\n      // Refresh should fetch again\n      await act(async () => {\n        await result.current.refresh();\n      });\n\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n    });\n  });\n\n  describe('Manual Refresh', () => {\n    it('refreshes data manually', async () => {\n      mockFetch.mockResolvedValue({\n        ok: true,\n        json: async () => mockCategories,\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: false })\n      );\n\n      await act(async () => {\n        await result.current.refresh();\n      });\n\n      expect(result.current.categories).toEqual(mockCategories);\n      expect(mockFetch).toHaveBeenCalledTimes(1);\n    });\n\n    it('handles refresh errors', async () => {\n      mockFetch.mockRejectedValueOnce(new Error('Refresh failed'));\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: false })\n      );\n\n      await act(async () => {\n        await result.current.refresh();\n      });\n\n      expect(result.current.error).toContain('Refresh failed');\n    });\n  });\n\n  describe('Utility Functions', () => {\n    it('finds category by ID', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockCategories,\n      } as Response);\n\n      const { result } = renderHook(() => \n        useCategoryData({ autoFetch: true })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const category = result.current.getCategoryById('test-1');\n      expect(category).toEqual(mockCategories[0]);\n\n      const notFound = result.current.getCategoryById('not-found');\n      expect(notFound).toBeUndefined();\n    });\n  });\n\n  describe('Analytics', () => {\n    it('tracks successful fetch', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockCategories,\n      } as Response);\n\n      renderHook(() => \n        useCategoryData({ \n          autoFetch: true,\n          enableAnalytics: true \n        })\n      );\n\n      await waitFor(() => {\n        expect(mockGtag).toHaveBeenCalledWith(\n          'event',\n          'category_data',\n          expect.objectContaining({\n            event_category: 'data',\n            event_label: 'fetch_success',\n          })\n        );\n      });\n    });\n\n    it('tracks fetch errors', async () => {\n      mockFetch.mockRejectedValueOnce(new Error('Test error'));\n\n      renderHook(() => \n        useCategoryData({ \n          autoFetch: true,\n          enableAnalytics: true \n        })\n      );\n\n      await waitFor(() => {\n        expect(mockGtag).toHaveBeenCalledWith(\n          'event',\n          'category_data',\n          expect.objectContaining({\n            event_category: 'data',\n            event_label: 'fetch_error',\n          })\n        );\n      });\n    });\n\n    it('does not track when analytics disabled', async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockCategories,\n      } as Response);\n\n      const { result } = renderHook(() =>\n        useCategoryData({\n          autoFetch: true,\n          enableAnalytics: false,\n          fallbackCategories: mockCategories\n        })\n      );\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(mockGtag).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Background Refresh', () => {\n    it('sets up background refresh interval', () => {\n      jest.useFakeTimers();\n      const setIntervalSpy = jest.spyOn(global, 'setInterval');\n\n      renderHook(() => \n        useCategoryData({ \n          autoFetch: false,\n          enableBackgroundRefresh: true,\n          refreshInterval: 5000 \n        })\n      );\n\n      expect(setIntervalSpy).toHaveBeenCalledWith(\n        expect.any(Function),\n        5000\n      );\n\n      jest.useRealTimers();\n    });\n\n    it('cleans up interval on unmount', () => {\n      jest.useFakeTimers();\n      const clearIntervalSpy = jest.spyOn(global, 'clearInterval');\n\n      const { unmount } = renderHook(() => \n        useCategoryData({ \n          enableBackgroundRefresh: true,\n          refreshInterval: 5000 \n        })\n      );\n\n      unmount();\n\n      expect(clearIntervalSpy).toHaveBeenCalled();\n\n      jest.useRealTimers();\n    });\n  });\n});\n"],"names":["global","fetch","jest","fn","mockGtag","Object","defineProperty","window","value","writable","mockCategories","id","name","icon","description","isAvailable","describe","mockFetch","beforeEach","clearAllMocks","clearCategoryCache","mockClear","afterEach","clearAllTimers","it","result","renderHook","useCategoryData","autoFetch","fallbackCategories","expect","current","categories","toEqual","loading","toBe","error","mockResolvedValueOnce","ok","json","waitFor","toHaveBeenCalledWith","data","errorMessage","mockRejectedValueOnce","Error","toContain","status","statusText","invalidData","manyCategories","Array","from","length","_","i","maxCategories","toHaveLength","result1","mockResolvedValue","cacheDuration","Promise","resolve","setTimeout","act","refresh","toHaveBeenCalledTimes","category","getCategoryById","notFound","toBeUndefined","enableAnalytics","objectContaining","event_category","event_label","not","toHaveBeenCalled","useFakeTimers","setIntervalSpy","spyOn","enableBackgroundRefresh","refreshInterval","any","Function","useRealTimers","clearIntervalSpy","unmount"],"mappings":"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"}