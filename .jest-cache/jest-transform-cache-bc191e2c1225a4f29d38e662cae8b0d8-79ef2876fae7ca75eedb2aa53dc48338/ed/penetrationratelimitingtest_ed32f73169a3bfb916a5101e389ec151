553b0c9d3853aa227d12de06b80197e8
/**
 * Tests de Penetración para Rate Limiting Enterprise
 * Simula ataques reales para validar la robustez del sistema
 */ // Mock de Redis para tests
"use strict";
jest.mock('ioredis', ()=>{
    const mockRedis = {
        get: jest.fn(),
        set: jest.fn(),
        incr: jest.fn(),
        expire: jest.fn(),
        del: jest.fn(),
        pipeline: jest.fn(()=>({
                get: jest.fn(),
                incr: jest.fn(),
                expire: jest.fn(),
                exec: jest.fn().mockResolvedValue([
                    [
                        null,
                        '1'
                    ],
                    [
                        null,
                        'OK'
                    ]
                ])
            })),
        disconnect: jest.fn()
    };
    return jest.fn(()=>mockRedis);
});
jest.mock('@/lib/security/enterprise-audit-system', ()=>({
        enterpriseAuditSystem: {
            logEnterpriseEvent: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _enterpriseratelimiter = require("../../lib/rate-limiting/enterprise-rate-limiter");
const _enterprisemiddleware = require("../../lib/rate-limiting/enterprise-middleware");
describe('Tests de Penetración - Rate Limiting Enterprise', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Reset metrics collector
        _enterpriseratelimiter.metricsCollector.metrics = {
            totalRequests: 0,
            allowedRequests: 0,
            blockedRequests: 0,
            redisHits: 0,
            memoryFallbacks: 0,
            errors: 0,
            averageResponseTime: 0,
            topBlockedIPs: [],
            topEndpoints: []
        };
    });
    describe('Ataque de Fuerza Bruta - Admin APIs', ()=>{
        it('debe bloquear múltiples requests rápidos desde la misma IP', async ()=>{
            const attackerIP = '192.168.1.100';
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL;
            const results = [];
            // Simular 20 requests rápidos (límite admin es 15/min)
            for(let i = 0; i < 20; i++){
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            attackerIP
                        ],
                        [
                            'user-agent',
                            'AttackBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/admin/products'
                    },
                    method: 'POST'
                };
                const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `admin_attack_${i}`);
                results.push(result);
            }
            // Verificar que los primeros requests pasan
            expect(results.slice(0, 15).every((r)=>r.allowed)).toBe(true);
            // Verificar que los siguientes son bloqueados
            expect(results.slice(15).every((r)=>!r.allowed)).toBe(true);
            // Verificar métricas de ataque
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.blockedRequests).toBeGreaterThan(0);
            expect(metrics.topBlockedIPs.some((ip)=>ip.ip === attackerIP)).toBe(true);
        });
        it('debe detectar ataque distribuido desde múltiples IPs', async ()=>{
            const attackerIPs = [
                '192.168.1.100',
                '192.168.1.101',
                '192.168.1.102',
                '192.168.1.103',
                '192.168.1.104'
            ];
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL;
            let totalBlocked = 0;
            // Simular ataque distribuido
            for (const ip of attackerIPs){
                for(let i = 0; i < 20; i++){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                ip
                            ],
                            [
                                'user-agent',
                                'DistributedBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/admin/users'
                        },
                        method: 'DELETE'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `distributed_attack_${ip}_${i}`);
                    if (!result.allowed) {
                        totalBlocked++;
                    }
                }
            }
            // Verificar que se bloquearon múltiples requests
            expect(totalBlocked).toBeGreaterThan(20); // 5 IPs * 5 requests bloqueados cada una
            // Verificar que múltiples IPs están en la lista de bloqueados
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.topBlockedIPs.length).toBeGreaterThan(3);
        });
        it('debe resistir ataque de bypass con headers falsos', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL;
            const results = [];
            // Intentar bypass con diferentes headers
            const bypassAttempts = [
                {
                    'x-forwarded-for': '127.0.0.1',
                    'x-real-ip': '192.168.1.100'
                },
                {
                    'x-forwarded-for': '192.168.1.100',
                    'x-real-ip': '127.0.0.1'
                },
                {
                    'x-forwarded-for': '192.168.1.100, 127.0.0.1'
                },
                {
                    'x-forwarded-for': '192.168.1.100',
                    'cf-connecting-ip': '127.0.0.1'
                },
                {
                    'x-forwarded-for': '192.168.1.100',
                    'x-client-ip': '10.0.0.1'
                }
            ];
            for(let attempt = 0; attempt < bypassAttempts.length; attempt++){
                for(let i = 0; i < 20; i++){
                    const mockRequest = {
                        headers: new Map(Object.entries({
                            ...bypassAttempts[attempt],
                            'user-agent': 'BypassBot/1.0'
                        })),
                        nextUrl: {
                            pathname: '/api/admin/settings'
                        },
                        method: 'PUT'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `bypass_attempt_${attempt}_${i}`);
                    results.push(result);
                }
            }
            // Verificar que el sistema no fue burlado
            const blockedCount = results.filter((r)=>!r.allowed).length;
            expect(blockedCount).toBeGreaterThan(50); // Debería bloquear la mayoría
        });
    });
    describe('Ataque de Agotamiento de Recursos', ()=>{
        it('debe manejar requests con payloads extremadamente grandes', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PAYMENT_HIGH;
            const attackerIP = '10.0.0.50';
            // Simular requests con diferentes tamaños de payload
            const payloadSizes = [
                1000,
                10000,
                100000,
                1000000
            ]; // Bytes
            const results = [];
            for (const size of payloadSizes){
                for(let i = 0; i < 10; i++){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                attackerIP
                            ],
                            [
                                'content-length',
                                size.toString()
                            ],
                            [
                                'user-agent',
                                'ResourceExhaustionBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/payments/process'
                        },
                        method: 'POST'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `resource_attack_${size}_${i}`);
                    results.push(result);
                }
            }
            // Verificar que el sistema mantiene performance
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.averageResponseTime).toBeLessThan(100); // < 100ms
            // Verificar que se aplicó rate limiting
            const blockedCount = results.filter((r)=>!r.allowed).length;
            expect(blockedCount).toBeGreaterThan(0);
        });
        it('debe detectar patrones de scraping automatizado', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD;
            const scraperIP = '203.0.113.100';
            const results = [];
            // Simular scraping con patrones regulares
            const endpoints = [
                '/api/products',
                '/api/categories',
                '/api/search',
                '/api/products/1',
                '/api/products/2'
            ];
            // Requests muy rápidos y regulares (típico de bots)
            for(let round = 0; round < 10; round++){
                for (const endpoint of endpoints){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                scraperIP
                            ],
                            [
                                'user-agent',
                                'ScrapingBot/2.0 (automated)'
                            ]
                        ]),
                        nextUrl: {
                            pathname: endpoint
                        },
                        method: 'GET'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `scraping_${round}_${endpoint.replace('/', '_')}`);
                    results.push(result);
                }
            }
            // Verificar detección de scraping
            const blockedCount = results.filter((r)=>!r.allowed).length;
            expect(blockedCount).toBeGreaterThan(20); // Debería bloquear muchos requests
            // Verificar que el endpoint está en top blocked
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.topEndpoints.length).toBeGreaterThan(0);
        });
    });
    describe('Ataques de Timing y Concurrencia', ()=>{
        it('debe manejar requests concurrentes masivos', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD;
            const attackerIP = '198.51.100.50';
            // Simular 100 requests concurrentes
            const concurrentRequests = Array.from({
                length: 100
            }, (_, i)=>{
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            attackerIP
                        ],
                        [
                            'user-agent',
                            'ConcurrencyBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/products'
                    },
                    method: 'GET'
                };
                return (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `concurrent_${i}`);
            });
            const results = await Promise.all(concurrentRequests);
            // Verificar que el sistema mantuvo consistencia
            const allowedCount = results.filter((r)=>r.allowed).length;
            const blockedCount = results.filter((r)=>!r.allowed).length;
            expect(allowedCount + blockedCount).toBe(100);
            expect(blockedCount).toBeGreaterThan(50); // Debería bloquear la mayoría
        });
        it('debe resistir ataques de timing para encontrar ventanas', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL;
            const attackerIP = '172.16.0.100';
            const results = [];
            // Intentar encontrar ventanas de tiempo donde el rate limit se resetea
            for(let window = 0; window < 5; window++){
                // Burst inicial
                for(let i = 0; i < 20; i++){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                attackerIP
                            ],
                            [
                                'user-agent',
                                'TimingAttackBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/admin/critical'
                        },
                        method: 'POST'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `timing_window_${window}_${i}`);
                    results.push(result);
                }
                // Esperar un poco (simular espera para reset)
                await new Promise((resolve)=>setTimeout(resolve, 100));
            }
            // Verificar que no se pudo explotar timing
            const totalBlocked = results.filter((r)=>!r.allowed).length;
            expect(totalBlocked).toBeGreaterThan(60); // Debería bloquear la mayoría
        });
    });
    describe('Middleware de Rate Limiting bajo Ataque', ()=>{
        it('debe mantener funcionalidad durante ataque DDoS simulado', async ()=>{
            const mockHandler = jest.fn().mockResolvedValue(new Response(JSON.stringify({
                success: true
            }), {
                status: 200
            }));
            const protectedHandler = (0, _enterprisemiddleware.withEnterpriseRateLimit)({
                configName: 'PUBLIC_STANDARD',
                enableLogging: true
            })(mockHandler);
            // Simular DDoS con múltiples IPs
            const attackIPs = Array.from({
                length: 50
            }, (_, i)=>`10.0.${Math.floor(i / 255)}.${i % 255}`);
            const results = [];
            for (const ip of attackIPs){
                for(let i = 0; i < 10; i++){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                ip
                            ],
                            [
                                'user-agent',
                                'DDoSBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/public/test'
                        },
                        method: 'GET'
                    };
                    try {
                        const response = await protectedHandler(mockRequest);
                        results.push(response);
                    } catch (error) {
                        // Rate limit debería devolver respuesta, no error
                        expect(error).toBeUndefined();
                    }
                }
            }
            // Verificar que el sistema respondió a todos los requests
            expect(results.length).toBe(500);
            // Verificar que muchos fueron bloqueados (status 429)
            const blockedResponses = results.filter((r)=>r.status === 429);
            expect(blockedResponses.length).toBeGreaterThan(300);
            // Verificar que algunos requests legítimos pasaron
            const successResponses = results.filter((r)=>r.status === 200);
            expect(successResponses.length).toBeGreaterThan(0);
        });
        it('debe mantener performance durante ataque sostenido', async ()=>{
            const mockHandler = jest.fn().mockResolvedValue(new Response(JSON.stringify({
                data: 'test'
            }), {
                status: 200
            }));
            const protectedHandler = (0, _enterprisemiddleware.withEnterpriseRateLimit)({
                configName: 'ADMIN_CRITICAL',
                enableLogging: false // Disable para performance
            })(mockHandler);
            const attackerIP = '192.0.2.100';
            const startTime = Date.now();
            const results = [];
            // Ataque sostenido por 1000 requests
            for(let i = 0; i < 1000; i++){
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            attackerIP
                        ],
                        [
                            'user-agent',
                            'SustainedAttackBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/admin/test'
                    },
                    method: 'GET'
                };
                const response = await protectedHandler(mockRequest);
                results.push(response);
            }
            const endTime = Date.now();
            const totalTime = endTime - startTime;
            const avgResponseTime = totalTime / 1000;
            // Verificar performance (< 5ms por request en promedio)
            expect(avgResponseTime).toBeLessThan(5);
            // Verificar que el rate limiting funcionó
            const blockedCount = results.filter((r)=>r.status === 429).length;
            expect(blockedCount).toBeGreaterThan(900); // Debería bloquear casi todos
        });
    });
    describe('Recuperación y Resilencia', ()=>{
        it('debe recuperarse después de un ataque masivo', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD;
            const attackerIP = '203.0.113.200';
            // Fase 1: Ataque masivo
            for(let i = 0; i < 100; i++){
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            attackerIP
                        ],
                        [
                            'user-agent',
                            'MassiveAttackBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/products'
                    },
                    method: 'GET'
                };
                await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `massive_attack_${i}`);
            }
            // Verificar que el atacante está bloqueado
            const duringAttackRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        attackerIP
                    ],
                    [
                        'user-agent',
                        'MassiveAttackBot/1.0'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/products'
                },
                method: 'GET'
            };
            const duringAttackResult = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(duringAttackRequest, config, 'during_attack_check');
            expect(duringAttackResult.allowed).toBe(false);
            // Fase 2: Usuario legítimo debe poder acceder
            const legitimateUserIP = '198.51.100.200';
            const legitimateRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        legitimateUserIP
                    ],
                    [
                        'user-agent',
                        'Mozilla/5.0 (legitimate browser)'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/products'
                },
                method: 'GET'
            };
            const legitimateResult = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(legitimateRequest, config, 'legitimate_user');
            expect(legitimateResult.allowed).toBe(true);
            // Verificar métricas de recuperación
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.totalRequests).toBeGreaterThan(100);
            expect(metrics.allowedRequests).toBeGreaterThan(0);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxzZWN1cml0eVxccGVuZXRyYXRpb24tcmF0ZS1saW1pdGluZy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgZGUgUGVuZXRyYWNpw7NuIHBhcmEgUmF0ZSBMaW1pdGluZyBFbnRlcnByaXNlXG4gKiBTaW11bGEgYXRhcXVlcyByZWFsZXMgcGFyYSB2YWxpZGFyIGxhIHJvYnVzdGV6IGRlbCBzaXN0ZW1hXG4gKi9cblxuLy8gTW9jayBkZSBSZWRpcyBwYXJhIHRlc3RzXG5qZXN0Lm1vY2soJ2lvcmVkaXMnLCAoKSA9PiB7XG4gIGNvbnN0IG1vY2tSZWRpcyA9IHtcbiAgICBnZXQ6IGplc3QuZm4oKSxcbiAgICBzZXQ6IGplc3QuZm4oKSxcbiAgICBpbmNyOiBqZXN0LmZuKCksXG4gICAgZXhwaXJlOiBqZXN0LmZuKCksXG4gICAgZGVsOiBqZXN0LmZuKCksXG4gICAgcGlwZWxpbmU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgIGdldDogamVzdC5mbigpLFxuICAgICAgaW5jcjogamVzdC5mbigpLFxuICAgICAgZXhwaXJlOiBqZXN0LmZuKCksXG4gICAgICBleGVjOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoW1tudWxsLCAnMSddLCBbbnVsbCwgJ09LJ11dKVxuICAgIH0pKSxcbiAgICBkaXNjb25uZWN0OiBqZXN0LmZuKClcbiAgfTtcbiAgcmV0dXJuIGplc3QuZm4oKCkgPT4gbW9ja1JlZGlzKTtcbn0pO1xuXG5qZXN0Lm1vY2soJ0AvbGliL3NlY3VyaXR5L2VudGVycHJpc2UtYXVkaXQtc3lzdGVtJywgKCkgPT4gKHtcbiAgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtOiB7XG4gICAgbG9nRW50ZXJwcmlzZUV2ZW50OiBqZXN0LmZuKClcbiAgfVxufSkpO1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7XG4gIGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdCxcbiAgRU5URVJQUklTRV9SQVRFX0xJTUlUX0NPTkZJR1MsXG4gIG1ldHJpY3NDb2xsZWN0b3IsXG4gIHR5cGUgRW50ZXJwcmlzZVJhdGVMaW1pdFJlc3VsdFxufSBmcm9tICdAL2xpYi9yYXRlLWxpbWl0aW5nL2VudGVycHJpc2UtcmF0ZS1saW1pdGVyJztcbmltcG9ydCB7IHdpdGhFbnRlcnByaXNlUmF0ZUxpbWl0IH0gZnJvbSAnQC9saWIvcmF0ZS1saW1pdGluZy9lbnRlcnByaXNlLW1pZGRsZXdhcmUnO1xuXG5kZXNjcmliZSgnVGVzdHMgZGUgUGVuZXRyYWNpw7NuIC0gUmF0ZSBMaW1pdGluZyBFbnRlcnByaXNlJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAvLyBSZXNldCBtZXRyaWNzIGNvbGxlY3RvclxuICAgIChtZXRyaWNzQ29sbGVjdG9yIGFzIGFueSkubWV0cmljcyA9IHtcbiAgICAgIHRvdGFsUmVxdWVzdHM6IDAsXG4gICAgICBhbGxvd2VkUmVxdWVzdHM6IDAsXG4gICAgICBibG9ja2VkUmVxdWVzdHM6IDAsXG4gICAgICByZWRpc0hpdHM6IDAsXG4gICAgICBtZW1vcnlGYWxsYmFja3M6IDAsXG4gICAgICBlcnJvcnM6IDAsXG4gICAgICBhdmVyYWdlUmVzcG9uc2VUaW1lOiAwLFxuICAgICAgdG9wQmxvY2tlZElQczogW10sXG4gICAgICB0b3BFbmRwb2ludHM6IFtdXG4gICAgfTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F0YXF1ZSBkZSBGdWVyemEgQnJ1dGEgLSBBZG1pbiBBUElzJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIGJsb3F1ZWFyIG3Dumx0aXBsZXMgcmVxdWVzdHMgcsOhcGlkb3MgZGVzZGUgbGEgbWlzbWEgSVAnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhdHRhY2tlcklQID0gJzE5Mi4xNjguMS4xMDAnO1xuICAgICAgY29uc3QgY29uZmlnID0gRU5URVJQUklTRV9SQVRFX0xJTUlUX0NPTkZJR1MuQURNSU5fQ1JJVElDQUw7XG4gICAgICBjb25zdCByZXN1bHRzOiBFbnRlcnByaXNlUmF0ZUxpbWl0UmVzdWx0W10gPSBbXTtcblxuICAgICAgLy8gU2ltdWxhciAyMCByZXF1ZXN0cyByw6FwaWRvcyAobMOtbWl0ZSBhZG1pbiBlcyAxNS9taW4pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbXG4gICAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIGF0dGFja2VySVBdLFxuICAgICAgICAgICAgWyd1c2VyLWFnZW50JywgJ0F0dGFja0JvdC8xLjAnXVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL2FkbWluL3Byb2R1Y3RzJyB9LFxuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXG4gICAgICAgIH0gYXMgYW55O1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChcbiAgICAgICAgICBtb2NrUmVxdWVzdCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgYGFkbWluX2F0dGFja18ke2l9YFxuICAgICAgICApO1xuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBsb3MgcHJpbWVyb3MgcmVxdWVzdHMgcGFzYW5cbiAgICAgIGV4cGVjdChyZXN1bHRzLnNsaWNlKDAsIDE1KS5ldmVyeShyID0+IHIuYWxsb3dlZCkpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgbG9zIHNpZ3VpZW50ZXMgc29uIGJsb3F1ZWFkb3NcbiAgICAgIGV4cGVjdChyZXN1bHRzLnNsaWNlKDE1KS5ldmVyeShyID0+ICFyLmFsbG93ZWQpKS50b0JlKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZmljYXIgbcOpdHJpY2FzIGRlIGF0YXF1ZVxuICAgICAgY29uc3QgbWV0cmljcyA9IG1ldHJpY3NDb2xsZWN0b3IuZ2V0TWV0cmljcygpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MuYmxvY2tlZFJlcXVlc3RzKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICBleHBlY3QobWV0cmljcy50b3BCbG9ja2VkSVBzLnNvbWUoaXAgPT4gaXAuaXAgPT09IGF0dGFja2VySVApKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgZGV0ZWN0YXIgYXRhcXVlIGRpc3RyaWJ1aWRvIGRlc2RlIG3Dumx0aXBsZXMgSVBzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXR0YWNrZXJJUHMgPSBbXG4gICAgICAgICcxOTIuMTY4LjEuMTAwJyxcbiAgICAgICAgJzE5Mi4xNjguMS4xMDEnLCBcbiAgICAgICAgJzE5Mi4xNjguMS4xMDInLFxuICAgICAgICAnMTkyLjE2OC4xLjEwMycsXG4gICAgICAgICcxOTIuMTY4LjEuMTA0J1xuICAgICAgXTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLkFETUlOX0NSSVRJQ0FMO1xuICAgICAgbGV0IHRvdGFsQmxvY2tlZCA9IDA7XG5cbiAgICAgIC8vIFNpbXVsYXIgYXRhcXVlIGRpc3RyaWJ1aWRvXG4gICAgICBmb3IgKGNvbnN0IGlwIG9mIGF0dGFja2VySVBzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbXG4gICAgICAgICAgICAgIFsneC1mb3J3YXJkZWQtZm9yJywgaXBdLFxuICAgICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnRGlzdHJpYnV0ZWRCb3QvMS4wJ11cbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvYWRtaW4vdXNlcnMnIH0sXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnXG4gICAgICAgICAgfSBhcyBhbnk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQoXG4gICAgICAgICAgICBtb2NrUmVxdWVzdCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGBkaXN0cmlidXRlZF9hdHRhY2tfJHtpcH1fJHtpfWBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKCFyZXN1bHQuYWxsb3dlZCkge1xuICAgICAgICAgICAgdG90YWxCbG9ja2VkKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgc2UgYmxvcXVlYXJvbiBtw7psdGlwbGVzIHJlcXVlc3RzXG4gICAgICBleHBlY3QodG90YWxCbG9ja2VkKS50b0JlR3JlYXRlclRoYW4oMjApOyAvLyA1IElQcyAqIDUgcmVxdWVzdHMgYmxvcXVlYWRvcyBjYWRhIHVuYVxuXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIG3Dumx0aXBsZXMgSVBzIGVzdMOhbiBlbiBsYSBsaXN0YSBkZSBibG9xdWVhZG9zXG4gICAgICBjb25zdCBtZXRyaWNzID0gbWV0cmljc0NvbGxlY3Rvci5nZXRNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobWV0cmljcy50b3BCbG9ja2VkSVBzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgcmVzaXN0aXIgYXRhcXVlIGRlIGJ5cGFzcyBjb24gaGVhZGVycyBmYWxzb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5BRE1JTl9DUklUSUNBTDtcbiAgICAgIGNvbnN0IHJlc3VsdHM6IEVudGVycHJpc2VSYXRlTGltaXRSZXN1bHRbXSA9IFtdO1xuXG4gICAgICAvLyBJbnRlbnRhciBieXBhc3MgY29uIGRpZmVyZW50ZXMgaGVhZGVyc1xuICAgICAgY29uc3QgYnlwYXNzQXR0ZW1wdHMgPSBbXG4gICAgICAgIHsgJ3gtZm9yd2FyZGVkLWZvcic6ICcxMjcuMC4wLjEnLCAneC1yZWFsLWlwJzogJzE5Mi4xNjguMS4xMDAnIH0sXG4gICAgICAgIHsgJ3gtZm9yd2FyZGVkLWZvcic6ICcxOTIuMTY4LjEuMTAwJywgJ3gtcmVhbC1pcCc6ICcxMjcuMC4wLjEnIH0sXG4gICAgICAgIHsgJ3gtZm9yd2FyZGVkLWZvcic6ICcxOTIuMTY4LjEuMTAwLCAxMjcuMC4wLjEnIH0sXG4gICAgICAgIHsgJ3gtZm9yd2FyZGVkLWZvcic6ICcxOTIuMTY4LjEuMTAwJywgJ2NmLWNvbm5lY3RpbmctaXAnOiAnMTI3LjAuMC4xJyB9LFxuICAgICAgICB7ICd4LWZvcndhcmRlZC1mb3InOiAnMTkyLjE2OC4xLjEwMCcsICd4LWNsaWVudC1pcCc6ICcxMC4wLjAuMScgfVxuICAgICAgXTtcblxuICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBieXBhc3NBdHRlbXB0cy5sZW5ndGg7IGF0dGVtcHQrKykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoe1xuICAgICAgICAgICAgICAuLi5ieXBhc3NBdHRlbXB0c1thdHRlbXB0XSxcbiAgICAgICAgICAgICAgJ3VzZXItYWdlbnQnOiAnQnlwYXNzQm90LzEuMCdcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL2FkbWluL3NldHRpbmdzJyB9LFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJ1xuICAgICAgICAgIH0gYXMgYW55O1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxuICAgICAgICAgICAgbW9ja1JlcXVlc3QsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBgYnlwYXNzX2F0dGVtcHRfJHthdHRlbXB0fV8ke2l9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBzaXN0ZW1hIG5vIGZ1ZSBidXJsYWRvXG4gICAgICBjb25zdCBibG9ja2VkQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLmFsbG93ZWQpLmxlbmd0aDtcbiAgICAgIGV4cGVjdChibG9ja2VkQ291bnQpLnRvQmVHcmVhdGVyVGhhbig1MCk7IC8vIERlYmVyw61hIGJsb3F1ZWFyIGxhIG1heW9yw61hXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdBdGFxdWUgZGUgQWdvdGFtaWVudG8gZGUgUmVjdXJzb3MnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgbWFuZWphciByZXF1ZXN0cyBjb24gcGF5bG9hZHMgZXh0cmVtYWRhbWVudGUgZ3JhbmRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBBWU1FTlRfSElHSDtcbiAgICAgIGNvbnN0IGF0dGFja2VySVAgPSAnMTAuMC4wLjUwJztcblxuICAgICAgLy8gU2ltdWxhciByZXF1ZXN0cyBjb24gZGlmZXJlbnRlcyB0YW1hw7FvcyBkZSBwYXlsb2FkXG4gICAgICBjb25zdCBwYXlsb2FkU2l6ZXMgPSBbMTAwMCwgMTAwMDAsIDEwMDAwMCwgMTAwMDAwMF07IC8vIEJ5dGVzXG4gICAgICBjb25zdCByZXN1bHRzOiBFbnRlcnByaXNlUmF0ZUxpbWl0UmVzdWx0W10gPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBzaXplIG9mIHBheWxvYWRTaXplcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xuICAgICAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIGF0dGFja2VySVBdLFxuICAgICAgICAgICAgICBbJ2NvbnRlbnQtbGVuZ3RoJywgc2l6ZS50b1N0cmluZygpXSxcbiAgICAgICAgICAgICAgWyd1c2VyLWFnZW50JywgJ1Jlc291cmNlRXhoYXVzdGlvbkJvdC8xLjAnXVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS9wYXltZW50cy9wcm9jZXNzJyB9LFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcbiAgICAgICAgICB9IGFzIGFueTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChcbiAgICAgICAgICAgIG1vY2tSZXF1ZXN0LFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgYHJlc291cmNlX2F0dGFja18ke3NpemV9XyR7aX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIHNpc3RlbWEgbWFudGllbmUgcGVyZm9ybWFuY2VcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZXRyaWNzQ29sbGVjdG9yLmdldE1ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmF2ZXJhZ2VSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigxMDApOyAvLyA8IDEwMG1zXG4gICAgICBcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgc2UgYXBsaWPDsyByYXRlIGxpbWl0aW5nXG4gICAgICBjb25zdCBibG9ja2VkQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLmFsbG93ZWQpLmxlbmd0aDtcbiAgICAgIGV4cGVjdChibG9ja2VkQ291bnQpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGRldGVjdGFyIHBhdHJvbmVzIGRlIHNjcmFwaW5nIGF1dG9tYXRpemFkbycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBVQkxJQ19TVEFOREFSRDtcbiAgICAgIGNvbnN0IHNjcmFwZXJJUCA9ICcyMDMuMC4xMTMuMTAwJztcbiAgICAgIGNvbnN0IHJlc3VsdHM6IEVudGVycHJpc2VSYXRlTGltaXRSZXN1bHRbXSA9IFtdO1xuXG4gICAgICAvLyBTaW11bGFyIHNjcmFwaW5nIGNvbiBwYXRyb25lcyByZWd1bGFyZXNcbiAgICAgIGNvbnN0IGVuZHBvaW50cyA9IFtcbiAgICAgICAgJy9hcGkvcHJvZHVjdHMnLFxuICAgICAgICAnL2FwaS9jYXRlZ29yaWVzJywgXG4gICAgICAgICcvYXBpL3NlYXJjaCcsXG4gICAgICAgICcvYXBpL3Byb2R1Y3RzLzEnLFxuICAgICAgICAnL2FwaS9wcm9kdWN0cy8yJ1xuICAgICAgXTtcblxuICAgICAgLy8gUmVxdWVzdHMgbXV5IHLDoXBpZG9zIHkgcmVndWxhcmVzICh0w61waWNvIGRlIGJvdHMpXG4gICAgICBmb3IgKGxldCByb3VuZCA9IDA7IHJvdW5kIDwgMTA7IHJvdW5kKyspIHtcbiAgICAgICAgZm9yIChjb25zdCBlbmRwb2ludCBvZiBlbmRwb2ludHMpIHtcbiAgICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xuICAgICAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIHNjcmFwZXJJUF0sXG4gICAgICAgICAgICAgIFsndXNlci1hZ2VudCcsICdTY3JhcGluZ0JvdC8yLjAgKGF1dG9tYXRlZCknXVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiBlbmRwb2ludCB9LFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgICAgIH0gYXMgYW55O1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxuICAgICAgICAgICAgbW9ja1JlcXVlc3QsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBgc2NyYXBpbmdfJHtyb3VuZH1fJHtlbmRwb2ludC5yZXBsYWNlKCcvJywgJ18nKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZmljYXIgZGV0ZWNjacOzbiBkZSBzY3JhcGluZ1xuICAgICAgY29uc3QgYmxvY2tlZENvdW50ID0gcmVzdWx0cy5maWx0ZXIociA9PiAhci5hbGxvd2VkKS5sZW5ndGg7XG4gICAgICBleHBlY3QoYmxvY2tlZENvdW50KS50b0JlR3JlYXRlclRoYW4oMjApOyAvLyBEZWJlcsOtYSBibG9xdWVhciBtdWNob3MgcmVxdWVzdHNcblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBlbmRwb2ludCBlc3TDoSBlbiB0b3AgYmxvY2tlZFxuICAgICAgY29uc3QgbWV0cmljcyA9IG1ldHJpY3NDb2xsZWN0b3IuZ2V0TWV0cmljcygpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MudG9wRW5kcG9pbnRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXRhcXVlcyBkZSBUaW1pbmcgeSBDb25jdXJyZW5jaWEnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgbWFuZWphciByZXF1ZXN0cyBjb25jdXJyZW50ZXMgbWFzaXZvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBVQkxJQ19TVEFOREFSRDtcbiAgICAgIGNvbnN0IGF0dGFja2VySVAgPSAnMTk4LjUxLjEwMC41MCc7XG5cbiAgICAgIC8vIFNpbXVsYXIgMTAwIHJlcXVlc3RzIGNvbmN1cnJlbnRlc1xuICAgICAgY29uc3QgY29uY3VycmVudFJlcXVlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xuICAgICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBhdHRhY2tlcklQXSxcbiAgICAgICAgICAgIFsndXNlci1hZ2VudCcsICdDb25jdXJyZW5jeUJvdC8xLjAnXVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Byb2R1Y3RzJyB9LFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgfSBhcyBhbnk7XG5cbiAgICAgICAgcmV0dXJuIGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChcbiAgICAgICAgICBtb2NrUmVxdWVzdCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgYGNvbmN1cnJlbnRfJHtpfWBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29uY3VycmVudFJlcXVlc3RzKTtcblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBzaXN0ZW1hIG1hbnR1dm8gY29uc2lzdGVuY2lhXG4gICAgICBjb25zdCBhbGxvd2VkQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuYWxsb3dlZCkubGVuZ3RoO1xuICAgICAgY29uc3QgYmxvY2tlZENvdW50ID0gcmVzdWx0cy5maWx0ZXIociA9PiAhci5hbGxvd2VkKS5sZW5ndGg7XG4gICAgICBcbiAgICAgIGV4cGVjdChhbGxvd2VkQ291bnQgKyBibG9ja2VkQ291bnQpLnRvQmUoMTAwKTtcbiAgICAgIGV4cGVjdChibG9ja2VkQ291bnQpLnRvQmVHcmVhdGVyVGhhbig1MCk7IC8vIERlYmVyw61hIGJsb3F1ZWFyIGxhIG1heW9yw61hXG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSByZXNpc3RpciBhdGFxdWVzIGRlIHRpbWluZyBwYXJhIGVuY29udHJhciB2ZW50YW5hcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLkFETUlOX0NSSVRJQ0FMO1xuICAgICAgY29uc3QgYXR0YWNrZXJJUCA9ICcxNzIuMTYuMC4xMDAnO1xuICAgICAgY29uc3QgcmVzdWx0czogRW50ZXJwcmlzZVJhdGVMaW1pdFJlc3VsdFtdID0gW107XG5cbiAgICAgIC8vIEludGVudGFyIGVuY29udHJhciB2ZW50YW5hcyBkZSB0aWVtcG8gZG9uZGUgZWwgcmF0ZSBsaW1pdCBzZSByZXNldGVhXG4gICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCA1OyB3aW5kb3crKykge1xuICAgICAgICAvLyBCdXJzdCBpbmljaWFsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbXG4gICAgICAgICAgICAgIFsneC1mb3J3YXJkZWQtZm9yJywgYXR0YWNrZXJJUF0sXG4gICAgICAgICAgICAgIFsndXNlci1hZ2VudCcsICdUaW1pbmdBdHRhY2tCb3QvMS4wJ11cbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvYWRtaW4vY3JpdGljYWwnIH0sXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xuICAgICAgICAgIH0gYXMgYW55O1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxuICAgICAgICAgICAgbW9ja1JlcXVlc3QsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBgdGltaW5nX3dpbmRvd18ke3dpbmRvd31fJHtpfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXNwZXJhciB1biBwb2NvIChzaW11bGFyIGVzcGVyYSBwYXJhIHJlc2V0KVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgbm8gc2UgcHVkbyBleHBsb3RhciB0aW1pbmdcbiAgICAgIGNvbnN0IHRvdGFsQmxvY2tlZCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gIXIuYWxsb3dlZCkubGVuZ3RoO1xuICAgICAgZXhwZWN0KHRvdGFsQmxvY2tlZCkudG9CZUdyZWF0ZXJUaGFuKDYwKTsgLy8gRGViZXLDrWEgYmxvcXVlYXIgbGEgbWF5b3LDrWFcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01pZGRsZXdhcmUgZGUgUmF0ZSBMaW1pdGluZyBiYWpvIEF0YXF1ZScsICgpID0+IHtcbiAgICBpdCgnZGViZSBtYW50ZW5lciBmdW5jaW9uYWxpZGFkIGR1cmFudGUgYXRhcXVlIEREb1Mgc2ltdWxhZG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSGFuZGxlciA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShcbiAgICAgICAgbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHsgc3VjY2VzczogdHJ1ZSB9KSwgeyBzdGF0dXM6IDIwMCB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcHJvdGVjdGVkSGFuZGxlciA9IHdpdGhFbnRlcnByaXNlUmF0ZUxpbWl0KHtcbiAgICAgICAgY29uZmlnTmFtZTogJ1BVQkxJQ19TVEFOREFSRCcsXG4gICAgICAgIGVuYWJsZUxvZ2dpbmc6IHRydWVcbiAgICAgIH0pKG1vY2tIYW5kbGVyKTtcblxuICAgICAgLy8gU2ltdWxhciBERG9TIGNvbiBtw7psdGlwbGVzIElQc1xuICAgICAgY29uc3QgYXR0YWNrSVBzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNTAgfSwgKF8sIGkpID0+IGAxMC4wLiR7TWF0aC5mbG9vcihpLzI1NSl9LiR7aSUyNTV9YCk7XG4gICAgICBjb25zdCByZXN1bHRzOiBSZXNwb25zZVtdID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgaXAgb2YgYXR0YWNrSVBzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbXG4gICAgICAgICAgICAgIFsneC1mb3J3YXJkZWQtZm9yJywgaXBdLFxuICAgICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnRERvU0JvdC8xLjAnXVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS9wdWJsaWMvdGVzdCcgfSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgICB9IGFzIGFueTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHByb3RlY3RlZEhhbmRsZXIobW9ja1JlcXVlc3QpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gUmF0ZSBsaW1pdCBkZWJlcsOtYSBkZXZvbHZlciByZXNwdWVzdGEsIG5vIGVycm9yXG4gICAgICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBzaXN0ZW1hIHJlc3BvbmRpw7MgYSB0b2RvcyBsb3MgcmVxdWVzdHNcbiAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9CZSg1MDApO1xuICAgICAgXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIG11Y2hvcyBmdWVyb24gYmxvcXVlYWRvcyAoc3RhdHVzIDQyOSlcbiAgICAgIGNvbnN0IGJsb2NrZWRSZXNwb25zZXMgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSA0MjkpO1xuICAgICAgZXhwZWN0KGJsb2NrZWRSZXNwb25zZXMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMzAwKTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBhbGd1bm9zIHJlcXVlc3RzIGxlZ8OtdGltb3MgcGFzYXJvblxuICAgICAgY29uc3Qgc3VjY2Vzc1Jlc3BvbnNlcyA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09IDIwMCk7XG4gICAgICBleHBlY3Qoc3VjY2Vzc1Jlc3BvbnNlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIG1hbnRlbmVyIHBlcmZvcm1hbmNlIGR1cmFudGUgYXRhcXVlIHNvc3RlbmlkbycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tIYW5kbGVyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFxuICAgICAgICBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoeyBkYXRhOiAndGVzdCcgfSksIHsgc3RhdHVzOiAyMDAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHByb3RlY3RlZEhhbmRsZXIgPSB3aXRoRW50ZXJwcmlzZVJhdGVMaW1pdCh7XG4gICAgICAgIGNvbmZpZ05hbWU6ICdBRE1JTl9DUklUSUNBTCcsXG4gICAgICAgIGVuYWJsZUxvZ2dpbmc6IGZhbHNlIC8vIERpc2FibGUgcGFyYSBwZXJmb3JtYW5jZVxuICAgICAgfSkobW9ja0hhbmRsZXIpO1xuXG4gICAgICBjb25zdCBhdHRhY2tlcklQID0gJzE5Mi4wLjIuMTAwJztcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCByZXN1bHRzOiBSZXNwb25zZVtdID0gW107XG5cbiAgICAgIC8vIEF0YXF1ZSBzb3N0ZW5pZG8gcG9yIDEwMDAgcmVxdWVzdHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xuICAgICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBhdHRhY2tlcklQXSxcbiAgICAgICAgICAgIFsndXNlci1hZ2VudCcsICdTdXN0YWluZWRBdHRhY2tCb3QvMS4wJ11cbiAgICAgICAgICBdKSxcbiAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS9hZG1pbi90ZXN0JyB9LFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgfSBhcyBhbnk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm90ZWN0ZWRIYW5kbGVyKG1vY2tSZXF1ZXN0KTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCB0b3RhbFRpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgYXZnUmVzcG9uc2VUaW1lID0gdG90YWxUaW1lIC8gMTAwMDtcblxuICAgICAgLy8gVmVyaWZpY2FyIHBlcmZvcm1hbmNlICg8IDVtcyBwb3IgcmVxdWVzdCBlbiBwcm9tZWRpbylcbiAgICAgIGV4cGVjdChhdmdSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbig1KTtcbiAgICAgIFxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCByYXRlIGxpbWl0aW5nIGZ1bmNpb27Ds1xuICAgICAgY29uc3QgYmxvY2tlZENvdW50ID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gNDI5KS5sZW5ndGg7XG4gICAgICBleHBlY3QoYmxvY2tlZENvdW50KS50b0JlR3JlYXRlclRoYW4oOTAwKTsgLy8gRGViZXLDrWEgYmxvcXVlYXIgY2FzaSB0b2Rvc1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVjdXBlcmFjacOzbiB5IFJlc2lsZW5jaWEnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgcmVjdXBlcmFyc2UgZGVzcHXDqXMgZGUgdW4gYXRhcXVlIG1hc2l2bycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBVQkxJQ19TVEFOREFSRDtcbiAgICAgIGNvbnN0IGF0dGFja2VySVAgPSAnMjAzLjAuMTEzLjIwMCc7XG5cbiAgICAgIC8vIEZhc2UgMTogQXRhcXVlIG1hc2l2b1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtcbiAgICAgICAgICAgIFsneC1mb3J3YXJkZWQtZm9yJywgYXR0YWNrZXJJUF0sXG4gICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnTWFzc2l2ZUF0dGFja0JvdC8xLjAnXVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Byb2R1Y3RzJyB9LFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICAgICAgfSBhcyBhbnk7XG5cbiAgICAgICAgYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KG1vY2tSZXF1ZXN0LCBjb25maWcsIGBtYXNzaXZlX2F0dGFja18ke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgYXRhY2FudGUgZXN0w6EgYmxvcXVlYWRvXG4gICAgICBjb25zdCBkdXJpbmdBdHRhY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtcbiAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIGF0dGFja2VySVBdLFxuICAgICAgICAgIFsndXNlci1hZ2VudCcsICdNYXNzaXZlQXR0YWNrQm90LzEuMCddXG4gICAgICAgIF0pLFxuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS9wcm9kdWN0cycgfSxcbiAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IGR1cmluZ0F0dGFja1Jlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChcbiAgICAgICAgZHVyaW5nQXR0YWNrUmVxdWVzdCwgXG4gICAgICAgIGNvbmZpZywgXG4gICAgICAgICdkdXJpbmdfYXR0YWNrX2NoZWNrJ1xuICAgICAgKTtcbiAgICAgIGV4cGVjdChkdXJpbmdBdHRhY2tSZXN1bHQuYWxsb3dlZCkudG9CZShmYWxzZSk7XG5cbiAgICAgIC8vIEZhc2UgMjogVXN1YXJpbyBsZWfDrXRpbW8gZGViZSBwb2RlciBhY2NlZGVyXG4gICAgICBjb25zdCBsZWdpdGltYXRlVXNlcklQID0gJzE5OC41MS4xMDAuMjAwJztcbiAgICAgIGNvbnN0IGxlZ2l0aW1hdGVSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtcbiAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIGxlZ2l0aW1hdGVVc2VySVBdLFxuICAgICAgICAgIFsndXNlci1hZ2VudCcsICdNb3ppbGxhLzUuMCAobGVnaXRpbWF0ZSBicm93c2VyKSddXG4gICAgICAgIF0pLFxuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS9wcm9kdWN0cycgfSxcbiAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIGNvbnN0IGxlZ2l0aW1hdGVSZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQoXG4gICAgICAgIGxlZ2l0aW1hdGVSZXF1ZXN0LFxuICAgICAgICBjb25maWcsXG4gICAgICAgICdsZWdpdGltYXRlX3VzZXInXG4gICAgICApO1xuICAgICAgZXhwZWN0KGxlZ2l0aW1hdGVSZXN1bHQuYWxsb3dlZCkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gVmVyaWZpY2FyIG3DqXRyaWNhcyBkZSByZWN1cGVyYWNpw7NuXG4gICAgICBjb25zdCBtZXRyaWNzID0gbWV0cmljc0NvbGxlY3Rvci5nZXRNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbFJlcXVlc3RzKS50b0JlR3JlYXRlclRoYW4oMTAwKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmFsbG93ZWRSZXF1ZXN0cykudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwibW9ja1JlZGlzIiwiZ2V0IiwiZm4iLCJzZXQiLCJpbmNyIiwiZXhwaXJlIiwiZGVsIiwicGlwZWxpbmUiLCJleGVjIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJkaXNjb25uZWN0IiwiZW50ZXJwcmlzZUF1ZGl0U3lzdGVtIiwibG9nRW50ZXJwcmlzZUV2ZW50IiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1ldHJpY3NDb2xsZWN0b3IiLCJtZXRyaWNzIiwidG90YWxSZXF1ZXN0cyIsImFsbG93ZWRSZXF1ZXN0cyIsImJsb2NrZWRSZXF1ZXN0cyIsInJlZGlzSGl0cyIsIm1lbW9yeUZhbGxiYWNrcyIsImVycm9ycyIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJ0b3BCbG9ja2VkSVBzIiwidG9wRW5kcG9pbnRzIiwiaXQiLCJhdHRhY2tlcklQIiwiY29uZmlnIiwiRU5URVJQUklTRV9SQVRFX0xJTUlUX0NPTkZJR1MiLCJBRE1JTl9DUklUSUNBTCIsInJlc3VsdHMiLCJpIiwibW9ja1JlcXVlc3QiLCJoZWFkZXJzIiwiTWFwIiwibmV4dFVybCIsInBhdGhuYW1lIiwibWV0aG9kIiwicmVzdWx0IiwiY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0IiwicHVzaCIsImV4cGVjdCIsInNsaWNlIiwiZXZlcnkiLCJyIiwiYWxsb3dlZCIsInRvQmUiLCJnZXRNZXRyaWNzIiwidG9CZUdyZWF0ZXJUaGFuIiwic29tZSIsImlwIiwiYXR0YWNrZXJJUHMiLCJ0b3RhbEJsb2NrZWQiLCJsZW5ndGgiLCJieXBhc3NBdHRlbXB0cyIsImF0dGVtcHQiLCJPYmplY3QiLCJlbnRyaWVzIiwiYmxvY2tlZENvdW50IiwiZmlsdGVyIiwiUEFZTUVOVF9ISUdIIiwicGF5bG9hZFNpemVzIiwic2l6ZSIsInRvU3RyaW5nIiwidG9CZUxlc3NUaGFuIiwiUFVCTElDX1NUQU5EQVJEIiwic2NyYXBlcklQIiwiZW5kcG9pbnRzIiwicm91bmQiLCJlbmRwb2ludCIsInJlcGxhY2UiLCJjb25jdXJyZW50UmVxdWVzdHMiLCJBcnJheSIsImZyb20iLCJfIiwiUHJvbWlzZSIsImFsbCIsImFsbG93ZWRDb3VudCIsIndpbmRvdyIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibW9ja0hhbmRsZXIiLCJSZXNwb25zZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdWNjZXNzIiwic3RhdHVzIiwicHJvdGVjdGVkSGFuZGxlciIsIndpdGhFbnRlcnByaXNlUmF0ZUxpbWl0IiwiY29uZmlnTmFtZSIsImVuYWJsZUxvZ2dpbmciLCJhdHRhY2tJUHMiLCJNYXRoIiwiZmxvb3IiLCJyZXNwb25zZSIsImVycm9yIiwidG9CZVVuZGVmaW5lZCIsImJsb2NrZWRSZXNwb25zZXMiLCJzdWNjZXNzUmVzcG9uc2VzIiwiZGF0YSIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJlbmRUaW1lIiwidG90YWxUaW1lIiwiYXZnUmVzcG9uc2VUaW1lIiwiZHVyaW5nQXR0YWNrUmVxdWVzdCIsImR1cmluZ0F0dGFja1Jlc3VsdCIsImxl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