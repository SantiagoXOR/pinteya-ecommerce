f4a16d160126e7e52f763510f4634c85
/**
 * Test independiente para useProductList sin dependencias de configuración global
 * Ejecutar con: npx jest src/hooks/admin/__tests__/useProductList.standalone.test.ts --no-cache --no-coverage
 */ // Mock React hooks
"use strict";
jest.mock('react', ()=>({
        useState: mockUseState,
        useEffect: mockUseEffect
    }));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockUseState = jest.fn();
const mockUseEffect = jest.fn();
// Mock fetch
global.fetch = jest.fn();
describe('useProductList Hook - Standalone Tests', ()=>{
    let mockSetProducts;
    let mockSetIsLoading;
    let mockSetError;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock useState calls
        mockSetProducts = jest.fn();
        mockSetIsLoading = jest.fn();
        mockSetError = jest.fn();
        mockUseState.mockReturnValueOnce([
            [],
            mockSetProducts
        ]) // products state
        .mockReturnValueOnce([
            true,
            mockSetIsLoading
        ]) // isLoading state
        .mockReturnValueOnce([
            null,
            mockSetError
        ]); // error state
        // Mock useEffect to immediately call the effect
        mockUseEffect.mockImplementation((effect)=>{
            effect();
        });
    });
    afterEach(()=>{
        jest.restoreAllMocks();
    });
    it('should initialize with correct default state', async ()=>{
        // Mock successful API response
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: [],
                        total: 0
                    }
                })
        });
        // Import and execute the hook
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        const result = useProductList();
        // Verify initial state setup
        expect(mockUseState).toHaveBeenCalledTimes(3);
        expect(mockUseState).toHaveBeenNthCalledWith(1, []); // products
        expect(mockUseState).toHaveBeenNthCalledWith(2, true); // isLoading
        expect(mockUseState).toHaveBeenNthCalledWith(3, null); // error
        // Verify return value structure
        expect(result).toEqual({
            products: [],
            isLoading: true,
            error: null
        });
    });
    it('should call fetch with correct URL', async ()=>{
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: [],
                        total: 0
                    }
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        expect(global.fetch).toHaveBeenCalledWith('/api/admin/products-direct?limit=25');
    });
    it('should handle successful API response', async ()=>{
        const mockProducts = [
            {
                id: 1,
                name: 'Test Product',
                description: 'Test Description',
                price: 1000,
                stock: 50,
                category_id: 1,
                images: {
                    main: '/test.jpg',
                    gallery: [],
                    previews: [],
                    thumbnails: []
                },
                created_at: '2025-01-01T00:00:00Z',
                updated_at: '2025-01-01T00:00:00Z',
                category_name: 'Test Category'
            }
        ];
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: mockProducts,
                        total: 1
                    }
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetIsLoading).toHaveBeenCalledWith(true);
        expect(mockSetError).toHaveBeenCalledWith(null);
        expect(mockSetProducts).toHaveBeenCalledWith(mockProducts);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle API errors', async ()=>{
        global.fetch.mockResolvedValueOnce({
            ok: false,
            status: 500,
            statusText: 'Internal Server Error'
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Error 500: Internal Server Error');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle network errors', async ()=>{
        global.fetch.mockRejectedValueOnce(new Error('Network error'));
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Network error');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle invalid response structure', async ()=>{
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: false,
                    error: 'Invalid request'
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Estructura de respuesta inválida');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should export correct TypeScript types', async ()=>{
        const module = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        expect(typeof module.useProductList).toBe('function');
        expect(module.Product).toBeDefined;
        expect(module.ProductListResponse).toBeDefined;
    });
    it('should follow React Hooks best practices', async ()=>{
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        // Hook should be a function
        expect(typeof useProductList).toBe('function');
        // Hook name should start with 'use'
        expect(useProductList.name).toBe('useProductList');
        // useEffect should be called with empty dependency array
        expect(mockUseEffect).toHaveBeenCalledWith(expect.any(Function), []);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcaG9va3NcXGFkbWluXFxfX3Rlc3RzX19cXHVzZVByb2R1Y3RMaXN0LnN0YW5kYWxvbmUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3QgaW5kZXBlbmRpZW50ZSBwYXJhIHVzZVByb2R1Y3RMaXN0IHNpbiBkZXBlbmRlbmNpYXMgZGUgY29uZmlndXJhY2nDs24gZ2xvYmFsXG4gKiBFamVjdXRhciBjb246IG5weCBqZXN0IHNyYy9ob29rcy9hZG1pbi9fX3Rlc3RzX18vdXNlUHJvZHVjdExpc3Quc3RhbmRhbG9uZS50ZXN0LnRzIC0tbm8tY2FjaGUgLS1uby1jb3ZlcmFnZVxuICovXG5cbi8vIE1vY2sgUmVhY3QgaG9va3NcbmNvbnN0IG1vY2tVc2VTdGF0ZSA9IGplc3QuZm4oKTtcbmNvbnN0IG1vY2tVc2VFZmZlY3QgPSBqZXN0LmZuKCk7XG5cbmplc3QubW9jaygncmVhY3QnLCAoKSA9PiAoe1xuICB1c2VTdGF0ZTogbW9ja1VzZVN0YXRlLFxuICB1c2VFZmZlY3Q6IG1vY2tVc2VFZmZlY3Rcbn0pKTtcblxuLy8gTW9jayBmZXRjaFxuZ2xvYmFsLmZldGNoID0gamVzdC5mbigpO1xuXG5kZXNjcmliZSgndXNlUHJvZHVjdExpc3QgSG9vayAtIFN0YW5kYWxvbmUgVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBtb2NrU2V0UHJvZHVjdHM6IGplc3QuTW9jaztcbiAgbGV0IG1vY2tTZXRJc0xvYWRpbmc6IGplc3QuTW9jaztcbiAgbGV0IG1vY2tTZXRFcnJvcjogamVzdC5Nb2NrO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIE1vY2sgdXNlU3RhdGUgY2FsbHNcbiAgICBtb2NrU2V0UHJvZHVjdHMgPSBqZXN0LmZuKCk7XG4gICAgbW9ja1NldElzTG9hZGluZyA9IGplc3QuZm4oKTtcbiAgICBtb2NrU2V0RXJyb3IgPSBqZXN0LmZuKCk7XG4gICAgXG4gICAgbW9ja1VzZVN0YXRlXG4gICAgICAubW9ja1JldHVyblZhbHVlT25jZShbW10sIG1vY2tTZXRQcm9kdWN0c10pIC8vIHByb2R1Y3RzIHN0YXRlXG4gICAgICAubW9ja1JldHVyblZhbHVlT25jZShbdHJ1ZSwgbW9ja1NldElzTG9hZGluZ10pIC8vIGlzTG9hZGluZyBzdGF0ZVxuICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoW251bGwsIG1vY2tTZXRFcnJvcl0pOyAvLyBlcnJvciBzdGF0ZVxuICAgIFxuICAgIC8vIE1vY2sgdXNlRWZmZWN0IHRvIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGVmZmVjdFxuICAgIG1vY2tVc2VFZmZlY3QubW9ja0ltcGxlbWVudGF0aW9uKChlZmZlY3QpID0+IHtcbiAgICAgIGVmZmVjdCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIGNvcnJlY3QgZGVmYXVsdCBzdGF0ZScsIGFzeW5jICgpID0+IHtcbiAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgQVBJIHJlc3BvbnNlXG4gICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIGpzb246IGFzeW5jICgpID0+ICh7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBwcm9kdWN0czogW10sXG4gICAgICAgICAgdG90YWw6IDBcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIC8vIEltcG9ydCBhbmQgZXhlY3V0ZSB0aGUgaG9va1xuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKTtcbiAgICBjb25zdCByZXN1bHQgPSB1c2VQcm9kdWN0TGlzdCgpO1xuXG4gICAgLy8gVmVyaWZ5IGluaXRpYWwgc3RhdGUgc2V0dXBcbiAgICBleHBlY3QobW9ja1VzZVN0YXRlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgZXhwZWN0KG1vY2tVc2VTdGF0ZSkudG9IYXZlQmVlbk50aENhbGxlZFdpdGgoMSwgW10pOyAvLyBwcm9kdWN0c1xuICAgIGV4cGVjdChtb2NrVXNlU3RhdGUpLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKDIsIHRydWUpOyAvLyBpc0xvYWRpbmdcbiAgICBleHBlY3QobW9ja1VzZVN0YXRlKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aCgzLCBudWxsKTsgLy8gZXJyb3JcblxuICAgIC8vIFZlcmlmeSByZXR1cm4gdmFsdWUgc3RydWN0dXJlXG4gICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICBwcm9kdWN0czogW10sXG4gICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH0pO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGNhbGwgZmV0Y2ggd2l0aCBjb3JyZWN0IFVSTCcsIGFzeW5jICgpID0+IHtcbiAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHByb2R1Y3RzOiBbXSxcbiAgICAgICAgICB0b3RhbDogMFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VQcm9kdWN0TGlzdCB9ID0gYXdhaXQgaW1wb3J0KCcuLi91c2VQcm9kdWN0TGlzdCcpO1xuICAgIHVzZVByb2R1Y3RMaXN0KCk7XG5cbiAgICBleHBlY3QoZ2xvYmFsLmZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9hZG1pbi9wcm9kdWN0cy1kaXJlY3Q/bGltaXQ9MjUnKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgc3VjY2Vzc2Z1bCBBUEkgcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1Byb2R1Y3RzID0gW1xuICAgICAge1xuICAgICAgICBpZDogMSxcbiAgICAgICAgbmFtZTogJ1Rlc3QgUHJvZHVjdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBEZXNjcmlwdGlvbicsXG4gICAgICAgIHByaWNlOiAxMDAwLFxuICAgICAgICBzdG9jazogNTAsXG4gICAgICAgIGNhdGVnb3J5X2lkOiAxLFxuICAgICAgICBpbWFnZXM6IHsgbWFpbjogJy90ZXN0LmpwZycsIGdhbGxlcnk6IFtdLCBwcmV2aWV3czogW10sIHRodW1ibmFpbHM6IFtdIH0sXG4gICAgICAgIGNyZWF0ZWRfYXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIGNhdGVnb3J5X25hbWU6ICdUZXN0IENhdGVnb3J5J1xuICAgICAgfVxuICAgIF07XG5cbiAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHByb2R1Y3RzOiBtb2NrUHJvZHVjdHMsXG4gICAgICAgICAgdG90YWw6IDFcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKTtcbiAgICB1c2VQcm9kdWN0TGlzdCgpO1xuXG4gICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG5cbiAgICBleHBlY3QobW9ja1NldElzTG9hZGluZykudG9IYXZlQmVlbkNhbGxlZFdpdGgodHJ1ZSk7XG4gICAgZXhwZWN0KG1vY2tTZXRFcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgobnVsbCk7XG4gICAgZXhwZWN0KG1vY2tTZXRQcm9kdWN0cykudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1Byb2R1Y3RzKTtcbiAgICBleHBlY3QobW9ja1NldElzTG9hZGluZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmFsc2UpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBBUEkgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IGZhbHNlLFxuICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICBzdGF0dXNUZXh0OiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJ1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VQcm9kdWN0TGlzdCB9ID0gYXdhaXQgaW1wb3J0KCcuLi91c2VQcm9kdWN0TGlzdCcpO1xuICAgIHVzZVByb2R1Y3RMaXN0KCk7XG5cbiAgICAvLyBXYWl0IGZvciBhc3luYyBvcGVyYXRpb25zXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcblxuICAgIGV4cGVjdChtb2NrU2V0RXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdFcnJvciA1MDA6IEludGVybmFsIFNlcnZlciBFcnJvcicpO1xuICAgIGV4cGVjdChtb2NrU2V0UHJvZHVjdHMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFtdKTtcbiAgICBleHBlY3QobW9ja1NldElzTG9hZGluZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmFsc2UpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcblxuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKTtcbiAgICB1c2VQcm9kdWN0TGlzdCgpO1xuXG4gICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG5cbiAgICBleHBlY3QobW9ja1NldEVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnTmV0d29yayBlcnJvcicpO1xuICAgIGV4cGVjdChtb2NrU2V0UHJvZHVjdHMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFtdKTtcbiAgICBleHBlY3QobW9ja1NldElzTG9hZGluZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmFsc2UpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnSW52YWxpZCByZXF1ZXN0J1xuICAgICAgfSlcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKTtcbiAgICB1c2VQcm9kdWN0TGlzdCgpO1xuXG4gICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG5cbiAgICBleHBlY3QobW9ja1NldEVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXN0cnVjdHVyYSBkZSByZXNwdWVzdGEgaW52w6FsaWRhJyk7XG4gICAgZXhwZWN0KG1vY2tTZXRQcm9kdWN0cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoW10pO1xuICAgIGV4cGVjdChtb2NrU2V0SXNMb2FkaW5nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmYWxzZSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgZXhwb3J0IGNvcnJlY3QgVHlwZVNjcmlwdCB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0Jyk7XG4gICAgXG4gICAgZXhwZWN0KHR5cGVvZiBtb2R1bGUudXNlUHJvZHVjdExpc3QpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgZXhwZWN0KG1vZHVsZS5Qcm9kdWN0KS50b0JlRGVmaW5lZDtcbiAgICBleHBlY3QobW9kdWxlLlByb2R1Y3RMaXN0UmVzcG9uc2UpLnRvQmVEZWZpbmVkO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGZvbGxvdyBSZWFjdCBIb29rcyBiZXN0IHByYWN0aWNlcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHVzZVByb2R1Y3RMaXN0IH0gPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0Jyk7XG4gICAgXG4gICAgLy8gSG9vayBzaG91bGQgYmUgYSBmdW5jdGlvblxuICAgIGV4cGVjdCh0eXBlb2YgdXNlUHJvZHVjdExpc3QpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgXG4gICAgLy8gSG9vayBuYW1lIHNob3VsZCBzdGFydCB3aXRoICd1c2UnXG4gICAgZXhwZWN0KHVzZVByb2R1Y3RMaXN0Lm5hbWUpLnRvQmUoJ3VzZVByb2R1Y3RMaXN0Jyk7XG4gICAgXG4gICAgLy8gdXNlRWZmZWN0IHNob3VsZCBiZSBjYWxsZWQgd2l0aCBlbXB0eSBkZXBlbmRlbmN5IGFycmF5XG4gICAgZXhwZWN0KG1vY2tVc2VFZmZlY3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5hbnkoRnVuY3Rpb24pLCBbXSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJ1c2VTdGF0ZSIsIm1vY2tVc2VTdGF0ZSIsInVzZUVmZmVjdCIsIm1vY2tVc2VFZmZlY3QiLCJmbiIsImdsb2JhbCIsImZldGNoIiwiZGVzY3JpYmUiLCJtb2NrU2V0UHJvZHVjdHMiLCJtb2NrU2V0SXNMb2FkaW5nIiwibW9ja1NldEVycm9yIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZWZmZWN0IiwiYWZ0ZXJFYWNoIiwicmVzdG9yZUFsbE1vY2tzIiwiaXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJzdWNjZXNzIiwiZGF0YSIsInByb2R1Y3RzIiwidG90YWwiLCJ1c2VQcm9kdWN0TGlzdCIsInJlc3VsdCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoIiwidG9FcXVhbCIsImlzTG9hZGluZyIsImVycm9yIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJtb2NrUHJvZHVjdHMiLCJpZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInByaWNlIiwic3RvY2siLCJjYXRlZ29yeV9pZCIsImltYWdlcyIsIm1haW4iLCJnYWxsZXJ5IiwicHJldmlld3MiLCJ0aHVtYm5haWxzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJjYXRlZ29yeV9uYW1lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwibW9kdWxlIiwidG9CZSIsIlByb2R1Y3QiLCJ0b0JlRGVmaW5lZCIsIlByb2R1Y3RMaXN0UmVzcG9uc2UiLCJhbnkiLCJGdW5jdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQsbUJBQW1COztBQUluQkEsS0FBS0MsSUFBSSxDQUFDLFNBQVMsSUFBTyxDQUFBO1FBQ3hCQyxVQUFVQztRQUNWQyxXQUFXQztJQUNiLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU5BLE1BQU1GLGVBQWVILEtBQUtNLEVBQUU7QUFDNUIsTUFBTUQsZ0JBQWdCTCxLQUFLTSxFQUFFO0FBTzdCLGFBQWE7QUFDYkMsT0FBT0MsS0FBSyxHQUFHUixLQUFLTSxFQUFFO0FBRXRCRyxTQUFTLDBDQUEwQztJQUNqRCxJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSkMsV0FBVztRQUNUYixLQUFLYyxhQUFhO1FBRWxCLHNCQUFzQjtRQUN0Qkosa0JBQWtCVixLQUFLTSxFQUFFO1FBQ3pCSyxtQkFBbUJYLEtBQUtNLEVBQUU7UUFDMUJNLGVBQWVaLEtBQUtNLEVBQUU7UUFFdEJILGFBQ0dZLG1CQUFtQixDQUFDO1lBQUMsRUFBRTtZQUFFTDtTQUFnQixFQUFFLGlCQUFpQjtTQUM1REssbUJBQW1CLENBQUM7WUFBQztZQUFNSjtTQUFpQixFQUFFLGtCQUFrQjtTQUNoRUksbUJBQW1CLENBQUM7WUFBQztZQUFNSDtTQUFhLEdBQUcsY0FBYztRQUU1RCxnREFBZ0Q7UUFDaERQLGNBQWNXLGtCQUFrQixDQUFDLENBQUNDO1lBQ2hDQTtRQUNGO0lBQ0Y7SUFFQUMsVUFBVTtRQUNSbEIsS0FBS21CLGVBQWU7SUFDdEI7SUFFQUMsR0FBRyxnREFBZ0Q7UUFDakQsK0JBQStCO1FBQzlCYixPQUFPQyxLQUFLLENBQWVhLHFCQUFxQixDQUFDO1lBQ2hEQyxJQUFJO1lBQ0pDLE1BQU0sVUFBYSxDQUFBO29CQUNqQkMsU0FBUztvQkFDVEMsTUFBTTt3QkFDSkMsVUFBVSxFQUFFO3dCQUNaQyxPQUFPO29CQUNU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