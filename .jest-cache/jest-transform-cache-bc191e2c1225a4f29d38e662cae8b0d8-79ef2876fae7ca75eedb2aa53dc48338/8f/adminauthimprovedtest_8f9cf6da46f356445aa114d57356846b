352c433794125dc7fb799d22cc5123b1
/**
 * Tests para las funciones de autenticación mejoradas con Clerk
 * Verifica las nuevas funciones getAuth(req) y compatibilidad
 */ "use strict";
// Mock de Clerk
jest.mock('@clerk/nextjs/server', ()=>({
        getAuth: jest.fn(),
        auth: jest.fn(),
        currentUser: jest.fn()
    }));
// Mock de Supabase
jest.mock('@/lib/supabase', ()=>({
        supabaseAdmin: {
            from: jest.fn(()=>({
                    select: jest.fn(()=>({
                            eq: jest.fn(()=>({
                                    single: jest.fn()
                                }))
                        }))
                }))
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _adminauth = require("../lib/auth/admin-auth");
const _server = require("@clerk/nextjs/server");
describe('Funciones de Autenticación Mejoradas', ()=>{
    let mockGetAuth;
    let mockAuth;
    beforeEach(()=>{
        mockGetAuth = _server.getAuth;
        mockAuth = _server.auth;
        jest.clearAllMocks();
    });
    describe('getAuthenticatedUser (mejorada)', ()=>{
        it('debe usar getAuth para NextApiRequest', async ()=>{
            const mockApiRequest = {
                query: {},
                headers: {},
                cookies: {}
            };
            mockGetAuth.mockReturnValue({
                userId: 'user_123',
                sessionId: 'session_456',
                getToken: jest.fn()
            });
            const result = await (0, _adminauth.getAuthenticatedUser)(mockApiRequest);
            expect(mockGetAuth).toHaveBeenCalledWith(mockApiRequest);
            expect(result).toEqual({
                userId: 'user_123',
                sessionId: 'session_456'
            });
        });
        it('debe usar auth() para NextRequest', async ()=>{
            const mockNextRequest = {
                nextUrl: {
                    pathname: '/test'
                },
                headers: new Map(),
                cookies: new Map()
            };
            mockAuth.mockResolvedValue({
                userId: 'user_789',
                sessionId: 'session_abc',
                getToken: jest.fn()
            });
            const result = await (0, _adminauth.getAuthenticatedUser)(mockNextRequest);
            expect(mockAuth).toHaveBeenCalled();
            expect(result).toEqual({
                userId: 'user_789',
                sessionId: 'session_abc'
            });
        });
        it('debe usar fallback a headers cuando getAuth falla', async ()=>{
            const mockRequest = {
                headers: {
                    get: jest.fn().mockReturnValue('user_fallback')
                }
            };
            mockAuth.mockRejectedValue(new Error('Auth failed'));
            const result = await (0, _adminauth.getAuthenticatedUser)(mockRequest);
            expect(result.userId).toBe('user_fallback');
        });
        it('debe retornar error cuando no hay autenticación', async ()=>{
            const mockRequest = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                }
            };
            mockAuth.mockRejectedValue(new Error('Auth failed'));
            const result = await (0, _adminauth.getAuthenticatedUser)(mockRequest);
            expect(result.userId).toBeNull();
            expect(result.error).toBe('No autorizado');
        });
    });
    describe('getAuthFromApiRoute', ()=>{
        it('debe usar getAuth correctamente para API Routes', ()=>{
            const mockReq = {
                query: {},
                headers: {}
            };
            const mockRes = {};
            mockGetAuth.mockReturnValue({
                userId: 'api_user_123',
                sessionId: 'api_session_456',
                getToken: jest.fn()
            });
            const result = (0, _adminauth.getAuthFromApiRoute)(mockReq, mockRes);
            expect(mockGetAuth).toHaveBeenCalledWith(mockReq);
            expect(result.userId).toBe('api_user_123');
            expect(result.sessionId).toBe('api_session_456');
        });
        it('debe lanzar error cuando no hay userId', ()=>{
            const mockReq = {
                query: {},
                headers: {}
            };
            const mockRes = {};
            mockGetAuth.mockReturnValue({
                userId: null,
                sessionId: null,
                getToken: jest.fn()
            });
            expect(()=>(0, _adminauth.getAuthFromApiRoute)(mockReq, mockRes)).toThrow('Usuario no autenticado');
        });
    });
    describe('getAuthFromRouteHandler', ()=>{
        it('debe usar auth() correctamente para Route Handlers', async ()=>{
            mockAuth.mockResolvedValue({
                userId: 'route_user_123',
                sessionId: 'route_session_456',
                getToken: jest.fn()
            });
            const result = await (0, _adminauth.getAuthFromRouteHandler)();
            expect(mockAuth).toHaveBeenCalled();
            expect(result.userId).toBe('route_user_123');
            expect(result.sessionId).toBe('route_session_456');
        });
        it('debe lanzar error cuando no hay userId', async ()=>{
            mockAuth.mockResolvedValue({
                userId: null,
                sessionId: null,
                getToken: jest.fn()
            });
            await expect((0, _adminauth.getAuthFromRouteHandler)()).rejects.toThrow('Usuario no autenticado');
        });
    });
    describe('getUnifiedAuth', ()=>{
        it('debe detectar NextApiRequest y usar getAuth', async ()=>{
            const mockApiRequest = {
                query: {},
                headers: {}
            };
            mockGetAuth.mockReturnValue({
                userId: 'unified_user_123',
                sessionId: 'unified_session_456',
                getToken: jest.fn()
            });
            const result = await (0, _adminauth.getUnifiedAuth)(mockApiRequest);
            expect(mockGetAuth).toHaveBeenCalledWith(mockApiRequest);
            expect(result.userId).toBe('unified_user_123');
        });
        it('debe detectar NextRequest y usar auth()', async ()=>{
            const mockNextRequest = {
                nextUrl: {
                    pathname: '/test'
                },
                headers: new Map()
            };
            mockAuth.mockResolvedValue({
                userId: 'unified_route_123',
                sessionId: 'unified_route_456',
                getToken: jest.fn()
            });
            const result = await (0, _adminauth.getUnifiedAuth)(mockNextRequest);
            expect(mockAuth).toHaveBeenCalled();
            expect(result.userId).toBe('unified_route_123');
        });
        it('debe usar fallback cuando hay error', async ()=>{
            const mockRequest = {
                headers: {
                    get: jest.fn().mockReturnValue('fallback_user')
                }
            };
            mockAuth.mockRejectedValue(new Error('Unified auth failed'));
            const result = await (0, _adminauth.getUnifiedAuth)(mockRequest);
            expect(result.userId).toBe('fallback_user');
        });
    });
    describe('withAdminAuthPages wrapper', ()=>{
        it('debe crear wrapper funcional para Pages Router', ()=>{
            const mockHandler = jest.fn();
            const wrappedHandler = (0, _adminauth.withAdminAuthPages)(mockHandler);
            expect(typeof wrappedHandler).toBe('function');
        });
        it('debe pasar contexto correcto al handler', async ()=>{
            const mockHandler = jest.fn();
            const mockReq = {
                query: {},
                headers: {}
            };
            const mockRes = {
                status: jest.fn().mockReturnThis(),
                json: jest.fn()
            };
            // Mock successful auth
            mockGetAuth.mockReturnValue({
                userId: 'admin_user',
                sessionId: 'admin_session',
                getToken: jest.fn()
            });
            const wrappedHandler = (0, _adminauth.withAdminAuthPages)(mockHandler);
            // Este test verificaría la estructura, pero requiere mocks más complejos
            // para el sistema completo de permisos
            expect(typeof wrappedHandler).toBe('function');
        });
    });
    describe('Compatibilidad hacia atrás', ()=>{
        it('debe mantener compatibilidad con headers x-clerk-user-id', async ()=>{
            const mockRequest = {
                headers: {
                    get: jest.fn().mockImplementation((key)=>{
                        if (key === 'x-clerk-user-id') return 'legacy_user_123';
                        return null;
                    })
                }
            };
            mockAuth.mockRejectedValue(new Error('Auth not available'));
            const result = await (0, _adminauth.getAuthenticatedUser)(mockRequest);
            expect(result.userId).toBe('legacy_user_123');
        });
        it('debe mantener compatibilidad con JWT en cookies', async ()=>{
            const mockJwtPayload = {
                sub: 'jwt_user_123'
            };
            const mockJwt = 'header.' + btoa(JSON.stringify(mockJwtPayload)) + '.signature';
            const mockRequest = {
                headers: {
                    get: jest.fn().mockReturnValue(null)
                },
                cookies: {
                    get: jest.fn().mockImplementation((key)=>{
                        if (key === '__session') return {
                            value: mockJwt
                        };
                        return undefined;
                    })
                }
            };
            mockAuth.mockRejectedValue(new Error('Auth not available'));
            const result = await (0, _adminauth.getAuthenticatedUser)(mockRequest);
            expect(result.userId).toBe('jwt_user_123');
        });
    });
    describe('Logging y debugging', ()=>{
        it('debe loggear autenticación exitosa', async ()=>{
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            const mockApiRequest = {
                query: {},
                headers: {}
            };
            mockGetAuth.mockReturnValue({
                userId: 'logged_user_123',
                sessionId: 'logged_session_456',
                getToken: jest.fn()
            });
            await (0, _adminauth.getAuthenticatedUser)(mockApiRequest);
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('[AUTH] Usuario autenticado via getAuth: logged_user_123'));
            consoleSpy.mockRestore();
        });
        it('debe loggear warnings para fallbacks', async ()=>{
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            const mockRequest = {
                headers: {
                    get: jest.fn().mockReturnValue('fallback_user')
                }
            };
            mockAuth.mockRejectedValue(new Error('Auth failed'));
            await (0, _adminauth.getAuthenticatedUser)(mockRequest);
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('[AUTH] Usando header fallback para userId'));
            consoleSpy.mockRestore();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxhZG1pbi1hdXRoLWltcHJvdmVkLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0cyBwYXJhIGxhcyBmdW5jaW9uZXMgZGUgYXV0ZW50aWNhY2nDs24gbWVqb3JhZGFzIGNvbiBDbGVya1xuICogVmVyaWZpY2EgbGFzIG51ZXZhcyBmdW5jaW9uZXMgZ2V0QXV0aChyZXEpIHkgY29tcGF0aWJpbGlkYWRcbiAqL1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB0eXBlIHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnO1xuXG4vLyBNb2NrIGRlIENsZXJrXG5qZXN0Lm1vY2soJ0BjbGVyay9uZXh0anMvc2VydmVyJywgKCkgPT4gKHtcbiAgZ2V0QXV0aDogamVzdC5mbigpLFxuICBhdXRoOiBqZXN0LmZuKCksXG4gIGN1cnJlbnRVc2VyOiBqZXN0LmZuKClcbn0pKTtcblxuLy8gTW9jayBkZSBTdXBhYmFzZVxuamVzdC5tb2NrKCdAL2xpYi9zdXBhYmFzZScsICgpID0+ICh7XG4gIHN1cGFiYXNlQWRtaW46IHtcbiAgICBmcm9tOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgZXE6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBzaW5nbGU6IGplc3QuZm4oKVxuICAgICAgICB9KSlcbiAgICAgIH0pKVxuICAgIH0pKVxuICB9XG59KSk7XG5cbmltcG9ydCB7IFxuICBnZXRBdXRoZW50aWNhdGVkVXNlciwgXG4gIGdldEF1dGhGcm9tQXBpUm91dGUsIFxuICBnZXRBdXRoRnJvbVJvdXRlSGFuZGxlcixcbiAgZ2V0VW5pZmllZEF1dGgsXG4gIHdpdGhBZG1pbkF1dGhQYWdlc1xufSBmcm9tICdAL2xpYi9hdXRoL2FkbWluLWF1dGgnO1xuaW1wb3J0IHsgZ2V0QXV0aCwgYXV0aCB9IGZyb20gJ0BjbGVyay9uZXh0anMvc2VydmVyJztcblxuZGVzY3JpYmUoJ0Z1bmNpb25lcyBkZSBBdXRlbnRpY2FjacOzbiBNZWpvcmFkYXMnLCAoKSA9PiB7XG4gIGxldCBtb2NrR2V0QXV0aDogamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZ2V0QXV0aD47XG4gIGxldCBtb2NrQXV0aDogamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgYXV0aD47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja0dldEF1dGggPSBnZXRBdXRoIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGdldEF1dGg+O1xuICAgIG1vY2tBdXRoID0gYXV0aCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBhdXRoPjtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEF1dGhlbnRpY2F0ZWRVc2VyIChtZWpvcmFkYSknLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgdXNhciBnZXRBdXRoIHBhcmEgTmV4dEFwaVJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQXBpUmVxdWVzdCA9IHtcbiAgICAgICAgcXVlcnk6IHt9LFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgY29va2llczoge31cbiAgICAgIH0gYXMgTmV4dEFwaVJlcXVlc3Q7XG5cbiAgICAgIG1vY2tHZXRBdXRoLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgc2Vzc2lvbklkOiAnc2Vzc2lvbl80NTYnLFxuICAgICAgICBnZXRUb2tlbjogamVzdC5mbigpXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZFVzZXIobW9ja0FwaVJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QobW9ja0dldEF1dGgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tBcGlSZXF1ZXN0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICB1c2VySWQ6ICd1c2VyXzEyMycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3Npb25fNDU2J1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSB1c2FyIGF1dGgoKSBwYXJhIE5leHRSZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja05leHRSZXF1ZXN0ID0ge1xuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL3Rlc3QnIH0sXG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgY29va2llczogbmV3IE1hcCgpXG4gICAgICB9IGFzIGFueTtcblxuICAgICAgbW9ja0F1dGgubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICB1c2VySWQ6ICd1c2VyXzc4OScsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3Npb25fYWJjJyxcbiAgICAgICAgZ2V0VG9rZW46IGplc3QuZm4oKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEF1dGhlbnRpY2F0ZWRVc2VyKG1vY2tOZXh0UmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChtb2NrQXV0aCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICAgIHVzZXJJZDogJ3VzZXJfNzg5JyxcbiAgICAgICAgc2Vzc2lvbklkOiAnc2Vzc2lvbl9hYmMnXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIHVzYXIgZmFsbGJhY2sgYSBoZWFkZXJzIGN1YW5kbyBnZXRBdXRoIGZhbGxhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ3VzZXJfZmFsbGJhY2snKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueTtcblxuICAgICAgbW9ja0F1dGgubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdBdXRoIGZhaWxlZCcpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZFVzZXIobW9ja1JlcXVlc3QpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnVzZXJJZCkudG9CZSgndXNlcl9mYWxsYmFjaycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgcmV0b3JuYXIgZXJyb3IgY3VhbmRvIG5vIGhheSBhdXRlbnRpY2FjacOzbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBtb2NrQXV0aC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0F1dGggZmFpbGVkJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBdXRoZW50aWNhdGVkVXNlcihtb2NrUmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZSgnTm8gYXV0b3JpemFkbycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0QXV0aEZyb21BcGlSb3V0ZScsICgpID0+IHtcbiAgICBpdCgnZGViZSB1c2FyIGdldEF1dGggY29ycmVjdGFtZW50ZSBwYXJhIEFQSSBSb3V0ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVxID0geyBxdWVyeToge30sIGhlYWRlcnM6IHt9IH0gYXMgTmV4dEFwaVJlcXVlc3Q7XG4gICAgICBjb25zdCBtb2NrUmVzID0ge30gYXMgTmV4dEFwaVJlc3BvbnNlO1xuXG4gICAgICBtb2NrR2V0QXV0aC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2VySWQ6ICdhcGlfdXNlcl8xMjMnLFxuICAgICAgICBzZXNzaW9uSWQ6ICdhcGlfc2Vzc2lvbl80NTYnLFxuICAgICAgICBnZXRUb2tlbjogamVzdC5mbigpXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0QXV0aEZyb21BcGlSb3V0ZShtb2NrUmVxLCBtb2NrUmVzKTtcblxuICAgICAgZXhwZWN0KG1vY2tHZXRBdXRoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrUmVxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCdhcGlfdXNlcl8xMjMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc2Vzc2lvbklkKS50b0JlKCdhcGlfc2Vzc2lvbl80NTYnKTtcbiAgICB9KTtcblxuICAgIGl0KCdkZWJlIGxhbnphciBlcnJvciBjdWFuZG8gbm8gaGF5IHVzZXJJZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXEgPSB7IHF1ZXJ5OiB7fSwgaGVhZGVyczoge30gfSBhcyBOZXh0QXBpUmVxdWVzdDtcbiAgICAgIGNvbnN0IG1vY2tSZXMgPSB7fSBhcyBOZXh0QXBpUmVzcG9uc2U7XG5cbiAgICAgIG1vY2tHZXRBdXRoLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogbnVsbCxcbiAgICAgICAgc2Vzc2lvbklkOiBudWxsLFxuICAgICAgICBnZXRUb2tlbjogamVzdC5mbigpXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KCgpID0+IGdldEF1dGhGcm9tQXBpUm91dGUobW9ja1JlcSwgbW9ja1JlcykpLnRvVGhyb3coJ1VzdWFyaW8gbm8gYXV0ZW50aWNhZG8nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEF1dGhGcm9tUm91dGVIYW5kbGVyJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIHVzYXIgYXV0aCgpIGNvcnJlY3RhbWVudGUgcGFyYSBSb3V0ZSBIYW5kbGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgdXNlcklkOiAncm91dGVfdXNlcl8xMjMnLFxuICAgICAgICBzZXNzaW9uSWQ6ICdyb3V0ZV9zZXNzaW9uXzQ1NicsXG4gICAgICAgIGdldFRva2VuOiBqZXN0LmZuKClcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRBdXRoRnJvbVJvdXRlSGFuZGxlcigpO1xuXG4gICAgICBleHBlY3QobW9ja0F1dGgpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCdyb3V0ZV91c2VyXzEyMycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zZXNzaW9uSWQpLnRvQmUoJ3JvdXRlX3Nlc3Npb25fNDU2Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBsYW56YXIgZXJyb3IgY3VhbmRvIG5vIGhheSB1c2VySWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXV0aC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogbnVsbCxcbiAgICAgICAgc2Vzc2lvbklkOiBudWxsLFxuICAgICAgICBnZXRUb2tlbjogamVzdC5mbigpXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgZXhwZWN0KGdldEF1dGhGcm9tUm91dGVIYW5kbGVyKCkpLnJlamVjdHMudG9UaHJvdygnVXN1YXJpbyBubyBhdXRlbnRpY2FkbycpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0VW5pZmllZEF1dGgnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgZGV0ZWN0YXIgTmV4dEFwaVJlcXVlc3QgeSB1c2FyIGdldEF1dGgnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQXBpUmVxdWVzdCA9IHtcbiAgICAgICAgcXVlcnk6IHt9LFxuICAgICAgICBoZWFkZXJzOiB7fVxuICAgICAgfSBhcyBOZXh0QXBpUmVxdWVzdDtcblxuICAgICAgbW9ja0dldEF1dGgubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdXNlcklkOiAndW5pZmllZF91c2VyXzEyMycsXG4gICAgICAgIHNlc3Npb25JZDogJ3VuaWZpZWRfc2Vzc2lvbl80NTYnLFxuICAgICAgICBnZXRUb2tlbjogamVzdC5mbigpXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VW5pZmllZEF1dGgobW9ja0FwaVJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QobW9ja0dldEF1dGgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tBcGlSZXF1ZXN0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCd1bmlmaWVkX3VzZXJfMTIzJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZGViZSBkZXRlY3RhciBOZXh0UmVxdWVzdCB5IHVzYXIgYXV0aCgpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja05leHRSZXF1ZXN0ID0ge1xuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL3Rlc3QnIH0sXG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoKVxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIG1vY2tBdXRoLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgdXNlcklkOiAndW5pZmllZF9yb3V0ZV8xMjMnLFxuICAgICAgICBzZXNzaW9uSWQ6ICd1bmlmaWVkX3JvdXRlXzQ1NicsXG4gICAgICAgIGdldFRva2VuOiBqZXN0LmZuKClcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVbmlmaWVkQXV0aChtb2NrTmV4dFJlcXVlc3QpO1xuXG4gICAgICBleHBlY3QobW9ja0F1dGgpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCd1bmlmaWVkX3JvdXRlXzEyMycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgdXNhciBmYWxsYmFjayBjdWFuZG8gaGF5IGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoJ2ZhbGxiYWNrX3VzZXInKVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueTtcblxuICAgICAgbW9ja0F1dGgubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdVbmlmaWVkIGF1dGggZmFpbGVkJykpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVbmlmaWVkQXV0aChtb2NrUmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQudXNlcklkKS50b0JlKCdmYWxsYmFja191c2VyJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCd3aXRoQWRtaW5BdXRoUGFnZXMgd3JhcHBlcicsICgpID0+IHtcbiAgICBpdCgnZGViZSBjcmVhciB3cmFwcGVyIGZ1bmNpb25hbCBwYXJhIFBhZ2VzIFJvdXRlcicsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tIYW5kbGVyID0gamVzdC5mbigpO1xuICAgICAgY29uc3Qgd3JhcHBlZEhhbmRsZXIgPSB3aXRoQWRtaW5BdXRoUGFnZXMobW9ja0hhbmRsZXIpO1xuXG4gICAgICBleHBlY3QodHlwZW9mIHdyYXBwZWRIYW5kbGVyKS50b0JlKCdmdW5jdGlvbicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgcGFzYXIgY29udGV4dG8gY29ycmVjdG8gYWwgaGFuZGxlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tIYW5kbGVyID0gamVzdC5mbigpO1xuICAgICAgY29uc3QgbW9ja1JlcSA9IHsgcXVlcnk6IHt9LCBoZWFkZXJzOiB7fSB9IGFzIE5leHRBcGlSZXF1ZXN0O1xuICAgICAgY29uc3QgbW9ja1JlcyA9IHsgXG4gICAgICAgIHN0YXR1czogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgICAgIGpzb246IGplc3QuZm4oKVxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBhdXRoXG4gICAgICBtb2NrR2V0QXV0aC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB1c2VySWQ6ICdhZG1pbl91c2VyJyxcbiAgICAgICAgc2Vzc2lvbklkOiAnYWRtaW5fc2Vzc2lvbicsXG4gICAgICAgIGdldFRva2VuOiBqZXN0LmZuKClcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IHdpdGhBZG1pbkF1dGhQYWdlcyhtb2NrSGFuZGxlcik7XG4gICAgICBcbiAgICAgIC8vIEVzdGUgdGVzdCB2ZXJpZmljYXLDrWEgbGEgZXN0cnVjdHVyYSwgcGVybyByZXF1aWVyZSBtb2NrcyBtw6FzIGNvbXBsZWpvc1xuICAgICAgLy8gcGFyYSBlbCBzaXN0ZW1hIGNvbXBsZXRvIGRlIHBlcm1pc29zXG4gICAgICBleHBlY3QodHlwZW9mIHdyYXBwZWRIYW5kbGVyKS50b0JlKCdmdW5jdGlvbicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcGF0aWJpbGlkYWQgaGFjaWEgYXRyw6FzJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIG1hbnRlbmVyIGNvbXBhdGliaWxpZGFkIGNvbiBoZWFkZXJzIHgtY2xlcmstdXNlci1pZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICd4LWNsZXJrLXVzZXItaWQnKSByZXR1cm4gJ2xlZ2FjeV91c2VyXzEyMyc7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGFzIGFueTtcblxuICAgICAgbW9ja0F1dGgubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdBdXRoIG5vdCBhdmFpbGFibGUnKSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEF1dGhlbnRpY2F0ZWRVc2VyKG1vY2tSZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC51c2VySWQpLnRvQmUoJ2xlZ2FjeV91c2VyXzEyMycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgbWFudGVuZXIgY29tcGF0aWJpbGlkYWQgY29uIEpXVCBlbiBjb29raWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0p3dFBheWxvYWQgPSB7IHN1YjogJ2p3dF91c2VyXzEyMycgfTtcbiAgICAgIGNvbnN0IG1vY2tKd3QgPSAnaGVhZGVyLicgKyBidG9hKEpTT04uc3RyaW5naWZ5KG1vY2tKd3RQYXlsb2FkKSkgKyAnLnNpZ25hdHVyZSc7XG5cbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG51bGwpXG4gICAgICAgIH0sXG4gICAgICAgIGNvb2tpZXM6IHtcbiAgICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19fc2Vzc2lvbicpIHJldHVybiB7IHZhbHVlOiBtb2NrSnd0IH07XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gYXMgYW55O1xuXG4gICAgICBtb2NrQXV0aC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0F1dGggbm90IGF2YWlsYWJsZScpKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXV0aGVudGljYXRlZFVzZXIobW9ja1JlcXVlc3QpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnVzZXJJZCkudG9CZSgnand0X3VzZXJfMTIzJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdMb2dnaW5nIHkgZGVidWdnaW5nJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIGxvZ2dlYXIgYXV0ZW50aWNhY2nDs24gZXhpdG9zYScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja0FwaVJlcXVlc3QgPSB7XG4gICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgaGVhZGVyczoge31cbiAgICAgIH0gYXMgTmV4dEFwaVJlcXVlc3Q7XG5cbiAgICAgIG1vY2tHZXRBdXRoLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHVzZXJJZDogJ2xvZ2dlZF91c2VyXzEyMycsXG4gICAgICAgIHNlc3Npb25JZDogJ2xvZ2dlZF9zZXNzaW9uXzQ1NicsXG4gICAgICAgIGdldFRva2VuOiBqZXN0LmZuKClcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBnZXRBdXRoZW50aWNhdGVkVXNlcihtb2NrQXBpUmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1tBVVRIXSBVc3VhcmlvIGF1dGVudGljYWRvIHZpYSBnZXRBdXRoOiBsb2dnZWRfdXNlcl8xMjMnKVxuICAgICAgKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2RlYmUgbG9nZ2VhciB3YXJuaW5ncyBwYXJhIGZhbGxiYWNrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgZ2V0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKCdmYWxsYmFja191c2VyJylcbiAgICAgICAgfVxuICAgICAgfSBhcyBhbnk7XG5cbiAgICAgIG1vY2tBdXRoLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQXV0aCBmYWlsZWQnKSk7XG5cbiAgICAgIGF3YWl0IGdldEF1dGhlbnRpY2F0ZWRVc2VyKG1vY2tSZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnW0FVVEhdIFVzYW5kbyBoZWFkZXIgZmFsbGJhY2sgcGFyYSB1c2VySWQnKVxuICAgICAgKTtcblxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZ2V0QXV0aCIsImZuIiwiYXV0aCIsImN1cnJlbnRVc2VyIiwic3VwYWJhc2VBZG1pbiIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsImRlc2NyaWJlIiwibW9ja0dldEF1dGgiLCJtb2NrQXV0aCIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJtb2NrQXBpUmVxdWVzdCIsInF1ZXJ5IiwiaGVhZGVycyIsImNvb2tpZXMiLCJtb2NrUmV0dXJuVmFsdWUiLCJ1c2VySWQiLCJzZXNzaW9uSWQiLCJnZXRUb2tlbiIsInJlc3VsdCIsImdldEF1dGhlbnRpY2F0ZWRVc2VyIiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0VxdWFsIiwibW9ja05leHRSZXF1ZXN0IiwibmV4dFVybCIsInBhdGhuYW1lIiwiTWFwIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibW9ja1JlcXVlc3QiLCJnZXQiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwidG9CZSIsInRvQmVOdWxsIiwiZXJyb3IiLCJtb2NrUmVxIiwibW9ja1JlcyIsImdldEF1dGhGcm9tQXBpUm91dGUiLCJ0b1Rocm93IiwiZ2V0QXV0aEZyb21Sb3V0ZUhhbmRsZXIiLCJyZWplY3RzIiwiZ2V0VW5pZmllZEF1dGgiLCJtb2NrSGFuZGxlciIsIndyYXBwZWRIYW5kbGVyIiwid2l0aEFkbWluQXV0aFBhZ2VzIiwic3RhdHVzIiwibW9ja1JldHVyblRoaXMiLCJqc29uIiwibW9ja0ltcGxlbWVudGF0aW9uIiwia2V5IiwibW9ja0p3dFBheWxvYWQiLCJzdWIiLCJtb2NrSnd0IiwiYnRvYSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImNvbnNvbGVTcHkiLCJzcHlPbiIsImNvbnNvbGUiLCJzdHJpbmdDb250YWluaW5nIiwibW9ja1Jlc3RvcmUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQztBQUtELGdCQUFnQjtBQUNoQkEsS0FBS0MsSUFBSSxDQUFDLHdCQUF3QixJQUFPLENBQUE7UUFDdkNDLFNBQVNGLEtBQUtHLEVBQUU7UUFDaEJDLE1BQU1KLEtBQUtHLEVBQUU7UUFDYkUsYUFBYUwsS0FBS0csRUFBRTtJQUN0QixDQUFBO0FBRUEsbUJBQW1CO0FBQ25CSCxLQUFLQyxJQUFJLENBQUMsa0JBQWtCLElBQU8sQ0FBQTtRQUNqQ0ssZUFBZTtZQUNiQyxNQUFNUCxLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO29CQUNuQkssUUFBUVIsS0FBS0csRUFBRSxDQUFDLElBQU8sQ0FBQTs0QkFDckJNLElBQUlULEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7b0NBQ2pCTyxRQUFRVixLQUFLRyxFQUFFO2dDQUNqQixDQUFBO3dCQUNGLENBQUE7Z0JBQ0YsQ0FBQTtRQUNGO0lBQ0YsQ0FBQTs7OzsyQkFRTzt3QkFDdUI7QUFFOUJRLFNBQVMsd0NBQXdDO0lBQy9DLElBQUlDO0lBQ0os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