54c4b5c8c4b3fc37a6b092658a0590aa
/**
 * useCategoryData Hook
 * Manages category data fetching, caching, and state
 * Pinteya E-commerce - Enterprise-ready implementation
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    clearCategoryCache: function() {
        return clearCategoryCache;
    },
    /**
 * Default export for convenience
 */ default: function() {
        return _default;
    },
    preloadCategoryImages: function() {
        return preloadCategoryImages;
    },
    useCategoryData: function() {
        return useCategoryData;
    }
});
const _react = require("react");
/**
 * In-memory cache for category data
 */ const categoryCache = new Map();
/**
 * Default categories data (fallback) - ELIMINADO
 * DATOS HARDCODEADOS ELIMINADOS - Ahora usa solo API real de Supabase
 * Las categorías se obtienen dinámicamente desde /api/categories
 */ const DEFAULT_CATEGORIES = [];
const useCategoryData = (options = {})=>{
    const { autoFetch = true, cacheDuration = 5 * 60 * 1000, enableBackgroundRefresh = true, refreshInterval = 30 * 60 * 1000, maxCategories = 20, enableAnalytics = true, fallbackCategories = [], apiEndpoint = '/api/categories' } = options;
    const [categories, setCategories] = (0, _react.useState)(fallbackCategories);
    const [loading, setLoading] = (0, _react.useState)(false);
    const [error, setError] = (0, _react.useState)(null);
    /**
   * Generate cache key based on options
   */ const cacheKey = (0, _react.useMemo)(()=>{
        return `categories_${maxCategories}_${apiEndpoint}`;
    }, [
        maxCategories,
        apiEndpoint
    ]);
    /**
   * Check if cached data is valid
   */ const isCacheValid = (0, _react.useCallback)((cache)=>{
        return Date.now() < cache.expiresAt;
    }, []);
    /**
   * Get data from cache if valid
   */ const getCachedData = (0, _react.useCallback)(()=>{
        const cached = categoryCache.get(cacheKey);
        if (cached && isCacheValid(cached)) {
            return cached.data;
        }
        return null;
    }, [
        cacheKey,
        isCacheValid
    ]);
    /**
   * Store data in cache
   */ const setCachedData = (0, _react.useCallback)((data)=>{
        const now = Date.now();
        categoryCache.set(cacheKey, {
            data,
            timestamp: now,
            expiresAt: now + cacheDuration
        });
    }, [
        cacheKey,
        cacheDuration
    ]);
    /**
   * Track analytics event
   */ const trackAnalytics = (0, _react.useCallback)((event, data)=>{
        if (!enableAnalytics) return;
        if (typeof window !== 'undefined' && window.gtag) {
            window.gtag('event', 'category_data', {
                event_category: 'data',
                event_label: event,
                custom_parameters: data
            });
        }
        if (process.env.NODE_ENV === 'development') {}
    }, [
        enableAnalytics
    ]);
    /**
   * Fetch categories from API
   */ const fetchCategories = (0, _react.useCallback)(async ()=>{
        try {
            const response = await fetch(apiEndpoint);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const result = await response.json();
            // Handle different API response formats
            let categoriesData;
            if (Array.isArray(result)) {
                categoriesData = result;
            } else if (result.data && Array.isArray(result.data)) {
                categoriesData = result.data;
            } else if (result.categories && Array.isArray(result.categories)) {
                categoriesData = result.categories;
            } else {
                throw new Error('Invalid API response format');
            }
            // Validate and transform data
            const validCategories = categoriesData.filter((cat)=>typeof cat === 'object' && cat !== null && (typeof cat.id === 'string' || typeof cat.id === 'number') && typeof cat.name === 'string').slice(0, maxCategories).map((cat)=>({
                    id: cat.slug || cat.id.toString(),
                    name: cat.name,
                    icon: cat.image_url || (cat.icon ? cat.icon : "/images/categories/placeholder.png"),
                    description: cat.description || `Productos de ${cat.name.toLowerCase()}`,
                    isAvailable: cat.isAvailable ?? true,
                    // Keep additional API fields for compatibility
                    products_count: cat.products_count || 0,
                    slug: cat.slug,
                    parent_id: cat.parent_id,
                    image_url: cat.image_url,
                    created_at: cat.created_at,
                    updated_at: cat.updated_at
                }));
            trackAnalytics('fetch_success', {
                count: validCategories.length
            });
            return validCategories;
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            trackAnalytics('fetch_error', {
                error: errorMessage
            });
            throw new Error(`Failed to fetch categories: ${errorMessage}`);
        }
    }, [
        apiEndpoint,
        maxCategories,
        trackAnalytics
    ]);
    /**
   * Refresh categories data
   */ const refresh = (0, _react.useCallback)(async ()=>{
        setLoading(true);
        setError(null);
        try {
            // Check cache first
            const cachedData = getCachedData();
            if (cachedData && !enableBackgroundRefresh) {
                setCategories(cachedData);
                setLoading(false);
                return;
            }
            // Fetch fresh data
            const freshData = await fetchCategories();
            // Update state and cache
            setCategories(freshData);
            setCachedData(freshData);
            setError(null);
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Failed to load categories';
            setError(errorMessage);
            // Use cached data as fallback if available
            const cachedData = getCachedData();
            if (cachedData) {
                setCategories(cachedData);
            } else {
                setCategories(fallbackCategories);
            }
            console.error('Category data error:', error);
        } finally{
            setLoading(false);
        }
    }, [
        getCachedData,
        enableBackgroundRefresh,
        fetchCategories,
        setCachedData,
        fallbackCategories
    ]);
    /**
   * Get category by ID
   */ const getCategoryById = (0, _react.useCallback)((id)=>{
        return categories.find((cat)=>cat.id === id);
    }, [
        categories
    ]);
    /**
   * Initial data load
   */ (0, _react.useEffect)(()=>{
        if (autoFetch) {
            refresh();
        }
    }, [
        autoFetch
    ]); // Removed refresh dependency to prevent infinite loop
    /**
   * Background refresh interval
   */ (0, _react.useEffect)(()=>{
        if (!enableBackgroundRefresh || refreshInterval <= 0) return;
        const interval = setInterval(()=>{
            refresh();
        }, refreshInterval);
        return ()=>clearInterval(interval);
    }, [
        enableBackgroundRefresh,
        refreshInterval
    ]); // Removed refresh dependency to prevent infinite loop
    /**
   * Memoized return object for performance
   */ const returnValue = (0, _react.useMemo)(()=>({
            categories,
            loading,
            error,
            refresh,
            getCategoryById
        }), [
        categories,
        loading,
        error,
        refresh,
        getCategoryById
    ]);
    return returnValue;
};
const preloadCategoryImages = (categories)=>{
    if (typeof window === 'undefined') return;
    categories.forEach((category)=>{
        if (category && category.icon) {
            const img = new Image();
            img.src = category.icon;
        }
    });
};
const clearCategoryCache = ()=>{
    categoryCache.clear();
};
const _default = useCategoryData;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcaG9va3NcXHVzZUNhdGVnb3J5RGF0YS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHVzZUNhdGVnb3J5RGF0YSBIb29rXG4gKiBNYW5hZ2VzIGNhdGVnb3J5IGRhdGEgZmV0Y2hpbmcsIGNhY2hpbmcsIGFuZCBzdGF0ZVxuICogUGludGV5YSBFLWNvbW1lcmNlIC0gRW50ZXJwcmlzZS1yZWFkeSBpbXBsZW1lbnRhdGlvblxuICovXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgeyBDYXRlZ29yeSwgVXNlQ2F0ZWdvcnlEYXRhUmV0dXJuIH0gZnJvbSAnQC90eXBlcy9jYXRlZ29yaWVzJztcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjYXRlZ29yeSBkYXRhIGhvb2tcbiAqL1xuaW50ZXJmYWNlIFVzZUNhdGVnb3J5RGF0YU9wdGlvbnMge1xuICAvKiogV2hldGhlciB0byBmZXRjaCBkYXRhIGltbWVkaWF0ZWx5IG9uIG1vdW50ICovXG4gIGF1dG9GZXRjaD86IGJvb2xlYW47XG4gIC8qKiBDYWNoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKi9cbiAgY2FjaGVEdXJhdGlvbj86IG51bWJlcjtcbiAgLyoqIFdoZXRoZXIgdG8gZW5hYmxlIGJhY2tncm91bmQgcmVmcmVzaCAqL1xuICBlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaD86IGJvb2xlYW47XG4gIC8qKiBSZWZyZXNoIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyAqL1xuICByZWZyZXNoSW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiBjYXRlZ29yaWVzIHRvIGZldGNoICovXG4gIG1heENhdGVnb3JpZXM/OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIHRvIGVuYWJsZSBhbmFseXRpY3MgdHJhY2tpbmcgKi9cbiAgZW5hYmxlQW5hbHl0aWNzPzogYm9vbGVhbjtcbiAgLyoqIEZhbGxiYWNrIGNhdGVnb3JpZXMgaWYgQVBJIGZhaWxzICovXG4gIGZhbGxiYWNrQ2F0ZWdvcmllcz86IENhdGVnb3J5W107XG4gIC8qKiBBUEkgZW5kcG9pbnQgZm9yIGNhdGVnb3JpZXMgKi9cbiAgYXBpRW5kcG9pbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ2FjaGUgaW50ZXJmYWNlIGZvciBzdG9yaW5nIGNhdGVnb3J5IGRhdGFcbiAqL1xuaW50ZXJmYWNlIENhdGVnb3J5Q2FjaGUge1xuICBkYXRhOiBDYXRlZ29yeVtdO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgZXhwaXJlc0F0OiBudW1iZXI7XG59XG5cbi8qKlxuICogSW4tbWVtb3J5IGNhY2hlIGZvciBjYXRlZ29yeSBkYXRhXG4gKi9cbmNvbnN0IGNhdGVnb3J5Q2FjaGUgPSBuZXcgTWFwPHN0cmluZywgQ2F0ZWdvcnlDYWNoZT4oKTtcblxuLyoqXG4gKiBEZWZhdWx0IGNhdGVnb3JpZXMgZGF0YSAoZmFsbGJhY2spIC0gRUxJTUlOQURPXG4gKiBEQVRPUyBIQVJEQ09ERUFET1MgRUxJTUlOQURPUyAtIEFob3JhIHVzYSBzb2xvIEFQSSByZWFsIGRlIFN1cGFiYXNlXG4gKiBMYXMgY2F0ZWdvcsOtYXMgc2Ugb2J0aWVuZW4gZGluw6FtaWNhbWVudGUgZGVzZGUgL2FwaS9jYXRlZ29yaWVzXG4gKi9cbmNvbnN0IERFRkFVTFRfQ0FURUdPUklFUzogQ2F0ZWdvcnlbXSA9IFtdO1xuXG4vKipcbiAqIEN1c3RvbSBob29rIGZvciBtYW5hZ2luZyBjYXRlZ29yeSBkYXRhXG4gKiBcbiAqIEZlYXR1cmVzOlxuICogLSBEYXRhIGZldGNoaW5nIHdpdGggY2FjaGluZ1xuICogLSBCYWNrZ3JvdW5kIHJlZnJlc2hcbiAqIC0gRXJyb3IgaGFuZGxpbmcgYW5kIGZhbGxiYWNrc1xuICogLSBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAqIC0gQW5hbHl0aWNzIHRyYWNraW5nXG4gKiBcbiAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHJldHVybnMgQ2F0ZWdvcnkgZGF0YSBzdGF0ZSBhbmQgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgdXNlQ2F0ZWdvcnlEYXRhID0gKFxuICBvcHRpb25zOiBVc2VDYXRlZ29yeURhdGFPcHRpb25zID0ge31cbik6IFVzZUNhdGVnb3J5RGF0YVJldHVybiA9PiB7XG4gIGNvbnN0IHtcbiAgICBhdXRvRmV0Y2ggPSB0cnVlLFxuICAgIGNhY2hlRHVyYXRpb24gPSA1ICogNjAgKiAxMDAwLCAvLyA1IG1pbnV0ZXNcbiAgICBlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaCA9IHRydWUsXG4gICAgcmVmcmVzaEludGVydmFsID0gMzAgKiA2MCAqIDEwMDAsIC8vIDMwIG1pbnV0ZXNcbiAgICBtYXhDYXRlZ29yaWVzID0gMjAsXG4gICAgZW5hYmxlQW5hbHl0aWNzID0gdHJ1ZSxcbiAgICBmYWxsYmFja0NhdGVnb3JpZXMgPSBbXSwgLy8gU2luIGZhbGxiYWNrIC0gdXNhciBzb2xvIGRhdG9zIGRlIEFQSVxuICAgIGFwaUVuZHBvaW50ID0gJy9hcGkvY2F0ZWdvcmllcycsXG4gIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IFtjYXRlZ29yaWVzLCBzZXRDYXRlZ29yaWVzXSA9IHVzZVN0YXRlPENhdGVnb3J5W10+KGZhbGxiYWNrQ2F0ZWdvcmllcyk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgY2FjaGUga2V5IGJhc2VkIG9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0IGNhY2hlS2V5ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGBjYXRlZ29yaWVzXyR7bWF4Q2F0ZWdvcmllc31fJHthcGlFbmRwb2ludH1gO1xuICB9LCBbbWF4Q2F0ZWdvcmllcywgYXBpRW5kcG9pbnRdKTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgY2FjaGVkIGRhdGEgaXMgdmFsaWRcbiAgICovXG4gIGNvbnN0IGlzQ2FjaGVWYWxpZCA9IHVzZUNhbGxiYWNrKChjYWNoZTogQ2F0ZWdvcnlDYWNoZSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBEYXRlLm5vdygpIDwgY2FjaGUuZXhwaXJlc0F0O1xuICB9LCBbXSk7XG5cbiAgLyoqXG4gICAqIEdldCBkYXRhIGZyb20gY2FjaGUgaWYgdmFsaWRcbiAgICovXG4gIGNvbnN0IGdldENhY2hlZERhdGEgPSB1c2VDYWxsYmFjaygoKTogQ2F0ZWdvcnlbXSB8IG51bGwgPT4ge1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhdGVnb3J5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoY2FjaGVkICYmIGlzQ2FjaGVWYWxpZChjYWNoZWQpKSB7XG4gICAgICByZXR1cm4gY2FjaGVkLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LCBbY2FjaGVLZXksIGlzQ2FjaGVWYWxpZF0pO1xuXG4gIC8qKlxuICAgKiBTdG9yZSBkYXRhIGluIGNhY2hlXG4gICAqL1xuICBjb25zdCBzZXRDYWNoZWREYXRhID0gdXNlQ2FsbGJhY2soKGRhdGE6IENhdGVnb3J5W10pID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNhdGVnb3J5Q2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICBkYXRhLFxuICAgICAgdGltZXN0YW1wOiBub3csXG4gICAgICBleHBpcmVzQXQ6IG5vdyArIGNhY2hlRHVyYXRpb24sXG4gICAgfSk7XG4gIH0sIFtjYWNoZUtleSwgY2FjaGVEdXJhdGlvbl0pO1xuXG4gIC8qKlxuICAgKiBUcmFjayBhbmFseXRpY3MgZXZlbnRcbiAgICovXG4gIGNvbnN0IHRyYWNrQW5hbHl0aWNzID0gdXNlQ2FsbGJhY2soKGV2ZW50OiBzdHJpbmcsIGRhdGE/OiBhbnkpID0+IHtcbiAgICBpZiAoIWVuYWJsZUFuYWx5dGljcykgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5ndGFnKSB7XG4gICAgICB3aW5kb3cuZ3RhZygnZXZlbnQnLCAnY2F0ZWdvcnlfZGF0YScsIHtcbiAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdkYXRhJyxcbiAgICAgICAgZXZlbnRfbGFiZWw6IGV2ZW50LFxuICAgICAgICBjdXN0b21fcGFyYW1ldGVyczogZGF0YSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIH1cbiAgfSwgW2VuYWJsZUFuYWx5dGljc10pO1xuXG4gIC8qKlxuICAgKiBGZXRjaCBjYXRlZ29yaWVzIGZyb20gQVBJXG4gICAqL1xuICBjb25zdCBmZXRjaENhdGVnb3JpZXMgPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTxDYXRlZ29yeVtdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpRW5kcG9pbnQpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IEFQSSByZXNwb25zZSBmb3JtYXRzXG4gICAgICBsZXQgY2F0ZWdvcmllc0RhdGE6IENhdGVnb3J5W107XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgIGNhdGVnb3JpZXNEYXRhID0gcmVzdWx0O1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZGF0YSAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC5kYXRhKSkge1xuICAgICAgICBjYXRlZ29yaWVzRGF0YSA9IHJlc3VsdC5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY2F0ZWdvcmllcyAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC5jYXRlZ29yaWVzKSkge1xuICAgICAgICBjYXRlZ29yaWVzRGF0YSA9IHJlc3VsdC5jYXRlZ29yaWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFQSSByZXNwb25zZSBmb3JtYXQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgYW5kIHRyYW5zZm9ybSBkYXRhXG4gICAgICBjb25zdCB2YWxpZENhdGVnb3JpZXMgPSBjYXRlZ29yaWVzRGF0YVxuICAgICAgICAuZmlsdGVyKChjYXQpOiBjYXQgaXMgYW55ID0+XG4gICAgICAgICAgdHlwZW9mIGNhdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBjYXQgIT09IG51bGwgJiZcbiAgICAgICAgICAodHlwZW9mIGNhdC5pZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNhdC5pZCA9PT0gJ251bWJlcicpICYmXG4gICAgICAgICAgdHlwZW9mIGNhdC5uYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICApXG4gICAgICAgIC5zbGljZSgwLCBtYXhDYXRlZ29yaWVzKVxuICAgICAgICAubWFwKGNhdCA9PiAoe1xuICAgICAgICAgIGlkOiBjYXQuc2x1ZyB8fCBjYXQuaWQudG9TdHJpbmcoKSwgLy8gVXNlIHNsdWcgYXMgSUQsIGZhbGxiYWNrIHRvIHN0cmluZyBJRFxuICAgICAgICAgIG5hbWU6IGNhdC5uYW1lLFxuICAgICAgICAgIGljb246IGNhdC5pbWFnZV91cmwgfHwgKGNhdC5pY29uID8gY2F0Lmljb24gOiBcIi9pbWFnZXMvY2F0ZWdvcmllcy9wbGFjZWhvbGRlci5wbmdcIiksIC8vIFNhZmUgYWNjZXNzIHRvIGljb24gcHJvcGVydHlcbiAgICAgICAgICBkZXNjcmlwdGlvbjogY2F0LmRlc2NyaXB0aW9uIHx8IGBQcm9kdWN0b3MgZGUgJHtjYXQubmFtZS50b0xvd2VyQ2FzZSgpfWAsIC8vIEdlbmVyYXRlIGRlc2NyaXB0aW9uIGlmIG1pc3NpbmdcbiAgICAgICAgICBpc0F2YWlsYWJsZTogY2F0LmlzQXZhaWxhYmxlID8/IHRydWUsXG4gICAgICAgICAgLy8gS2VlcCBhZGRpdGlvbmFsIEFQSSBmaWVsZHMgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICBwcm9kdWN0c19jb3VudDogY2F0LnByb2R1Y3RzX2NvdW50IHx8IDAsXG4gICAgICAgICAgc2x1ZzogY2F0LnNsdWcsXG4gICAgICAgICAgcGFyZW50X2lkOiBjYXQucGFyZW50X2lkLFxuICAgICAgICAgIGltYWdlX3VybDogY2F0LmltYWdlX3VybCxcbiAgICAgICAgICBjcmVhdGVkX2F0OiBjYXQuY3JlYXRlZF9hdCxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBjYXQudXBkYXRlZF9hdFxuICAgICAgICB9KSk7XG5cbiAgICAgIHRyYWNrQW5hbHl0aWNzKCdmZXRjaF9zdWNjZXNzJywgeyBjb3VudDogdmFsaWRDYXRlZ29yaWVzLmxlbmd0aCB9KTtcbiAgICAgIHJldHVybiB2YWxpZENhdGVnb3JpZXM7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XG4gICAgICB0cmFja0FuYWx5dGljcygnZmV0Y2hfZXJyb3InLCB7IGVycm9yOiBlcnJvck1lc3NhZ2UgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBjYXRlZ29yaWVzOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICB9XG4gIH0sIFthcGlFbmRwb2ludCwgbWF4Q2F0ZWdvcmllcywgdHJhY2tBbmFseXRpY3NdKTtcblxuICAvKipcbiAgICogUmVmcmVzaCBjYXRlZ29yaWVzIGRhdGFcbiAgICovXG4gIGNvbnN0IHJlZnJlc2ggPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgICAgY29uc3QgY2FjaGVkRGF0YSA9IGdldENhY2hlZERhdGEoKTtcbiAgICAgIGlmIChjYWNoZWREYXRhICYmICFlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaCkge1xuICAgICAgICBzZXRDYXRlZ29yaWVzKGNhY2hlZERhdGEpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCBmcmVzaCBkYXRhXG4gICAgICBjb25zdCBmcmVzaERhdGEgPSBhd2FpdCBmZXRjaENhdGVnb3JpZXMoKTtcblxuICAgICAgLy8gVXBkYXRlIHN0YXRlIGFuZCBjYWNoZVxuICAgICAgc2V0Q2F0ZWdvcmllcyhmcmVzaERhdGEpO1xuICAgICAgc2V0Q2FjaGVkRGF0YShmcmVzaERhdGEpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGxvYWQgY2F0ZWdvcmllcyc7XG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuXG4gICAgICAvLyBVc2UgY2FjaGVkIGRhdGEgYXMgZmFsbGJhY2sgaWYgYXZhaWxhYmxlXG4gICAgICBjb25zdCBjYWNoZWREYXRhID0gZ2V0Q2FjaGVkRGF0YSgpO1xuICAgICAgaWYgKGNhY2hlZERhdGEpIHtcbiAgICAgICAgc2V0Q2F0ZWdvcmllcyhjYWNoZWREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldENhdGVnb3JpZXMoZmFsbGJhY2tDYXRlZ29yaWVzKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcignQ2F0ZWdvcnkgZGF0YSBlcnJvcjonLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW1xuICAgIGdldENhY2hlZERhdGEsXG4gICAgZW5hYmxlQmFja2dyb3VuZFJlZnJlc2gsXG4gICAgZmV0Y2hDYXRlZ29yaWVzLFxuICAgIHNldENhY2hlZERhdGEsXG4gICAgZmFsbGJhY2tDYXRlZ29yaWVzLFxuICBdKTtcblxuICAvKipcbiAgICogR2V0IGNhdGVnb3J5IGJ5IElEXG4gICAqL1xuICBjb25zdCBnZXRDYXRlZ29yeUJ5SWQgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZyk6IENhdGVnb3J5IHwgdW5kZWZpbmVkID0+IHtcbiAgICByZXR1cm4gY2F0ZWdvcmllcy5maW5kKGNhdCA9PiBjYXQuaWQgPT09IGlkKTtcbiAgfSwgW2NhdGVnb3JpZXNdKTtcblxuICAvKipcbiAgICogSW5pdGlhbCBkYXRhIGxvYWRcbiAgICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGF1dG9GZXRjaCkge1xuICAgICAgcmVmcmVzaCgpO1xuICAgIH1cbiAgfSwgW2F1dG9GZXRjaF0pOyAvLyBSZW1vdmVkIHJlZnJlc2ggZGVwZW5kZW5jeSB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BcblxuICAvKipcbiAgICogQmFja2dyb3VuZCByZWZyZXNoIGludGVydmFsXG4gICAqL1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlQmFja2dyb3VuZFJlZnJlc2ggfHwgcmVmcmVzaEludGVydmFsIDw9IDApIHJldHVybjtcblxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgcmVmcmVzaCgpO1xuICAgIH0sIHJlZnJlc2hJbnRlcnZhbCk7XG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0sIFtlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaCwgcmVmcmVzaEludGVydmFsXSk7IC8vIFJlbW92ZWQgcmVmcmVzaCBkZXBlbmRlbmN5IHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcFxuXG4gIC8qKlxuICAgKiBNZW1vaXplZCByZXR1cm4gb2JqZWN0IGZvciBwZXJmb3JtYW5jZVxuICAgKi9cbiAgY29uc3QgcmV0dXJuVmFsdWUgPSB1c2VNZW1vKCgpOiBVc2VDYXRlZ29yeURhdGFSZXR1cm4gPT4gKHtcbiAgICBjYXRlZ29yaWVzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgcmVmcmVzaCxcbiAgICBnZXRDYXRlZ29yeUJ5SWQsXG4gIH0pLCBbY2F0ZWdvcmllcywgbG9hZGluZywgZXJyb3IsIHJlZnJlc2gsIGdldENhdGVnb3J5QnlJZF0pO1xuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cbi8qKlxuICogVXRpbGl0eSB0byBwcmVsb2FkIGNhdGVnb3J5IGltYWdlc1xuICovXG5leHBvcnQgY29uc3QgcHJlbG9hZENhdGVnb3J5SW1hZ2VzID0gKGNhdGVnb3JpZXM6IENhdGVnb3J5W10pOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgY2F0ZWdvcmllcy5mb3JFYWNoKGNhdGVnb3J5ID0+IHtcbiAgICBpZiAoY2F0ZWdvcnkgJiYgY2F0ZWdvcnkuaWNvbikge1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcuc3JjID0gY2F0ZWdvcnkuaWNvbjtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IHRvIGNsZWFyIGNhdGVnb3J5IGNhY2hlXG4gKi9cbmV4cG9ydCBjb25zdCBjbGVhckNhdGVnb3J5Q2FjaGUgPSAoKTogdm9pZCA9PiB7XG4gIGNhdGVnb3J5Q2FjaGUuY2xlYXIoKTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBleHBvcnQgZm9yIGNvbnZlbmllbmNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHVzZUNhdGVnb3J5RGF0YTtcbiJdLCJuYW1lcyI6WyJjbGVhckNhdGVnb3J5Q2FjaGUiLCJwcmVsb2FkQ2F0ZWdvcnlJbWFnZXMiLCJ1c2VDYXRlZ29yeURhdGEiLCJjYXRlZ29yeUNhY2hlIiwiTWFwIiwiREVGQVVMVF9DQVRFR09SSUVTIiwib3B0aW9ucyIsImF1dG9GZXRjaCIsImNhY2hlRHVyYXRpb24iLCJlbmFibGVCYWNrZ3JvdW5kUmVmcmVzaCIsInJlZnJlc2hJbnRlcnZhbCIsIm1heENhdGVnb3JpZXMiLCJlbmFibGVBbmFseXRpY3MiLCJmYWxsYmFja0NhdGVnb3JpZXMiLCJhcGlFbmRwb2ludCIsImNhdGVnb3JpZXMiLCJzZXRDYXRlZ29yaWVzIiwidXNlU3RhdGUiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJjYWNoZUtleSIsInVzZU1lbW8iLCJpc0NhY2hlVmFsaWQiLCJ1c2VDYWxsYmFjayIsImNhY2hlIiwiRGF0ZSIsIm5vdyIsImV4cGlyZXNBdCIsImdldENhY2hlZERhdGEiLCJjYWNoZWQiLCJnZXQiLCJkYXRhIiwic2V0Q2FjaGVkRGF0YSIsInNldCIsInRpbWVzdGFtcCIsInRyYWNrQW5hbHl0aWNzIiwiZXZlbnQiLCJ3aW5kb3ciLCJndGFnIiwiZXZlbnRfY2F0ZWdvcnkiLCJldmVudF9sYWJlbCIsImN1c3RvbV9wYXJhbWV0ZXJzIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZmV0Y2hDYXRlZ29yaWVzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwicmVzdWx0IiwianNvbiIsImNhdGVnb3JpZXNEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWRDYXRlZ29yaWVzIiwiZmlsdGVyIiwiY2F0IiwiaWQiLCJuYW1lIiwic2xpY2UiLCJtYXAiLCJzbHVnIiwidG9TdHJpbmciLCJpY29uIiwiaW1hZ2VfdXJsIiwiZGVzY3JpcHRpb24iLCJ0b0xvd2VyQ2FzZSIsImlzQXZhaWxhYmxlIiwicHJvZHVjdHNfY291bnQiLCJwYXJlbnRfaWQiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsImNvdW50IiwibGVuZ3RoIiwiZXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsInJlZnJlc2giLCJjYWNoZWREYXRhIiwiZnJlc2hEYXRhIiwiY29uc29sZSIsImdldENhdGVnb3J5QnlJZCIsImZpbmQiLCJ1c2VFZmZlY3QiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInJldHVyblZhbHVlIiwiZm9yRWFjaCIsImNhdGVnb3J5IiwiaW1nIiwiSW1hZ2UiLCJzcmMiLCJjbGVhciJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQzs7Ozs7Ozs7Ozs7SUE2U1lBLGtCQUFrQjtlQUFsQkE7O0lBSWI7O0NBRUMsR0FDRCxPQUErQjtlQUEvQjs7SUFyQmFDLHFCQUFxQjtlQUFyQkE7O0lBbE9BQyxlQUFlO2VBQWZBOzs7dUJBM0Q2QztBQWtDMUQ7O0NBRUMsR0FDRCxNQUFNQyxnQkFBZ0IsSUFBSUM7QUFFMUI7Ozs7Q0FJQyxHQUNELE1BQU1DLHFCQUFpQyxFQUFFO0FBZWxDLE1BQU1ILGtCQUFrQixDQUM3QkksVUFBa0MsQ0FBQyxDQUFDO0lBRXBDLE1BQU0sRUFDSkMsWUFBWSxJQUFJLEVBQ2hCQyxnQkFBZ0IsSUFBSSxLQUFLLElBQUksRUFDN0JDLDBCQUEwQixJQUFJLEVBQzlCQyxrQkFBa0IsS0FBSyxLQUFLLElBQUksRUFDaENDLGdCQUFnQixFQUFFLEVBQ2xCQyxrQkFBa0IsSUFBSSxFQUN0QkMscUJBQXFCLEVBQUUsRUFDdkJDLGNBQWMsaUJBQWlCLEVBQ2hDLEdBQUdSO0lBRUosTUFBTSxDQUFDUyxZQUFZQyxjQUFjLEdBQUdDLElBQUFBLGVBQVEsRUFBYUo7SUFDekQsTUFBTSxDQUFDSyxTQUFTQyxXQUFX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