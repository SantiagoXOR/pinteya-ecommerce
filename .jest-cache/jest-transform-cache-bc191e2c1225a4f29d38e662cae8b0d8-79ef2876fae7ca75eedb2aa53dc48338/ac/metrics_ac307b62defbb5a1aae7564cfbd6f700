dcc7aca2a430c0a42d03d6769c21b614
// ===================================
// PINTEYA E-COMMERCE - METRICS SYSTEM
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get MetricsCollector () {
        return MetricsCollector;
    },
    get metricsCollector () {
        return metricsCollector;
    }
});
const _redis = require("./redis");
const _logger = require("./logger");
// Configuración de métricas
const METRICS_CONFIG = {
    RETENTION_HOURS: 24,
    AGGREGATION_WINDOW_MINUTES: 5,
    ALERT_THRESHOLDS: {
        ERROR_RATE: 0.05,
        RESPONSE_TIME_P95: 5000,
        RATE_LIMIT_RATE: 0.1
    }
};
class MetricsCollector {
    constructor(){}
    static getInstance() {
        if (!MetricsCollector.instance) {
            MetricsCollector.instance = new MetricsCollector();
        }
        return MetricsCollector.instance;
    }
    /**
   * Registra una métrica de request
   */ async recordRequest(endpoint, method, statusCode, responseTime, labels = {}) {
        const timestamp = Date.now();
        const baseKey = `metrics:${endpoint}:${method}`;
        try {
            // Registrar request total
            await this.incrementCounter(`${baseKey}:requests:total`, timestamp);
            // Registrar por tipo de respuesta
            if (statusCode >= 200 && statusCode < 300) {
                await this.incrementCounter(`${baseKey}:requests:success`, timestamp);
            } else if (statusCode === 429) {
                await this.incrementCounter(`${baseKey}:requests:rate_limited`, timestamp);
            } else {
                await this.incrementCounter(`${baseKey}:requests:error`, timestamp);
                // Categorizar errores
                if (statusCode >= 400 && statusCode < 500) {
                    await this.incrementCounter(`${baseKey}:errors:4xx`, timestamp);
                } else if (statusCode >= 500) {
                    await this.incrementCounter(`${baseKey}:errors:5xx`, timestamp);
                }
            }
            // Registrar tiempo de respuesta
            await this.recordValue(`${baseKey}:response_time`, responseTime, timestamp);
            // Log para debugging
            _logger.logger.info(_logger.LogCategory.API, 'Metric recorded');
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to record metric', error);
        }
    }
    /**
   * Registra una llamada a API (alias para recordRequest)
   */ async recordApiCall(params) {
        await this.recordRequest(params.endpoint, params.method, params.statusCode, params.responseTime, {
            userId: params.userId || 'anonymous',
            error: params.error || ''
        });
    }
    /**
   * Registra métricas de retry
   */ async recordRetry(operation, attempts, success, totalDuration) {
        const timestamp = Date.now();
        const baseKey = `metrics:retry:${operation}`;
        try {
            await this.incrementCounter(`${baseKey}:total`, timestamp);
            await this.recordValue(`${baseKey}:attempts`, attempts, timestamp);
            await this.recordValue(`${baseKey}:duration`, totalDuration, timestamp);
            if (success) {
                await this.incrementCounter(`${baseKey}:success`, timestamp);
            } else {
                await this.incrementCounter(`${baseKey}:failed`, timestamp);
            }
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to record retry metric', error);
        }
    }
    /**
   * Registra métricas de rate limiting
   */ async recordRateLimit(endpoint, blocked, remaining, limit) {
        const timestamp = Date.now();
        const baseKey = `metrics:rate_limit:${endpoint}`;
        try {
            await this.incrementCounter(`${baseKey}:checks`, timestamp);
            if (blocked) {
                await this.incrementCounter(`${baseKey}:blocked`, timestamp);
            }
            await this.recordValue(`${baseKey}:remaining`, remaining, timestamp);
            await this.recordValue(`${baseKey}:utilization`, (limit - remaining) / limit, timestamp);
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to record rate limit metric', error);
        }
    }
    /**
   * Incrementa un contador
   */ async incrementCounter(key, timestamp) {
        const windowKey = this.getWindowKey(key, timestamp);
        await _redis.redisCache.incr(windowKey);
        await _redis.redisCache.expire(windowKey, METRICS_CONFIG.RETENTION_HOURS * 3600);
    }
    /**
   * Registra un valor numérico
   */ async recordValue(key, value, timestamp) {
        try {
            const windowKey = this.getWindowKey(key, timestamp);
            const listKey = `${windowKey}:values`;
            // Obtener cliente Redis (real o mock)
            const client = _redis.redisCache['client'] || _redis.redisCache;
            // Verificar si el cliente tiene los métodos necesarios
            if (typeof client.lpush === 'function') {
                await client.lpush(listKey, value.toString());
                await client.ltrim(listKey, 0, 999); // Mantener últimos 1000 valores
                await client.expire(listKey, METRICS_CONFIG.RETENTION_HOURS * 3600);
            } else {
                // Fallback para mock básico - usar storage simple
                await _redis.redisCache.set(`${listKey}:latest`, value.toString());
            }
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to record metric value', error);
        }
    }
    /**
   * Genera clave de ventana temporal
   */ getWindowKey(baseKey, timestamp) {
        const windowStart = Math.floor(timestamp / (METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000));
        return `${baseKey}:${windowStart}`;
    }
    /**
   * Obtiene métricas agregadas para un endpoint
   */ async getApiMetrics(endpoint, method, hoursBack = 1) {
        const baseKey = `metrics:${endpoint}:${method}`;
        const now = Date.now();
        const startTime = now - hoursBack * 60 * 60 * 1000;
        try {
            // Obtener contadores
            const requests = await this.getCounterSum(baseKey, 'requests', startTime, now);
            const errors = await this.getCounterSum(baseKey, 'errors', startTime, now);
            // Obtener tiempos de respuesta
            const responseTimes = await this.getValueStats(`${baseKey}:response_time`, startTime, now);
            // Obtener métricas de retry
            const retryStats = await this.getRetryStats(endpoint, startTime, now);
            return {
                requests: {
                    total: requests.total || 0,
                    success: requests.success || 0,
                    error: requests.error || 0,
                    rate_limited: requests.rate_limited || 0
                },
                response_times: responseTimes,
                error_rates: {
                    '4xx': errors['4xx'] || 0,
                    '5xx': errors['5xx'] || 0,
                    network: errors.network || 0,
                    timeout: errors.timeout || 0
                },
                retry_stats: retryStats
            };
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to get API metrics', error);
            // Retornar métricas vacías en caso de error
            return this.getEmptyApiMetrics();
        }
    }
    /**
   * Obtiene suma de contadores en un rango de tiempo
   */ async getCounterSum(baseKey, category, startTime, endTime) {
        const result = {};
        const windowSize = METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000;
        for(let time = startTime; time <= endTime; time += windowSize){
            const windowStart = Math.floor(time / windowSize);
            // Obtener diferentes tipos de contadores
            const types = [
                'total',
                'success',
                'error',
                'rate_limited',
                '4xx',
                '5xx',
                'network',
                'timeout'
            ];
            for (const type of types){
                const key = `${baseKey}:${category}:${type}:${windowStart}`;
                const value = await _redis.redisCache.get(key);
                result[type] = (result[type] || 0) + parseInt(value || '0');
            }
        }
        return result;
    }
    /**
   * Obtiene estadísticas de valores numéricos
   */ async getValueStats(baseKey, startTime, endTime) {
        const values = [];
        const windowSize = METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000;
        for(let time = startTime; time <= endTime; time += windowSize){
            const windowStart = Math.floor(time / windowSize);
            const key = `${baseKey}:${windowStart}:values`;
            try {
                const client = _redis.redisCache['client'] || _redis.redisCache;
                if (typeof client.lrange === 'function') {
                    const windowValues = await client.lrange(key, 0, -1);
                    values.push(...windowValues.map((v)=>parseFloat(v)).filter((v)=>!isNaN(v)));
                } else {
                    // Fallback para mock básico
                    const value = await _redis.redisCache.get(`${key}:latest`);
                    if (value) {
                        const numValue = parseFloat(value);
                        if (!isNaN(numValue)) {
                            values.push(numValue);
                        }
                    }
                }
            } catch (error) {
            // Continuar si no se puede obtener valores de una ventana
            }
        }
        if (values.length === 0) {
            return {
                count: 0,
                sum: 0,
                avg: 0,
                min: 0,
                max: 0,
                p95: 0,
                p99: 0
            };
        }
        values.sort((a, b)=>a - b);
        const sum = values.reduce((a, b)=>a + b, 0);
        return {
            count: values.length,
            sum,
            avg: sum / values.length,
            min: values[0],
            max: values[values.length - 1],
            p95: values[Math.floor(values.length * 0.95)] || 0,
            p99: values[Math.floor(values.length * 0.99)] || 0
        };
    }
    /**
   * Obtiene estadísticas de retry
   */ async getRetryStats(operation, startTime, endTime) {
        const baseKey = `metrics:retry:${operation}`;
        const counters = await this.getCounterSum(baseKey, '', startTime, endTime);
        const attempts = await this.getValueStats(`${baseKey}:attempts`, startTime, endTime);
        return {
            total_retries: counters.total || 0,
            successful_retries: counters.success || 0,
            failed_retries: counters.failed || 0,
            avg_attempts: attempts.avg || 0
        };
    }
    /**
   * Obtiene métricas específicas de MercadoPago
   */ async getMercadoPagoMetrics(hoursBack = 1) {
        try {
            const [paymentCreation, paymentQueries, webhookProcessing] = await Promise.all([
                this.getApiMetrics('/api/payments/create-preference', 'POST', hoursBack),
                this.getApiMetrics('/api/payments/query', 'GET', hoursBack),
                this.getApiMetrics('/api/webhooks/mercadopago', 'POST', hoursBack)
            ]);
            // Calcular métricas generales de salud
            const totalRequests = paymentCreation.requests.total + paymentQueries.requests.total + webhookProcessing.requests.total;
            const totalErrors = paymentCreation.requests.error + paymentQueries.requests.error + webhookProcessing.requests.error;
            const overallErrorRate = totalRequests > 0 ? totalErrors / totalRequests : 0;
            const avgResponseTime = totalRequests > 0 ? (paymentCreation.response_times.avg * paymentCreation.requests.total + paymentQueries.response_times.avg * paymentQueries.requests.total + webhookProcessing.response_times.avg * webhookProcessing.requests.total) / totalRequests : 0;
            return {
                payment_creation: paymentCreation,
                payment_queries: paymentQueries,
                webhook_processing: webhookProcessing,
                overall_health: {
                    uptime_percentage: overallErrorRate < 0.05 ? 99.9 : 95.0,
                    avg_response_time: avgResponseTime,
                    error_rate: overallErrorRate,
                    last_incident: overallErrorRate > 0.1 ? new Date().toISOString() : null
                }
            };
        } catch (error) {
            console.error('Error getting MercadoPago metrics:', error);
            // Retornar métricas vacías en caso de error
            const emptyMetrics = this.getEmptyApiMetrics();
            return {
                payment_creation: emptyMetrics,
                payment_queries: emptyMetrics,
                webhook_processing: emptyMetrics,
                overall_health: {
                    uptime_percentage: 0,
                    avg_response_time: 0,
                    error_rate: 1,
                    last_incident: new Date().toISOString()
                }
            };
        }
    }
    /**
   * Retorna métricas vacías por defecto
   */ getEmptyApiMetrics() {
        return {
            requests: {
                total: 0,
                success: 0,
                error: 0,
                rate_limited: 0
            },
            response_times: {
                count: 0,
                sum: 0,
                avg: 0,
                min: 0,
                max: 0,
                p95: 0,
                p99: 0
            },
            error_rates: {
                '4xx': 0,
                '5xx': 0,
                network: 0,
                timeout: 0
            },
            retry_stats: {
                total_retries: 0,
                successful_retries: 0,
                failed_retries: 0,
                avg_attempts: 0
            }
        };
    }
}
const metricsCollector = MetricsCollector.getInstance();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcbGliXFxtZXRyaWNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBJTlRFWUEgRS1DT01NRVJDRSAtIE1FVFJJQ1MgU1lTVEVNXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbXBvcnQgeyByZWRpc0NhY2hlIH0gZnJvbSAnLi9yZWRpcyc7XHJcbmltcG9ydCB7IGxvZ2dlciwgTG9nTGV2ZWwsIExvZ0NhdGVnb3J5IH0gZnJvbSAnLi9sb2dnZXInO1xyXG5cclxuLy8gVGlwb3MgZGUgbcOpdHJpY2FzXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljRGF0YSB7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgdmFsdWU6IG51bWJlcjtcclxuICBsYWJlbHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFnZ3JlZ2F0ZWRNZXRyaWMge1xyXG4gIGNvdW50OiBudW1iZXI7XHJcbiAgc3VtOiBudW1iZXI7XHJcbiAgYXZnOiBudW1iZXI7XHJcbiAgbWluOiBudW1iZXI7XHJcbiAgbWF4OiBudW1iZXI7XHJcbiAgcDk1OiBudW1iZXI7XHJcbiAgcDk5OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXBpTWV0cmljcyB7XHJcbiAgcmVxdWVzdHM6IHtcclxuICAgIHRvdGFsOiBudW1iZXI7XHJcbiAgICBzdWNjZXNzOiBudW1iZXI7XHJcbiAgICBlcnJvcjogbnVtYmVyO1xyXG4gICAgcmF0ZV9saW1pdGVkOiBudW1iZXI7XHJcbiAgfTtcclxuICByZXNwb25zZV90aW1lczogQWdncmVnYXRlZE1ldHJpYztcclxuICBlcnJvcl9yYXRlczoge1xyXG4gICAgJzR4eCc6IG51bWJlcjtcclxuICAgICc1eHgnOiBudW1iZXI7XHJcbiAgICBuZXR3b3JrOiBudW1iZXI7XHJcbiAgICB0aW1lb3V0OiBudW1iZXI7XHJcbiAgfTtcclxuICByZXRyeV9zdGF0czoge1xyXG4gICAgdG90YWxfcmV0cmllczogbnVtYmVyO1xyXG4gICAgc3VjY2Vzc2Z1bF9yZXRyaWVzOiBudW1iZXI7XHJcbiAgICBmYWlsZWRfcmV0cmllczogbnVtYmVyO1xyXG4gICAgYXZnX2F0dGVtcHRzOiBudW1iZXI7XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXJjYWRvUGFnb01ldHJpY3Mge1xyXG4gIHBheW1lbnRfY3JlYXRpb246IEFwaU1ldHJpY3M7XHJcbiAgcGF5bWVudF9xdWVyaWVzOiBBcGlNZXRyaWNzO1xyXG4gIHdlYmhvb2tfcHJvY2Vzc2luZzogQXBpTWV0cmljcztcclxuICBvdmVyYWxsX2hlYWx0aDoge1xyXG4gICAgdXB0aW1lX3BlcmNlbnRhZ2U6IG51bWJlcjtcclxuICAgIGF2Z19yZXNwb25zZV90aW1lOiBudW1iZXI7XHJcbiAgICBlcnJvcl9yYXRlOiBudW1iZXI7XHJcbiAgICBsYXN0X2luY2lkZW50OiBzdHJpbmcgfCBudWxsO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIENvbmZpZ3VyYWNpw7NuIGRlIG3DqXRyaWNhc1xyXG5jb25zdCBNRVRSSUNTX0NPTkZJRyA9IHtcclxuICBSRVRFTlRJT05fSE9VUlM6IDI0LFxyXG4gIEFHR1JFR0FUSU9OX1dJTkRPV19NSU5VVEVTOiA1LFxyXG4gIEFMRVJUX1RIUkVTSE9MRFM6IHtcclxuICAgIEVSUk9SX1JBVEU6IDAuMDUsIC8vIDUlXHJcbiAgICBSRVNQT05TRV9USU1FX1A5NTogNTAwMCwgLy8gNSBzZWd1bmRvc1xyXG4gICAgUkFURV9MSU1JVF9SQVRFOiAwLjEsIC8vIDEwJVxyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc2UgcHJpbmNpcGFsIHBhcmEgbWFuZWpvIGRlIG3DqXRyaWNhc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1ldHJpY3NDb2xsZWN0b3Ige1xyXG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBNZXRyaWNzQ29sbGVjdG9yO1xyXG5cclxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cclxuXHJcbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IE1ldHJpY3NDb2xsZWN0b3Ige1xyXG4gICAgaWYgKCFNZXRyaWNzQ29sbGVjdG9yLmluc3RhbmNlKSB7XHJcbiAgICAgIE1ldHJpY3NDb2xsZWN0b3IuaW5zdGFuY2UgPSBuZXcgTWV0cmljc0NvbGxlY3RvcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1ldHJpY3NDb2xsZWN0b3IuaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RyYSB1bmEgbcOpdHJpY2EgZGUgcmVxdWVzdFxyXG4gICAqL1xyXG4gIGFzeW5jIHJlY29yZFJlcXVlc3QoXHJcbiAgICBlbmRwb2ludDogc3RyaW5nLFxyXG4gICAgbWV0aG9kOiBzdHJpbmcsXHJcbiAgICBzdGF0dXNDb2RlOiBudW1iZXIsXHJcbiAgICByZXNwb25zZVRpbWU6IG51bWJlcixcclxuICAgIGxhYmVsczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9XHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgYmFzZUtleSA9IGBtZXRyaWNzOiR7ZW5kcG9pbnR9OiR7bWV0aG9kfWA7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gUmVnaXN0cmFyIHJlcXVlc3QgdG90YWxcclxuICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnJlcXVlc3RzOnRvdGFsYCwgdGltZXN0YW1wKTtcclxuXHJcbiAgICAgIC8vIFJlZ2lzdHJhciBwb3IgdGlwbyBkZSByZXNwdWVzdGFcclxuICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPCAzMDApIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmluY3JlbWVudENvdW50ZXIoYCR7YmFzZUtleX06cmVxdWVzdHM6c3VjY2Vzc2AsIHRpbWVzdGFtcCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzQ29kZSA9PT0gNDI5KSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnJlcXVlc3RzOnJhdGVfbGltaXRlZGAsIHRpbWVzdGFtcCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnJlcXVlc3RzOmVycm9yYCwgdGltZXN0YW1wKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDYXRlZ29yaXphciBlcnJvcmVzXHJcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gNDAwICYmIHN0YXR1c0NvZGUgPCA1MDApIHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuaW5jcmVtZW50Q291bnRlcihgJHtiYXNlS2V5fTplcnJvcnM6NHh4YCwgdGltZXN0YW1wKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1c0NvZGUgPj0gNTAwKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmluY3JlbWVudENvdW50ZXIoYCR7YmFzZUtleX06ZXJyb3JzOjV4eGAsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZWdpc3RyYXIgdGllbXBvIGRlIHJlc3B1ZXN0YVxyXG4gICAgICBhd2FpdCB0aGlzLnJlY29yZFZhbHVlKGAke2Jhc2VLZXl9OnJlc3BvbnNlX3RpbWVgLCByZXNwb25zZVRpbWUsIHRpbWVzdGFtcCk7XHJcblxyXG4gICAgICAvLyBMb2cgcGFyYSBkZWJ1Z2dpbmdcclxuICAgICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuQVBJLCAnTWV0cmljIHJlY29yZGVkJyk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0ZhaWxlZCB0byByZWNvcmQgbWV0cmljJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0cmEgdW5hIGxsYW1hZGEgYSBBUEkgKGFsaWFzIHBhcmEgcmVjb3JkUmVxdWVzdClcclxuICAgKi9cclxuICBhc3luYyByZWNvcmRBcGlDYWxsKHBhcmFtczoge1xyXG4gICAgZW5kcG9pbnQ6IHN0cmluZztcclxuICAgIG1ldGhvZDogc3RyaW5nO1xyXG4gICAgc3RhdHVzQ29kZTogbnVtYmVyO1xyXG4gICAgcmVzcG9uc2VUaW1lOiBudW1iZXI7XHJcbiAgICB1c2VySWQ/OiBzdHJpbmc7XHJcbiAgICBlcnJvcj86IHN0cmluZztcclxuICB9KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCB0aGlzLnJlY29yZFJlcXVlc3QoXHJcbiAgICAgIHBhcmFtcy5lbmRwb2ludCxcclxuICAgICAgcGFyYW1zLm1ldGhvZCxcclxuICAgICAgcGFyYW1zLnN0YXR1c0NvZGUsXHJcbiAgICAgIHBhcmFtcy5yZXNwb25zZVRpbWUsXHJcbiAgICAgIHtcclxuICAgICAgICB1c2VySWQ6IHBhcmFtcy51c2VySWQgfHwgJ2Fub255bW91cycsXHJcbiAgICAgICAgZXJyb3I6IHBhcmFtcy5lcnJvciB8fCAnJ1xyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0cmEgbcOpdHJpY2FzIGRlIHJldHJ5XHJcbiAgICovXHJcbiAgYXN5bmMgcmVjb3JkUmV0cnkoXHJcbiAgICBvcGVyYXRpb246IHN0cmluZyxcclxuICAgIGF0dGVtcHRzOiBudW1iZXIsXHJcbiAgICBzdWNjZXNzOiBib29sZWFuLFxyXG4gICAgdG90YWxEdXJhdGlvbjogbnVtYmVyXHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgYmFzZUtleSA9IGBtZXRyaWNzOnJldHJ5OiR7b3BlcmF0aW9ufWA7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnRvdGFsYCwgdGltZXN0YW1wKTtcclxuICAgICAgYXdhaXQgdGhpcy5yZWNvcmRWYWx1ZShgJHtiYXNlS2V5fTphdHRlbXB0c2AsIGF0dGVtcHRzLCB0aW1lc3RhbXApO1xyXG4gICAgICBhd2FpdCB0aGlzLnJlY29yZFZhbHVlKGAke2Jhc2VLZXl9OmR1cmF0aW9uYCwgdG90YWxEdXJhdGlvbiwgdGltZXN0YW1wKTtcclxuXHJcbiAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnN1Y2Nlc3NgLCB0aW1lc3RhbXApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuaW5jcmVtZW50Q291bnRlcihgJHtiYXNlS2V5fTpmYWlsZWRgLCB0aW1lc3RhbXApO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0ZhaWxlZCB0byByZWNvcmQgcmV0cnkgbWV0cmljJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0cmEgbcOpdHJpY2FzIGRlIHJhdGUgbGltaXRpbmdcclxuICAgKi9cclxuICBhc3luYyByZWNvcmRSYXRlTGltaXQoXHJcbiAgICBlbmRwb2ludDogc3RyaW5nLFxyXG4gICAgYmxvY2tlZDogYm9vbGVhbixcclxuICAgIHJlbWFpbmluZzogbnVtYmVyLFxyXG4gICAgbGltaXQ6IG51bWJlclxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IGJhc2VLZXkgPSBgbWV0cmljczpyYXRlX2xpbWl0OiR7ZW5kcG9pbnR9YDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLmluY3JlbWVudENvdW50ZXIoYCR7YmFzZUtleX06Y2hlY2tzYCwgdGltZXN0YW1wKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChibG9ja2VkKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OmJsb2NrZWRgLCB0aW1lc3RhbXApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLnJlY29yZFZhbHVlKGAke2Jhc2VLZXl9OnJlbWFpbmluZ2AsIHJlbWFpbmluZywgdGltZXN0YW1wKTtcclxuICAgICAgYXdhaXQgdGhpcy5yZWNvcmRWYWx1ZShgJHtiYXNlS2V5fTp1dGlsaXphdGlvbmAsIChsaW1pdCAtIHJlbWFpbmluZykgLyBsaW1pdCwgdGltZXN0YW1wKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnRmFpbGVkIHRvIHJlY29yZCByYXRlIGxpbWl0IG1ldHJpYycsIGVycm9yIGFzIEVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluY3JlbWVudGEgdW4gY29udGFkb3JcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGluY3JlbWVudENvdW50ZXIoa2V5OiBzdHJpbmcsIHRpbWVzdGFtcDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB3aW5kb3dLZXkgPSB0aGlzLmdldFdpbmRvd0tleShrZXksIHRpbWVzdGFtcCk7XHJcbiAgICBhd2FpdCByZWRpc0NhY2hlLmluY3Iod2luZG93S2V5KTtcclxuICAgIGF3YWl0IHJlZGlzQ2FjaGUuZXhwaXJlKHdpbmRvd0tleSwgTUVUUklDU19DT05GSUcuUkVURU5USU9OX0hPVVJTICogMzYwMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RyYSB1biB2YWxvciBudW3DqXJpY29cclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHJlY29yZFZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyLCB0aW1lc3RhbXA6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgd2luZG93S2V5ID0gdGhpcy5nZXRXaW5kb3dLZXkoa2V5LCB0aW1lc3RhbXApO1xyXG4gICAgICBjb25zdCBsaXN0S2V5ID0gYCR7d2luZG93S2V5fTp2YWx1ZXNgO1xyXG5cclxuICAgICAgLy8gT2J0ZW5lciBjbGllbnRlIFJlZGlzIChyZWFsIG8gbW9jaylcclxuICAgICAgY29uc3QgY2xpZW50ID0gcmVkaXNDYWNoZVsnY2xpZW50J10gfHwgcmVkaXNDYWNoZTtcclxuXHJcbiAgICAgIC8vIFZlcmlmaWNhciBzaSBlbCBjbGllbnRlIHRpZW5lIGxvcyBtw6l0b2RvcyBuZWNlc2FyaW9zXHJcbiAgICAgIGlmICh0eXBlb2YgY2xpZW50LmxwdXNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgYXdhaXQgY2xpZW50LmxwdXNoKGxpc3RLZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIGF3YWl0IGNsaWVudC5sdHJpbShsaXN0S2V5LCAwLCA5OTkpOyAvLyBNYW50ZW5lciDDumx0aW1vcyAxMDAwIHZhbG9yZXNcclxuICAgICAgICBhd2FpdCBjbGllbnQuZXhwaXJlKGxpc3RLZXksIE1FVFJJQ1NfQ09ORklHLlJFVEVOVElPTl9IT1VSUyAqIDM2MDApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEZhbGxiYWNrIHBhcmEgbW9jayBiw6FzaWNvIC0gdXNhciBzdG9yYWdlIHNpbXBsZVxyXG4gICAgICAgIGF3YWl0IHJlZGlzQ2FjaGUuc2V0KGAke2xpc3RLZXl9OmxhdGVzdGAsIHZhbHVlLnRvU3RyaW5nKCkpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnRmFpbGVkIHRvIHJlY29yZCBtZXRyaWMgdmFsdWUnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmEgY2xhdmUgZGUgdmVudGFuYSB0ZW1wb3JhbFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0V2luZG93S2V5KGJhc2VLZXk6IHN0cmluZywgdGltZXN0YW1wOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgY29uc3Qgd2luZG93U3RhcnQgPSBNYXRoLmZsb29yKHRpbWVzdGFtcCAvIChNRVRSSUNTX0NPTkZJRy5BR0dSRUdBVElPTl9XSU5ET1dfTUlOVVRFUyAqIDYwICogMTAwMCkpO1xyXG4gICAgcmV0dXJuIGAke2Jhc2VLZXl9OiR7d2luZG93U3RhcnR9YDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgbcOpdHJpY2FzIGFncmVnYWRhcyBwYXJhIHVuIGVuZHBvaW50XHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0QXBpTWV0cmljcyhlbmRwb2ludDogc3RyaW5nLCBtZXRob2Q6IHN0cmluZywgaG91cnNCYWNrOiBudW1iZXIgPSAxKTogUHJvbWlzZTxBcGlNZXRyaWNzPiB7XHJcbiAgICBjb25zdCBiYXNlS2V5ID0gYG1ldHJpY3M6JHtlbmRwb2ludH06JHttZXRob2R9YDtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBub3cgLSAoaG91cnNCYWNrICogNjAgKiA2MCAqIDEwMDApO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIE9idGVuZXIgY29udGFkb3Jlc1xyXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IGF3YWl0IHRoaXMuZ2V0Q291bnRlclN1bShiYXNlS2V5LCAncmVxdWVzdHMnLCBzdGFydFRpbWUsIG5vdyk7XHJcbiAgICAgIGNvbnN0IGVycm9ycyA9IGF3YWl0IHRoaXMuZ2V0Q291bnRlclN1bShiYXNlS2V5LCAnZXJyb3JzJywgc3RhcnRUaW1lLCBub3cpO1xyXG4gICAgICBcclxuICAgICAgLy8gT2J0ZW5lciB0aWVtcG9zIGRlIHJlc3B1ZXN0YVxyXG4gICAgICBjb25zdCByZXNwb25zZVRpbWVzID0gYXdhaXQgdGhpcy5nZXRWYWx1ZVN0YXRzKGAke2Jhc2VLZXl9OnJlc3BvbnNlX3RpbWVgLCBzdGFydFRpbWUsIG5vdyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBPYnRlbmVyIG3DqXRyaWNhcyBkZSByZXRyeVxyXG4gICAgICBjb25zdCByZXRyeVN0YXRzID0gYXdhaXQgdGhpcy5nZXRSZXRyeVN0YXRzKGVuZHBvaW50LCBzdGFydFRpbWUsIG5vdyk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlcXVlc3RzOiB7XHJcbiAgICAgICAgICB0b3RhbDogcmVxdWVzdHMudG90YWwgfHwgMCxcclxuICAgICAgICAgIHN1Y2Nlc3M6IHJlcXVlc3RzLnN1Y2Nlc3MgfHwgMCxcclxuICAgICAgICAgIGVycm9yOiByZXF1ZXN0cy5lcnJvciB8fCAwLFxyXG4gICAgICAgICAgcmF0ZV9saW1pdGVkOiByZXF1ZXN0cy5yYXRlX2xpbWl0ZWQgfHwgMCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc3BvbnNlX3RpbWVzOiByZXNwb25zZVRpbWVzLFxyXG4gICAgICAgIGVycm9yX3JhdGVzOiB7XHJcbiAgICAgICAgICAnNHh4JzogZXJyb3JzWyc0eHgnXSB8fCAwLFxyXG4gICAgICAgICAgJzV4eCc6IGVycm9yc1snNXh4J10gfHwgMCxcclxuICAgICAgICAgIG5ldHdvcms6IGVycm9ycy5uZXR3b3JrIHx8IDAsXHJcbiAgICAgICAgICB0aW1lb3V0OiBlcnJvcnMudGltZW91dCB8fCAwLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmV0cnlfc3RhdHM6IHJldHJ5U3RhdHMsXHJcbiAgICAgIH07XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0ZhaWxlZCB0byBnZXQgQVBJIG1ldHJpY3MnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXRvcm5hciBtw6l0cmljYXMgdmFjw61hcyBlbiBjYXNvIGRlIGVycm9yXHJcbiAgICAgIHJldHVybiB0aGlzLmdldEVtcHR5QXBpTWV0cmljcygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT2J0aWVuZSBzdW1hIGRlIGNvbnRhZG9yZXMgZW4gdW4gcmFuZ28gZGUgdGllbXBvXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRDb3VudGVyU3VtKFxyXG4gICAgYmFzZUtleTogc3RyaW5nLCBcclxuICAgIGNhdGVnb3J5OiBzdHJpbmcsIFxyXG4gICAgc3RhcnRUaW1lOiBudW1iZXIsIFxyXG4gICAgZW5kVGltZTogbnVtYmVyXHJcbiAgKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiB7XHJcbiAgICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcclxuICAgIGNvbnN0IHdpbmRvd1NpemUgPSBNRVRSSUNTX0NPTkZJRy5BR0dSRUdBVElPTl9XSU5ET1dfTUlOVVRFUyAqIDYwICogMTAwMDtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgdGltZSA9IHN0YXJ0VGltZTsgdGltZSA8PSBlbmRUaW1lOyB0aW1lICs9IHdpbmRvd1NpemUpIHtcclxuICAgICAgY29uc3Qgd2luZG93U3RhcnQgPSBNYXRoLmZsb29yKHRpbWUgLyB3aW5kb3dTaXplKTtcclxuICAgICAgXHJcbiAgICAgIC8vIE9idGVuZXIgZGlmZXJlbnRlcyB0aXBvcyBkZSBjb250YWRvcmVzXHJcbiAgICAgIGNvbnN0IHR5cGVzID0gWyd0b3RhbCcsICdzdWNjZXNzJywgJ2Vycm9yJywgJ3JhdGVfbGltaXRlZCcsICc0eHgnLCAnNXh4JywgJ25ldHdvcmsnLCAndGltZW91dCddO1xyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7YmFzZUtleX06JHtjYXRlZ29yeX06JHt0eXBlfToke3dpbmRvd1N0YXJ0fWA7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCByZWRpc0NhY2hlLmdldChrZXkpO1xyXG4gICAgICAgIHJlc3VsdFt0eXBlXSA9IChyZXN1bHRbdHlwZV0gfHwgMCkgKyAocGFyc2VJbnQodmFsdWUgfHwgJzAnKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgZXN0YWTDrXN0aWNhcyBkZSB2YWxvcmVzIG51bcOpcmljb3NcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGdldFZhbHVlU3RhdHMoXHJcbiAgICBiYXNlS2V5OiBzdHJpbmcsXHJcbiAgICBzdGFydFRpbWU6IG51bWJlcixcclxuICAgIGVuZFRpbWU6IG51bWJlclxyXG4gICk6IFByb21pc2U8QWdncmVnYXRlZE1ldHJpYz4ge1xyXG4gICAgY29uc3QgdmFsdWVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IE1FVFJJQ1NfQ09ORklHLkFHR1JFR0FUSU9OX1dJTkRPV19NSU5VVEVTICogNjAgKiAxMDAwO1xyXG5cclxuICAgIGZvciAobGV0IHRpbWUgPSBzdGFydFRpbWU7IHRpbWUgPD0gZW5kVGltZTsgdGltZSArPSB3aW5kb3dTaXplKSB7XHJcbiAgICAgIGNvbnN0IHdpbmRvd1N0YXJ0ID0gTWF0aC5mbG9vcih0aW1lIC8gd2luZG93U2l6ZSk7XHJcbiAgICAgIGNvbnN0IGtleSA9IGAke2Jhc2VLZXl9OiR7d2luZG93U3RhcnR9OnZhbHVlc2A7XHJcblxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHJlZGlzQ2FjaGVbJ2NsaWVudCddIHx8IHJlZGlzQ2FjaGU7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY2xpZW50LmxyYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgY29uc3Qgd2luZG93VmFsdWVzID0gYXdhaXQgY2xpZW50LmxyYW5nZShrZXksIDAsIC0xKTtcclxuICAgICAgICAgIHZhbHVlcy5wdXNoKC4uLndpbmRvd1ZhbHVlcy5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKS5maWx0ZXIodiA9PiAhaXNOYU4odikpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gRmFsbGJhY2sgcGFyYSBtb2NrIGLDoXNpY29cclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcmVkaXNDYWNoZS5nZXQoYCR7a2V5fTpsYXRlc3RgKTtcclxuICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBudW1WYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKG51bVZhbHVlKSkge1xyXG4gICAgICAgICAgICAgIHZhbHVlcy5wdXNoKG51bVZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAvLyBDb250aW51YXIgc2kgbm8gc2UgcHVlZGUgb2J0ZW5lciB2YWxvcmVzIGRlIHVuYSB2ZW50YW5hXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4geyBjb3VudDogMCwgc3VtOiAwLCBhdmc6IDAsIG1pbjogMCwgbWF4OiAwLCBwOTU6IDAsIHA5OTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICBjb25zdCBzdW0gPSB2YWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvdW50OiB2YWx1ZXMubGVuZ3RoLFxyXG4gICAgICBzdW0sXHJcbiAgICAgIGF2Zzogc3VtIC8gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgbWluOiB2YWx1ZXNbMF0sXHJcbiAgICAgIG1heDogdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSxcclxuICAgICAgcDk1OiB2YWx1ZXNbTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoICogMC45NSldIHx8IDAsXHJcbiAgICAgIHA5OTogdmFsdWVzW01hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAqIDAuOTkpXSB8fCAwLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgZXN0YWTDrXN0aWNhcyBkZSByZXRyeVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZ2V0UmV0cnlTdGF0cyhcclxuICAgIG9wZXJhdGlvbjogc3RyaW5nLCBcclxuICAgIHN0YXJ0VGltZTogbnVtYmVyLCBcclxuICAgIGVuZFRpbWU6IG51bWJlclxyXG4gICk6IFByb21pc2U8QXBpTWV0cmljc1sncmV0cnlfc3RhdHMnXT4ge1xyXG4gICAgY29uc3QgYmFzZUtleSA9IGBtZXRyaWNzOnJldHJ5OiR7b3BlcmF0aW9ufWA7XHJcbiAgICBjb25zdCBjb3VudGVycyA9IGF3YWl0IHRoaXMuZ2V0Q291bnRlclN1bShiYXNlS2V5LCAnJywgc3RhcnRUaW1lLCBlbmRUaW1lKTtcclxuICAgIGNvbnN0IGF0dGVtcHRzID0gYXdhaXQgdGhpcy5nZXRWYWx1ZVN0YXRzKGAke2Jhc2VLZXl9OmF0dGVtcHRzYCwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbF9yZXRyaWVzOiBjb3VudGVycy50b3RhbCB8fCAwLFxyXG4gICAgICBzdWNjZXNzZnVsX3JldHJpZXM6IGNvdW50ZXJzLnN1Y2Nlc3MgfHwgMCxcclxuICAgICAgZmFpbGVkX3JldHJpZXM6IGNvdW50ZXJzLmZhaWxlZCB8fCAwLFxyXG4gICAgICBhdmdfYXR0ZW1wdHM6IGF0dGVtcHRzLmF2ZyB8fCAwLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgbcOpdHJpY2FzIGVzcGVjw61maWNhcyBkZSBNZXJjYWRvUGFnb1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldE1lcmNhZG9QYWdvTWV0cmljcyhob3Vyc0JhY2s6IG51bWJlciA9IDEpOiBQcm9taXNlPE1lcmNhZG9QYWdvTWV0cmljcz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgW3BheW1lbnRDcmVhdGlvbiwgcGF5bWVudFF1ZXJpZXMsIHdlYmhvb2tQcm9jZXNzaW5nXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICB0aGlzLmdldEFwaU1ldHJpY3MoJy9hcGkvcGF5bWVudHMvY3JlYXRlLXByZWZlcmVuY2UnLCAnUE9TVCcsIGhvdXJzQmFjayksXHJcbiAgICAgICAgdGhpcy5nZXRBcGlNZXRyaWNzKCcvYXBpL3BheW1lbnRzL3F1ZXJ5JywgJ0dFVCcsIGhvdXJzQmFjayksXHJcbiAgICAgICAgdGhpcy5nZXRBcGlNZXRyaWNzKCcvYXBpL3dlYmhvb2tzL21lcmNhZG9wYWdvJywgJ1BPU1QnLCBob3Vyc0JhY2spLFxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGFyIG3DqXRyaWNhcyBnZW5lcmFsZXMgZGUgc2FsdWRcclxuICAgICAgY29uc3QgdG90YWxSZXF1ZXN0cyA9IHBheW1lbnRDcmVhdGlvbi5yZXF1ZXN0cy50b3RhbCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRRdWVyaWVzLnJlcXVlc3RzLnRvdGFsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViaG9va1Byb2Nlc3NpbmcucmVxdWVzdHMudG90YWw7XHJcblxyXG4gICAgICBjb25zdCB0b3RhbEVycm9ycyA9IHBheW1lbnRDcmVhdGlvbi5yZXF1ZXN0cy5lcnJvciArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50UXVlcmllcy5yZXF1ZXN0cy5lcnJvciArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJob29rUHJvY2Vzc2luZy5yZXF1ZXN0cy5lcnJvcjtcclxuXHJcbiAgICAgIGNvbnN0IG92ZXJhbGxFcnJvclJhdGUgPSB0b3RhbFJlcXVlc3RzID4gMCA/IHRvdGFsRXJyb3JzIC8gdG90YWxSZXF1ZXN0cyA6IDA7XHJcblxyXG4gICAgICBjb25zdCBhdmdSZXNwb25zZVRpbWUgPSB0b3RhbFJlcXVlc3RzID4gMCA/XHJcbiAgICAgICAgKHBheW1lbnRDcmVhdGlvbi5yZXNwb25zZV90aW1lcy5hdmcgKiBwYXltZW50Q3JlYXRpb24ucmVxdWVzdHMudG90YWwgK1xyXG4gICAgICAgICBwYXltZW50UXVlcmllcy5yZXNwb25zZV90aW1lcy5hdmcgKiBwYXltZW50UXVlcmllcy5yZXF1ZXN0cy50b3RhbCArXHJcbiAgICAgICAgIHdlYmhvb2tQcm9jZXNzaW5nLnJlc3BvbnNlX3RpbWVzLmF2ZyAqIHdlYmhvb2tQcm9jZXNzaW5nLnJlcXVlc3RzLnRvdGFsKSAvIHRvdGFsUmVxdWVzdHMgOiAwO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwYXltZW50X2NyZWF0aW9uOiBwYXltZW50Q3JlYXRpb24sXHJcbiAgICAgICAgcGF5bWVudF9xdWVyaWVzOiBwYXltZW50UXVlcmllcyxcclxuICAgICAgICB3ZWJob29rX3Byb2Nlc3Npbmc6IHdlYmhvb2tQcm9jZXNzaW5nLFxyXG4gICAgICAgIG92ZXJhbGxfaGVhbHRoOiB7XHJcbiAgICAgICAgICB1cHRpbWVfcGVyY2VudGFnZTogb3ZlcmFsbEVycm9yUmF0ZSA8IDAuMDUgPyA5OS45IDogOTUuMCwgLy8gU2ltcGxpZmljYWRvXHJcbiAgICAgICAgICBhdmdfcmVzcG9uc2VfdGltZTogYXZnUmVzcG9uc2VUaW1lLFxyXG4gICAgICAgICAgZXJyb3JfcmF0ZTogb3ZlcmFsbEVycm9yUmF0ZSxcclxuICAgICAgICAgIGxhc3RfaW5jaWRlbnQ6IG92ZXJhbGxFcnJvclJhdGUgPiAwLjEgPyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgOiBudWxsLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIE1lcmNhZG9QYWdvIG1ldHJpY3M6JywgZXJyb3IpO1xyXG4gICAgICAvLyBSZXRvcm5hciBtw6l0cmljYXMgdmFjw61hcyBlbiBjYXNvIGRlIGVycm9yXHJcbiAgICAgIGNvbnN0IGVtcHR5TWV0cmljcyA9IHRoaXMuZ2V0RW1wdHlBcGlNZXRyaWNzKCk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcGF5bWVudF9jcmVhdGlvbjogZW1wdHlNZXRyaWNzLFxyXG4gICAgICAgIHBheW1lbnRfcXVlcmllczogZW1wdHlNZXRyaWNzLFxyXG4gICAgICAgIHdlYmhvb2tfcHJvY2Vzc2luZzogZW1wdHlNZXRyaWNzLFxyXG4gICAgICAgIG92ZXJhbGxfaGVhbHRoOiB7XHJcbiAgICAgICAgICB1cHRpbWVfcGVyY2VudGFnZTogMCxcclxuICAgICAgICAgIGF2Z19yZXNwb25zZV90aW1lOiAwLFxyXG4gICAgICAgICAgZXJyb3JfcmF0ZTogMSxcclxuICAgICAgICAgIGxhc3RfaW5jaWRlbnQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0b3JuYSBtw6l0cmljYXMgdmFjw61hcyBwb3IgZGVmZWN0b1xyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0RW1wdHlBcGlNZXRyaWNzKCk6IEFwaU1ldHJpY3Mge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVxdWVzdHM6IHsgdG90YWw6IDAsIHN1Y2Nlc3M6IDAsIGVycm9yOiAwLCByYXRlX2xpbWl0ZWQ6IDAgfSxcclxuICAgICAgcmVzcG9uc2VfdGltZXM6IHsgY291bnQ6IDAsIHN1bTogMCwgYXZnOiAwLCBtaW46IDAsIG1heDogMCwgcDk1OiAwLCBwOTk6IDAgfSxcclxuICAgICAgZXJyb3JfcmF0ZXM6IHsgJzR4eCc6IDAsICc1eHgnOiAwLCBuZXR3b3JrOiAwLCB0aW1lb3V0OiAwIH0sXHJcbiAgICAgIHJldHJ5X3N0YXRzOiB7IHRvdGFsX3JldHJpZXM6IDAsIHN1Y2Nlc3NmdWxfcmV0cmllczogMCwgZmFpbGVkX3JldHJpZXM6IDAsIGF2Z19hdHRlbXB0czogMCB9LFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEluc3RhbmNpYSBzaW5nbGV0b25cclxuZXhwb3J0IGNvbnN0IG1ldHJpY3NDb2xsZWN0b3IgPSBNZXRyaWNzQ29sbGVjdG9yLmdldEluc3RhbmNlKCk7XHJcbiJdLCJuYW1lcyI6WyJNZXRyaWNzQ29sbGVjdG9yIiwibWV0cmljc0NvbGxlY3RvciIsIk1FVFJJQ1NfQ09ORklHIiwiUkVURU5USU9OX0hPVVJTIiwiQUdHUkVHQVRJT05fV0lORE9XX01JTlVURVMiLCJBTEVSVF9USFJFU0hPTERTIiwiRVJST1JfUkFURSIsIlJFU1BPTlNFX1RJTUVfUDk1IiwiUkFURV9MSU1JVF9SQVRFIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInJlY29yZFJlcXVlc3QiLCJlbmRwb2ludCIsIm1ldGhvZCIsInN0YXR1c0NvZGUiLCJyZXNwb25zZVRpbWUiLCJsYWJlbHMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwiYmFzZUtleSIsImluY3JlbWVudENvdW50ZXIiLCJyZWNvcmRWYWx1ZSIsImxvZ2dlciIsImluZm8iLCJMb2dDYXRlZ29yeSIsIkFQSSIsImVycm9yIiwicmVjb3JkQXBpQ2FsbCIsInBhcmFtcyIsInVzZXJJZCIsInJlY29yZFJldHJ5Iiwib3BlcmF0aW9uIiwiYXR0ZW1wdHMiLCJzdWNjZXNzIiwidG90YWxEdXJhdGlvbiIsInJlY29yZFJhdGVMaW1pdCIsImJsb2NrZWQiLCJyZW1haW5pbmciLCJsaW1pdCIsImtleSIsIndpbmRvd0tleSIsImdldFdpbmRvd0tleSIsInJlZGlzQ2FjaGUiLCJpbmNyIiwiZXhwaXJlIiwidmFsdWUiLCJsaXN0S2V5IiwiY2xpZW50IiwibHB1c2giLCJ0b1N0cmluZyIsImx0cmltIiwic2V0Iiwid2luZG93U3RhcnQiLCJNYXRoIiwiZmxvb3IiLCJnZXRBcGlNZXRyaWNzIiwiaG91cnNCYWNrIiwic3RhcnRUaW1lIiwicmVxdWVzdHMiLCJnZXRDb3VudGVyU3VtIiwiZXJyb3JzIiwicmVzcG9uc2VUaW1lcyIsImdldFZhbHVlU3RhdHMiLCJyZXRyeVN0YXRzIiwiZ2V0UmV0cnlTdGF0cyIsInRvdGFsIiwicmF0ZV9saW1pdGVkIiwicmVzcG9uc2VfdGltZXMiLCJlcnJvcl9yYXRlcyIsIm5ldHdvcmsiLCJ0aW1lb3V0IiwicmV0cnlfc3RhdHMiLCJnZXRFbXB0eUFwaU1ldHJpY3MiLCJjYXRlZ29yeSIsImVuZFRpbWUiLCJyZXN1bHQiLCJ3aW5kb3dTaXplIiwidGltZSIsInR5cGVzIiwidHlwZSIsImdldCIsInBhcnNlSW50IiwidmFsdWVzIiwibHJhbmdlIiwid2luZG93VmFsdWVzIiwicHVzaCIsIm1hcCIsInYiLCJwYXJzZUZsb2F0IiwiZmlsdGVyIiwiaXNOYU4iLCJudW1WYWx1ZSIsImxlbmd0aCIsImNvdW50Iiwic3VtIiwiYXZnIiwibWluIiwibWF4IiwicDk1IiwicDk5Iiwic29ydCIsImEiLCJiIiwicmVkdWNlIiwiY291bnRlcnMiLCJ0b3RhbF9yZXRyaWVzIiwic3VjY2Vzc2Z1bF9yZXRyaWVzIiwiZmFpbGVkX3JldHJpZXMiLCJmYWlsZWQiLCJhdmdfYXR0ZW1wdHMiLCJnZXRNZXJjYWRvUGFnb01ldHJpY3MiLCJwYXltZW50Q3JlYXRpb24iLCJwYXltZW50UXVlcmllcyIsIndlYmhvb2tQcm9jZXNzaW5nIiwiUHJvbWlzZSIsImFsbCIsInRvdGFsUmVxdWVzdHMiLCJ0b3RhbEVycm9ycyIsIm92ZXJhbGxFcnJvclJhdGUiLCJhdmdSZXNwb25zZVRpbWUiLCJwYXltZW50X2NyZWF0aW9uIiwicGF5bWVudF9xdWVyaWVzIiwid2ViaG9va19wcm9jZXNzaW5nIiwib3ZlcmFsbF9oZWFsdGgiLCJ1cHRpbWVfcGVyY2VudGFnZSIsImF2Z19yZXNwb25zZV90aW1lIiwiZXJyb3JfcmF0ZSIsImxhc3RfaW5jaWRlbnQiLCJ0b0lTT1N0cmluZyIsImNvbnNvbGUiLCJlbXB0eU1ldHJpY3MiXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDOzs7Ozs7Ozs7Ozs7UUFzRXpCQTtlQUFBQTs7UUF3WUFDO2VBQUFBOzs7dUJBNWNjO3dCQUNtQjtBQXFEOUMsNEJBQTRCO0FBQzVCLE1BQU1DLGlCQUFpQjtJQUNyQkMsaUJBQWlCO0lBQ2pCQyw0QkFBNEI7SUFDNUJDLGtCQUFrQjtRQUNoQkMsWUFBWTtRQUNaQyxtQkFBbUI7UUFDbkJDLGlCQUFpQjtJQUNuQjtBQUNGO0FBS08sTUFBTVI7SUFHWCxhQUFzQixDQUFDO0lBRXZCLE9BQU9TLGNBQWdDO1FBQ3JDLElBQUksQ0FBQ1QsaUJBQWlCVSxRQUFRLEVBQUU7WUFDOUJWLGlCQUFpQlUsUUFBUSxHQUFHLElBQUlWO1FBQ2xDO1FBQ0EsT0FBT0EsaUJBQWlCVSxRQUFRO0lBQ2xDO0lBRUE7O0dBRUMsR0FDRCxNQUFNQyxjQUNKQyxRQUFnQixFQUNoQkMsTUFBYyxFQUNkQyxVQUFrQixFQUNsQkMsWUFBb0IsRUFDcEJDLFNBQWlDLENBQUMsQ0FBQyxFQUNwQjtRQUNmLE1BQU1DLFlBQVlDLEtBQUtDLEdBQUc7UUFDMUIsTUFBTUMsVUFBVSxDQUFDLFFBQVEsRUFBRVIsU0FBUyxDQUFDLEVBQUVDLFFBQVE7UUFFL0MsSUFBSTtZQUNGLDBCQUEwQjtZQUMxQixNQUFNLElBQUksQ0FBQ1EsZ0JBQWdCLENBQUMsR0FBR0QsUUFBUSxlQUFlLENBQUMsRUFBRUg7WUFFekQs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