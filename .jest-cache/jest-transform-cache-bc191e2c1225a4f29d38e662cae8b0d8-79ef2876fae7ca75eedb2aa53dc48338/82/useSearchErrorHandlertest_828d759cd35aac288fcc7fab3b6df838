6d12ae4f08062708dd04905e4dde7f3f
// ===================================
// TESTS: useSearchErrorHandler Hook - Manejo robusto de errores
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useSearchErrorHandler = require("../../hooks/useSearchErrorHandler");
// ===================================
// SETUP
// ===================================
beforeEach(()=>{
    jest.clearAllMocks();
    jest.useFakeTimers();
    // Mock console methods to reduce noise
    jest.spyOn(console, 'warn').mockImplementation(()=>{});
    jest.spyOn(console, 'error').mockImplementation(()=>{});
});
afterEach(()=>{
    jest.useRealTimers();
    jest.restoreAllMocks();
});
// ===================================
// TESTS BÁSICOS
// ===================================
describe('useSearchErrorHandler Hook', ()=>{
    it('should initialize with default state', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        expect(result.current.currentError).toBe(null);
        expect(result.current.retryCount).toBe(0);
        expect(result.current.isRetrying).toBe(false);
        expect(result.current.hasError).toBe(false);
    });
    it('should accept custom retry configuration', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                retryConfig: {
                    maxRetries: 5,
                    baseDelay: 500
                }
            }));
        expect(result.current.retryConfig.maxRetries).toBe(5);
        expect(result.current.retryConfig.baseDelay).toBe(500);
    });
});
// ===================================
// TESTS DE CLASIFICACIÓN DE ERRORES
// ===================================
describe('useSearchErrorHandler - Error Classification', ()=>{
    it('should classify network errors correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const networkError = new TypeError('fetch failed');
        networkError.name = 'TypeError';
        (0, _react.act)(()=>{
            const error = result.current.handleError(networkError);
            expect(error.type).toBe('network');
            expect(error.retryable).toBe(true);
            expect(error.message).toContain('conexión');
        });
    });
    it('should classify timeout errors correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const timeoutError = new Error('timeout');
        timeoutError.name = 'AbortError';
        (0, _react.act)(()=>{
            const error = result.current.handleError(timeoutError);
            expect(error.type).toBe('timeout');
            expect(error.retryable).toBe(true);
            expect(error.message).toContain('tardó demasiado');
        });
    });
    it('should classify server errors correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const serverError = {
            status: 500,
            message: 'Internal Server Error'
        };
        (0, _react.act)(()=>{
            const error = result.current.handleError(serverError);
            expect(error.type).toBe('server');
            expect(error.retryable).toBe(true);
            expect(error.code).toBe('500');
        });
    });
    it('should classify validation errors correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const validationError = {
            status: 400,
            message: 'Bad Request'
        };
        (0, _react.act)(()=>{
            const error = result.current.handleError(validationError);
            expect(error.type).toBe('validation');
            expect(error.retryable).toBe(false);
            expect(error.code).toBe('400');
        });
    });
});
// ===================================
// TESTS DE RETRY AUTOMÁTICO
// ===================================
describe('useSearchErrorHandler - Retry Logic', ()=>{
    it('should retry failed operations with exponential backoff', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                retryConfig: {
                    maxRetries: 3,
                    baseDelay: 100,
                    backoffFactor: 2
                }
            }));
        let callCount = 0;
        const failingOperation = jest.fn().mockImplementation(()=>{
            callCount++;
            if (callCount < 3) {
                throw new Error('Network error');
            }
            return Promise.resolve('success');
        });
        let executePromise;
        await (0, _react.act)(async ()=>{
            executePromise = result.current.executeWithRetry(failingOperation, 'test operation');
        });
        // Avanzar timers para los retries
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(100); // Primer retry
            await Promise.resolve();
            jest.advanceTimersByTime(200); // Segundo retry
            await Promise.resolve();
        });
        const result_value = await executePromise;
        expect(result_value).toBe('success');
        expect(failingOperation).toHaveBeenCalledTimes(3);
    });
    it('should not retry non-retryable errors', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const nonRetryableOperation = jest.fn().mockRejectedValue({
            status: 400,
            message: 'Bad Request'
        });
        await (0, _react.act)(async ()=>{
            await expect(result.current.executeWithRetry(nonRetryableOperation, 'validation test')).rejects.toThrow();
        });
        expect(nonRetryableOperation).toHaveBeenCalledTimes(1);
    });
    it('should stop retrying after max attempts', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                retryConfig: {
                    maxRetries: 2,
                    baseDelay: 10
                }
            }));
        const alwaysFailingOperation = jest.fn().mockRejectedValue(new Error('Persistent error'));
        let executePromise;
        await (0, _react.act)(async ()=>{
            executePromise = result.current.executeWithRetry(alwaysFailingOperation, 'persistent failure test');
        });
        // Avanzar timers para todos los retries de forma más eficiente
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(10); // Primer retry
            await Promise.resolve();
            jest.advanceTimersByTime(20); // Segundo retry
            await Promise.resolve();
            jest.advanceTimersByTime(100); // Asegurar que todos los timers se ejecuten
        });
        await expect(executePromise).rejects.toThrow('Persistent error');
        expect(alwaysFailingOperation).toHaveBeenCalledTimes(3); // Original + 2 retries
    });
});
// ===================================
// TESTS DE CALLBACKS
// ===================================
describe('useSearchErrorHandler - Callbacks', ()=>{
    it('should call onError callback when error occurs', ()=>{
        const onError = jest.fn();
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                onError
            }));
        const testError = new Error('Test error');
        (0, _react.act)(()=>{
            result.current.handleError(testError);
        });
        expect(onError).toHaveBeenCalledWith(expect.objectContaining({
            type: 'unknown',
            message: 'Test error',
            retryable: true
        }));
    });
    it('should call onRetrySuccess callback on successful retry', async ()=>{
        const onRetrySuccess = jest.fn();
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                onRetrySuccess,
                retryConfig: {
                    maxRetries: 2,
                    baseDelay: 50
                }
            }));
        let callCount = 0;
        const retryOperation = jest.fn().mockImplementation(()=>{
            callCount++;
            if (callCount === 1) {
                throw new Error('First failure');
            }
            return Promise.resolve('success');
        });
        let executePromise;
        await (0, _react.act)(async ()=>{
            executePromise = result.current.executeWithRetry(retryOperation);
        });
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(50);
            await Promise.resolve();
        });
        await executePromise;
        expect(onRetrySuccess).toHaveBeenCalled();
    });
    it('should call onRetryFailed callback when all retries fail', async ()=>{
        const onRetryFailed = jest.fn();
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                onRetryFailed,
                retryConfig: {
                    maxRetries: 1,
                    baseDelay: 50
                }
            }));
        const failingOperation = jest.fn().mockRejectedValue(new Error('Always fails'));
        let executePromise;
        await (0, _react.act)(async ()=>{
            executePromise = result.current.executeWithRetry(failingOperation);
        });
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(50);
            await Promise.resolve();
        });
        await expect(executePromise).rejects.toThrow();
        expect(onRetryFailed).toHaveBeenCalledWith(expect.objectContaining({
            type: 'unknown',
            message: 'Always fails'
        }), 1 // número de intentos
        );
    });
});
// ===================================
// TESTS DE ESTADO
// ===================================
describe('useSearchErrorHandler - State Management', ()=>{
    it('should update retry state during retries', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                retryConfig: {
                    maxRetries: 2,
                    baseDelay: 50
                }
            }));
        let callCount = 0;
        const retryOperation = jest.fn().mockImplementation(()=>{
            callCount++;
            if (callCount < 3) {
                throw new Error('Retry test');
            }
            return Promise.resolve('success');
        });
        let executePromise;
        await (0, _react.act)(async ()=>{
            executePromise = result.current.executeWithRetry(retryOperation);
        });
        // Verificar estado durante primer retry
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(50);
            await Promise.resolve();
        });
        expect(result.current.isRetrying).toBe(true);
        expect(result.current.retryCount).toBe(1);
        // Completar la operación
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(100);
            await Promise.resolve();
        });
        await executePromise;
        expect(result.current.isRetrying).toBe(false);
        expect(result.current.retryCount).toBe(0);
    });
    it('should clear error state', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        // Simular error
        (0, _react.act)(()=>{
            result.current.handleError(new Error('Test error'));
        });
        expect(result.current.hasError).toBe(true);
        // Limpiar error
        (0, _react.act)(()=>{
            result.current.clearError();
        });
        expect(result.current.hasError).toBe(false);
        expect(result.current.currentError).toBe(null);
        expect(result.current.retryCount).toBe(0);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlU2VhcmNoRXJyb3JIYW5kbGVyLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFRFU1RTOiB1c2VTZWFyY2hFcnJvckhhbmRsZXIgSG9vayAtIE1hbmVqbyByb2J1c3RvIGRlIGVycm9yZXNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VTZWFyY2hFcnJvckhhbmRsZXIgfSBmcm9tICdAL2hvb2tzL3VzZVNlYXJjaEVycm9ySGFuZGxlcic7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBTRVRVUFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgamVzdC51c2VGYWtlVGltZXJzKCk7XHJcbiAgLy8gTW9jayBjb25zb2xlIG1ldGhvZHMgdG8gcmVkdWNlIG5vaXNlXHJcbiAgamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XHJcbiAgamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xyXG59KTtcclxuXHJcbmFmdGVyRWFjaCgoKSA9PiB7XHJcbiAgamVzdC51c2VSZWFsVGltZXJzKCk7XHJcbiAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBCw4FTSUNPU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZVNlYXJjaEVycm9ySGFuZGxlciBIb29rJywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIGRlZmF1bHQgc3RhdGUnLCAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTZWFyY2hFcnJvckhhbmRsZXIoKSk7XHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmN1cnJlbnRFcnJvcikudG9CZShudWxsKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5yZXRyeUNvdW50KS50b0JlKDApO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzUmV0cnlpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmhhc0Vycm9yKS50b0JlKGZhbHNlKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBhY2NlcHQgY3VzdG9tIHJldHJ5IGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcclxuICAgICAgdXNlU2VhcmNoRXJyb3JIYW5kbGVyKHtcclxuICAgICAgICByZXRyeUNvbmZpZzoge1xyXG4gICAgICAgICAgbWF4UmV0cmllczogNSxcclxuICAgICAgICAgIGJhc2VEZWxheTogNTAwLFxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnJldHJ5Q29uZmlnLm1heFJldHJpZXMpLnRvQmUoNSk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucmV0cnlDb25maWcuYmFzZURlbGF5KS50b0JlKDUwMCk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgQ0xBU0lGSUNBQ0nDk04gREUgRVJST1JFU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZVNlYXJjaEVycm9ySGFuZGxlciAtIEVycm9yIENsYXNzaWZpY2F0aW9uJywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgY2xhc3NpZnkgbmV0d29yayBlcnJvcnMgY29ycmVjdGx5JywgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU2VhcmNoRXJyb3JIYW5kbGVyKCkpO1xyXG5cclxuICAgIGNvbnN0IG5ldHdvcmtFcnJvciA9IG5ldyBUeXBlRXJyb3IoJ2ZldGNoIGZhaWxlZCcpO1xyXG4gICAgbmV0d29ya0Vycm9yLm5hbWUgPSAnVHlwZUVycm9yJztcclxuXHJcbiAgICBhY3QoKCkgPT4ge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHJlc3VsdC5jdXJyZW50LmhhbmRsZUVycm9yKG5ldHdvcmtFcnJvcik7XHJcbiAgICAgIGV4cGVjdChlcnJvci50eXBlKS50b0JlKCduZXR3b3JrJyk7XHJcbiAgICAgIGV4cGVjdChlcnJvci5yZXRyeWFibGUpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2NvbmV4acOzbicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgY2xhc3NpZnkgdGltZW91dCBlcnJvcnMgY29ycmVjdGx5JywgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU2VhcmNoRXJyb3JIYW5kbGVyKCkpO1xyXG5cclxuICAgIGNvbnN0IHRpbWVvdXRFcnJvciA9IG5ldyBFcnJvcigndGltZW91dCcpO1xyXG4gICAgdGltZW91dEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XHJcblxyXG4gICAgYWN0KCgpID0+IHtcclxuICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQuY3VycmVudC5oYW5kbGVFcnJvcih0aW1lb3V0RXJyb3IpO1xyXG4gICAgICBleHBlY3QoZXJyb3IudHlwZSkudG9CZSgndGltZW91dCcpO1xyXG4gICAgICBleHBlY3QoZXJyb3IucmV0cnlhYmxlKS50b0JlKHRydWUpO1xyXG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9Db250YWluKCd0YXJkw7MgZGVtYXNpYWRvJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBjbGFzc2lmeSBzZXJ2ZXIgZXJyb3JzIGNvcnJlY3RseScsICgpID0+IHtcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVNlYXJjaEVycm9ySGFuZGxlcigpKTtcclxuXHJcbiAgICBjb25zdCBzZXJ2ZXJFcnJvciA9IHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InIH07XHJcblxyXG4gICAgYWN0KCgpID0+IHtcclxuICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQuY3VycmVudC5oYW5kbGVFcnJvcihzZXJ2ZXJFcnJvcik7XHJcbiAgICAgIGV4cGVjdChlcnJvci50eXBlKS50b0JlKCdzZXJ2ZXInKTtcclxuICAgICAgZXhwZWN0KGVycm9yLnJldHJ5YWJsZSkudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJzUwMCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgY2xhc3NpZnkgdmFsaWRhdGlvbiBlcnJvcnMgY29ycmVjdGx5JywgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU2VhcmNoRXJyb3JIYW5kbGVyKCkpO1xyXG5cclxuICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IHsgc3RhdHVzOiA0MDAsIG1lc3NhZ2U6ICdCYWQgUmVxdWVzdCcgfTtcclxuXHJcbiAgICBhY3QoKCkgPT4ge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHJlc3VsdC5jdXJyZW50LmhhbmRsZUVycm9yKHZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgIGV4cGVjdChlcnJvci50eXBlKS50b0JlKCd2YWxpZGF0aW9uJyk7XHJcbiAgICAgIGV4cGVjdChlcnJvci5yZXRyeWFibGUpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnNDAwJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBSRVRSWSBBVVRPTcOBVElDT1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZVNlYXJjaEVycm9ySGFuZGxlciAtIFJldHJ5IExvZ2ljJywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgcmV0cnkgZmFpbGVkIG9wZXJhdGlvbnMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXHJcbiAgICAgIHVzZVNlYXJjaEVycm9ySGFuZGxlcih7XHJcbiAgICAgICAgcmV0cnlDb25maWc6IHtcclxuICAgICAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgICAgICBiYXNlRGVsYXk6IDEwMCxcclxuICAgICAgICAgIGJhY2tvZmZGYWN0b3I6IDIsXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgY2FsbENvdW50ID0gMDtcclxuICAgIGNvbnN0IGZhaWxpbmdPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcclxuICAgICAgY2FsbENvdW50Kys7XHJcbiAgICAgIGlmIChjYWxsQ291bnQgPCAzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnc3VjY2VzcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGV4ZWN1dGVQcm9taXNlOiBQcm9taXNlPGFueT47XHJcblxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgZXhlY3V0ZVByb21pc2UgPSByZXN1bHQuY3VycmVudC5leGVjdXRlV2l0aFJldHJ5KGZhaWxpbmdPcGVyYXRpb24sICd0ZXN0IG9wZXJhdGlvbicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXZhbnphciB0aW1lcnMgcGFyYSBsb3MgcmV0cmllc1xyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMCk7IC8vIFByaW1lciByZXRyeVxyXG4gICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDIwMCk7IC8vIFNlZ3VuZG8gcmV0cnlcclxuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXN1bHRfdmFsdWUgPSBhd2FpdCBleGVjdXRlUHJvbWlzZSE7XHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdF92YWx1ZSkudG9CZSgnc3VjY2VzcycpO1xyXG4gICAgZXhwZWN0KGZhaWxpbmdPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBub3QgcmV0cnkgbm9uLXJldHJ5YWJsZSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTZWFyY2hFcnJvckhhbmRsZXIoKSk7XHJcblxyXG4gICAgY29uc3Qgbm9uUmV0cnlhYmxlT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKHsgXHJcbiAgICAgIHN0YXR1czogNDAwLCBcclxuICAgICAgbWVzc2FnZTogJ0JhZCBSZXF1ZXN0JyBcclxuICAgIH0pO1xyXG5cclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGF3YWl0IGV4cGVjdChcclxuICAgICAgICByZXN1bHQuY3VycmVudC5leGVjdXRlV2l0aFJldHJ5KG5vblJldHJ5YWJsZU9wZXJhdGlvbiwgJ3ZhbGlkYXRpb24gdGVzdCcpXHJcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBlY3Qobm9uUmV0cnlhYmxlT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgc3RvcCByZXRyeWluZyBhZnRlciBtYXggYXR0ZW1wdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxyXG4gICAgICB1c2VTZWFyY2hFcnJvckhhbmRsZXIoe1xyXG4gICAgICAgIHJldHJ5Q29uZmlnOiB7IG1heFJldHJpZXM6IDIsIGJhc2VEZWxheTogMTAgfVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBhbHdheXNGYWlsaW5nT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKFxyXG4gICAgICBuZXcgRXJyb3IoJ1BlcnNpc3RlbnQgZXJyb3InKVxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgZXhlY3V0ZVByb21pc2U6IFByb21pc2U8YW55PjtcclxuXHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBleGVjdXRlUHJvbWlzZSA9IHJlc3VsdC5jdXJyZW50LmV4ZWN1dGVXaXRoUmV0cnkoXHJcbiAgICAgICAgYWx3YXlzRmFpbGluZ09wZXJhdGlvbixcclxuICAgICAgICAncGVyc2lzdGVudCBmYWlsdXJlIHRlc3QnXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBdmFuemFyIHRpbWVycyBwYXJhIHRvZG9zIGxvcyByZXRyaWVzIGRlIGZvcm1hIG3DoXMgZWZpY2llbnRlXHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTApOyAgLy8gUHJpbWVyIHJldHJ5XHJcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMjApOyAgLy8gU2VndW5kbyByZXRyeVxyXG4gICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMCk7IC8vIEFzZWd1cmFyIHF1ZSB0b2RvcyBsb3MgdGltZXJzIHNlIGVqZWN1dGVuXHJcbiAgICB9KTtcclxuXHJcbiAgICBhd2FpdCBleHBlY3QoZXhlY3V0ZVByb21pc2UhKS5yZWplY3RzLnRvVGhyb3coJ1BlcnNpc3RlbnQgZXJyb3InKTtcclxuICAgIGV4cGVjdChhbHdheXNGYWlsaW5nT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7IC8vIE9yaWdpbmFsICsgMiByZXRyaWVzXHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgQ0FMTEJBQ0tTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5kZXNjcmliZSgndXNlU2VhcmNoRXJyb3JIYW5kbGVyIC0gQ2FsbGJhY2tzJywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgY2FsbCBvbkVycm9yIGNhbGxiYWNrIHdoZW4gZXJyb3Igb2NjdXJzJywgKCkgPT4ge1xyXG4gICAgY29uc3Qgb25FcnJvciA9IGplc3QuZm4oKTtcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVNlYXJjaEVycm9ySGFuZGxlcih7IG9uRXJyb3IgfSkpO1xyXG5cclxuICAgIGNvbnN0IHRlc3RFcnJvciA9IG5ldyBFcnJvcignVGVzdCBlcnJvcicpO1xyXG5cclxuICAgIGFjdCgoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZUVycm9yKHRlc3RFcnJvcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBlY3Qob25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICB0eXBlOiAndW5rbm93bicsXHJcbiAgICAgICAgbWVzc2FnZTogJ1Rlc3QgZXJyb3InLFxyXG4gICAgICAgIHJldHJ5YWJsZTogdHJ1ZSxcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgY2FsbCBvblJldHJ5U3VjY2VzcyBjYWxsYmFjayBvbiBzdWNjZXNzZnVsIHJldHJ5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3Qgb25SZXRyeVN1Y2Nlc3MgPSBqZXN0LmZuKCk7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcclxuICAgICAgdXNlU2VhcmNoRXJyb3JIYW5kbGVyKHsgXHJcbiAgICAgICAgb25SZXRyeVN1Y2Nlc3MsXHJcbiAgICAgICAgcmV0cnlDb25maWc6IHsgbWF4UmV0cmllczogMiwgYmFzZURlbGF5OiA1MCB9XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIGxldCBjYWxsQ291bnQgPSAwO1xyXG4gICAgY29uc3QgcmV0cnlPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcclxuICAgICAgY2FsbENvdW50Kys7XHJcbiAgICAgIGlmIChjYWxsQ291bnQgPT09IDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGZhaWx1cmUnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdzdWNjZXNzJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgZXhlY3V0ZVByb21pc2U6IFByb21pc2U8YW55PjtcclxuXHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBleGVjdXRlUHJvbWlzZSA9IHJlc3VsdC5jdXJyZW50LmV4ZWN1dGVXaXRoUmV0cnkocmV0cnlPcGVyYXRpb24pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDUwKTtcclxuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhd2FpdCBleGVjdXRlUHJvbWlzZSE7XHJcblxyXG4gICAgZXhwZWN0KG9uUmV0cnlTdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgY2FsbCBvblJldHJ5RmFpbGVkIGNhbGxiYWNrIHdoZW4gYWxsIHJldHJpZXMgZmFpbCcsIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IG9uUmV0cnlGYWlsZWQgPSBqZXN0LmZuKCk7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcclxuICAgICAgdXNlU2VhcmNoRXJyb3JIYW5kbGVyKHsgXHJcbiAgICAgICAgb25SZXRyeUZhaWxlZCxcclxuICAgICAgICByZXRyeUNvbmZpZzogeyBtYXhSZXRyaWVzOiAxLCBiYXNlRGVsYXk6IDUwIH1cclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgZmFpbGluZ09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0Fsd2F5cyBmYWlscycpKTtcclxuXHJcbiAgICBsZXQgZXhlY3V0ZVByb21pc2U6IFByb21pc2U8YW55PjtcclxuXHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBleGVjdXRlUHJvbWlzZSA9IHJlc3VsdC5jdXJyZW50LmV4ZWN1dGVXaXRoUmV0cnkoZmFpbGluZ09wZXJhdGlvbik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoNTApO1xyXG4gICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGF3YWl0IGV4cGVjdChleGVjdXRlUHJvbWlzZSEpLnJlamVjdHMudG9UaHJvdygpO1xyXG5cclxuICAgIGV4cGVjdChvblJldHJ5RmFpbGVkKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xyXG4gICAgICAgIHR5cGU6ICd1bmtub3duJyxcclxuICAgICAgICBtZXNzYWdlOiAnQWx3YXlzIGZhaWxzJyxcclxuICAgICAgfSksXHJcbiAgICAgIDEgLy8gbsO6bWVybyBkZSBpbnRlbnRvc1xyXG4gICAgKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBFU1RBRE9cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmRlc2NyaWJlKCd1c2VTZWFyY2hFcnJvckhhbmRsZXIgLSBTdGF0ZSBNYW5hZ2VtZW50JywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgdXBkYXRlIHJldHJ5IHN0YXRlIGR1cmluZyByZXRyaWVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXHJcbiAgICAgIHVzZVNlYXJjaEVycm9ySGFuZGxlcih7XHJcbiAgICAgICAgcmV0cnlDb25maWc6IHsgbWF4UmV0cmllczogMiwgYmFzZURlbGF5OiA1MCB9XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIGxldCBjYWxsQ291bnQgPSAwO1xyXG4gICAgY29uc3QgcmV0cnlPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcclxuICAgICAgY2FsbENvdW50Kys7XHJcbiAgICAgIGlmIChjYWxsQ291bnQgPCAzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXRyeSB0ZXN0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnc3VjY2VzcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGV4ZWN1dGVQcm9taXNlOiBQcm9taXNlPGFueT47XHJcblxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgZXhlY3V0ZVByb21pc2UgPSByZXN1bHQuY3VycmVudC5leGVjdXRlV2l0aFJldHJ5KHJldHJ5T3BlcmF0aW9uKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFZlcmlmaWNhciBlc3RhZG8gZHVyYW50ZSBwcmltZXIgcmV0cnlcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSg1MCk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzUmV0cnlpbmcpLnRvQmUodHJ1ZSk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucmV0cnlDb3VudCkudG9CZSgxKTtcclxuXHJcbiAgICAvLyBDb21wbGV0YXIgbGEgb3BlcmFjacOzblxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMCk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgZXhlY3V0ZVByb21pc2UhO1xyXG5cclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1JldHJ5aW5nKS50b0JlKGZhbHNlKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5yZXRyeUNvdW50KS50b0JlKDApO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIGNsZWFyIGVycm9yIHN0YXRlJywgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU2VhcmNoRXJyb3JIYW5kbGVyKCkpO1xyXG5cclxuICAgIC8vIFNpbXVsYXIgZXJyb3JcclxuICAgIGFjdCgoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZUVycm9yKG5ldyBFcnJvcignVGVzdCBlcnJvcicpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNFcnJvcikudG9CZSh0cnVlKTtcclxuXHJcbiAgICAvLyBMaW1waWFyIGVycm9yXHJcbiAgICBhY3QoKCkgPT4ge1xyXG4gICAgICByZXN1bHQuY3VycmVudC5jbGVhckVycm9yKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaGFzRXJyb3IpLnRvQmUoZmFsc2UpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmN1cnJlbnRFcnJvcikudG9CZShudWxsKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5yZXRyeUNvdW50KS50b0JlKDApO1xyXG4gIH0pO1xyXG59KTtcclxuIl0sIm5hbWVzIjpbImJlZm9yZUVhY2giLCJqZXN0IiwiY2xlYXJBbGxNb2NrcyIsInVzZUZha2VUaW1lcnMiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJhZnRlckVhY2giLCJ1c2VSZWFsVGltZXJzIiwicmVzdG9yZUFsbE1vY2tzIiwiZGVzY3JpYmUiLCJpdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VTZWFyY2hFcnJvckhhbmRsZXIiLCJleHBlY3QiLCJjdXJyZW50IiwiY3VycmVudEVycm9yIiwidG9CZSIsInJldHJ5Q291bnQiLCJpc1JldHJ5aW5nIiwiaGFzRXJyb3IiLCJyZXRyeUNvbmZpZyIsIm1heFJldHJpZXMiLCJiYXNlRGVsYXkiLCJuZXR3b3JrRXJyb3IiLCJUeXBlRXJyb3IiLCJuYW1lIiwiYWN0IiwiZXJyb3IiLCJoYW5kbGVFcnJvciIsInR5cGUiLCJyZXRyeWFibGUiLCJtZXNzYWdlIiwidG9Db250YWluIiwidGltZW91dEVycm9yIiwiRXJyb3IiLCJzZXJ2ZXJFcnJvciIsInN0YXR1cyIsImNvZGUiLCJ2YWxpZGF0aW9uRXJyb3IiLCJiYWNrb2ZmRmFjdG9yIiwiY2FsbENvdW50IiwiZmFpbGluZ09wZXJhdGlvbiIsImZuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJleGVjdXRlUHJvbWlzZSIsImV4ZWN1dGVXaXRoUmV0cnkiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwicmVzdWx0X3ZhbHVlIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwibm9uUmV0cnlhYmxlT3BlcmF0aW9uIiwibW9ja1JlamVjdGVkVmFsdWUiLCJyZWplY3RzIiwidG9UaHJvdyIsImFsd2F5c0ZhaWxpbmdPcGVyYXRpb24iLCJvbkVycm9yIiwidGVzdEVycm9yIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwib25SZXRyeVN1Y2Nlc3MiLCJyZXRyeU9wZXJhdGlvbiIsInRvSGF2ZUJlZW5DYWxsZWQiLCJvblJldHJ5RmFpbGVkIiwiY2xlYXJFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLGdFQUFnRTtBQUNoRSxzQ0FBc0M7Ozs7O3VCQUVHO3VDQUNIO0FBRXRDLHNDQUFzQztBQUN0QyxRQUFRO0FBQ1Isc0NBQXNDO0FBRXRDQSxXQUFXO0lBQ1RDLEtBQUtD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