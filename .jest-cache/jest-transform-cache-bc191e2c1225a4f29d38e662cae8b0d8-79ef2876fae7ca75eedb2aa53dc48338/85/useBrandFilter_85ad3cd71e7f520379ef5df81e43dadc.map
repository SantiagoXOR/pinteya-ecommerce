{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\hooks\\useBrandFilter.ts"],"sourcesContent":["// ===================================\r\n// HOOK: useBrandFilter\r\n// ===================================\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { getBrands, Brand } from '@/lib/api/brands';\r\nimport { useRouter, useSearchParams } from 'next/navigation';\r\n\r\n// ===================================\r\n// TIPOS\r\n// ===================================\r\n\r\nexport interface UseBrandFilterOptions {\r\n  /** Cargar marcas automáticamente al montar */\r\n  autoLoad?: boolean;\r\n  /** Sincronizar con URL search params */\r\n  syncWithUrl?: boolean;\r\n  /** Parámetro de URL para las marcas */\r\n  urlParam?: string;\r\n  /** Mínimo número de productos por marca */\r\n  minProducts?: number;\r\n  /** Callback cuando cambian las marcas seleccionadas */\r\n  onBrandsChange?: (brands: string[]) => void;\r\n}\r\n\r\nexport interface UseBrandFilterReturn {\r\n  /** Lista de marcas disponibles */\r\n  brands: Brand[];\r\n  /** Marcas seleccionadas */\r\n  selectedBrands: string[];\r\n  /** Estado de carga */\r\n  isLoading: boolean;\r\n  /** Error si ocurre */\r\n  error: string | null;\r\n  /** Función para cambiar marcas seleccionadas */\r\n  setSelectedBrands: (brands: string[]) => void;\r\n  /** Función para alternar una marca */\r\n  toggleBrand: (brandName: string) => void;\r\n  /** Función para limpiar todas las marcas */\r\n  clearBrands: () => void;\r\n  /** Función para recargar marcas */\r\n  refetch: () => Promise<void>;\r\n  /** Función para buscar marcas */\r\n  searchBrands: (searchTerm: string) => void;\r\n}\r\n\r\n// ===================================\r\n// HOOK PRINCIPAL\r\n// ===================================\r\n\r\nexport function useBrandFilter(options: UseBrandFilterOptions = {}): UseBrandFilterReturn {\r\n  const {\r\n    autoLoad = true,\r\n    syncWithUrl = false,\r\n    urlParam = 'brands',\r\n    minProducts = 1,\r\n    onBrandsChange,\r\n  } = options;\r\n\r\n  const router = useRouter();\r\n  const searchParams = useSearchParams();\r\n\r\n  // Estados\r\n  const [brands, setBrands] = useState<Brand[]>([]);\r\n  const [selectedBrands, setSelectedBrandsState] = useState<string[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // Inicializar marcas seleccionadas desde URL\r\n  useEffect(() => {\r\n    if (syncWithUrl && searchParams) {\r\n      const urlBrands = searchParams.get(urlParam);\r\n      if (urlBrands) {\r\n        const brandsArray = urlBrands.split(',').filter(Boolean);\r\n        setSelectedBrandsState(brandsArray);\r\n      }\r\n    }\r\n  }, [syncWithUrl, urlParam, searchParams]);\r\n\r\n  // Cargar marcas\r\n  const fetchBrands = useCallback(async () => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const response = await getBrands({ minProducts });\r\n      \r\n      if (response.success && response.data) {\r\n        setBrands(response.data);\r\n      } else {\r\n        setError(response.error || 'Error cargando marcas');\r\n      }\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Error desconocido');\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [minProducts]);\r\n\r\n  // Cargar marcas automáticamente\r\n  useEffect(() => {\r\n    if (autoLoad) {\r\n      fetchBrands();\r\n    }\r\n  }, [autoLoad, fetchBrands]);\r\n\r\n  // Actualizar URL cuando cambian las marcas seleccionadas\r\n  const updateUrl = useCallback((newBrands: string[]) => {\r\n    if (!syncWithUrl) return;\r\n\r\n    const params = new URLSearchParams(searchParams?.toString());\r\n    \r\n    if (newBrands.length > 0) {\r\n      params.set(urlParam, newBrands.join(','));\r\n    } else {\r\n      params.delete(urlParam);\r\n    }\r\n\r\n    const newUrl = `${window.location.pathname}?${params.toString()}`;\r\n    router.push(newUrl, { scroll: false });\r\n  }, [syncWithUrl, urlParam, searchParams, router]);\r\n\r\n  // Función para cambiar marcas seleccionadas\r\n  const setSelectedBrands = useCallback((newBrands: string[]) => {\r\n    setSelectedBrandsState(newBrands);\r\n    updateUrl(newBrands);\r\n    onBrandsChange?.(newBrands);\r\n  }, [updateUrl, onBrandsChange]);\r\n\r\n  // Función para alternar una marca\r\n  const toggleBrand = useCallback((brandName: string) => {\r\n    const newBrands = selectedBrands.includes(brandName)\r\n      ? selectedBrands.filter(b => b !== brandName)\r\n      : [...selectedBrands, brandName];\r\n    \r\n    setSelectedBrands(newBrands);\r\n  }, [selectedBrands, setSelectedBrands]);\r\n\r\n  // Función para limpiar todas las marcas\r\n  const clearBrands = useCallback(() => {\r\n    setSelectedBrands([]);\r\n  }, [setSelectedBrands]);\r\n\r\n  // Función para buscar marcas\r\n  const searchBrands = useCallback(async (searchTerm: string) => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const response = await getBrands({ \r\n        search: searchTerm,\r\n        minProducts \r\n      });\r\n      \r\n      if (response.success && response.data) {\r\n        setBrands(response.data);\r\n      } else {\r\n        setError(response.error || 'Error buscando marcas');\r\n      }\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Error desconocido');\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [minProducts]);\r\n\r\n  return {\r\n    brands,\r\n    selectedBrands,\r\n    isLoading,\r\n    error,\r\n    setSelectedBrands,\r\n    toggleBrand,\r\n    clearBrands,\r\n    refetch: fetchBrands,\r\n    searchBrands,\r\n  };\r\n}\r\n\r\n// ===================================\r\n// HOOK SIMPLIFICADO\r\n// ===================================\r\n\r\nexport function useSimpleBrandFilter() {\r\n  const [selectedBrands, setSelectedBrands] = useState<string[]>([]);\r\n\r\n  const toggleBrand = useCallback((brandName: string) => {\r\n    setSelectedBrands(prev => \r\n      prev.includes(brandName)\r\n        ? prev.filter(b => b !== brandName)\r\n        : [...prev, brandName]\r\n    );\r\n  }, []);\r\n\r\n  const clearBrands = useCallback(() => {\r\n    setSelectedBrands([]);\r\n  }, []);\r\n\r\n  return {\r\n    selectedBrands,\r\n    setSelectedBrands,\r\n    toggleBrand,\r\n    clearBrands,\r\n  };\r\n}\r\n\r\n// ===================================\r\n// UTILIDADES\r\n// ===================================\r\n\r\n/**\r\n * Convierte array de marcas a string para URL\r\n */\r\nexport function brandsToUrlString(brands: string[]): string {\r\n  return brands.join(',');\r\n}\r\n\r\n/**\r\n * Convierte string de URL a array de marcas\r\n */\r\nexport function urlStringToBrands(urlString: string): string[] {\r\n  return urlString.split(',').filter(Boolean);\r\n}\r\n\r\n/**\r\n * Valida si una marca existe en la lista\r\n */\r\nexport function validateBrand(brandName: string, availableBrands: Brand[]): boolean {\r\n  return availableBrands.some(brand => brand.name === brandName);\r\n}\r\n\r\n/**\r\n * Filtra marcas válidas de una lista\r\n */\r\nexport function filterValidBrands(brandNames: string[], availableBrands: Brand[]): string[] {\r\n  return brandNames.filter(name => validateBrand(name, availableBrands));\r\n}\r\n"],"names":["brandsToUrlString","filterValidBrands","urlStringToBrands","useBrandFilter","useSimpleBrandFilter","validateBrand","options","autoLoad","syncWithUrl","urlParam","minProducts","onBrandsChange","router","useRouter","searchParams","useSearchParams","brands","setBrands","useState","selectedBrands","setSelectedBrandsState","isLoading","setIsLoading","error","setError","useEffect","urlBrands","get","brandsArray","split","filter","Boolean","fetchBrands","useCallback","response","getBrands","success","data","err","Error","message","updateUrl","newBrands","params","URLSearchParams","toString","length","set","join","delete","newUrl","window","location","pathname","push","scroll","setSelectedBrands","toggleBrand","brandName","includes","b","clearBrands","searchBrands","searchTerm","search","refetch","prev","urlString","availableBrands","some","brand","name","brandNames"],"mappings":"AAAA,sCAAsC;AACtC,uBAAuB;AACvB,sCAAsC;;;;;;;;;;;;IAmNtBA,iBAAiB;eAAjBA;;IAqBAC,iBAAiB;eAAjBA;;IAdAC,iBAAiB;eAAjBA;;IA1KAC,cAAc;eAAdA;;IAqIAC,oBAAoB;eAApBA;;IA4CAC,aAAa;eAAbA;;;uBA/NiC;wBAChB;4BACU;AA4CpC,SAASF,eAAeG,UAAiC,CAAC,CAAC;IAChE,MAAM,EACJC,WAAW,IAAI,EACfC,cAAc,KAAK,EACnBC,WAAW,QAAQ,EACnBC,cAAc,CAAC,EACfC,cAAc,EACf,GAAGL;IAEJ,MAAMM,SAASC,IAAAA,qBAAS;IACxB,MAAMC,eAAeC,IAAAA,2BAAe;IAEpC,UAAU;IACV,MAAM,CAACC,QAAQC,UAAU,GAAGC,IAAAA,eAAQ,EAAU,EAAE;IAChD,MAAM,CAACC,gBAAgBC,uBAAuB,GAAGF,IAAAA,eAAQ,EAAW,EAAE;IACtE,MAAM,CAACG,WAAWC,aAAa,GAAGJ,IAAAA,eAAQ,EAAC;IAC3C,MAAM,CAACK,OAAOC,SAAS,GAAGN,IAAAA,eAAQ,EAAgB;IAElD,6CAA6C;IAC7CO,IAAAA,gBAAS,EAAC;QACR,IAAIjB,eAAeM,cAAc;YAC/B,MAAMY,YAAYZ,aAAaa,GAAG,CAAClB;YACnC,IAAIiB,WAAW;gBACb,MAAME,cAAcF,UAAUG,KAAK,CAAC,KAAKC,MAAM,CAACC;gBAChDX,uBAAuBQ;YACzB;QACF;IACF,GAAG;QAACpB;QAAaC;QAAUK;KAAa;IAExC,gBAAgB;IAChB,MAAMkB,cAAcC,IAAAA,kBAAW,EAAC;QAC9BX,aAAa;QACbE,SAAS;QAET,IAAI;YACF,MAAMU,WAAW,MAAMC,IAAAA,iBAAS,EAAC;gBAAEzB;YAAY;YAE/C,IAAIwB,SAASE,OAAO,IAAIF,SAASG,IAAI,EAAE;gBACrCpB,UAAUiB,SAASG,IAAI;YACzB,OAAO;gBACLb,SAASU,SAASX,KAAK,IAAI;YAC7B;QACF,EAAE,OAAOe,KAAK;YACZd,SAASc,eAAeC,QAAQD,IAAIE,OAAO,GAAG;QAChD,SAAU;YACRlB,aAAa;QACf;IACF,GAAG;QAACZ;KAAY;IAEhB,gCAAgC;IAChCe,IAAAA,gBAAS,EAAC;QACR,IAAIlB,UAAU;YACZyB;QACF;IACF,GAAG;QAACzB;QAAUyB;KAAY;IAE1B,yDAAyD;IACzD,MAAMS,YAAYR,IAAAA,kBAAW,EAAC,CAACS;QAC7B,IAAI,CAAClC,aAAa;QAElB,MAAMmC,SAAS,IAAIC,gBAAgB9B,cAAc+B;QAEjD,IAAIH,UAAUI,MAAM,GAAG,GAAG;YACxBH,OAAOI,GAAG,CAACtC,UAAUiC,UAAUM,IAAI,CAAC;QACtC,OAAO;YACLL,OAAOM,MAAM,CAACxC;QAChB;QAEA,MAAMyC,SAAS,GAAGC,OAAOC,QAAQ,CAACC,QAAQ,CAAC,CAAC,EAAEV,OAAOE,QAAQ,IAAI;QACjEjC,OAAO0C,IAAI,CAACJ,QAAQ;YAAEK,QAAQ;QAAM;IACtC,GAAG;QAAC/C;QAAaC;QAAUK;QAAcF;KAAO;IAEhD,4CAA4C;IAC5C,MAAM4C,oBAAoBvB,IAAAA,kBAAW,EAAC,CAACS;QACrCtB,uBAAuBsB;QACvBD,UAAUC;QACV/B,iBAAiB+B;IACnB,GAAG;QAACD;QAAW9B;KAAe;IAE9B,kCAAkC;IAClC,MAAM8C,cAAcxB,IAAAA,kBAAW,EAAC,CAACyB;QAC/B,MAAMhB,YAAYvB,eAAewC,QAAQ,CAACD,aACtCvC,eAAeW,MAAM,CAAC8B,CAAAA,IAAKA,MAAMF,aACjC;eAAIvC;YAAgBuC;SAAU;QAElCF,kBAAkBd;IACpB,GAAG;QAACvB;QAAgBqC;KAAkB;IAEtC,wCAAwC;IACxC,MAAMK,cAAc5B,IAAAA,kBAAW,EAAC;QAC9BuB,kBAAkB,EAAE;IACtB,GAAG;QAACA;KAAkB;IAEtB,6BAA6B;IAC7B,MAAMM,eAAe7B,IAAAA,kBAAW,EAAC,OAAO8B;QACtCzC,aAAa;QACbE,SAAS;QAET,IAAI;YACF,MAAMU,WAAW,MAAMC,IAAAA,iBAAS,EAAC;gBAC/B6B,QAAQD;gBACRrD;YACF;YAEA,IAAIwB,SAASE,OAAO,IAAIF,SAASG,IAAI,EAAE;gBACrCpB,UAAUiB,SAASG,IAAI;YACzB,OAAO;gBACLb,SAASU,SAASX,KAAK,IAAI;YAC7B;QACF,EAAE,OAAOe,KAAK;YACZd,SAASc,eAAeC,QAAQD,IAAIE,OAAO,GAAG;QAChD,SAAU;YACRlB,aAAa;QACf;IACF,GAAG;QAACZ;KAAY;IAEhB,OAAO;QACLM;QACAG;QACAE;QACAE;QACAiC;QACAC;QACAI;QACAI,SAASjC;QACT8B;IACF;AACF;AAMO,SAAS1D;IACd,MAAM,CAACe,gBAAgBqC,kBAAkB,GAAGtC,IAAAA,eAAQ,EAAW,EAAE;IAEjE,MAAMuC,cAAcxB,IAAAA,kBAAW,EAAC,CAACyB;QAC/BF,kBAAkBU,CAAAA,OAChBA,KAAKP,QAAQ,CAACD,aACVQ,KAAKpC,MAAM,CAAC8B,CAAAA,IAAKA,MAAMF,aACvB;mBAAIQ;gBAAMR;aAAU;IAE5B,GAAG,EAAE;IAEL,MAAMG,cAAc5B,IAAAA,kBAAW,EAAC;QAC9BuB,kBAAkB,EAAE;IACtB,GAAG,EAAE;IAEL,OAAO;QACLrC;QACAqC;QACAC;QACAI;IACF;AACF;AASO,SAAS7D,kBAAkBgB,MAAgB;IAChD,OAAOA,OAAOgC,IAAI,CAAC;AACrB;AAKO,SAAS9C,kBAAkBiE,SAAiB;IACjD,OAAOA,UAAUtC,KAAK,CAAC,KAAKC,MAAM,CAACC;AACrC;AAKO,SAAS1B,cAAcqD,SAAiB,EAAEU,eAAwB;IACvE,OAAOA,gBAAgBC,IAAI,CAACC,CAAAA,QAASA,MAAMC,IAAI,KAAKb;AACtD;AAKO,SAASzD,kBAAkBuE,UAAoB,EAAEJ,eAAwB;IAC9E,OAAOI,WAAW1C,MAAM,CAACyC,CAAAA,OAAQlE,cAAckE,MAAMH;AACvD"}