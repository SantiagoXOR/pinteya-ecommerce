9382c9a544d1342c83b4a824ac5121fa
/**
 * Tests de Penetración para Rate Limiting Enterprise
 * Simula ataques reales para validar la robustez del sistema
 */ // Mock de Redis para tests
"use strict";
jest.mock('ioredis', ()=>{
    const mockRedis = {
        get: jest.fn(),
        set: jest.fn(),
        incr: jest.fn(),
        expire: jest.fn(),
        del: jest.fn(),
        pipeline: jest.fn(()=>({
                get: jest.fn(),
                incr: jest.fn(),
                expire: jest.fn(),
                exec: jest.fn().mockResolvedValue([
                    [
                        null,
                        '1'
                    ],
                    [
                        null,
                        'OK'
                    ]
                ])
            })),
        disconnect: jest.fn()
    };
    return jest.fn(()=>mockRedis);
});
jest.mock('@/lib/security/enterprise-audit-system', ()=>({
        enterpriseAuditSystem: {
            logEnterpriseEvent: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _enterpriseratelimiter = require("../../lib/rate-limiting/enterprise-rate-limiter");
const _enterprisemiddleware = require("../../lib/rate-limiting/enterprise-middleware");
describe('Tests de Penetración - Rate Limiting Enterprise', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Reset metrics collector
        _enterpriseratelimiter.metricsCollector.metrics = {
            totalRequests: 0,
            allowedRequests: 0,
            blockedRequests: 0,
            redisHits: 0,
            memoryFallbacks: 0,
            errors: 0,
            averageResponseTime: 0,
            topBlockedIPs: [],
            topEndpoints: []
        };
    });
    describe('Ataque de Fuerza Bruta - Admin APIs', ()=>{
        it('debe bloquear múltiples requests rápidos desde la misma IP', async ()=>{
            const attackerIP = '192.168.1.100';
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL;
            const results = [];
            // Simular 20 requests rápidos (límite admin es 15/min)
            for(let i = 0; i < 20; i++){
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            attackerIP
                        ],
                        [
                            'user-agent',
                            'AttackBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/admin/products'
                    },
                    method: 'POST'
                };
                const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `admin_attack_${i}`);
                results.push(result);
            }
            // Verificar que los primeros requests pasan
            expect(results.slice(0, 15).every((r)=>r.allowed)).toBe(true);
            // Verificar que los siguientes son bloqueados
            expect(results.slice(15).every((r)=>!r.allowed)).toBe(true);
            // Verificar métricas de ataque
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.blockedRequests).toBeGreaterThan(0);
            expect(metrics.topBlockedIPs.some((ip)=>ip.ip === attackerIP)).toBe(true);
        });
        it('debe detectar ataque distribuido desde múltiples IPs', async ()=>{
            const attackerIPs = [
                '192.168.1.100',
                '192.168.1.101',
                '192.168.1.102',
                '192.168.1.103',
                '192.168.1.104'
            ];
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL;
            let totalBlocked = 0;
            // Simular ataque distribuido
            for (const ip of attackerIPs){
                for(let i = 0; i < 20; i++){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                ip
                            ],
                            [
                                'user-agent',
                                'DistributedBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/admin/users'
                        },
                        method: 'DELETE'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `distributed_attack_${ip}_${i}`);
                    if (!result.allowed) {
                        totalBlocked++;
                    }
                }
            }
            // Verificar que se bloquearon múltiples requests
            expect(totalBlocked).toBeGreaterThan(20); // 5 IPs * 5 requests bloqueados cada una
            // Verificar que múltiples IPs están en la lista de bloqueados
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.topBlockedIPs.length).toBeGreaterThan(3);
        });
        it('debe resistir ataque de bypass con headers falsos', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL;
            const results = [];
            // Intentar bypass con diferentes headers
            const bypassAttempts = [
                {
                    'x-forwarded-for': '127.0.0.1',
                    'x-real-ip': '192.168.1.100'
                },
                {
                    'x-forwarded-for': '192.168.1.100',
                    'x-real-ip': '127.0.0.1'
                },
                {
                    'x-forwarded-for': '192.168.1.100, 127.0.0.1'
                },
                {
                    'x-forwarded-for': '192.168.1.100',
                    'cf-connecting-ip': '127.0.0.1'
                },
                {
                    'x-forwarded-for': '192.168.1.100',
                    'x-client-ip': '10.0.0.1'
                }
            ];
            for(let attempt = 0; attempt < bypassAttempts.length; attempt++){
                for(let i = 0; i < 20; i++){
                    const mockRequest = {
                        headers: new Map(Object.entries({
                            ...bypassAttempts[attempt],
                            'user-agent': 'BypassBot/1.0'
                        })),
                        nextUrl: {
                            pathname: '/api/admin/settings'
                        },
                        method: 'PUT'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `bypass_attempt_${attempt}_${i}`);
                    results.push(result);
                }
            }
            // Verificar que el sistema no fue burlado
            const blockedCount = results.filter((r)=>!r.allowed).length;
            expect(blockedCount).toBeGreaterThan(50); // Debería bloquear la mayoría
        });
    });
    describe('Ataque de Agotamiento de Recursos', ()=>{
        it('debe manejar requests con payloads extremadamente grandes', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PAYMENT_HIGH;
            const attackerIP = '10.0.0.50';
            // Simular requests con diferentes tamaños de payload
            const payloadSizes = [
                1000,
                10000,
                100000,
                1000000
            ]; // Bytes
            const results = [];
            for (const size of payloadSizes){
                for(let i = 0; i < 10; i++){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                attackerIP
                            ],
                            [
                                'content-length',
                                size.toString()
                            ],
                            [
                                'user-agent',
                                'ResourceExhaustionBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/payments/process'
                        },
                        method: 'POST'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `resource_attack_${size}_${i}`);
                    results.push(result);
                }
            }
            // Verificar que el sistema mantiene performance
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.averageResponseTime).toBeLessThan(100); // < 100ms
            // Verificar que se aplicó rate limiting
            const blockedCount = results.filter((r)=>!r.allowed).length;
            expect(blockedCount).toBeGreaterThan(0);
        });
        it('debe detectar patrones de scraping automatizado', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD;
            const scraperIP = '203.0.113.100';
            const results = [];
            // Simular scraping con patrones regulares
            const endpoints = [
                '/api/products',
                '/api/categories',
                '/api/search',
                '/api/products/1',
                '/api/products/2'
            ];
            // Requests muy rápidos y regulares (típico de bots)
            for(let round = 0; round < 10; round++){
                for (const endpoint of endpoints){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                scraperIP
                            ],
                            [
                                'user-agent',
                                'ScrapingBot/2.0 (automated)'
                            ]
                        ]),
                        nextUrl: {
                            pathname: endpoint
                        },
                        method: 'GET'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `scraping_${round}_${endpoint.replace('/', '_')}`);
                    results.push(result);
                }
            }
            // Verificar detección de scraping
            const blockedCount = results.filter((r)=>!r.allowed).length;
            expect(blockedCount).toBeGreaterThan(20); // Debería bloquear muchos requests
            // Verificar que el endpoint está en top blocked
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.topEndpoints.length).toBeGreaterThan(0);
        });
    });
    describe('Ataques de Timing y Concurrencia', ()=>{
        it('debe manejar requests concurrentes masivos', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD;
            const attackerIP = '198.51.100.50';
            // Simular 100 requests concurrentes
            const concurrentRequests = Array.from({
                length: 100
            }, (_, i)=>{
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            attackerIP
                        ],
                        [
                            'user-agent',
                            'ConcurrencyBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/products'
                    },
                    method: 'GET'
                };
                return (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `concurrent_${i}`);
            });
            const results = await Promise.all(concurrentRequests);
            // Verificar que el sistema mantuvo consistencia
            const allowedCount = results.filter((r)=>r.allowed).length;
            const blockedCount = results.filter((r)=>!r.allowed).length;
            expect(allowedCount + blockedCount).toBe(100);
            expect(blockedCount).toBeGreaterThan(50); // Debería bloquear la mayoría
        });
        it('debe resistir ataques de timing para encontrar ventanas', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_CRITICAL;
            const attackerIP = '172.16.0.100';
            const results = [];
            // Intentar encontrar ventanas de tiempo donde el rate limit se resetea
            for(let window = 0; window < 5; window++){
                // Burst inicial
                for(let i = 0; i < 20; i++){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                attackerIP
                            ],
                            [
                                'user-agent',
                                'TimingAttackBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/admin/critical'
                        },
                        method: 'POST'
                    };
                    const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `timing_window_${window}_${i}`);
                    results.push(result);
                }
                // Esperar un poco (simular espera para reset)
                await new Promise((resolve)=>setTimeout(resolve, 100));
            }
            // Verificar que no se pudo explotar timing
            const totalBlocked = results.filter((r)=>!r.allowed).length;
            expect(totalBlocked).toBeGreaterThan(60); // Debería bloquear la mayoría
        });
    });
    describe('Middleware de Rate Limiting bajo Ataque', ()=>{
        it('debe mantener funcionalidad durante ataque DDoS simulado', async ()=>{
            const mockHandler = jest.fn().mockResolvedValue(new Response(JSON.stringify({
                success: true
            }), {
                status: 200
            }));
            const protectedHandler = (0, _enterprisemiddleware.withEnterpriseRateLimit)({
                configName: 'PUBLIC_STANDARD',
                enableLogging: true
            })(mockHandler);
            // Simular DDoS con múltiples IPs
            const attackIPs = Array.from({
                length: 50
            }, (_, i)=>`10.0.${Math.floor(i / 255)}.${i % 255}`);
            const results = [];
            for (const ip of attackIPs){
                for(let i = 0; i < 10; i++){
                    const mockRequest = {
                        headers: new Map([
                            [
                                'x-forwarded-for',
                                ip
                            ],
                            [
                                'user-agent',
                                'DDoSBot/1.0'
                            ]
                        ]),
                        nextUrl: {
                            pathname: '/api/public/test'
                        },
                        method: 'GET'
                    };
                    try {
                        const response = await protectedHandler(mockRequest);
                        results.push(response);
                    } catch (error) {
                        // Rate limit debería devolver respuesta, no error
                        expect(error).toBeUndefined();
                    }
                }
            }
            // Verificar que el sistema respondió a todos los requests
            expect(results.length).toBe(500);
            // Verificar que muchos fueron bloqueados (status 429)
            const blockedResponses = results.filter((r)=>r.status === 429);
            expect(blockedResponses.length).toBeGreaterThan(300);
            // Verificar que algunos requests legítimos pasaron
            const successResponses = results.filter((r)=>r.status === 200);
            expect(successResponses.length).toBeGreaterThan(0);
        });
        it('debe mantener performance durante ataque sostenido', async ()=>{
            const mockHandler = jest.fn().mockResolvedValue(new Response(JSON.stringify({
                data: 'test'
            }), {
                status: 200
            }));
            const protectedHandler = (0, _enterprisemiddleware.withEnterpriseRateLimit)({
                configName: 'ADMIN_CRITICAL',
                enableLogging: false // Disable para performance
            })(mockHandler);
            const attackerIP = '192.0.2.100';
            const startTime = Date.now();
            const results = [];
            // Ataque sostenido por 1000 requests
            for(let i = 0; i < 1000; i++){
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            attackerIP
                        ],
                        [
                            'user-agent',
                            'SustainedAttackBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/admin/test'
                    },
                    method: 'GET'
                };
                const response = await protectedHandler(mockRequest);
                results.push(response);
            }
            const endTime = Date.now();
            const totalTime = endTime - startTime;
            const avgResponseTime = totalTime / 1000;
            // Verificar performance (< 5ms por request en promedio)
            expect(avgResponseTime).toBeLessThan(5);
            // Verificar que el rate limiting funcionó
            const blockedCount = results.filter((r)=>r.status === 429).length;
            expect(blockedCount).toBeGreaterThan(900); // Debería bloquear casi todos
        });
    });
    describe('Recuperación y Resilencia', ()=>{
        it('debe recuperarse después de un ataque masivo', async ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_STANDARD;
            const attackerIP = '203.0.113.200';
            // Fase 1: Ataque masivo
            for(let i = 0; i < 100; i++){
                const mockRequest = {
                    headers: new Map([
                        [
                            'x-forwarded-for',
                            attackerIP
                        ],
                        [
                            'user-agent',
                            'MassiveAttackBot/1.0'
                        ]
                    ]),
                    nextUrl: {
                        pathname: '/api/products'
                    },
                    method: 'GET'
                };
                await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, config, `massive_attack_${i}`);
            }
            // Verificar que el atacante está bloqueado
            const duringAttackRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        attackerIP
                    ],
                    [
                        'user-agent',
                        'MassiveAttackBot/1.0'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/products'
                },
                method: 'GET'
            };
            const duringAttackResult = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(duringAttackRequest, config, 'during_attack_check');
            expect(duringAttackResult.allowed).toBe(false);
            // Fase 2: Usuario legítimo debe poder acceder
            const legitimateUserIP = '198.51.100.200';
            const legitimateRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        legitimateUserIP
                    ],
                    [
                        'user-agent',
                        'Mozilla/5.0 (legitimate browser)'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/products'
                },
                method: 'GET'
            };
            const legitimateResult = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(legitimateRequest, config, 'legitimate_user');
            expect(legitimateResult.allowed).toBe(true);
            // Verificar métricas de recuperación
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.totalRequests).toBeGreaterThan(100);
            expect(metrics.allowedRequests).toBeGreaterThan(0);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxzZWN1cml0eVxccGVuZXRyYXRpb24tcmF0ZS1saW1pdGluZy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUZXN0cyBkZSBQZW5ldHJhY2nDs24gcGFyYSBSYXRlIExpbWl0aW5nIEVudGVycHJpc2VcclxuICogU2ltdWxhIGF0YXF1ZXMgcmVhbGVzIHBhcmEgdmFsaWRhciBsYSByb2J1c3RleiBkZWwgc2lzdGVtYVxyXG4gKi9cclxuXHJcbi8vIE1vY2sgZGUgUmVkaXMgcGFyYSB0ZXN0c1xyXG5qZXN0Lm1vY2soJ2lvcmVkaXMnLCAoKSA9PiB7XHJcbiAgY29uc3QgbW9ja1JlZGlzID0ge1xyXG4gICAgZ2V0OiBqZXN0LmZuKCksXHJcbiAgICBzZXQ6IGplc3QuZm4oKSxcclxuICAgIGluY3I6IGplc3QuZm4oKSxcclxuICAgIGV4cGlyZTogamVzdC5mbigpLFxyXG4gICAgZGVsOiBqZXN0LmZuKCksXHJcbiAgICBwaXBlbGluZTogamVzdC5mbigoKSA9PiAoe1xyXG4gICAgICBnZXQ6IGplc3QuZm4oKSxcclxuICAgICAgaW5jcjogamVzdC5mbigpLFxyXG4gICAgICBleHBpcmU6IGplc3QuZm4oKSxcclxuICAgICAgZXhlYzogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKFtbbnVsbCwgJzEnXSwgW251bGwsICdPSyddXSlcclxuICAgIH0pKSxcclxuICAgIGRpc2Nvbm5lY3Q6IGplc3QuZm4oKVxyXG4gIH07XHJcbiAgcmV0dXJuIGplc3QuZm4oKCkgPT4gbW9ja1JlZGlzKTtcclxufSk7XHJcblxyXG5qZXN0Lm1vY2soJ0AvbGliL3NlY3VyaXR5L2VudGVycHJpc2UtYXVkaXQtc3lzdGVtJywgKCkgPT4gKHtcclxuICBlbnRlcnByaXNlQXVkaXRTeXN0ZW06IHtcclxuICAgIGxvZ0VudGVycHJpc2VFdmVudDogamVzdC5mbigpXHJcbiAgfVxyXG59KSk7XHJcblxyXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHtcclxuICBjaGVja0VudGVycHJpc2VSYXRlTGltaXQsXHJcbiAgRU5URVJQUklTRV9SQVRFX0xJTUlUX0NPTkZJR1MsXHJcbiAgbWV0cmljc0NvbGxlY3RvcixcclxuICB0eXBlIEVudGVycHJpc2VSYXRlTGltaXRSZXN1bHRcclxufSBmcm9tICdAL2xpYi9yYXRlLWxpbWl0aW5nL2VudGVycHJpc2UtcmF0ZS1saW1pdGVyJztcclxuaW1wb3J0IHsgd2l0aEVudGVycHJpc2VSYXRlTGltaXQgfSBmcm9tICdAL2xpYi9yYXRlLWxpbWl0aW5nL2VudGVycHJpc2UtbWlkZGxld2FyZSc7XHJcblxyXG5kZXNjcmliZSgnVGVzdHMgZGUgUGVuZXRyYWNpw7NuIC0gUmF0ZSBMaW1pdGluZyBFbnRlcnByaXNlJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgICAvLyBSZXNldCBtZXRyaWNzIGNvbGxlY3RvclxyXG4gICAgKG1ldHJpY3NDb2xsZWN0b3IgYXMgYW55KS5tZXRyaWNzID0ge1xyXG4gICAgICB0b3RhbFJlcXVlc3RzOiAwLFxyXG4gICAgICBhbGxvd2VkUmVxdWVzdHM6IDAsXHJcbiAgICAgIGJsb2NrZWRSZXF1ZXN0czogMCxcclxuICAgICAgcmVkaXNIaXRzOiAwLFxyXG4gICAgICBtZW1vcnlGYWxsYmFja3M6IDAsXHJcbiAgICAgIGVycm9yczogMCxcclxuICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogMCxcclxuICAgICAgdG9wQmxvY2tlZElQczogW10sXHJcbiAgICAgIHRvcEVuZHBvaW50czogW11cclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdBdGFxdWUgZGUgRnVlcnphIEJydXRhIC0gQWRtaW4gQVBJcycsICgpID0+IHtcclxuICAgIGl0KCdkZWJlIGJsb3F1ZWFyIG3Dumx0aXBsZXMgcmVxdWVzdHMgcsOhcGlkb3MgZGVzZGUgbGEgbWlzbWEgSVAnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGF0dGFja2VySVAgPSAnMTkyLjE2OC4xLjEwMCc7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLkFETUlOX0NSSVRJQ0FMO1xyXG4gICAgICBjb25zdCByZXN1bHRzOiBFbnRlcnByaXNlUmF0ZUxpbWl0UmVzdWx0W10gPSBbXTtcclxuXHJcbiAgICAgIC8vIFNpbXVsYXIgMjAgcmVxdWVzdHMgcsOhcGlkb3MgKGzDrW1pdGUgYWRtaW4gZXMgMTUvbWluKVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcclxuICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcclxuICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xyXG4gICAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIGF0dGFja2VySVBdLFxyXG4gICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnQXR0YWNrQm90LzEuMCddXHJcbiAgICAgICAgICBdKSxcclxuICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL2FkbWluL3Byb2R1Y3RzJyB9LFxyXG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCdcclxuICAgICAgICB9IGFzIGFueTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxyXG4gICAgICAgICAgbW9ja1JlcXVlc3QsXHJcbiAgICAgICAgICBjb25maWcsXHJcbiAgICAgICAgICBgYWRtaW5fYXR0YWNrXyR7aX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBsb3MgcHJpbWVyb3MgcmVxdWVzdHMgcGFzYW5cclxuICAgICAgZXhwZWN0KHJlc3VsdHMuc2xpY2UoMCwgMTUpLmV2ZXJ5KHIgPT4gci5hbGxvd2VkKSkudG9CZSh0cnVlKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgbG9zIHNpZ3VpZW50ZXMgc29uIGJsb3F1ZWFkb3NcclxuICAgICAgZXhwZWN0KHJlc3VsdHMuc2xpY2UoMTUpLmV2ZXJ5KHIgPT4gIXIuYWxsb3dlZCkpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBWZXJpZmljYXIgbcOpdHJpY2FzIGRlIGF0YXF1ZVxyXG4gICAgICBjb25zdCBtZXRyaWNzID0gbWV0cmljc0NvbGxlY3Rvci5nZXRNZXRyaWNzKCk7XHJcbiAgICAgIGV4cGVjdChtZXRyaWNzLmJsb2NrZWRSZXF1ZXN0cykudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICBleHBlY3QobWV0cmljcy50b3BCbG9ja2VkSVBzLnNvbWUoaXAgPT4gaXAuaXAgPT09IGF0dGFja2VySVApKS50b0JlKHRydWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RlYmUgZGV0ZWN0YXIgYXRhcXVlIGRpc3RyaWJ1aWRvIGRlc2RlIG3Dumx0aXBsZXMgSVBzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBhdHRhY2tlcklQcyA9IFtcclxuICAgICAgICAnMTkyLjE2OC4xLjEwMCcsXHJcbiAgICAgICAgJzE5Mi4xNjguMS4xMDEnLCBcclxuICAgICAgICAnMTkyLjE2OC4xLjEwMicsXHJcbiAgICAgICAgJzE5Mi4xNjguMS4xMDMnLFxyXG4gICAgICAgICcxOTIuMTY4LjEuMTA0J1xyXG4gICAgICBdO1xyXG4gICAgICBjb25zdCBjb25maWcgPSBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5BRE1JTl9DUklUSUNBTDtcclxuICAgICAgbGV0IHRvdGFsQmxvY2tlZCA9IDA7XHJcblxyXG4gICAgICAvLyBTaW11bGFyIGF0YXF1ZSBkaXN0cmlidWlkb1xyXG4gICAgICBmb3IgKGNvbnN0IGlwIG9mIGF0dGFja2VySVBzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbXHJcbiAgICAgICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBpcF0sXHJcbiAgICAgICAgICAgICAgWyd1c2VyLWFnZW50JywgJ0Rpc3RyaWJ1dGVkQm90LzEuMCddXHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS9hZG1pbi91c2VycycgfSxcclxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJ1xyXG4gICAgICAgICAgfSBhcyBhbnk7XHJcblxyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxyXG4gICAgICAgICAgICBtb2NrUmVxdWVzdCxcclxuICAgICAgICAgICAgY29uZmlnLFxyXG4gICAgICAgICAgICBgZGlzdHJpYnV0ZWRfYXR0YWNrXyR7aXB9XyR7aX1gXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGlmICghcmVzdWx0LmFsbG93ZWQpIHtcclxuICAgICAgICAgICAgdG90YWxCbG9ja2VkKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIHNlIGJsb3F1ZWFyb24gbcO6bHRpcGxlcyByZXF1ZXN0c1xyXG4gICAgICBleHBlY3QodG90YWxCbG9ja2VkKS50b0JlR3JlYXRlclRoYW4oMjApOyAvLyA1IElQcyAqIDUgcmVxdWVzdHMgYmxvcXVlYWRvcyBjYWRhIHVuYVxyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBtw7psdGlwbGVzIElQcyBlc3TDoW4gZW4gbGEgbGlzdGEgZGUgYmxvcXVlYWRvc1xyXG4gICAgICBjb25zdCBtZXRyaWNzID0gbWV0cmljc0NvbGxlY3Rvci5nZXRNZXRyaWNzKCk7XHJcbiAgICAgIGV4cGVjdChtZXRyaWNzLnRvcEJsb2NrZWRJUHMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnZGViZSByZXNpc3RpciBhdGFxdWUgZGUgYnlwYXNzIGNvbiBoZWFkZXJzIGZhbHNvcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY29uZmlnID0gRU5URVJQUklTRV9SQVRFX0xJTUlUX0NPTkZJR1MuQURNSU5fQ1JJVElDQUw7XHJcbiAgICAgIGNvbnN0IHJlc3VsdHM6IEVudGVycHJpc2VSYXRlTGltaXRSZXN1bHRbXSA9IFtdO1xyXG5cclxuICAgICAgLy8gSW50ZW50YXIgYnlwYXNzIGNvbiBkaWZlcmVudGVzIGhlYWRlcnNcclxuICAgICAgY29uc3QgYnlwYXNzQXR0ZW1wdHMgPSBbXHJcbiAgICAgICAgeyAneC1mb3J3YXJkZWQtZm9yJzogJzEyNy4wLjAuMScsICd4LXJlYWwtaXAnOiAnMTkyLjE2OC4xLjEwMCcgfSxcclxuICAgICAgICB7ICd4LWZvcndhcmRlZC1mb3InOiAnMTkyLjE2OC4xLjEwMCcsICd4LXJlYWwtaXAnOiAnMTI3LjAuMC4xJyB9LFxyXG4gICAgICAgIHsgJ3gtZm9yd2FyZGVkLWZvcic6ICcxOTIuMTY4LjEuMTAwLCAxMjcuMC4wLjEnIH0sXHJcbiAgICAgICAgeyAneC1mb3J3YXJkZWQtZm9yJzogJzE5Mi4xNjguMS4xMDAnLCAnY2YtY29ubmVjdGluZy1pcCc6ICcxMjcuMC4wLjEnIH0sXHJcbiAgICAgICAgeyAneC1mb3J3YXJkZWQtZm9yJzogJzE5Mi4xNjguMS4xMDAnLCAneC1jbGllbnQtaXAnOiAnMTAuMC4wLjEnIH1cclxuICAgICAgXTtcclxuXHJcbiAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgYnlwYXNzQXR0ZW1wdHMubGVuZ3RoOyBhdHRlbXB0KyspIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHtcclxuICAgICAgICAgICAgICAuLi5ieXBhc3NBdHRlbXB0c1thdHRlbXB0XSxcclxuICAgICAgICAgICAgICAndXNlci1hZ2VudCc6ICdCeXBhc3NCb3QvMS4wJ1xyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL2FkbWluL3NldHRpbmdzJyB9LFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnXHJcbiAgICAgICAgICB9IGFzIGFueTtcclxuXHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQoXHJcbiAgICAgICAgICAgIG1vY2tSZXF1ZXN0LFxyXG4gICAgICAgICAgICBjb25maWcsXHJcbiAgICAgICAgICAgIGBieXBhc3NfYXR0ZW1wdF8ke2F0dGVtcHR9XyR7aX1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIHNpc3RlbWEgbm8gZnVlIGJ1cmxhZG9cclxuICAgICAgY29uc3QgYmxvY2tlZENvdW50ID0gcmVzdWx0cy5maWx0ZXIociA9PiAhci5hbGxvd2VkKS5sZW5ndGg7XHJcbiAgICAgIGV4cGVjdChibG9ja2VkQ291bnQpLnRvQmVHcmVhdGVyVGhhbig1MCk7IC8vIERlYmVyw61hIGJsb3F1ZWFyIGxhIG1heW9yw61hXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ0F0YXF1ZSBkZSBBZ290YW1pZW50byBkZSBSZWN1cnNvcycsICgpID0+IHtcclxuICAgIGl0KCdkZWJlIG1hbmVqYXIgcmVxdWVzdHMgY29uIHBheWxvYWRzIGV4dHJlbWFkYW1lbnRlIGdyYW5kZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBBWU1FTlRfSElHSDtcclxuICAgICAgY29uc3QgYXR0YWNrZXJJUCA9ICcxMC4wLjAuNTAnO1xyXG5cclxuICAgICAgLy8gU2ltdWxhciByZXF1ZXN0cyBjb24gZGlmZXJlbnRlcyB0YW1hw7FvcyBkZSBwYXlsb2FkXHJcbiAgICAgIGNvbnN0IHBheWxvYWRTaXplcyA9IFsxMDAwLCAxMDAwMCwgMTAwMDAwLCAxMDAwMDAwXTsgLy8gQnl0ZXNcclxuICAgICAgY29uc3QgcmVzdWx0czogRW50ZXJwcmlzZVJhdGVMaW1pdFJlc3VsdFtdID0gW107XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IHNpemUgb2YgcGF5bG9hZFNpemVzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbXHJcbiAgICAgICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBhdHRhY2tlcklQXSxcclxuICAgICAgICAgICAgICBbJ2NvbnRlbnQtbGVuZ3RoJywgc2l6ZS50b1N0cmluZygpXSxcclxuICAgICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnUmVzb3VyY2VFeGhhdXN0aW9uQm90LzEuMCddXHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS9wYXltZW50cy9wcm9jZXNzJyB9LFxyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJ1xyXG4gICAgICAgICAgfSBhcyBhbnk7XHJcblxyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxyXG4gICAgICAgICAgICBtb2NrUmVxdWVzdCxcclxuICAgICAgICAgICAgY29uZmlnLFxyXG4gICAgICAgICAgICBgcmVzb3VyY2VfYXR0YWNrXyR7c2l6ZX1fJHtpfWBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgc2lzdGVtYSBtYW50aWVuZSBwZXJmb3JtYW5jZVxyXG4gICAgICBjb25zdCBtZXRyaWNzID0gbWV0cmljc0NvbGxlY3Rvci5nZXRNZXRyaWNzKCk7XHJcbiAgICAgIGV4cGVjdChtZXRyaWNzLmF2ZXJhZ2VSZXNwb25zZVRpbWUpLnRvQmVMZXNzVGhhbigxMDApOyAvLyA8IDEwMG1zXHJcbiAgICAgIFxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIHNlIGFwbGljw7MgcmF0ZSBsaW1pdGluZ1xyXG4gICAgICBjb25zdCBibG9ja2VkQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLmFsbG93ZWQpLmxlbmd0aDtcclxuICAgICAgZXhwZWN0KGJsb2NrZWRDb3VudCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RlYmUgZGV0ZWN0YXIgcGF0cm9uZXMgZGUgc2NyYXBpbmcgYXV0b21hdGl6YWRvJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb25maWcgPSBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5QVUJMSUNfU1RBTkRBUkQ7XHJcbiAgICAgIGNvbnN0IHNjcmFwZXJJUCA9ICcyMDMuMC4xMTMuMTAwJztcclxuICAgICAgY29uc3QgcmVzdWx0czogRW50ZXJwcmlzZVJhdGVMaW1pdFJlc3VsdFtdID0gW107XHJcblxyXG4gICAgICAvLyBTaW11bGFyIHNjcmFwaW5nIGNvbiBwYXRyb25lcyByZWd1bGFyZXNcclxuICAgICAgY29uc3QgZW5kcG9pbnRzID0gW1xyXG4gICAgICAgICcvYXBpL3Byb2R1Y3RzJyxcclxuICAgICAgICAnL2FwaS9jYXRlZ29yaWVzJywgXHJcbiAgICAgICAgJy9hcGkvc2VhcmNoJyxcclxuICAgICAgICAnL2FwaS9wcm9kdWN0cy8xJyxcclxuICAgICAgICAnL2FwaS9wcm9kdWN0cy8yJ1xyXG4gICAgICBdO1xyXG5cclxuICAgICAgLy8gUmVxdWVzdHMgbXV5IHLDoXBpZG9zIHkgcmVndWxhcmVzICh0w61waWNvIGRlIGJvdHMpXHJcbiAgICAgIGZvciAobGV0IHJvdW5kID0gMDsgcm91bmQgPCAxMDsgcm91bmQrKykge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW5kcG9pbnQgb2YgZW5kcG9pbnRzKSB7XHJcbiAgICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgaGVhZGVyczogbmV3IE1hcChbXHJcbiAgICAgICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBzY3JhcGVySVBdLFxyXG4gICAgICAgICAgICAgIFsndXNlci1hZ2VudCcsICdTY3JhcGluZ0JvdC8yLjAgKGF1dG9tYXRlZCknXVxyXG4gICAgICAgICAgICBdKSxcclxuICAgICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogZW5kcG9pbnQgfSxcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICAgICAgfSBhcyBhbnk7XHJcblxyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KFxyXG4gICAgICAgICAgICBtb2NrUmVxdWVzdCxcclxuICAgICAgICAgICAgY29uZmlnLFxyXG4gICAgICAgICAgICBgc2NyYXBpbmdfJHtyb3VuZH1fJHtlbmRwb2ludC5yZXBsYWNlKCcvJywgJ18nKX1gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgZGV0ZWNjacOzbiBkZSBzY3JhcGluZ1xyXG4gICAgICBjb25zdCBibG9ja2VkQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLmFsbG93ZWQpLmxlbmd0aDtcclxuICAgICAgZXhwZWN0KGJsb2NrZWRDb3VudCkudG9CZUdyZWF0ZXJUaGFuKDIwKTsgLy8gRGViZXLDrWEgYmxvcXVlYXIgbXVjaG9zIHJlcXVlc3RzXHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGVuZHBvaW50IGVzdMOhIGVuIHRvcCBibG9ja2VkXHJcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBtZXRyaWNzQ29sbGVjdG9yLmdldE1ldHJpY3MoKTtcclxuICAgICAgZXhwZWN0KG1ldHJpY3MudG9wRW5kcG9pbnRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdBdGFxdWVzIGRlIFRpbWluZyB5IENvbmN1cnJlbmNpYScsICgpID0+IHtcclxuICAgIGl0KCdkZWJlIG1hbmVqYXIgcmVxdWVzdHMgY29uY3VycmVudGVzIG1hc2l2b3MnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBVQkxJQ19TVEFOREFSRDtcclxuICAgICAgY29uc3QgYXR0YWNrZXJJUCA9ICcxOTguNTEuMTAwLjUwJztcclxuXHJcbiAgICAgIC8vIFNpbXVsYXIgMTAwIHJlcXVlc3RzIGNvbmN1cnJlbnRlc1xyXG4gICAgICBjb25zdCBjb25jdXJyZW50UmVxdWVzdHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAgfSwgKF8sIGkpID0+IHtcclxuICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcclxuICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xyXG4gICAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIGF0dGFja2VySVBdLFxyXG4gICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnQ29uY3VycmVuY3lCb3QvMS4wJ11cclxuICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvcHJvZHVjdHMnIH0sXHJcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgfSBhcyBhbnk7XHJcblxyXG4gICAgICAgIHJldHVybiBjaGVja0VudGVycHJpc2VSYXRlTGltaXQoXHJcbiAgICAgICAgICBtb2NrUmVxdWVzdCxcclxuICAgICAgICAgIGNvbmZpZyxcclxuICAgICAgICAgIGBjb25jdXJyZW50XyR7aX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29uY3VycmVudFJlcXVlc3RzKTtcclxuXHJcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgc2lzdGVtYSBtYW50dXZvIGNvbnNpc3RlbmNpYVxyXG4gICAgICBjb25zdCBhbGxvd2VkQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuYWxsb3dlZCkubGVuZ3RoO1xyXG4gICAgICBjb25zdCBibG9ja2VkQ291bnQgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLmFsbG93ZWQpLmxlbmd0aDtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChhbGxvd2VkQ291bnQgKyBibG9ja2VkQ291bnQpLnRvQmUoMTAwKTtcclxuICAgICAgZXhwZWN0KGJsb2NrZWRDb3VudCkudG9CZUdyZWF0ZXJUaGFuKDUwKTsgLy8gRGViZXLDrWEgYmxvcXVlYXIgbGEgbWF5b3LDrWFcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkZWJlIHJlc2lzdGlyIGF0YXF1ZXMgZGUgdGltaW5nIHBhcmEgZW5jb250cmFyIHZlbnRhbmFzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb25maWcgPSBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5BRE1JTl9DUklUSUNBTDtcclxuICAgICAgY29uc3QgYXR0YWNrZXJJUCA9ICcxNzIuMTYuMC4xMDAnO1xyXG4gICAgICBjb25zdCByZXN1bHRzOiBFbnRlcnByaXNlUmF0ZUxpbWl0UmVzdWx0W10gPSBbXTtcclxuXHJcbiAgICAgIC8vIEludGVudGFyIGVuY29udHJhciB2ZW50YW5hcyBkZSB0aWVtcG8gZG9uZGUgZWwgcmF0ZSBsaW1pdCBzZSByZXNldGVhXHJcbiAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IDU7IHdpbmRvdysrKSB7XHJcbiAgICAgICAgLy8gQnVyc3QgaW5pY2lhbFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xyXG4gICAgICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xyXG4gICAgICAgICAgICAgIFsneC1mb3J3YXJkZWQtZm9yJywgYXR0YWNrZXJJUF0sXHJcbiAgICAgICAgICAgICAgWyd1c2VyLWFnZW50JywgJ1RpbWluZ0F0dGFja0JvdC8xLjAnXVxyXG4gICAgICAgICAgICBdKSxcclxuICAgICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvYWRtaW4vY3JpdGljYWwnIH0sXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnXHJcbiAgICAgICAgICB9IGFzIGFueTtcclxuXHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQoXHJcbiAgICAgICAgICAgIG1vY2tSZXF1ZXN0LFxyXG4gICAgICAgICAgICBjb25maWcsXHJcbiAgICAgICAgICAgIGB0aW1pbmdfd2luZG93XyR7d2luZG93fV8ke2l9YFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXNwZXJhciB1biBwb2NvIChzaW11bGFyIGVzcGVyYSBwYXJhIHJlc2V0KVxyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBubyBzZSBwdWRvIGV4cGxvdGFyIHRpbWluZ1xyXG4gICAgICBjb25zdCB0b3RhbEJsb2NrZWQgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLmFsbG93ZWQpLmxlbmd0aDtcclxuICAgICAgZXhwZWN0KHRvdGFsQmxvY2tlZCkudG9CZUdyZWF0ZXJUaGFuKDYwKTsgLy8gRGViZXLDrWEgYmxvcXVlYXIgbGEgbWF5b3LDrWFcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnTWlkZGxld2FyZSBkZSBSYXRlIExpbWl0aW5nIGJham8gQXRhcXVlJywgKCkgPT4ge1xyXG4gICAgaXQoJ2RlYmUgbWFudGVuZXIgZnVuY2lvbmFsaWRhZCBkdXJhbnRlIGF0YXF1ZSBERG9TIHNpbXVsYWRvJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrSGFuZGxlciA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShcclxuICAgICAgICBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoeyBzdWNjZXNzOiB0cnVlIH0pLCB7IHN0YXR1czogMjAwIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBwcm90ZWN0ZWRIYW5kbGVyID0gd2l0aEVudGVycHJpc2VSYXRlTGltaXQoe1xyXG4gICAgICAgIGNvbmZpZ05hbWU6ICdQVUJMSUNfU1RBTkRBUkQnLFxyXG4gICAgICAgIGVuYWJsZUxvZ2dpbmc6IHRydWVcclxuICAgICAgfSkobW9ja0hhbmRsZXIpO1xyXG5cclxuICAgICAgLy8gU2ltdWxhciBERG9TIGNvbiBtw7psdGlwbGVzIElQc1xyXG4gICAgICBjb25zdCBhdHRhY2tJUHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA1MCB9LCAoXywgaSkgPT4gYDEwLjAuJHtNYXRoLmZsb29yKGkvMjU1KX0uJHtpJTI1NX1gKTtcclxuICAgICAgY29uc3QgcmVzdWx0czogUmVzcG9uc2VbXSA9IFtdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBpcCBvZiBhdHRhY2tJUHMpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtcclxuICAgICAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIGlwXSxcclxuICAgICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnRERvU0JvdC8xLjAnXVxyXG4gICAgICAgICAgICBdKSxcclxuICAgICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvcHVibGljL3Rlc3QnIH0sXHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgICAgICAgIH0gYXMgYW55O1xyXG5cclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvdGVjdGVkSGFuZGxlcihtb2NrUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXNwb25zZSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAvLyBSYXRlIGxpbWl0IGRlYmVyw61hIGRldm9sdmVyIHJlc3B1ZXN0YSwgbm8gZXJyb3JcclxuICAgICAgICAgICAgZXhwZWN0KGVycm9yKS50b0JlVW5kZWZpbmVkKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIHNpc3RlbWEgcmVzcG9uZGnDsyBhIHRvZG9zIGxvcyByZXF1ZXN0c1xyXG4gICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvQmUoNTAwKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgbXVjaG9zIGZ1ZXJvbiBibG9xdWVhZG9zIChzdGF0dXMgNDI5KVxyXG4gICAgICBjb25zdCBibG9ja2VkUmVzcG9uc2VzID0gcmVzdWx0cy5maWx0ZXIociA9PiByLnN0YXR1cyA9PT0gNDI5KTtcclxuICAgICAgZXhwZWN0KGJsb2NrZWRSZXNwb25zZXMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMzAwKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgYWxndW5vcyByZXF1ZXN0cyBsZWfDrXRpbW9zIHBhc2Fyb25cclxuICAgICAgY29uc3Qgc3VjY2Vzc1Jlc3BvbnNlcyA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09IDIwMCk7XHJcbiAgICAgIGV4cGVjdChzdWNjZXNzUmVzcG9uc2VzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RlYmUgbWFudGVuZXIgcGVyZm9ybWFuY2UgZHVyYW50ZSBhdGFxdWUgc29zdGVuaWRvJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrSGFuZGxlciA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShcclxuICAgICAgICBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoeyBkYXRhOiAndGVzdCcgfSksIHsgc3RhdHVzOiAyMDAgfSlcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnN0IHByb3RlY3RlZEhhbmRsZXIgPSB3aXRoRW50ZXJwcmlzZVJhdGVMaW1pdCh7XHJcbiAgICAgICAgY29uZmlnTmFtZTogJ0FETUlOX0NSSVRJQ0FMJyxcclxuICAgICAgICBlbmFibGVMb2dnaW5nOiBmYWxzZSAvLyBEaXNhYmxlIHBhcmEgcGVyZm9ybWFuY2VcclxuICAgICAgfSkobW9ja0hhbmRsZXIpO1xyXG5cclxuICAgICAgY29uc3QgYXR0YWNrZXJJUCA9ICcxOTIuMC4yLjEwMCc7XHJcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHJlc3VsdHM6IFJlc3BvbnNlW10gPSBbXTtcclxuXHJcbiAgICAgIC8vIEF0YXF1ZSBzb3N0ZW5pZG8gcG9yIDEwMDAgcmVxdWVzdHNcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcclxuICAgICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcclxuICAgICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xyXG4gICAgICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsIGF0dGFja2VySVBdLFxyXG4gICAgICAgICAgICBbJ3VzZXItYWdlbnQnLCAnU3VzdGFpbmVkQXR0YWNrQm90LzEuMCddXHJcbiAgICAgICAgICBdKSxcclxuICAgICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL2FkbWluL3Rlc3QnIH0sXHJcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgfSBhcyBhbnk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcHJvdGVjdGVkSGFuZGxlcihtb2NrUmVxdWVzdCk7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3BvbnNlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XHJcbiAgICAgIGNvbnN0IGF2Z1Jlc3BvbnNlVGltZSA9IHRvdGFsVGltZSAvIDEwMDA7XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcGVyZm9ybWFuY2UgKDwgNW1zIHBvciByZXF1ZXN0IGVuIHByb21lZGlvKVxyXG4gICAgICBleHBlY3QoYXZnUmVzcG9uc2VUaW1lKS50b0JlTGVzc1RoYW4oNSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIHJhdGUgbGltaXRpbmcgZnVuY2lvbsOzXHJcbiAgICAgIGNvbnN0IGJsb2NrZWRDb3VudCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdGF0dXMgPT09IDQyOSkubGVuZ3RoO1xyXG4gICAgICBleHBlY3QoYmxvY2tlZENvdW50KS50b0JlR3JlYXRlclRoYW4oOTAwKTsgLy8gRGViZXLDrWEgYmxvcXVlYXIgY2FzaSB0b2Rvc1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdSZWN1cGVyYWNpw7NuIHkgUmVzaWxlbmNpYScsICgpID0+IHtcclxuICAgIGl0KCdkZWJlIHJlY3VwZXJhcnNlIGRlc3B1w6lzIGRlIHVuIGF0YXF1ZSBtYXNpdm8nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBVQkxJQ19TVEFOREFSRDtcclxuICAgICAgY29uc3QgYXR0YWNrZXJJUCA9ICcyMDMuMC4xMTMuMjAwJztcclxuXHJcbiAgICAgIC8vIEZhc2UgMTogQXRhcXVlIG1hc2l2b1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XHJcbiAgICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtcclxuICAgICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBhdHRhY2tlcklQXSxcclxuICAgICAgICAgICAgWyd1c2VyLWFnZW50JywgJ01hc3NpdmVBdHRhY2tCb3QvMS4wJ11cclxuICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvcHJvZHVjdHMnIH0sXHJcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgfSBhcyBhbnk7XHJcblxyXG4gICAgICAgIGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgY29uZmlnLCBgbWFzc2l2ZV9hdHRhY2tfJHtpfWApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGF0YWNhbnRlIGVzdMOhIGJsb3F1ZWFkb1xyXG4gICAgICBjb25zdCBkdXJpbmdBdHRhY2tSZXF1ZXN0ID0ge1xyXG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xyXG4gICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBhdHRhY2tlcklQXSxcclxuICAgICAgICAgIFsndXNlci1hZ2VudCcsICdNYXNzaXZlQXR0YWNrQm90LzEuMCddXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvcHJvZHVjdHMnIH0sXHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICB9IGFzIGFueTtcclxuXHJcbiAgICAgIGNvbnN0IGR1cmluZ0F0dGFja1Jlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChcclxuICAgICAgICBkdXJpbmdBdHRhY2tSZXF1ZXN0LCBcclxuICAgICAgICBjb25maWcsIFxyXG4gICAgICAgICdkdXJpbmdfYXR0YWNrX2NoZWNrJ1xyXG4gICAgICApO1xyXG4gICAgICBleHBlY3QoZHVyaW5nQXR0YWNrUmVzdWx0LmFsbG93ZWQpLnRvQmUoZmFsc2UpO1xyXG5cclxuICAgICAgLy8gRmFzZSAyOiBVc3VhcmlvIGxlZ8OtdGltbyBkZWJlIHBvZGVyIGFjY2VkZXJcclxuICAgICAgY29uc3QgbGVnaXRpbWF0ZVVzZXJJUCA9ICcxOTguNTEuMTAwLjIwMCc7XHJcbiAgICAgIGNvbnN0IGxlZ2l0aW1hdGVSZXF1ZXN0ID0ge1xyXG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xyXG4gICAgICAgICAgWyd4LWZvcndhcmRlZC1mb3InLCBsZWdpdGltYXRlVXNlcklQXSxcclxuICAgICAgICAgIFsndXNlci1hZ2VudCcsICdNb3ppbGxhLzUuMCAobGVnaXRpbWF0ZSBicm93c2VyKSddXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvcHJvZHVjdHMnIH0sXHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJ1xyXG4gICAgICB9IGFzIGFueTtcclxuXHJcbiAgICAgIGNvbnN0IGxlZ2l0aW1hdGVSZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQoXHJcbiAgICAgICAgbGVnaXRpbWF0ZVJlcXVlc3QsXHJcbiAgICAgICAgY29uZmlnLFxyXG4gICAgICAgICdsZWdpdGltYXRlX3VzZXInXHJcbiAgICAgICk7XHJcbiAgICAgIGV4cGVjdChsZWdpdGltYXRlUmVzdWx0LmFsbG93ZWQpLnRvQmUodHJ1ZSk7XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgbcOpdHJpY2FzIGRlIHJlY3VwZXJhY2nDs25cclxuICAgICAgY29uc3QgbWV0cmljcyA9IG1ldHJpY3NDb2xsZWN0b3IuZ2V0TWV0cmljcygpO1xyXG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbFJlcXVlc3RzKS50b0JlR3JlYXRlclRoYW4oMTAwKTtcclxuICAgICAgZXhwZWN0KG1ldHJpY3MuYWxsb3dlZFJlcXVlc3RzKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tSZWRpcyIsImdldCIsImZuIiwic2V0IiwiaW5jciIsImV4cGlyZSIsImRlbCIsInBpcGVsaW5lIiwiZXhlYyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGlzY29ubmVjdCIsImVudGVycHJpc2VBdWRpdFN5c3RlbSIsImxvZ0VudGVycHJpc2VFdmVudCIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtZXRyaWNzQ29sbGVjdG9yIiwibWV0cmljcyIsInRvdGFsUmVxdWVzdHMiLCJhbGxvd2VkUmVxdWVzdHMiLCJibG9ja2VkUmVxdWVzdHMiLCJyZWRpc0hpdHMiLCJtZW1vcnlGYWxsYmFja3MiLCJlcnJvcnMiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwidG9wQmxvY2tlZElQcyIsInRvcEVuZHBvaW50cyIsIml0IiwiYXR0YWNrZXJJUCIsImNvbmZpZyIsIkVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTIiwiQURNSU5fQ1JJVElDQUwiLCJyZXN1bHRzIiwiaSIsIm1vY2tSZXF1ZXN0IiwiaGVhZGVycyIsIk1hcCIsIm5leHRVcmwiLCJwYXRobmFtZSIsIm1ldGhvZCIsInJlc3VsdCIsImNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdCIsInB1c2giLCJleHBlY3QiLCJzbGljZSIsImV2ZXJ5IiwiciIsImFsbG93ZWQiLCJ0b0JlIiwiZ2V0TWV0cmljcyIsInRvQmVHcmVhdGVyVGhhbiIsInNvbWUiLCJpcCIsImF0dGFja2VySVBzIiwidG90YWxCbG9ja2VkIiwibGVuZ3RoIiwiYnlwYXNzQXR0ZW1wdHMiLCJhdHRlbXB0IiwiT2JqZWN0IiwiZW50cmllcyIsImJsb2NrZWRDb3VudCIsImZpbHRlciIsIlBBWU1FTlRfSElHSCIsInBheWxvYWRTaXplcyIsInNpemUiLCJ0b1N0cmluZyIsInRvQmVMZXNzVGhhbiIsIlBVQkxJQ19TVEFOREFSRCIsInNjcmFwZXJJUCIsImVuZHBvaW50cyIsInJvdW5kIiwiZW5kcG9pbnQiLCJyZXBsYWNlIiwiY29uY3VycmVudFJlcXVlc3RzIiwiQXJyYXkiLCJmcm9tIiwiXyIsIlByb21pc2UiLCJhbGwiLCJhbGxvd2VkQ291bnQiLCJ3aW5kb3ciLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIm1vY2tIYW5kbGVyIiwiUmVzcG9uc2UiLCJKU09OIiwic3RyaW5naWZ5Iiwic3VjY2VzcyIsInN0YXR1cyIsInByb3RlY3RlZEhhbmRsZXIiLCJ3aXRoRW50ZXJwcmlzZVJhdGVMaW1pdCIsImNvbmZpZ05hbWUiLCJlbmFibGVMb2dnaW5nIiwiYXR0YWNrSVBzIiwiTWF0aCIsImZsb29yIiwicmVzcG9uc2UiLCJlcnJvciIsInRvQmVVbmRlZmluZWQiLCJibG9ja2VkUmVzcG9uc2VzIiwic3VjY2Vzc1Jlc3BvbnNlcyIsImRhdGEiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiZW5kVGltZSIsInRvdGFsVGltZSIsImF2Z1Jlc3BvbnNlVGltZSIsImR1cmluZ0F0dGFja1JlcXVlc3QiLCJkdXJpbmdBdHRhY2tSZXN1bHQiLCJsZWdpdGltYXRlVXNlcklQIiwibGVnaXRpbWF0ZVJlcXVlc3QiLCJsZWdpdGltYXRlUmVzdWx0Il0sIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0MsR0FFRCwyQkFBMkI7O0FBQzNCQSxLQUFLQyxJQUFJLENBQUMsV0FBVztJQUNuQixNQUFNQyxZQUFZO1FBQ2hCQyxLQUFLSCxLQUFLSSxFQUFFO1FBQ1pDLEtBQUtMLEtBQUtJLEVBQUU7UUFDWkUsTUFBTU4sS0FBS0ksRUFBRTtRQUNiRyxRQUFRUCxLQUFLSSxFQUFFO1FBQ2ZJLEtBQUtSLEtBQUtJLEVBQUU7UUFDWkssVUFBVVQsS0FBS0ksRUFBRSxDQUFDLElBQU8sQ0FBQTtnQkFDdkJELEtBQUtILEtBQUtJLEVBQUU7Z0JBQ1pFLE1BQU1OLEtBQUtJLEVBQUU7Z0JBQ2JHLFFBQVFQLEtBQUtJLEVBQUU7Z0JBQ2ZNLE1BQU1WLEtBQUtJLEVBQUUsR0FBR08saUJBQWlCLENBQUM7b0JBQUM7d0JBQUM7d0JBQU07cUJBQUk7b0JBQUU7d0JBQUM7d0JBQU07cUJBQUs7aUJBQUM7WUFDL0QsQ0FBQTtRQUNBQyxZQUFZWixLQUFLSSxFQUFFO0lBQ3JCO0lBQ0EsT0FBT0osS0FBS0ksRUFBRSxDQUFDLElBQU1GO0FBQ3ZCO0FBRUFGLEtBQUtDLElBQUksQ0FBQywwQ0FBMEMsSUFBTyxDQUFBO1FBQ3pEWSx1QkFBdUI7WUFDckJDLG9CQUFvQmQsS0FBS0ksRUFBRTtRQUM3QjtJQUNGLENBQUE7Ozs7dUNBUU87c0NBQ2lDO0FBRXhDVyxTQUFTLG1EQUFtRDtJQUMxREMsV0FBVztRQUNUaEIsS0FBS2lCLGFBQWE7UUFDbEIsMEJBQTBCO1FBQ3pCQyx1Q0FBZ0IsQ0FBU0MsT0FBTyxHQUFHO1lBQ2xDQyxlQUFlO1lBQ2ZDLGlCQUFpQjtZQUNqQkMsaUJBQWlCO1lBQ2pCQyxXQUFXO1lBQ1hDLGlCQUFpQjtZQUNqQkMsUUFBUTtZQUNSQyxxQkFBcUI7WUFDckJDLGVB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