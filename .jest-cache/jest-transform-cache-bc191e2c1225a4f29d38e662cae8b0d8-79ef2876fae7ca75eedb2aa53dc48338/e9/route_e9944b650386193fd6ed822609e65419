671cc3428f49d6de0f83a6bb3b0f9c0b
// ===================================
// PINTEYA E-COMMERCE - MERCADOPAGO REPORTS API
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get GET () {
        return GET;
    },
    get POST () {
        return POST;
    }
});
const _server = require("next/server");
const _auth = require("../../../../auth");
const _supabase = require("../../../../lib/supabase");
const _logger = require("../../../../lib/logger");
const _ratelimiter = require("../../../../lib/rate-limiter");
const _metrics = require("../../../../lib/metrics");
async function GET(request) {
    const startTime = Date.now();
    const clientIP = request.headers.get('x-forwarded-for') || 'unknown';
    const userAgent = request.headers.get('user-agent') || 'unknown';
    try {
        // Verificar autenticación
        const session = await (0, _auth.auth)();
        if (!session?.user) {
            return _server.NextResponse.json({
                success: false,
                error: 'No autorizado'
            }, {
                status: 401
            });
        }
        // Rate limiting
        const rateLimitResult = await (0, _ratelimiter.checkRateLimit)(request, _ratelimiter.RATE_LIMIT_CONFIGS.QUERY_API);
        if (!rateLimitResult.success) {
            _logger.logger.warn(_logger.LogCategory.API, 'Rate limit exceeded for reports', {
                clientIP,
                userId
            });
            const response = _server.NextResponse.json({
                success: false,
                error: 'Demasiadas solicitudes'
            }, {
                status: 429
            });
            (0, _ratelimiter.addRateLimitHeaders)(response, rateLimitResult, _ratelimiter.RATE_LIMIT_CONFIGS.QUERY_API);
            return response;
        }
        // Obtener parámetros de consulta
        const url = new URL(request.url);
        const reportType = url.searchParams.get('type') || 'account_money';
        const dateFrom = url.searchParams.get('date_from');
        const dateTo = url.searchParams.get('date_to');
        const includeMetrics = url.searchParams.get('include_metrics') === 'true';
        // Validar parámetros
        if (![
            'released_money',
            'account_money',
            'sales_report'
        ].includes(reportType)) {
            return _server.NextResponse.json({
                success: false,
                error: 'Tipo de reporte inválido'
            }, {
                status: 400
            });
        }
        _logger.logger.info(_logger.LogCategory.API, 'Reports request started', {
            userId,
            reportType,
            dateFrom,
            dateTo,
            includeMetrics,
            clientIP
        });
        // Generar reporte
        const reportData = await generateReport(reportType, dateFrom, dateTo, includeMetrics);
        // Registrar métricas
        await _metrics.metricsCollector.recordRequest('/api/payments/reports', 'GET', 200, Date.now() - startTime, {
            userId,
            reportType
        });
        _logger.logger.info(_logger.LogCategory.API, 'Reports request completed', {
            userId,
            reportType,
            recordsCount: reportData.records?.length || 0,
            processingTime: Date.now() - startTime
        });
        const response = _server.NextResponse.json({
            success: true,
            data: reportData,
            timestamp: Date.now(),
            processing_time: Date.now() - startTime
        });
        (0, _ratelimiter.addRateLimitHeaders)(response, rateLimitResult, _ratelimiter.RATE_LIMIT_CONFIGS.QUERY_API);
        return response;
    } catch (error) {
        const processingTime = Date.now() - startTime;
        _logger.logger.performance(_logger.LogLevel.ERROR, 'Reports request failed', {
            operation: 'reports-api',
            duration: processingTime,
            statusCode: 500
        }, {
            clientIP,
            userAgent
        });
        await _metrics.metricsCollector.recordRequest('/api/payments/reports', 'GET', 500, processingTime, {
            error: error.message
        });
        return _server.NextResponse.json({
            success: false,
            error: 'Error interno del servidor'
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    const startTime = Date.now();
    const clientIP = request.headers.get('x-forwarded-for') || 'unknown';
    try {
        // Verificar autenticación
        const session = await (0, _auth.auth)();
        if (!session?.user) {
            return _server.NextResponse.json({
                success: false,
                error: 'No autorizado'
            }, {
                status: 401
            });
        }
        // Rate limiting
        const rateLimitResult = await (0, _ratelimiter.checkRateLimit)(request, _ratelimiter.RATE_LIMIT_CONFIGS.PAYMENT_API);
        if (!rateLimitResult.success) {
            const response = _server.NextResponse.json({
                success: false,
                error: 'Demasiadas solicitudes'
            }, {
                status: 429
            });
            (0, _ratelimiter.addRateLimitHeaders)(response, rateLimitResult, _ratelimiter.RATE_LIMIT_CONFIGS.PAYMENT_API);
            return response;
        }
        const body = await request.json();
        const { type, date_from, date_to, columns } = body;
        // Validar datos requeridos
        if (!type || !date_from || !date_to) {
            return _server.NextResponse.json({
                success: false,
                error: 'Faltan parámetros requeridos'
            }, {
                status: 400
            });
        }
        _logger.logger.info(_logger.LogCategory.API, 'Report creation started', {
            userId,
            type,
            date_from,
            date_to,
            clientIP
        });
        // Crear reporte
        const report = await createMercadoPagoReport(type, date_from, date_to, columns);
        // Registrar métricas
        await _metrics.metricsCollector.recordRequest('/api/payments/reports', 'POST', 201, Date.now() - startTime, {
            userId,
            reportType: type
        });
        _logger.logger.info(_logger.LogCategory.API, 'Report creation completed', {
            userId,
            reportId: report.id,
            type,
            processingTime: Date.now() - startTime
        });
        const response = _server.NextResponse.json({
            success: true,
            data: report,
            timestamp: Date.now(),
            processing_time: Date.now() - startTime
        }, {
            status: 201
        });
        (0, _ratelimiter.addRateLimitHeaders)(response, rateLimitResult, _ratelimiter.RATE_LIMIT_CONFIGS.PAYMENT_API);
        return response;
    } catch (error) {
        const processingTime = Date.now() - startTime;
        _logger.logger.performance(_logger.LogLevel.ERROR, 'Report creation failed', {
            operation: 'report-creation-api',
            duration: processingTime,
            statusCode: 500
        }, {
            clientIP
        });
        await _metrics.metricsCollector.recordRequest('/api/payments/reports', 'POST', 500, processingTime, {
            error: error.message
        });
        return _server.NextResponse.json({
            success: false,
            error: 'Error interno del servidor'
        }, {
            status: 500
        });
    }
}
/**
 * Genera reporte basado en datos de Supabase (simulando API de MercadoPago)
 */ async function generateReport(type, dateFrom, dateTo, includeMetrics = false) {
    const supabase = (0, _supabase.getSupabaseClient)();
    if (!supabase) {
        throw new Error('Error de configuración de base de datos');
    }
    // Configurar fechas por defecto (últimos 30 días)
    const endDate = dateTo ? new Date(dateTo) : new Date();
    const startDate = dateFrom ? new Date(dateFrom) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    let query = supabase.from('orders').select(`
      id,
      total_amount,
      status,
      payment_status,
      created_at,
      updated_at,
      order_items (
        quantity,
        unit_price,
        products (
          name,
          category_id
        )
      )
    `).gte('created_at', startDate.toISOString()).lte('created_at', endDate.toISOString());
    // Filtrar según tipo de reporte
    switch(type){
        case 'released_money':
            query = query.eq('payment_status', 'approved');
            break;
        case 'account_money':
            break;
        case 'sales_report':
            query = query.in('status', [
                'completed',
                'processing'
            ]);
            break;
    }
    const { data: orders, error } = await query;
    if (error) {
        throw new Error(`Error al obtener datos: ${error.message}`);
    }
    // Procesar datos según tipo de reporte
    const processedData = processReportData(orders || [], type);
    // Calcular métricas si se solicitan
    const metrics = includeMetrics ? calculateReportMetrics(orders || []) : undefined;
    return {
        type,
        date_from: startDate.toISOString(),
        date_to: endDate.toISOString(),
        records: processedData,
        metrics,
        total_records: processedData.length,
        generated_at: new Date().toISOString()
    };
}
/**
 * Procesa los datos según el tipo de reporte
 */ function processReportData(orders, type) {
    return orders.map((order)=>{
        const baseData = {
            order_id: order.id,
            amount: order.total_amount,
            status: order.payment_status || order.status,
            created_at: order.created_at,
            updated_at: order.updated_at
        };
        switch(type){
            case 'released_money':
                return {
                    ...baseData,
                    release_date: order.updated_at,
                    net_amount: order.total_amount * 0.96,
                    fee_amount: order.total_amount * 0.04
                };
            case 'account_money':
                return {
                    ...baseData,
                    transaction_type: 'payment',
                    balance_impact: order.payment_status === 'approved' ? order.total_amount : 0
                };
            case 'sales_report':
                return {
                    ...baseData,
                    items: order.order_items?.map((item)=>({
                            name: item.products?.name,
                            quantity: item.quantity,
                            unit_price: item.unit_price,
                            category: item.products?.category_id
                        })) || [],
                    items_count: order.order_items?.length || 0
                };
            default:
                return baseData;
        }
    });
}
/**
 * Calcula métricas del reporte
 */ function calculateReportMetrics(orders) {
    const totalTransactions = orders.length;
    const successfulPayments = orders.filter((o)=>o.payment_status === 'approved').length;
    const failedPayments = orders.filter((o)=>o.payment_status === 'rejected').length;
    const totalAmount = orders.reduce((sum, o)=>sum + (o.total_amount || 0), 0);
    return {
        total_transactions: totalTransactions,
        total_amount: totalAmount,
        successful_payments: successfulPayments,
        failed_payments: failedPayments,
        refunds: 0,
        chargebacks: 0,
        average_ticket: totalTransactions > 0 ? totalAmount / totalTransactions : 0,
        conversion_rate: totalTransactions > 0 ? successfulPayments / totalTransactions * 100 : 0
    };
}
/**
 * Crea un reporte en MercadoPago (simulado)
 */ async function createMercadoPagoReport(type, dateFrom, dateTo, columns) {
    // En una implementación real, aquí se haría la llamada a la API de MercadoPago
    // Por ahora simulamos la creación del reporte
    const reportId = `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    return {
        id: reportId,
        type: type,
        date_from: dateFrom,
        date_to: dateTo,
        status: 'pending',
        created_at: new Date().toISOString()
    };
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcYXBwXFxhcGlcXHBheW1lbnRzXFxyZXBvcnRzXFxyb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBNRVJDQURPUEFHTyBSRVBPUlRTIEFQSVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcclxuaW1wb3J0IHsgYXV0aCB9IGZyb20gJ0AvYXV0aCc7XHJcbmltcG9ydCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnO1xyXG5pbXBvcnQgeyBsb2dnZXIsIExvZ0xldmVsLCBMb2dDYXRlZ29yeSB9IGZyb20gJ0AvbGliL2xvZ2dlcic7XHJcbmltcG9ydCB7IGNoZWNrUmF0ZUxpbWl0LCBhZGRSYXRlTGltaXRIZWFkZXJzLCBSQVRFX0xJTUlUX0NPTkZJR1MgfSBmcm9tICdAL2xpYi9yYXRlLWxpbWl0ZXInO1xyXG5pbXBvcnQgeyBtZXRyaWNzQ29sbGVjdG9yIH0gZnJvbSAnQC9saWIvbWV0cmljcyc7XHJcbmltcG9ydCB7IE1lcmNhZG9QYWdvUmVwb3J0LCBSZXBvcnRNZXRyaWNzIH0gZnJvbSAnQC90eXBlcy9hcGknO1xyXG5cclxuLyoqXHJcbiAqIEdFVCAvYXBpL3BheW1lbnRzL3JlcG9ydHNcclxuICogT2J0aWVuZSByZXBvcnRlcyBkZSBNZXJjYWRvUGFnbyBzZWfDum4gZG9jdW1lbnRhY2nDs24gb2ZpY2lhbFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xyXG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgY29uc3QgY2xpZW50SVAgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCd4LWZvcndhcmRlZC1mb3InKSB8fCAndW5rbm93bic7XHJcbiAgY29uc3QgdXNlckFnZW50ID0gcmVxdWVzdC5oZWFkZXJzLmdldCgndXNlci1hZ2VudCcpIHx8ICd1bmtub3duJztcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIFZlcmlmaWNhciBhdXRlbnRpY2FjacOzblxyXG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGF1dGgoKTtcclxuICAgIGlmICghc2Vzc2lvbj8udXNlcikge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdObyBhdXRvcml6YWRvJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA0MDEgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJhdGUgbGltaXRpbmdcclxuICAgIGNvbnN0IHJhdGVMaW1pdFJlc3VsdCA9IGF3YWl0IGNoZWNrUmF0ZUxpbWl0KFxyXG4gICAgICByZXF1ZXN0LFxyXG4gICAgICBSQVRFX0xJTUlUX0NPTkZJR1MuUVVFUllfQVBJXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghcmF0ZUxpbWl0UmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgbG9nZ2VyLndhcm4oTG9nQ2F0ZWdvcnkuQVBJLCAnUmF0ZSBsaW1pdCBleGNlZWRlZCBmb3IgcmVwb3J0cycsIHtcclxuICAgICAgICBjbGllbnRJUCxcclxuICAgICAgICB1c2VySWQsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0RlbWFzaWFkYXMgc29saWNpdHVkZXMnIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQyOSB9XHJcbiAgICAgICk7XHJcbiAgICAgIGFkZFJhdGVMaW1pdEhlYWRlcnMocmVzcG9uc2UsIHJhdGVMaW1pdFJlc3VsdCwgUkFURV9MSU1JVF9DT05GSUdTLlFVRVJZX0FQSSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPYnRlbmVyIHBhcsOhbWV0cm9zIGRlIGNvbnN1bHRhXHJcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcclxuICAgIGNvbnN0IHJlcG9ydFR5cGUgPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgndHlwZScpIHx8ICdhY2NvdW50X21vbmV5JztcclxuICAgIGNvbnN0IGRhdGVGcm9tID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2RhdGVfZnJvbScpO1xyXG4gICAgY29uc3QgZGF0ZVRvID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2RhdGVfdG8nKTtcclxuICAgIGNvbnN0IGluY2x1ZGVNZXRyaWNzID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2luY2x1ZGVfbWV0cmljcycpID09PSAndHJ1ZSc7XHJcblxyXG4gICAgLy8gVmFsaWRhciBwYXLDoW1ldHJvc1xyXG4gICAgaWYgKCFbJ3JlbGVhc2VkX21vbmV5JywgJ2FjY291bnRfbW9uZXknLCAnc2FsZXNfcmVwb3J0J10uaW5jbHVkZXMocmVwb3J0VHlwZSkpIHtcclxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICAgIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnVGlwbyBkZSByZXBvcnRlIGludsOhbGlkbycgfSxcclxuICAgICAgICB7IHN0YXR1czogNDAwIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdSZXBvcnRzIHJlcXVlc3Qgc3RhcnRlZCcsIHtcclxuICAgICAgdXNlcklkLFxyXG4gICAgICByZXBvcnRUeXBlLFxyXG4gICAgICBkYXRlRnJvbSxcclxuICAgICAgZGF0ZVRvLFxyXG4gICAgICBpbmNsdWRlTWV0cmljcyxcclxuICAgICAgY2xpZW50SVAsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBHZW5lcmFyIHJlcG9ydGVcclxuICAgIGNvbnN0IHJlcG9ydERhdGEgPSBhd2FpdCBnZW5lcmF0ZVJlcG9ydChyZXBvcnRUeXBlLCBkYXRlRnJvbSwgZGF0ZVRvLCBpbmNsdWRlTWV0cmljcyk7XHJcblxyXG4gICAgLy8gUmVnaXN0cmFyIG3DqXRyaWNhc1xyXG4gICAgYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRSZXF1ZXN0KFxyXG4gICAgICAnL2FwaS9wYXltZW50cy9yZXBvcnRzJyxcclxuICAgICAgJ0dFVCcsXHJcbiAgICAgIDIwMCxcclxuICAgICAgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcclxuICAgICAgeyB1c2VySWQsIHJlcG9ydFR5cGUgfVxyXG4gICAgKTtcclxuXHJcbiAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdSZXBvcnRzIHJlcXVlc3QgY29tcGxldGVkJywge1xyXG4gICAgICB1c2VySWQsXHJcbiAgICAgIHJlcG9ydFR5cGUsXHJcbiAgICAgIHJlY29yZHNDb3VudDogcmVwb3J0RGF0YS5yZWNvcmRzPy5sZW5ndGggfHwgMCxcclxuICAgICAgcHJvY2Vzc2luZ1RpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgZGF0YTogcmVwb3J0RGF0YSxcclxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICBwcm9jZXNzaW5nX3RpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBhZGRSYXRlTGltaXRIZWFkZXJzKHJlc3BvbnNlLCByYXRlTGltaXRSZXN1bHQsIFJBVEVfTElNSVRfQ09ORklHUy5RVUVSWV9BUEkpO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG4gICAgXHJcbiAgICBsb2dnZXIucGVyZm9ybWFuY2UoTG9nTGV2ZWwuRVJST1IsICdSZXBvcnRzIHJlcXVlc3QgZmFpbGVkJywge1xyXG4gICAgICBvcGVyYXRpb246ICdyZXBvcnRzLWFwaScsXHJcbiAgICAgIGR1cmF0aW9uOiBwcm9jZXNzaW5nVGltZSxcclxuICAgICAgc3RhdHVzQ29kZTogNTAwLFxyXG4gICAgfSwge1xyXG4gICAgICBjbGllbnRJUCxcclxuICAgICAgdXNlckFnZW50LFxyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRSZXF1ZXN0KFxyXG4gICAgICAnL2FwaS9wYXltZW50cy9yZXBvcnRzJyxcclxuICAgICAgJ0dFVCcsXHJcbiAgICAgIDUwMCxcclxuICAgICAgcHJvY2Vzc2luZ1RpbWUsXHJcbiAgICAgIHsgZXJyb3I6IChlcnJvciBhcyBFcnJvcikubWVzc2FnZSB9XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdFcnJvciBpbnRlcm5vIGRlbCBzZXJ2aWRvcicgfSxcclxuICAgICAgeyBzdGF0dXM6IDUwMCB9XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBPU1QgL2FwaS9wYXltZW50cy9yZXBvcnRzXHJcbiAqIENyZWEgdW4gbnVldm8gcmVwb3J0ZSBzZWfDum4gZG9jdW1lbnRhY2nDs24gb2ZpY2lhbCBkZSBNZXJjYWRvUGFnb1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcclxuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gIGNvbnN0IGNsaWVudElQID0gcmVxdWVzdC5oZWFkZXJzLmdldCgneC1mb3J3YXJkZWQtZm9yJykgfHwgJ3Vua25vd24nO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gVmVyaWZpY2FyIGF1dGVudGljYWNpw7NuXHJcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYXV0aCgpO1xyXG4gICAgaWYgKCFzZXNzaW9uPy51c2VyKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ05vIGF1dG9yaXphZG8nIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMSB9XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmF0ZSBsaW1pdGluZ1xyXG4gICAgY29uc3QgcmF0ZUxpbWl0UmVzdWx0ID0gYXdhaXQgY2hlY2tSYXRlTGltaXQoXHJcbiAgICAgIHJlcXVlc3QsXHJcbiAgICAgIFJBVEVfTElNSVRfQ09ORklHUy5QQVlNRU5UX0FQSVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIXJhdGVMaW1pdFJlc3VsdC5zdWNjZXNzKSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdEZW1hc2lhZGFzIHNvbGljaXR1ZGVzJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA0MjkgfVxyXG4gICAgICApO1xyXG4gICAgICBhZGRSYXRlTGltaXRIZWFkZXJzKHJlc3BvbnNlLCByYXRlTGltaXRSZXN1bHQsIFJBVEVfTElNSVRfQ09ORklHUy5QQVlNRU5UX0FQSSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XHJcbiAgICBjb25zdCB7IHR5cGUsIGRhdGVfZnJvbSwgZGF0ZV90bywgY29sdW1ucyB9ID0gYm9keTtcclxuXHJcbiAgICAvLyBWYWxpZGFyIGRhdG9zIHJlcXVlcmlkb3NcclxuICAgIGlmICghdHlwZSB8fCAhZGF0ZV9mcm9tIHx8ICFkYXRlX3RvKSB7XHJcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcclxuICAgICAgICB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0ZhbHRhbiBwYXLDoW1ldHJvcyByZXF1ZXJpZG9zJyB9LFxyXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgJ1JlcG9ydCBjcmVhdGlvbiBzdGFydGVkJywge1xyXG4gICAgICB1c2VySWQsXHJcbiAgICAgIHR5cGUsXHJcbiAgICAgIGRhdGVfZnJvbSxcclxuICAgICAgZGF0ZV90byxcclxuICAgICAgY2xpZW50SVAsXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDcmVhciByZXBvcnRlXHJcbiAgICBjb25zdCByZXBvcnQgPSBhd2FpdCBjcmVhdGVNZXJjYWRvUGFnb1JlcG9ydCh0eXBlLCBkYXRlX2Zyb20sIGRhdGVfdG8sIGNvbHVtbnMpO1xyXG5cclxuICAgIC8vIFJlZ2lzdHJhciBtw6l0cmljYXNcclxuICAgIGF3YWl0IG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkUmVxdWVzdChcclxuICAgICAgJy9hcGkvcGF5bWVudHMvcmVwb3J0cycsXHJcbiAgICAgICdQT1NUJyxcclxuICAgICAgMjAxLFxyXG4gICAgICBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxyXG4gICAgICB7IHVzZXJJZCwgcmVwb3J0VHlwZTogdHlwZSB9XHJcbiAgICApO1xyXG5cclxuICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgJ1JlcG9ydCBjcmVhdGlvbiBjb21wbGV0ZWQnLCB7XHJcbiAgICAgIHVzZXJJZCxcclxuICAgICAgcmVwb3J0SWQ6IHJlcG9ydC5pZCxcclxuICAgICAgdHlwZSxcclxuICAgICAgcHJvY2Vzc2luZ1RpbWU6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IE5leHRSZXNwb25zZS5qc29uKHtcclxuICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgZGF0YTogcmVwb3J0LFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIHByb2Nlc3NpbmdfdGltZTogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcclxuICAgIH0sIHsgc3RhdHVzOiAyMDEgfSk7XHJcblxyXG4gICAgYWRkUmF0ZUxpbWl0SGVhZGVycyhyZXNwb25zZSwgcmF0ZUxpbWl0UmVzdWx0LCBSQVRFX0xJTUlUX0NPTkZJR1MuUEFZTUVOVF9BUEkpO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG5cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG4gICAgXHJcbiAgICBsb2dnZXIucGVyZm9ybWFuY2UoTG9nTGV2ZWwuRVJST1IsICdSZXBvcnQgY3JlYXRpb24gZmFpbGVkJywge1xyXG4gICAgICBvcGVyYXRpb246ICdyZXBvcnQtY3JlYXRpb24tYXBpJyxcclxuICAgICAgZHVyYXRpb246IHByb2Nlc3NpbmdUaW1lLFxyXG4gICAgICBzdGF0dXNDb2RlOiA1MDAsXHJcbiAgICB9LCB7XHJcbiAgICAgIGNsaWVudElQLFxyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRSZXF1ZXN0KFxyXG4gICAgICAnL2FwaS9wYXltZW50cy9yZXBvcnRzJyxcclxuICAgICAgJ1BPU1QnLFxyXG4gICAgICA1MDAsXHJcbiAgICAgIHByb2Nlc3NpbmdUaW1lLFxyXG4gICAgICB7IGVycm9yOiAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UgfVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnRXJyb3IgaW50ZXJubyBkZWwgc2Vydmlkb3InIH0sXHJcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmEgcmVwb3J0ZSBiYXNhZG8gZW4gZGF0b3MgZGUgU3VwYWJhc2UgKHNpbXVsYW5kbyBBUEkgZGUgTWVyY2Fkb1BhZ28pXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVJlcG9ydChcclxuICB0eXBlOiBzdHJpbmcsXHJcbiAgZGF0ZUZyb20/OiBzdHJpbmcgfCBudWxsLFxyXG4gIGRhdGVUbz86IHN0cmluZyB8IG51bGwsXHJcbiAgaW5jbHVkZU1ldHJpY3M6IGJvb2xlYW4gPSBmYWxzZVxyXG4pIHtcclxuICBjb25zdCBzdXBhYmFzZSA9IGdldFN1cGFiYXNlQ2xpZW50KCk7XHJcbiAgaWYgKCFzdXBhYmFzZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBkZSBjb25maWd1cmFjacOzbiBkZSBiYXNlIGRlIGRhdG9zJyk7XHJcbiAgfVxyXG5cclxuICAvLyBDb25maWd1cmFyIGZlY2hhcyBwb3IgZGVmZWN0byAow7psdGltb3MgMzAgZMOtYXMpXHJcbiAgY29uc3QgZW5kRGF0ZSA9IGRhdGVUbyA/IG5ldyBEYXRlKGRhdGVUbykgOiBuZXcgRGF0ZSgpO1xyXG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IGRhdGVGcm9tID8gbmV3IERhdGUoZGF0ZUZyb20pIDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDMwICogMjQgKiA2MCAqIDYwICogMTAwMCk7XHJcblxyXG4gIGxldCBxdWVyeSA9IHN1cGFiYXNlXHJcbiAgICAuZnJvbSgnb3JkZXJzJylcclxuICAgIC5zZWxlY3QoYFxyXG4gICAgICBpZCxcclxuICAgICAgdG90YWxfYW1vdW50LFxyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIHBheW1lbnRfc3RhdHVzLFxyXG4gICAgICBjcmVhdGVkX2F0LFxyXG4gICAgICB1cGRhdGVkX2F0LFxyXG4gICAgICBvcmRlcl9pdGVtcyAoXHJcbiAgICAgICAgcXVhbnRpdHksXHJcbiAgICAgICAgdW5pdF9wcmljZSxcclxuICAgICAgICBwcm9kdWN0cyAoXHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgY2F0ZWdvcnlfaWRcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgIGApXHJcbiAgICAuZ3RlKCdjcmVhdGVkX2F0Jywgc3RhcnREYXRlLnRvSVNPU3RyaW5nKCkpXHJcbiAgICAubHRlKCdjcmVhdGVkX2F0JywgZW5kRGF0ZS50b0lTT1N0cmluZygpKTtcclxuXHJcbiAgLy8gRmlsdHJhciBzZWfDum4gdGlwbyBkZSByZXBvcnRlXHJcbiAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICBjYXNlICdyZWxlYXNlZF9tb25leSc6XHJcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3BheW1lbnRfc3RhdHVzJywgJ2FwcHJvdmVkJyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnYWNjb3VudF9tb25leSc6XHJcbiAgICAgIC8vIEluY2x1aXIgdG9kb3MgbG9zIGVzdGFkb3NcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdzYWxlc19yZXBvcnQnOlxyXG4gICAgICBxdWVyeSA9IHF1ZXJ5LmluKCdzdGF0dXMnLCBbJ2NvbXBsZXRlZCcsICdwcm9jZXNzaW5nJ10pO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcblxyXG4gIGNvbnN0IHsgZGF0YTogb3JkZXJzLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XHJcblxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBvYnRlbmVyIGRhdG9zOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgfVxyXG5cclxuICAvLyBQcm9jZXNhciBkYXRvcyBzZWfDum4gdGlwbyBkZSByZXBvcnRlXHJcbiAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IHByb2Nlc3NSZXBvcnREYXRhKG9yZGVycyB8fCBbXSwgdHlwZSk7XHJcbiAgXHJcbiAgLy8gQ2FsY3VsYXIgbcOpdHJpY2FzIHNpIHNlIHNvbGljaXRhblxyXG4gIGNvbnN0IG1ldHJpY3MgPSBpbmNsdWRlTWV0cmljcyA/IGNhbGN1bGF0ZVJlcG9ydE1ldHJpY3Mob3JkZXJzIHx8IFtdKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGUsXHJcbiAgICBkYXRlX2Zyb206IHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpLFxyXG4gICAgZGF0ZV90bzogZW5kRGF0ZS50b0lTT1N0cmluZygpLFxyXG4gICAgcmVjb3JkczogcHJvY2Vzc2VkRGF0YSxcclxuICAgIG1ldHJpY3MsXHJcbiAgICB0b3RhbF9yZWNvcmRzOiBwcm9jZXNzZWREYXRhLmxlbmd0aCxcclxuICAgIGdlbmVyYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNhIGxvcyBkYXRvcyBzZWfDum4gZWwgdGlwbyBkZSByZXBvcnRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9jZXNzUmVwb3J0RGF0YShvcmRlcnM6IGFueVtdLCB0eXBlOiBzdHJpbmcpIHtcclxuICByZXR1cm4gb3JkZXJzLm1hcChvcmRlciA9PiB7XHJcbiAgICBjb25zdCBiYXNlRGF0YSA9IHtcclxuICAgICAgb3JkZXJfaWQ6IG9yZGVyLmlkLFxyXG4gICAgICBhbW91bnQ6IG9yZGVyLnRvdGFsX2Ftb3VudCxcclxuICAgICAgc3RhdHVzOiBvcmRlci5wYXltZW50X3N0YXR1cyB8fCBvcmRlci5zdGF0dXMsXHJcbiAgICAgIGNyZWF0ZWRfYXQ6IG9yZGVyLmNyZWF0ZWRfYXQsXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IG9yZGVyLnVwZGF0ZWRfYXQsXHJcbiAgICB9O1xyXG5cclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlICdyZWxlYXNlZF9tb25leSc6XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIC4uLmJhc2VEYXRhLFxyXG4gICAgICAgICAgcmVsZWFzZV9kYXRlOiBvcmRlci51cGRhdGVkX2F0LFxyXG4gICAgICAgICAgbmV0X2Ftb3VudDogb3JkZXIudG90YWxfYW1vdW50ICogMC45NiwgLy8gU2ltdWxhciBjb21pc2nDs24gTVBcclxuICAgICAgICAgIGZlZV9hbW91bnQ6IG9yZGVyLnRvdGFsX2Ftb3VudCAqIDAuMDQsXHJcbiAgICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGNhc2UgJ2FjY291bnRfbW9uZXknOlxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAuLi5iYXNlRGF0YSxcclxuICAgICAgICAgIHRyYW5zYWN0aW9uX3R5cGU6ICdwYXltZW50JyxcclxuICAgICAgICAgIGJhbGFuY2VfaW1wYWN0OiBvcmRlci5wYXltZW50X3N0YXR1cyA9PT0gJ2FwcHJvdmVkJyA/IG9yZGVyLnRvdGFsX2Ftb3VudCA6IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGNhc2UgJ3NhbGVzX3JlcG9ydCc6XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIC4uLmJhc2VEYXRhLFxyXG4gICAgICAgICAgaXRlbXM6IG9yZGVyLm9yZGVyX2l0ZW1zPy5tYXAoKGl0ZW06IGFueSkgPT4gKHtcclxuICAgICAgICAgICAgbmFtZTogaXRlbS5wcm9kdWN0cz8ubmFtZSxcclxuICAgICAgICAgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHksXHJcbiAgICAgICAgICAgIHVuaXRfcHJpY2U6IGl0ZW0udW5pdF9wcmljZSxcclxuICAgICAgICAgICAgY2F0ZWdvcnk6IGl0ZW0ucHJvZHVjdHM/LmNhdGVnb3J5X2lkLFxyXG4gICAgICAgICAgfSkpIHx8IFtdLFxyXG4gICAgICAgICAgaXRlbXNfY291bnQ6IG9yZGVyLm9yZGVyX2l0ZW1zPy5sZW5ndGggfHwgMCxcclxuICAgICAgICB9O1xyXG4gICAgICBcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gYmFzZURhdGE7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhIG3DqXRyaWNhcyBkZWwgcmVwb3J0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlUmVwb3J0TWV0cmljcyhvcmRlcnM6IGFueVtdKTogUmVwb3J0TWV0cmljcyB7XHJcbiAgY29uc3QgdG90YWxUcmFuc2FjdGlvbnMgPSBvcmRlcnMubGVuZ3RoO1xyXG4gIGNvbnN0IHN1Y2Nlc3NmdWxQYXltZW50cyA9IG9yZGVycy5maWx0ZXIobyA9PiBvLnBheW1lbnRfc3RhdHVzID09PSAnYXBwcm92ZWQnKS5sZW5ndGg7XHJcbiAgY29uc3QgZmFpbGVkUGF5bWVudHMgPSBvcmRlcnMuZmlsdGVyKG8gPT4gby5wYXltZW50X3N0YXR1cyA9PT0gJ3JlamVjdGVkJykubGVuZ3RoO1xyXG4gIGNvbnN0IHRvdGFsQW1vdW50ID0gb3JkZXJzLnJlZHVjZSgoc3VtLCBvKSA9PiBzdW0gKyAoby50b3RhbF9hbW91bnQgfHwgMCksIDApO1xyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICB0b3RhbF90cmFuc2FjdGlvbnM6IHRvdGFsVHJhbnNhY3Rpb25zLFxyXG4gICAgdG90YWxfYW1vdW50OiB0b3RhbEFtb3VudCxcclxuICAgIHN1Y2Nlc3NmdWxfcGF5bWVudHM6IHN1Y2Nlc3NmdWxQYXltZW50cyxcclxuICAgIGZhaWxlZF9wYXltZW50czogZmFpbGVkUGF5bWVudHMsXHJcbiAgICByZWZ1bmRzOiAwLCAvLyBUT0RPOiBJbXBsZW1lbnRhciBjdWFuZG8gc2UgYWdyZWd1ZSB0YWJsYSBkZSByZWZ1bmRzXHJcbiAgICBjaGFyZ2ViYWNrczogMCwgLy8gVE9ETzogSW1wbGVtZW50YXIgY3VhbmRvIHNlIGFncmVndWUgdGFibGEgZGUgY2hhcmdlYmFja3NcclxuICAgIGF2ZXJhZ2VfdGlja2V0OiB0b3RhbFRyYW5zYWN0aW9ucyA+IDAgPyB0b3RhbEFtb3VudCAvIHRvdGFsVHJhbnNhY3Rpb25zIDogMCxcclxuICAgIGNvbnZlcnNpb25fcmF0ZTogdG90YWxUcmFuc2FjdGlvbnMgPiAwID8gKHN1Y2Nlc3NmdWxQYXltZW50cyAvIHRvdGFsVHJhbnNhY3Rpb25zKSAqIDEwMCA6IDAsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWEgdW4gcmVwb3J0ZSBlbiBNZXJjYWRvUGFnbyAoc2ltdWxhZG8pXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVNZXJjYWRvUGFnb1JlcG9ydChcclxuICB0eXBlOiBzdHJpbmcsXHJcbiAgZGF0ZUZyb206IHN0cmluZyxcclxuICBkYXRlVG86IHN0cmluZyxcclxuICBjb2x1bW5zPzogc3RyaW5nW11cclxuKTogUHJvbWlzZTxNZXJjYWRvUGFnb1JlcG9ydD4ge1xyXG4gIC8vIEVuIHVuYSBpbXBsZW1lbnRhY2nDs24gcmVhbCwgYXF1w60gc2UgaGFyw61hIGxhIGxsYW1hZGEgYSBsYSBBUEkgZGUgTWVyY2Fkb1BhZ29cclxuICAvLyBQb3IgYWhvcmEgc2ltdWxhbW9zIGxhIGNyZWFjacOzbiBkZWwgcmVwb3J0ZVxyXG4gIFxyXG4gIGNvbnN0IHJlcG9ydElkID0gYHJlcG9ydF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkOiByZXBvcnRJZCxcclxuICAgIHR5cGU6IHR5cGUgYXMgYW55LFxyXG4gICAgZGF0ZV9mcm9tOiBkYXRlRnJvbSxcclxuICAgIGRhdGVfdG86IGRhdGVUbyxcclxuICAgIHN0YXR1czogJ3BlbmRpbmcnLFxyXG4gICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbIkdFVCIsIlBPU1QiLCJyZXF1ZXN0Iiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImNsaWVudElQIiwiaGVhZGVycyIsImdldCIsInVzZXJBZ2VudCIsInNlc3Npb24iLCJhdXRoIiwidXNlciIsIk5leHRSZXNwb25zZSIsImpzb24iLCJzdWNjZXNzIiwiZXJyb3IiLCJzdGF0dXMiLCJyYXRlTGltaXRSZXN1bHQiLCJjaGVja1JhdGVMaW1pdCIsIlJBVEVfTElNSVRfQ09ORklHUyIsIlFVRVJZX0FQSSIsImxvZ2dlciIsIndhcm4iLCJMb2dDYXRlZ29yeSIsIkFQSSIsInVzZXJJZCIsInJlc3BvbnNlIiwiYWRkUmF0ZUxpbWl0SGVhZGVycyIsInVybCIsIlVSTCIsInJlcG9ydFR5cGUiLCJzZWFyY2hQYXJhbXMiLCJkYXRlRnJvbSIsImRhdGVUbyIsImluY2x1ZGVNZXRyaWNzIiwiaW5jbHVkZXMiLCJpbmZvIiwicmVwb3J0RGF0YSIsImdlbmVyYXRlUmVwb3J0IiwibWV0cmljc0NvbGxlY3RvciIsInJlY29yZFJlcXVlc3QiLCJyZWNvcmRzQ291bnQiLCJyZWNvcmRzIiwibGVuZ3RoIiwicHJvY2Vzc2luZ1RpbWUiLCJkYXRhIiwidGltZXN0YW1wIiwicHJvY2Vzc2luZ190aW1lIiwicGVyZm9ybWFuY2UiLCJMb2dMZXZlbCIsIkVSUk9SIiwib3BlcmF0aW9uIiwiZHVyYXRpb24iLCJzdGF0dXNDb2RlIiwibWVzc2FnZSIsIlBBWU1FTlRfQVBJIiwiYm9keSIsInR5cGUiLCJkYXRlX2Zyb20iLCJkYXRlX3RvIiwiY29sdW1ucyIsInJlcG9ydCIsImNyZWF0ZU1lcmNhZG9QYWdvUmVwb3J0IiwicmVwb3J0SWQiLCJpZCIsInN1cGFiYXNlIiwiZ2V0U3VwYWJhc2VDbGllbnQiLCJFcnJvciIsImVuZERhdGUiLCJzdGFydERhdGUiLCJxdWVyeSIsImZyb20iLCJzZWxlY3QiLCJndGUiLCJ0b0lTT1N0cmluZyIsImx0ZSIsImVxIiwiaW4iLCJvcmRlcnMiLCJwcm9jZXNzZWREYXRhIiwicHJvY2Vzc1JlcG9ydERhdGEiLCJtZXRyaWNzIiwiY2FsY3VsYXRlUmVwb3J0TWV0cmljcyIsInVuZGVmaW5lZCIsInRvdGFsX3JlY29yZHMiLCJnZW5lcmF0ZWRfYXQiLCJtYXAiLCJvcmRlciIsImJhc2VEYXRhIiwib3JkZXJfaWQiLCJhbW91bnQiLCJ0b3RhbF9hbW91bnQiLCJwYXltZW50X3N0YXR1cyIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwicmVsZWFzZV9kYXRlIiwibmV0X2Ftb3VudCIsImZlZV9hbW91bnQiLCJ0cmFuc2FjdGlvbl90eXBlIiwiYmFsYW5jZV9pbXBhY3QiLCJpdGVtcyIsIm9yZGVyX2l0ZW1zIiwiaXRlbSIsIm5hbWUiLCJwcm9kdWN0cyIsInF1YW50aXR5IiwidW5pdF9wcmljZSIsImNhdGVnb3J5IiwiY2F0ZWdvcnlfaWQiLCJpdGVtc19jb3VudCIsInRvdGFsVHJhbnNhY3Rpb25zIiwic3VjY2Vzc2Z1bFBheW1lbnRzIiwiZmlsdGVyIiwibyIsImZhaWxlZFBheW1lbnRzIiwidG90YWxBbW91bnQiLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbF90cmFuc2FjdGlvbnMiLCJzdWNjZXNzZnVsX3BheW1lbnRzIiwiZmFpbGVkX3BheW1lbnRzIiwicmVmdW5kcyIsImNoYXJnZWJhY2tzIiwiYXZlcmFnZV90aWNrZXQiLCJjb252ZXJzaW9uX3JhdGUiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0QywrQ0FBK0M7QUFDL0Msc0NBQXNDOzs7Ozs7Ozs7Ozs7UUFjaEJBO2VBQUFBOztRQXVIQUM7ZUFBQUE7Ozt3QkFuSW9CO3NCQUNyQjswQkFDYTt3QkFDWTs2QkFDMEI7eUJBQ3ZDO0FBTzFCLGVBQWVELElBQUlFLE9BQW9CO0lBQzVDLE1BQU1DLFlBQVlDLEtBQUtDLEdBQUc7SUFDMUIsTUFBTUMsV0FBV0osUUFBUUssT0FBTyxDQUFDQyxHQUFHLENBQUMsc0JBQXNCO0lBQzNELE1BQU1DLFlBQVlQLFFBQVFLLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGlCQUFpQjtJQUV2RCxJQUFJO1FBQ0YsMEJBQTBCO1FBQzFCLE1BQU1FLFVBQVUsTUFBTUMsSUFBQUEsVUFBSTtRQUMxQixJQUFJLENBQUNELFNB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