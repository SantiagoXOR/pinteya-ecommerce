2808dd7fe2e6269fec4e93ac5b043b5d
// ===================================
// PINTEYA E-COMMERCE - MONITORING INTEGRATION TESTS
// ===================================
"use strict";
// Mock dependencies
jest.mock('@/lib/auth/admin-auth', ()=>({
        getAuthenticatedAdmin: jest.fn(()=>({
                isAdmin: true,
                userId: 'admin-user-123'
            }))
    }));
jest.mock('@/lib/supabase', ()=>({
        getSupabaseClient: jest.fn(()=>({
                from: jest.fn(()=>({
                        select: jest.fn(()=>({
                                eq: jest.fn(()=>({
                                        single: jest.fn(()=>({
                                                data: null,
                                                error: null
                                            })),
                                        order: jest.fn(()=>({
                                                limit: jest.fn(()=>({
                                                        data: [],
                                                        error: null
                                                    })),
                                                range: jest.fn(()=>({
                                                        data: [],
                                                        error: null
                                                    }))
                                            })),
                                        gte: jest.fn(()=>({
                                                lte: jest.fn(()=>({
                                                        order: jest.fn(()=>({
                                                                data: [],
                                                                error: null
                                                            }))
                                                    }))
                                            })),
                                        in: jest.fn(()=>({
                                                gte: jest.fn(()=>({
                                                        lte: jest.fn(()=>({
                                                                order: jest.fn(()=>({
                                                                        data: [],
                                                                        error: null
                                                                    }))
                                                            }))
                                                    }))
                                            })),
                                        is: jest.fn(()=>({
                                                order: jest.fn(()=>({
                                                        limit: jest.fn(()=>({
                                                                data: [],
                                                                error: null
                                                            }))
                                                    }))
                                            }))
                                    })),
                                insert: jest.fn(()=>({
                                        error: null
                                    })),
                                update: jest.fn(()=>({
                                        error: null
                                    })),
                                delete: jest.fn(()=>({
                                        error: null
                                    }))
                            })),
                        rpc: jest.fn(()=>({
                                data: [],
                                error: null
                            }))
                    }))
            }))
    }));
jest.mock('@/lib/cache-manager', ()=>({
        CacheUtils: {
            get: jest.fn(),
            set: jest.fn(),
            cacheMetricsAggregation: jest.fn((key, fn)=>fn())
        }
    }));
jest.mock('@/lib/logger', ()=>({
        logger: {
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn(),
            debug: jest.fn()
        },
        LogLevel: {
            INFO: 'info',
            WARN: 'warn',
            ERROR: 'error',
            DEBUG: 'debug'
        },
        LogCategory: {
            SYSTEM: 'system'
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _enterprisemetrics = require("../../lib/monitoring/enterprise-metrics");
const _alertsystem = require("../../lib/monitoring/alert-system");
const _healthchecks = require("../../lib/monitoring/health-checks");
const _circuitbreaker = require("../../lib/mercadopago/circuit-breaker");
// Helper para crear requests
function createRequest(url, options = {}) {
    return new _server.NextRequest(url, {
        method: options.method || 'GET',
        body: options.body ? JSON.stringify(options.body) : undefined,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
}
describe('Monitoring Integration Tests', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        jest.useFakeTimers();
    });
    afterEach(()=>{
        jest.useRealTimers();
    });
    describe('Flujo Completo de Métricas', ()=>{
        test('debe registrar métrica, disparar alerta y ejecutar health check', async ()=>{
            // 1. Registrar métrica que supera umbral
            await _enterprisemetrics.enterpriseMetrics.recordMetric('test.critical.metric', 150, 'gauge', 'performance', {
                environment: 'test'
            });
            // 2. Configurar regla de alerta
            _alertsystem.enterpriseAlertSystem.setAlertRule({
                id: 'test_critical_alert',
                name: 'Test Critical Alert',
                description: 'Test alert for integration',
                enabled: true,
                metricName: 'test.critical.metric',
                condition: 'gt',
                threshold: 100,
                level: 'critical',
                cooldownMinutes: 1,
                channels: [
                    'default_log'
                ],
                escalationRules: [],
                tags: {
                    test: 'integration'
                }
            });
            // 3. Disparar alerta
            const alert = await _alertsystem.enterpriseAlertSystem.triggerAlert('test_critical_alert', 'test.critical.metric', 150, 'Integration test alert');
            expect(alert).toBeTruthy();
            expect(alert?.level).toBe('critical');
            // 4. Ejecutar health check
            const healthResult = await _healthchecks.enterpriseHealthSystem.runHealthCheck('database');
            expect(healthResult.service).toBe('database');
            expect(healthResult.status).toBeDefined();
            // Verificar que todo el flujo funciona sin errores
            expect(true).toBe(true);
        });
        test('debe manejar escalamiento de alertas automáticamente', async ()=>{
            // Configurar regla de escalamiento
            _alertsystem.enterpriseAlertSystem.setEscalationRule({
                id: 'test_escalation',
                name: 'Test Escalation',
                enabled: true,
                conditions: {
                    level: 'warning',
                    duration: 1 // 1 minuto
                },
                actions: {
                    escalateToLevel: 'critical',
                    notifyChannels: [
                        'default_log'
                    ]
                }
            });
            // Configurar alerta con escalamiento
            _alertsystem.enterpriseAlertSystem.setAlertRule({
                id: 'escalation_test',
                name: 'Escalation Test',
                description: 'Test escalation',
                enabled: true,
                metricName: 'test.escalation.metric',
                condition: 'gt',
                threshold: 50,
                level: 'warning',
                cooldownMinutes: 1,
                channels: [
                    'default_log'
                ],
                escalationRules: [
                    'test_escalation'
                ],
                tags: {}
            });
            // Disparar alerta inicial
            const alert = await _alertsystem.enterpriseAlertSystem.triggerAlert('escalation_test', 'test.escalation.metric', 75);
            expect(alert).toBeTruthy();
            expect(alert?.level).toBe('warning');
            // Simular paso del tiempo para escalamiento
            jest.advanceTimersByTime(2 * 60 * 1000); // 2 minutos
            // El escalamiento se maneja automáticamente en el sistema
            expect(true).toBe(true);
        });
    });
    describe('Integración Circuit Breaker + Health Checks', ()=>{
        test('debe detectar circuit breaker abierto en health check', async ()=>{
            // Simular circuit breaker abierto
            jest.spyOn(_circuitbreaker.mercadoPagoCriticalBreaker, 'getState').mockReturnValue('open');
            // Ejecutar health check
            const result = await _healthchecks.enterpriseHealthSystem.runHealthCheck('circuit_breakers');
            expect(result.status).toBe('unhealthy');
            expect(result.message).toContain('circuit breaker(s) open');
            expect(result.details.mercadopago_critical).toBe('open');
        });
        test('debe ejecutar recuperación automática para circuit breakers', async ()=>{
            const resetSpy = jest.spyOn(_circuitbreaker.mercadoPagoCriticalBreaker, 'reset');
            // Ejecutar acción de recuperación
            const success = await _healthchecks.enterpriseHealthSystem.executeRecoveryAction('reset_circuit_breakers');
            expect(success).toBe(true);
            expect(resetSpy).toHaveBeenCalled();
        });
    });
    describe('Integración Métricas + Alertas', ()=>{
        test('debe disparar alerta automáticamente cuando métrica supera umbral', async ()=>{
            // Configurar alerta para response time alto
            _alertsystem.enterpriseAlertSystem.setAlertRule({
                id: 'high_response_time',
                name: 'High Response Time',
                description: 'Response time too high',
                enabled: true,
                metricName: 'performance.api.duration',
                condition: 'gt',
                threshold: 1000,
                level: 'warning',
                cooldownMinutes: 1,
                channels: [
                    'default_log'
                ],
                escalationRules: [],
                tags: {}
            });
            // Registrar métrica que supera umbral
            await _enterprisemetrics.enterpriseMetrics.recordMetric('performance.api.duration', 1500, 'timer', 'performance');
            // La alerta se dispara automáticamente en el sistema real
            // En el test verificamos que no hay errores
            expect(true).toBe(true);
        });
        test('debe agregar métricas correctamente', async ()=>{
            // Registrar múltiples métricas
            const metrics = [
                {
                    name: 'test.metric.1',
                    value: 100
                },
                {
                    name: 'test.metric.1',
                    value: 150
                },
                {
                    name: 'test.metric.1',
                    value: 200
                }
            ];
            for (const metric of metrics){
                await _enterprisemetrics.enterpriseMetrics.recordMetric(metric.name, metric.value, 'gauge', 'performance');
            }
            // Obtener agregación
            const aggregated = await _enterprisemetrics.enterpriseMetrics.getAggregatedMetrics('test.metric.1', '1h', new Date(Date.now() - 60 * 60 * 1000).toISOString(), new Date().toISOString());
            // En el mock, esto retorna un array vacío, pero verificamos que no hay errores
            expect(aggregated).toBeInstanceOf(Array);
        });
    });
    describe('Integración Health Checks + Métricas', ()=>{
        test('debe registrar métricas de health check automáticamente', async ()=>{
            // Ejecutar health check
            await _healthchecks.enterpriseHealthSystem.runHealthCheck('database');
            // Las métricas se registran automáticamente
            // Verificamos que no hay errores en el proceso
            expect(true).toBe(true);
        });
        test('debe registrar métricas de seguridad para fallos críticos', async ()=>{
            // Mock error en base de datos
            const { getSupabaseClient } = require('@/lib/supabase');
            getSupabaseClient.mockReturnValueOnce(null);
            // Ejecutar health check que fallará
            const result = await _healthchecks.enterpriseHealthSystem.runHealthCheck('database');
            expect(result.status).toBe('unhealthy');
            expect(result.severity).toBe('critical');
            // Las métricas de seguridad se registran automáticamente
            expect(true).toBe(true);
        });
    });
    describe('Flujo Completo de Monitoreo', ()=>{
        test('debe ejecutar ciclo completo de monitoreo', async ()=>{
            // 1. Ejecutar todos los health checks
            const healthResults = await _healthchecks.enterpriseHealthSystem.runAllHealthChecks();
            expect(healthResults).toBeInstanceOf(Array);
            // 2. Obtener estado del sistema
            const systemHealth = _healthchecks.enterpriseHealthSystem.getSystemHealth();
            expect(systemHealth.overall).toBeDefined();
            expect(systemHealth.services).toBeInstanceOf(Array);
            // 3. Registrar métricas de performance
            await _enterprisemetrics.enterpriseMetrics.recordMetric('system.health.score', systemHealth.summary.healthy / systemHealth.services.length * 100, 'gauge', 'performance');
            // 4. Verificar alertas activas (simulado)
            // En un sistema real, esto consultaría la base de datos
            expect(true).toBe(true);
        });
        test('debe manejar errores en cascada correctamente', async ()=>{
            // Simular múltiples fallos
            const { getSupabaseClient } = require('@/lib/supabase');
            getSupabaseClient.mockReturnValue(null);
            const { CacheUtils } = require('@/lib/cache-manager');
            CacheUtils.get.mockRejectedValue(new Error('Cache error'));
            // Ejecutar health checks con errores
            const results = await _healthchecks.enterpriseHealthSystem.runAllHealthChecks();
            // Verificar que el sistema maneja los errores sin fallar completamente
            expect(results).toBeInstanceOf(Array);
            // Algunos servicios deberían estar unhealthy
            const unhealthyServices = results.filter((r)=>r.status === 'unhealthy');
            expect(unhealthyServices.length).toBeGreaterThan(0);
        });
    });
    describe('Performance y Escalabilidad', ()=>{
        test('debe manejar múltiples métricas concurrentemente', async ()=>{
            const promises = [];
            // Registrar 100 métricas concurrentemente
            for(let i = 0; i < 100; i++){
                promises.push(_enterprisemetrics.enterpriseMetrics.recordMetric(`concurrent.metric.${i}`, Math.random() * 1000, 'gauge', 'performance'));
            }
            // Esperar que todas se completen sin errores
            await expect(Promise.all(promises)).resolves.not.toThrow();
        });
        test('debe manejar múltiples health checks concurrentemente', async ()=>{
            const services = [
                'database',
                'cache',
                'mercadopago',
                'circuit_breakers'
            ];
            const promises = services.map((service)=>_healthchecks.enterpriseHealthSystem.runHealthCheck(service));
            const results = await Promise.all(promises);
            expect(results).toHaveLength(services.length);
            results.forEach((result)=>{
                expect(result.service).toBeDefined();
                expect(result.status).toBeDefined();
            });
        });
    });
    describe('Casos Edge y Recuperación', ()=>{
        test('debe recuperarse de errores temporales', async ()=>{
            const { getSupabaseClient } = require('@/lib/supabase');
            // Primer intento falla
            getSupabaseClient.mockReturnValueOnce(null);
            const result1 = await _healthchecks.enterpriseHealthSystem.runHealthCheck('database');
            expect(result1.status).toBe('unhealthy');
            // Segundo intento exitoso
            getSupabaseClient.mockReturnValueOnce({
                from: jest.fn(()=>({
                        select: jest.fn(()=>({
                                limit: jest.fn(()=>({
                                        data: [
                                            {
                                                id: 1
                                            }
                                        ],
                                        error: null
                                    }))
                            }))
                    }))
            });
            const result2 = await _healthchecks.enterpriseHealthSystem.runHealthCheck('database');
            expect(result2.status).toBe('healthy');
        });
        test('debe manejar timeouts correctamente', async ()=>{
            // Simular timeout en health check
            const { CacheUtils } = require('@/lib/cache-manager');
            CacheUtils.set.mockImplementation(()=>new Promise((resolve)=>setTimeout(resolve, 10000)));
            // El health check debería completarse rápidamente
            const startTime = Date.now();
            const result = await _healthchecks.enterpriseHealthSystem.runHealthCheck('cache');
            const duration = Date.now() - startTime;
            expect(duration).toBeLessThan(5000); // Menos de 5 segundos
            expect(result.service).toBe('cache');
        });
    });
    describe('Compliance y Auditoría', ()=>{
        test('debe mantener audit trail de todas las operaciones', async ()=>{
            // Ejecutar operaciones que deberían generar audit trail
            await _enterprisemetrics.enterpriseMetrics.recordMetric('audit.test', 1, 'counter', 'security');
            await _healthchecks.enterpriseHealthSystem.runHealthCheck('database');
            const alert = await _alertsystem.enterpriseAlertSystem.triggerAlert('test_audit_alert', 'audit.test', 1);
            // En un sistema real, verificaríamos que se crearon entradas de auditoría
            // Por ahora verificamos que no hay errores
            expect(true).toBe(true);
        });
        test('debe cumplir con retención de datos', async ()=>{
            // Verificar que las políticas de retención están configuradas
            // En un sistema real, esto verificaría la configuración de la base de datos
            expect(true).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxpbnRlZ3JhdGlvblxcbW9uaXRvcmluZy1pbnRlZ3JhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBNT05JVE9SSU5HIElOVEVHUkFUSU9OIFRFU1RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IGVudGVycHJpc2VNZXRyaWNzIH0gZnJvbSAnQC9saWIvbW9uaXRvcmluZy9lbnRlcnByaXNlLW1ldHJpY3MnO1xuaW1wb3J0IHsgZW50ZXJwcmlzZUFsZXJ0U3lzdGVtIH0gZnJvbSAnQC9saWIvbW9uaXRvcmluZy9hbGVydC1zeXN0ZW0nO1xuaW1wb3J0IHsgZW50ZXJwcmlzZUhlYWx0aFN5c3RlbSB9IGZyb20gJ0AvbGliL21vbml0b3JpbmcvaGVhbHRoLWNoZWNrcyc7XG5pbXBvcnQgeyBcbiAgbWVyY2Fkb1BhZ29Dcml0aWNhbEJyZWFrZXIsIFxuICBtZXJjYWRvUGFnb1N0YW5kYXJkQnJlYWtlciwgXG4gIHdlYmhvb2tQcm9jZXNzaW5nQnJlYWtlciBcbn0gZnJvbSAnQC9saWIvbWVyY2Fkb3BhZ28vY2lyY3VpdC1icmVha2VyJztcblxuLy8gTW9jayBkZXBlbmRlbmNpZXNcbmplc3QubW9jaygnQC9saWIvYXV0aC9hZG1pbi1hdXRoJywgKCkgPT4gKHtcbiAgZ2V0QXV0aGVudGljYXRlZEFkbWluOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgaXNBZG1pbjogdHJ1ZSxcbiAgICB1c2VySWQ6ICdhZG1pbi11c2VyLTEyMydcbiAgfSkpXG59KSk7XG5cbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBnZXRTdXBhYmFzZUNsaWVudDogamVzdC5mbigoKSA9PiAoe1xuICAgIGZyb206IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBlcTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHNpbmdsZTogamVzdC5mbigoKSA9PiAoeyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgb3JkZXI6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIGxpbWl0OiBqZXN0LmZuKCgpID0+ICh7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9KSksXG4gICAgICAgICAgICByYW5nZTogamVzdC5mbigoKSA9PiAoeyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfSkpXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIGd0ZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgbHRlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICAgIG9yZGVyOiBqZXN0LmZuKCgpID0+ICh7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9KSlcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0pKSxcbiAgICAgICAgICBpbjogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgZ3RlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICAgIGx0ZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgICAgIG9yZGVyOiBqZXN0LmZuKCgpID0+ICh7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9KSlcbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgaXM6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIG9yZGVyOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICAgIGxpbWl0OiBqZXN0LmZuKCgpID0+ICh7IGRhdGE6IFtdLCBlcnJvcjogbnVsbCB9KSlcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSksXG4gICAgICAgIGluc2VydDogamVzdC5mbigoKSA9PiAoeyBlcnJvcjogbnVsbCB9KSksXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigoKSA9PiAoeyBlcnJvcjogbnVsbCB9KSksXG4gICAgICAgIGRlbGV0ZTogamVzdC5mbigoKSA9PiAoeyBlcnJvcjogbnVsbCB9KSlcbiAgICAgIH0pKSxcbiAgICAgIHJwYzogamVzdC5mbigoKSA9PiAoeyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfSkpXG4gICAgfSkpXG4gIH0pKVxufSkpO1xuXG5qZXN0Lm1vY2soJ0AvbGliL2NhY2hlLW1hbmFnZXInLCAoKSA9PiAoe1xuICBDYWNoZVV0aWxzOiB7XG4gICAgZ2V0OiBqZXN0LmZuKCksXG4gICAgc2V0OiBqZXN0LmZuKCksXG4gICAgY2FjaGVNZXRyaWNzQWdncmVnYXRpb246IGplc3QuZm4oKGtleSwgZm4pID0+IGZuKCkpXG4gIH1cbn0pKTtcblxuamVzdC5tb2NrKCdAL2xpYi9sb2dnZXInLCAoKSA9PiAoe1xuICBsb2dnZXI6IHtcbiAgICBpbmZvOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgZGVidWc6IGplc3QuZm4oKVxuICB9LFxuICBMb2dMZXZlbDoge1xuICAgIElORk86ICdpbmZvJyxcbiAgICBXQVJOOiAnd2FybicsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gICAgREVCVUc6ICdkZWJ1ZydcbiAgfSxcbiAgTG9nQ2F0ZWdvcnk6IHtcbiAgICBTWVNURU06ICdzeXN0ZW0nXG4gIH1cbn0pKTtcblxuLy8gSGVscGVyIHBhcmEgY3JlYXIgcmVxdWVzdHNcbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QodXJsOiBzdHJpbmcsIG9wdGlvbnM6IGFueSA9IHt9KSB7XG4gIHJldHVybiBuZXcgTmV4dFJlcXVlc3QodXJsLCB7XG4gICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICBib2R5OiBvcHRpb25zLmJvZHkgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpIDogdW5kZWZpbmVkLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICB9XG4gIH0pO1xufVxuXG5kZXNjcmliZSgnTW9uaXRvcmluZyBJbnRlZ3JhdGlvbiBUZXN0cycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC51c2VSZWFsVGltZXJzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGbHVqbyBDb21wbGV0byBkZSBNw6l0cmljYXMnLCAoKSA9PiB7XG4gICAgdGVzdCgnZGViZSByZWdpc3RyYXIgbcOpdHJpY2EsIGRpc3BhcmFyIGFsZXJ0YSB5IGVqZWN1dGFyIGhlYWx0aCBjaGVjaycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIDEuIFJlZ2lzdHJhciBtw6l0cmljYSBxdWUgc3VwZXJhIHVtYnJhbFxuICAgICAgYXdhaXQgZW50ZXJwcmlzZU1ldHJpY3MucmVjb3JkTWV0cmljKFxuICAgICAgICAndGVzdC5jcml0aWNhbC5tZXRyaWMnLFxuICAgICAgICAxNTAsXG4gICAgICAgICdnYXVnZScsXG4gICAgICAgICdwZXJmb3JtYW5jZScsXG4gICAgICAgIHsgZW52aXJvbm1lbnQ6ICd0ZXN0JyB9XG4gICAgICApO1xuXG4gICAgICAvLyAyLiBDb25maWd1cmFyIHJlZ2xhIGRlIGFsZXJ0YVxuICAgICAgZW50ZXJwcmlzZUFsZXJ0U3lzdGVtLnNldEFsZXJ0UnVsZSh7XG4gICAgICAgIGlkOiAndGVzdF9jcml0aWNhbF9hbGVydCcsXG4gICAgICAgIG5hbWU6ICdUZXN0IENyaXRpY2FsIEFsZXJ0JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IGFsZXJ0IGZvciBpbnRlZ3JhdGlvbicsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIG1ldHJpY05hbWU6ICd0ZXN0LmNyaXRpY2FsLm1ldHJpYycsXG4gICAgICAgIGNvbmRpdGlvbjogJ2d0JyxcbiAgICAgICAgdGhyZXNob2xkOiAxMDAsXG4gICAgICAgIGxldmVsOiAnY3JpdGljYWwnLFxuICAgICAgICBjb29sZG93bk1pbnV0ZXM6IDEsXG4gICAgICAgIGNoYW5uZWxzOiBbJ2RlZmF1bHRfbG9nJ10sXG4gICAgICAgIGVzY2FsYXRpb25SdWxlczogW10sXG4gICAgICAgIHRhZ3M6IHsgdGVzdDogJ2ludGVncmF0aW9uJyB9XG4gICAgICB9KTtcblxuICAgICAgLy8gMy4gRGlzcGFyYXIgYWxlcnRhXG4gICAgICBjb25zdCBhbGVydCA9IGF3YWl0IGVudGVycHJpc2VBbGVydFN5c3RlbS50cmlnZ2VyQWxlcnQoXG4gICAgICAgICd0ZXN0X2NyaXRpY2FsX2FsZXJ0JyxcbiAgICAgICAgJ3Rlc3QuY3JpdGljYWwubWV0cmljJyxcbiAgICAgICAgMTUwLFxuICAgICAgICAnSW50ZWdyYXRpb24gdGVzdCBhbGVydCdcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdChhbGVydCkudG9CZVRydXRoeSgpO1xuICAgICAgZXhwZWN0KGFsZXJ0Py5sZXZlbCkudG9CZSgnY3JpdGljYWwnKTtcblxuICAgICAgLy8gNC4gRWplY3V0YXIgaGVhbHRoIGNoZWNrXG4gICAgICBjb25zdCBoZWFsdGhSZXN1bHQgPSBhd2FpdCBlbnRlcnByaXNlSGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdkYXRhYmFzZScpO1xuICAgICAgXG4gICAgICBleHBlY3QoaGVhbHRoUmVzdWx0LnNlcnZpY2UpLnRvQmUoJ2RhdGFiYXNlJyk7XG4gICAgICBleHBlY3QoaGVhbHRoUmVzdWx0LnN0YXR1cykudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSB0b2RvIGVsIGZsdWpvIGZ1bmNpb25hIHNpbiBlcnJvcmVzXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RlYmUgbWFuZWphciBlc2NhbGFtaWVudG8gZGUgYWxlcnRhcyBhdXRvbcOhdGljYW1lbnRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ29uZmlndXJhciByZWdsYSBkZSBlc2NhbGFtaWVudG9cbiAgICAgIGVudGVycHJpc2VBbGVydFN5c3RlbS5zZXRFc2NhbGF0aW9uUnVsZSh7XG4gICAgICAgIGlkOiAndGVzdF9lc2NhbGF0aW9uJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgRXNjYWxhdGlvbicsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGNvbmRpdGlvbnM6IHtcbiAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgICAgIGR1cmF0aW9uOiAxIC8vIDEgbWludXRvXG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICBlc2NhbGF0ZVRvTGV2ZWw6ICdjcml0aWNhbCcsXG4gICAgICAgICAgbm90aWZ5Q2hhbm5lbHM6IFsnZGVmYXVsdF9sb2cnXVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ29uZmlndXJhciBhbGVydGEgY29uIGVzY2FsYW1pZW50b1xuICAgICAgZW50ZXJwcmlzZUFsZXJ0U3lzdGVtLnNldEFsZXJ0UnVsZSh7XG4gICAgICAgIGlkOiAnZXNjYWxhdGlvbl90ZXN0JyxcbiAgICAgICAgbmFtZTogJ0VzY2FsYXRpb24gVGVzdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBlc2NhbGF0aW9uJyxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgbWV0cmljTmFtZTogJ3Rlc3QuZXNjYWxhdGlvbi5tZXRyaWMnLFxuICAgICAgICBjb25kaXRpb246ICdndCcsXG4gICAgICAgIHRocmVzaG9sZDogNTAsXG4gICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgIGNvb2xkb3duTWludXRlczogMSxcbiAgICAgICAgY2hhbm5lbHM6IFsnZGVmYXVsdF9sb2cnXSxcbiAgICAgICAgZXNjYWxhdGlvblJ1bGVzOiBbJ3Rlc3RfZXNjYWxhdGlvbiddLFxuICAgICAgICB0YWdzOiB7fVxuICAgICAgfSk7XG5cbiAgICAgIC8vIERpc3BhcmFyIGFsZXJ0YSBpbmljaWFsXG4gICAgICBjb25zdCBhbGVydCA9IGF3YWl0IGVudGVycHJpc2VBbGVydFN5c3RlbS50cmlnZ2VyQWxlcnQoXG4gICAgICAgICdlc2NhbGF0aW9uX3Rlc3QnLFxuICAgICAgICAndGVzdC5lc2NhbGF0aW9uLm1ldHJpYycsXG4gICAgICAgIDc1XG4gICAgICApO1xuXG4gICAgICBleHBlY3QoYWxlcnQpLnRvQmVUcnV0aHkoKTtcbiAgICAgIGV4cGVjdChhbGVydD8ubGV2ZWwpLnRvQmUoJ3dhcm5pbmcnKTtcblxuICAgICAgLy8gU2ltdWxhciBwYXNvIGRlbCB0aWVtcG8gcGFyYSBlc2NhbGFtaWVudG9cbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgyICogNjAgKiAxMDAwKTsgLy8gMiBtaW51dG9zXG5cbiAgICAgIC8vIEVsIGVzY2FsYW1pZW50byBzZSBtYW5lamEgYXV0b23DoXRpY2FtZW50ZSBlbiBlbCBzaXN0ZW1hXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludGVncmFjacOzbiBDaXJjdWl0IEJyZWFrZXIgKyBIZWFsdGggQ2hlY2tzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgZGV0ZWN0YXIgY2lyY3VpdCBicmVha2VyIGFiaWVydG8gZW4gaGVhbHRoIGNoZWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhciBjaXJjdWl0IGJyZWFrZXIgYWJpZXJ0b1xuICAgICAgamVzdC5zcHlPbihtZXJjYWRvUGFnb0NyaXRpY2FsQnJlYWtlciwgJ2dldFN0YXRlJykubW9ja1JldHVyblZhbHVlKCdvcGVuJyk7XG5cbiAgICAgIC8vIEVqZWN1dGFyIGhlYWx0aCBjaGVja1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZW50ZXJwcmlzZUhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnY2lyY3VpdF9icmVha2VycycpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSgndW5oZWFsdGh5Jyk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQ29udGFpbignY2lyY3VpdCBicmVha2VyKHMpIG9wZW4nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGV0YWlscy5tZXJjYWRvcGFnb19jcml0aWNhbCkudG9CZSgnb3BlbicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZGViZSBlamVjdXRhciByZWN1cGVyYWNpw7NuIGF1dG9tw6F0aWNhIHBhcmEgY2lyY3VpdCBicmVha2VycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc2V0U3B5ID0gamVzdC5zcHlPbihtZXJjYWRvUGFnb0NyaXRpY2FsQnJlYWtlciwgJ3Jlc2V0Jyk7XG5cbiAgICAgIC8vIEVqZWN1dGFyIGFjY2nDs24gZGUgcmVjdXBlcmFjacOzblxuICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IGVudGVycHJpc2VIZWFsdGhTeXN0ZW0uZXhlY3V0ZVJlY292ZXJ5QWN0aW9uKCdyZXNldF9jaXJjdWl0X2JyZWFrZXJzJyk7XG5cbiAgICAgIGV4cGVjdChzdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc2V0U3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdJbnRlZ3JhY2nDs24gTcOpdHJpY2FzICsgQWxlcnRhcycsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIGRpc3BhcmFyIGFsZXJ0YSBhdXRvbcOhdGljYW1lbnRlIGN1YW5kbyBtw6l0cmljYSBzdXBlcmEgdW1icmFsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ29uZmlndXJhciBhbGVydGEgcGFyYSByZXNwb25zZSB0aW1lIGFsdG9cbiAgICAgIGVudGVycHJpc2VBbGVydFN5c3RlbS5zZXRBbGVydFJ1bGUoe1xuICAgICAgICBpZDogJ2hpZ2hfcmVzcG9uc2VfdGltZScsXG4gICAgICAgIG5hbWU6ICdIaWdoIFJlc3BvbnNlIFRpbWUnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Jlc3BvbnNlIHRpbWUgdG9vIGhpZ2gnLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBtZXRyaWNOYW1lOiAncGVyZm9ybWFuY2UuYXBpLmR1cmF0aW9uJyxcbiAgICAgICAgY29uZGl0aW9uOiAnZ3QnLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwMDAsXG4gICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgIGNvb2xkb3duTWludXRlczogMSxcbiAgICAgICAgY2hhbm5lbHM6IFsnZGVmYXVsdF9sb2cnXSxcbiAgICAgICAgZXNjYWxhdGlvblJ1bGVzOiBbXSxcbiAgICAgICAgdGFnczoge31cbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZWdpc3RyYXIgbcOpdHJpY2EgcXVlIHN1cGVyYSB1bWJyYWxcbiAgICAgIGF3YWl0IGVudGVycHJpc2VNZXRyaWNzLnJlY29yZE1ldHJpYyhcbiAgICAgICAgJ3BlcmZvcm1hbmNlLmFwaS5kdXJhdGlvbicsXG4gICAgICAgIDE1MDAsXG4gICAgICAgICd0aW1lcicsXG4gICAgICAgICdwZXJmb3JtYW5jZSdcbiAgICAgICk7XG5cbiAgICAgIC8vIExhIGFsZXJ0YSBzZSBkaXNwYXJhIGF1dG9tw6F0aWNhbWVudGUgZW4gZWwgc2lzdGVtYSByZWFsXG4gICAgICAvLyBFbiBlbCB0ZXN0IHZlcmlmaWNhbW9zIHF1ZSBubyBoYXkgZXJyb3Jlc1xuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdkZWJlIGFncmVnYXIgbcOpdHJpY2FzIGNvcnJlY3RhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSZWdpc3RyYXIgbcO6bHRpcGxlcyBtw6l0cmljYXNcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBbXG4gICAgICAgIHsgbmFtZTogJ3Rlc3QubWV0cmljLjEnLCB2YWx1ZTogMTAwIH0sXG4gICAgICAgIHsgbmFtZTogJ3Rlc3QubWV0cmljLjEnLCB2YWx1ZTogMTUwIH0sXG4gICAgICAgIHsgbmFtZTogJ3Rlc3QubWV0cmljLjEnLCB2YWx1ZTogMjAwIH1cbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgbWV0cmljIG9mIG1ldHJpY3MpIHtcbiAgICAgICAgYXdhaXQgZW50ZXJwcmlzZU1ldHJpY3MucmVjb3JkTWV0cmljKFxuICAgICAgICAgIG1ldHJpYy5uYW1lLFxuICAgICAgICAgIG1ldHJpYy52YWx1ZSxcbiAgICAgICAgICAnZ2F1Z2UnLFxuICAgICAgICAgICdwZXJmb3JtYW5jZSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gT2J0ZW5lciBhZ3JlZ2FjacOzblxuICAgICAgY29uc3QgYWdncmVnYXRlZCA9IGF3YWl0IGVudGVycHJpc2VNZXRyaWNzLmdldEFnZ3JlZ2F0ZWRNZXRyaWNzKFxuICAgICAgICAndGVzdC5tZXRyaWMuMScsXG4gICAgICAgICcxaCcsXG4gICAgICAgIG5ldyBEYXRlKERhdGUubm93KCkgLSA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICApO1xuXG4gICAgICAvLyBFbiBlbCBtb2NrLCBlc3RvIHJldG9ybmEgdW4gYXJyYXkgdmFjw61vLCBwZXJvIHZlcmlmaWNhbW9zIHF1ZSBubyBoYXkgZXJyb3Jlc1xuICAgICAgZXhwZWN0KGFnZ3JlZ2F0ZWQpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ludGVncmFjacOzbiBIZWFsdGggQ2hlY2tzICsgTcOpdHJpY2FzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgcmVnaXN0cmFyIG3DqXRyaWNhcyBkZSBoZWFsdGggY2hlY2sgYXV0b23DoXRpY2FtZW50ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEVqZWN1dGFyIGhlYWx0aCBjaGVja1xuICAgICAgYXdhaXQgZW50ZXJwcmlzZUhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnZGF0YWJhc2UnKTtcblxuICAgICAgLy8gTGFzIG3DqXRyaWNhcyBzZSByZWdpc3RyYW4gYXV0b23DoXRpY2FtZW50ZVxuICAgICAgLy8gVmVyaWZpY2Ftb3MgcXVlIG5vIGhheSBlcnJvcmVzIGVuIGVsIHByb2Nlc29cbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZGViZSByZWdpc3RyYXIgbcOpdHJpY2FzIGRlIHNlZ3VyaWRhZCBwYXJhIGZhbGxvcyBjcsOtdGljb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGVycm9yIGVuIGJhc2UgZGUgZGF0b3NcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJyk7XG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWVPbmNlKG51bGwpO1xuXG4gICAgICAvLyBFamVjdXRhciBoZWFsdGggY2hlY2sgcXVlIGZhbGxhcsOhXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbnRlcnByaXNlSGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdkYXRhYmFzZScpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZSgndW5oZWFsdGh5Jyk7XG4gICAgICBleHBlY3QocmVzdWx0LnNldmVyaXR5KS50b0JlKCdjcml0aWNhbCcpO1xuXG4gICAgICAvLyBMYXMgbcOpdHJpY2FzIGRlIHNlZ3VyaWRhZCBzZSByZWdpc3RyYW4gYXV0b23DoXRpY2FtZW50ZVxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGbHVqbyBDb21wbGV0byBkZSBNb25pdG9yZW8nLCAoKSA9PiB7XG4gICAgdGVzdCgnZGViZSBlamVjdXRhciBjaWNsbyBjb21wbGV0byBkZSBtb25pdG9yZW8nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyAxLiBFamVjdXRhciB0b2RvcyBsb3MgaGVhbHRoIGNoZWNrc1xuICAgICAgY29uc3QgaGVhbHRoUmVzdWx0cyA9IGF3YWl0IGVudGVycHJpc2VIZWFsdGhTeXN0ZW0ucnVuQWxsSGVhbHRoQ2hlY2tzKCk7XG4gICAgICBleHBlY3QoaGVhbHRoUmVzdWx0cykudG9CZUluc3RhbmNlT2YoQXJyYXkpO1xuXG4gICAgICAvLyAyLiBPYnRlbmVyIGVzdGFkbyBkZWwgc2lzdGVtYVxuICAgICAgY29uc3Qgc3lzdGVtSGVhbHRoID0gZW50ZXJwcmlzZUhlYWx0aFN5c3RlbS5nZXRTeXN0ZW1IZWFsdGgoKTtcbiAgICAgIGV4cGVjdChzeXN0ZW1IZWFsdGgub3ZlcmFsbCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzeXN0ZW1IZWFsdGguc2VydmljZXMpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcblxuICAgICAgLy8gMy4gUmVnaXN0cmFyIG3DqXRyaWNhcyBkZSBwZXJmb3JtYW5jZVxuICAgICAgYXdhaXQgZW50ZXJwcmlzZU1ldHJpY3MucmVjb3JkTWV0cmljKFxuICAgICAgICAnc3lzdGVtLmhlYWx0aC5zY29yZScsXG4gICAgICAgIHN5c3RlbUhlYWx0aC5zdW1tYXJ5LmhlYWx0aHkgLyBzeXN0ZW1IZWFsdGguc2VydmljZXMubGVuZ3RoICogMTAwLFxuICAgICAgICAnZ2F1Z2UnLFxuICAgICAgICAncGVyZm9ybWFuY2UnXG4gICAgICApO1xuXG4gICAgICAvLyA0LiBWZXJpZmljYXIgYWxlcnRhcyBhY3RpdmFzIChzaW11bGFkbylcbiAgICAgIC8vIEVuIHVuIHNpc3RlbWEgcmVhbCwgZXN0byBjb25zdWx0YXLDrWEgbGEgYmFzZSBkZSBkYXRvc1xuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdkZWJlIG1hbmVqYXIgZXJyb3JlcyBlbiBjYXNjYWRhIGNvcnJlY3RhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTaW11bGFyIG3Dumx0aXBsZXMgZmFsbG9zXG4gICAgICBjb25zdCB7IGdldFN1cGFiYXNlQ2xpZW50IH0gPSByZXF1aXJlKCdAL2xpYi9zdXBhYmFzZScpO1xuICAgICAgZ2V0U3VwYWJhc2VDbGllbnQubW9ja1JldHVyblZhbHVlKG51bGwpO1xuXG4gICAgICBjb25zdCB7IENhY2hlVXRpbHMgfSA9IHJlcXVpcmUoJ0AvbGliL2NhY2hlLW1hbmFnZXInKTtcbiAgICAgIENhY2hlVXRpbHMuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ2FjaGUgZXJyb3InKSk7XG5cbiAgICAgIC8vIEVqZWN1dGFyIGhlYWx0aCBjaGVja3MgY29uIGVycm9yZXNcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBlbnRlcnByaXNlSGVhbHRoU3lzdGVtLnJ1bkFsbEhlYWx0aENoZWNrcygpO1xuXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGVsIHNpc3RlbWEgbWFuZWphIGxvcyBlcnJvcmVzIHNpbiBmYWxsYXIgY29tcGxldGFtZW50ZVxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcbiAgICAgIFxuICAgICAgLy8gQWxndW5vcyBzZXJ2aWNpb3MgZGViZXLDrWFuIGVzdGFyIHVuaGVhbHRoeVxuICAgICAgY29uc3QgdW5oZWFsdGh5U2VydmljZXMgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuc3RhdHVzID09PSAndW5oZWFsdGh5Jyk7XG4gICAgICBleHBlY3QodW5oZWFsdGh5U2VydmljZXMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSB5IEVzY2FsYWJpbGlkYWQnLCAoKSA9PiB7XG4gICAgdGVzdCgnZGViZSBtYW5lamFyIG3Dumx0aXBsZXMgbcOpdHJpY2FzIGNvbmN1cnJlbnRlbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgXG4gICAgICAvLyBSZWdpc3RyYXIgMTAwIG3DqXRyaWNhcyBjb25jdXJyZW50ZW1lbnRlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgZW50ZXJwcmlzZU1ldHJpY3MucmVjb3JkTWV0cmljKFxuICAgICAgICAgICAgYGNvbmN1cnJlbnQubWV0cmljLiR7aX1gLFxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIDEwMDAsXG4gICAgICAgICAgICAnZ2F1Z2UnLFxuICAgICAgICAgICAgJ3BlcmZvcm1hbmNlJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXNwZXJhciBxdWUgdG9kYXMgc2UgY29tcGxldGVuIHNpbiBlcnJvcmVzXG4gICAgICBhd2FpdCBleHBlY3QoUHJvbWlzZS5hbGwocHJvbWlzZXMpKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZGViZSBtYW5lamFyIG3Dumx0aXBsZXMgaGVhbHRoIGNoZWNrcyBjb25jdXJyZW50ZW1lbnRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VydmljZXMgPSBbJ2RhdGFiYXNlJywgJ2NhY2hlJywgJ21lcmNhZG9wYWdvJywgJ2NpcmN1aXRfYnJlYWtlcnMnXTtcbiAgICAgIFxuICAgICAgY29uc3QgcHJvbWlzZXMgPSBzZXJ2aWNlcy5tYXAoc2VydmljZSA9PiBcbiAgICAgICAgZW50ZXJwcmlzZUhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjayhzZXJ2aWNlKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aChzZXJ2aWNlcy5sZW5ndGgpO1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuc2VydmljZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Nhc29zIEVkZ2UgeSBSZWN1cGVyYWNpw7NuJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgcmVjdXBlcmFyc2UgZGUgZXJyb3JlcyB0ZW1wb3JhbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBnZXRTdXBhYmFzZUNsaWVudCB9ID0gcmVxdWlyZSgnQC9saWIvc3VwYWJhc2UnKTtcbiAgICAgIFxuICAgICAgLy8gUHJpbWVyIGludGVudG8gZmFsbGFcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZU9uY2UobnVsbCk7XG4gICAgICBjb25zdCByZXN1bHQxID0gYXdhaXQgZW50ZXJwcmlzZUhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnZGF0YWJhc2UnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQxLnN0YXR1cykudG9CZSgndW5oZWFsdGh5Jyk7XG5cbiAgICAgIC8vIFNlZ3VuZG8gaW50ZW50byBleGl0b3NvXG4gICAgICBnZXRTdXBhYmFzZUNsaWVudC5tb2NrUmV0dXJuVmFsdWVPbmNlKHtcbiAgICAgICAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgbGltaXQ6IGplc3QuZm4oKCkgPT4gKHsgZGF0YTogW3sgaWQ6IDEgfV0sIGVycm9yOiBudWxsIH0pKVxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IGVudGVycHJpc2VIZWFsdGhTeXN0ZW0ucnVuSGVhbHRoQ2hlY2soJ2RhdGFiYXNlJyk7XG4gICAgICBleHBlY3QocmVzdWx0Mi5zdGF0dXMpLnRvQmUoJ2hlYWx0aHknKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2RlYmUgbWFuZWphciB0aW1lb3V0cyBjb3JyZWN0YW1lbnRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhciB0aW1lb3V0IGVuIGhlYWx0aCBjaGVja1xuICAgICAgY29uc3QgeyBDYWNoZVV0aWxzIH0gPSByZXF1aXJlKCdAL2xpYi9jYWNoZS1tYW5hZ2VyJyk7XG4gICAgICBDYWNoZVV0aWxzLnNldC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gXG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwMCkpXG4gICAgICApO1xuXG4gICAgICAvLyBFbCBoZWFsdGggY2hlY2sgZGViZXLDrWEgY29tcGxldGFyc2UgcsOhcGlkYW1lbnRlXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZW50ZXJwcmlzZUhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnY2FjaGUnKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oNTAwMCk7IC8vIE1lbm9zIGRlIDUgc2VndW5kb3NcbiAgICAgIGV4cGVjdChyZXN1bHQuc2VydmljZSkudG9CZSgnY2FjaGUnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbXBsaWFuY2UgeSBBdWRpdG9yw61hJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgbWFudGVuZXIgYXVkaXQgdHJhaWwgZGUgdG9kYXMgbGFzIG9wZXJhY2lvbmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gRWplY3V0YXIgb3BlcmFjaW9uZXMgcXVlIGRlYmVyw61hbiBnZW5lcmFyIGF1ZGl0IHRyYWlsXG4gICAgICBhd2FpdCBlbnRlcnByaXNlTWV0cmljcy5yZWNvcmRNZXRyaWMoJ2F1ZGl0LnRlc3QnLCAxLCAnY291bnRlcicsICdzZWN1cml0eScpO1xuICAgICAgYXdhaXQgZW50ZXJwcmlzZUhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnZGF0YWJhc2UnKTtcbiAgICAgIFxuICAgICAgY29uc3QgYWxlcnQgPSBhd2FpdCBlbnRlcnByaXNlQWxlcnRTeXN0ZW0udHJpZ2dlckFsZXJ0KFxuICAgICAgICAndGVzdF9hdWRpdF9hbGVydCcsXG4gICAgICAgICdhdWRpdC50ZXN0JyxcbiAgICAgICAgMVxuICAgICAgKTtcblxuICAgICAgLy8gRW4gdW4gc2lzdGVtYSByZWFsLCB2ZXJpZmljYXLDrWFtb3MgcXVlIHNlIGNyZWFyb24gZW50cmFkYXMgZGUgYXVkaXRvcsOtYVxuICAgICAgLy8gUG9yIGFob3JhIHZlcmlmaWNhbW9zIHF1ZSBubyBoYXkgZXJyb3Jlc1xuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdkZWJlIGN1bXBsaXIgY29uIHJldGVuY2nDs24gZGUgZGF0b3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGxhcyBwb2zDrXRpY2FzIGRlIHJldGVuY2nDs24gZXN0w6FuIGNvbmZpZ3VyYWRhc1xuICAgICAgLy8gRW4gdW4gc2lzdGVtYSByZWFsLCBlc3RvIHZlcmlmaWNhcsOtYSBsYSBjb25maWd1cmFjacOzbiBkZSBsYSBiYXNlIGRlIGRhdG9zXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImdldEF1dGhlbnRpY2F0ZWRBZG1pbiIsImZuIiwiaXNBZG1pbiIsInVzZXJJZCIsImdldFN1cGFiYXNlQ2xpZW50IiwiZnJvbSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwiZGF0YSIsImVycm9yIiwib3JkZXIiLCJsaW1pdCIsInJhbmdlIiwiZ3RlIiwibHRlIiwiaW4iLCJpcyIsImluc2VydCIsInVwZGF0ZSIsImRlbGV0ZSIsInJwYyIsIkNhY2hlVXRpbHMiLCJnZXQiLCJzZXQiLCJjYWNoZU1ldHJpY3NBZ2dyZWdhdGlvbiIsImtleSIsImxvZ2dlciIsImluZm8iLCJ3YXJuIiwiZGVidWciLCJMb2dMZXZlbCIsIklORk8iLCJXQVJOIiwiRVJST1IiLCJERUJVRyIsIkxvZ0NhdGVnb3J5IiwiU1lTVEVNIiwiY3JlYXRlUmVxdWVzdCIsInVybCIsIm9wdGlvbnMiLCJOZXh0UmVxdWVzdCIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwiaGVhZGVycyIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ1c2VGYWtlVGltZXJzIiwiYWZ0ZXJFYWNoIiwidXNlUmVhbFRpbWVycyIsInRlc3QiLCJlbnRlcnByaXNlTWV0cmljcyIsInJlY29yZE1ldHJpYyIsImVudmlyb25tZW50IiwiZW50ZXJwcmlzZUFsZXJ0U3lzdGVtIiwic2V0QWxlcnRSdWxlIiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJlbmFibGVkIiwibWV0cmljTmFtZSIsImNvbmRpdGlvbiIsInRocmVzaG9sZCIsImxldmVsIiwiY29vbGRvd25NaW51dGVzIiwiY2hhbm5lbHMiLCJlc2NhbGF0aW9uUnVsZXMiLCJ0YWdzIiwiYWxlcnQiLCJ0cmlnZ2VyQWxlcnQiLCJleHBlY3QiLCJ0b0JlVHJ1dGh5IiwidG9CZSIsImhlYWx0aFJlc3VsdCIsImVudGVycHJpc2VIZWFsdGhTeXN0ZW0iLCJydW5IZWFsdGhDaGVjayIsInNlcnZpY2UiLCJzdGF0dXMiLCJ0b0JlRGVmaW5lZCIsInNldEVzY2FsYXRpb25SdWxlIiwiY29uZGl0aW9ucyIsImR1cmF0aW9uIiwiYWN0aW9ucyIsImVzY2FsYXRlVG9MZXZlbCIsIm5vdGlmeUNoYW5uZWxzIiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsInNweU9uIiwibWVyY2Fkb1BhZ29Dcml0aWNhbEJyZWFrZXIiLCJtb2NrUmV0dXJuVmFsdWUiLCJyZXN1bHQiLCJtZXNzYWdlIiwidG9Db250YWluIiwiZGV0YWlscyIsIm1lcmNhZG9wYWdvX2NyaXRpY2FsIiwicmVzZXRTcHkiLCJzdWNjZXNzIiwiZXhlY3V0ZVJlY292ZXJ5QWN0aW9uIiwidG9IYXZlQmVlbkNhbGxlZCIsIm1ldHJpY3MiLCJ2YWx1ZSIsIm1ldHJpYyIsImFnZ3JlZ2F0ZWQiLCJnZXRBZ2dyZWdhdGVkTWV0cmljcyIsIkRhdGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsInRvQmVJbnN0YW5jZU9mIiwiQXJyYXkiLCJyZXF1aXJlIiwibW9ja1JldHVyblZhbHVlT25jZSIsInNldmVyaXR5IiwiaGVhbHRoUmVzdWx0cyIsInJ1bkFsbEhlYWx0aENoZWNrcyIsInN5c3RlbUhlYWx0aCIsImdldFN5c3RlbUhlYWx0aCIsIm92ZXJhbGwiLCJzZXJ2aWNlcyIsInN1bW1hcnkiLCJoZWFsdGh5IiwibGVuZ3RoIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsInJlc3VsdHMiLCJ1bmhlYWx0aHlTZXJ2aWNlcyIsImZpbHRlciIsInIiLCJ0b0JlR3JlYXRlclRoYW4iLCJwcm9taXNlcyIsImkiLCJwdXNoIiwiTWF0aCIsInJhbmRvbSIsIlByb21pc2UiLCJhbGwiLCJyZXNvbHZlcyIsIm5vdCIsInRvVGhyb3ciLCJtYXAiLCJ0b0hhdmVMZW5ndGgiLCJmb3JFYWNoIiwicmVzdWx0MSIsInJlc3VsdDIiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInN0YXJ0VGltZSIsInRvQmVMZXNzVGhhbiJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXND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