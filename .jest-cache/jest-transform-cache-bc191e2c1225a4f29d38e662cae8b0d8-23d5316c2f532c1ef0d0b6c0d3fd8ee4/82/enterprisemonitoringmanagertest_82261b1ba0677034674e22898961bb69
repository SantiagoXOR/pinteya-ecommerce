20bf960fd61344e8c48ab580b0034472
// ===================================
// TESTS - ENTERPRISE MONITORING MANAGER
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _enterprisemonitoringmanager = /*#__PURE__*/ _interop_require_default(require("../../src/lib/monitoring/enterprise-monitoring-manager"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Mock performance.now
const mockPerformanceNow = jest.fn();
global.performance.now = mockPerformanceNow;
// Mock PerformanceObserver
global.PerformanceObserver = jest.fn().mockImplementation((callback)=>({
        observe: jest.fn(),
        disconnect: jest.fn()
    }));
describe('EnterpriseMonitoringManager', ()=>{
    let monitoringManager;
    let config;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Reset singleton instance
        _enterprisemonitoringmanager.default.instance = undefined;
        config = {
            errorTracking: {
                enabled: true,
                sampleRate: 1.0,
                ignoreErrors: [
                    'test-ignore'
                ],
                maxBreadcrumbs: 50
            },
            performance: {
                enabled: true,
                sampleRate: 1.0,
                thresholds: {
                    lcp: 2500,
                    fid: 100,
                    cls: 0.1,
                    loadTime: 3000
                }
            },
            alerts: {
                enabled: true,
                channels: {
                    email: [
                        'test@example.com'
                    ],
                    slack: 'https://hooks.slack.com/test'
                }
            }
        };
        monitoringManager = _enterprisemonitoringmanager.default.getInstance(config);
        // Mock performance.now to return predictable values
        let callCount = 0;
        mockPerformanceNow.mockImplementation(()=>{
            callCount++;
            return callCount * 100; // 100ms increments
        });
    });
    describe('Initialization', ()=>{
        it('should create singleton instance', ()=>{
            const instance1 = _enterprisemonitoringmanager.default.getInstance(config);
            const instance2 = _enterprisemonitoringmanager.default.getInstance();
            expect(instance1).toBe(instance2);
        });
        it('should throw error if no config provided for first initialization', ()=>{
            // Reset singleton
            _enterprisemonitoringmanager.default.instance = undefined;
            expect(()=>{
                _enterprisemonitoringmanager.default.getInstance();
            }).toThrow('Configuration required for first initialization');
        });
        it('should initialize with default alert rules', ()=>{
            const summary = monitoringManager.getMonitoringSummary();
            expect(summary).toBeDefined();
            expect(summary.system.sessionId).toMatch(/^session_/);
        });
    });
    describe('Error Tracking', ()=>{
        it('should capture error successfully', ()=>{
            const errorId = monitoringManager.captureError(new Error('Test error'), 'error', {
                component: 'TestComponent'
            }, [
                'test'
            ]);
            expect(errorId).toMatch(/^error_/);
            const errors = monitoringManager.getErrors();
            expect(errors).toHaveLength(1);
            expect(errors[0].message).toBe('Test error');
            expect(errors[0].level).toBe('error');
            expect(errors[0].context.component).toBe('TestComponent');
            expect(errors[0].tags).toContain('test');
        });
        it('should capture string error', ()=>{
            const errorId = monitoringManager.captureError('String error message', 'warning');
            expect(errorId).toMatch(/^error_/);
            const errors = monitoringManager.getErrors();
            expect(errors).toHaveLength(1);
            expect(errors[0].message).toBe('String error message');
            expect(errors[0].level).toBe('warning');
            expect(errors[0].stack).toBeUndefined();
        });
        it('should ignore errors based on configuration', ()=>{
            const errorId = monitoringManager.captureError('test-ignore error message', 'error');
            expect(errorId).toBe('');
            const errors = monitoringManager.getErrors();
            expect(errors).toHaveLength(0);
        });
        it('should respect sample rate', ()=>{
            // Create manager with low sample rate
            const lowSampleConfig = {
                ...config
            };
            lowSampleConfig.errorTracking.sampleRate = 0.0;
            // Reset singleton
            _enterprisemonitoringmanager.default.instance = undefined;
            const lowSampleManager = _enterprisemonitoringmanager.default.getInstance(lowSampleConfig);
            const errorId = lowSampleManager.captureError('Test error', 'error');
            expect(errorId).toBe('');
        });
        it('should deduplicate errors with same fingerprint', ()=>{
            // Capture same error twice
            monitoringManager.captureError('Duplicate error', 'error');
            monitoringManager.captureError('Duplicate error', 'error');
            const errors = monitoringManager.getErrors();
            expect(errors).toHaveLength(1);
            expect(errors[0].count).toBe(2);
        });
        it('should filter errors by level', ()=>{
            monitoringManager.captureError('Critical error', 'critical');
            monitoringManager.captureError('Warning error', 'warning');
            monitoringManager.captureError('Info error', 'info');
            const criticalErrors = monitoringManager.getErrors({
                level: 'critical'
            });
            expect(criticalErrors).toHaveLength(1);
            expect(criticalErrors[0].level).toBe('critical');
            const warningErrors = monitoringManager.getErrors({
                level: 'warning'
            });
            expect(warningErrors).toHaveLength(1);
            expect(warningErrors[0].level).toBe('warning');
        });
        it('should filter errors by time range', ()=>{
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            monitoringManager.captureError('Recent error', 'error');
            const recentErrors = monitoringManager.getErrors({
                timeRange: {
                    start: oneHourAgo,
                    end: now
                }
            });
            expect(recentErrors).toHaveLength(1);
            const futureErrors = monitoringManager.getErrors({
                timeRange: {
                    start: new Date(now.getTime() + 60 * 60 * 1000),
                    end: new Date(now.getTime() + 2 * 60 * 60 * 1000)
                }
            });
            expect(futureErrors).toHaveLength(0);
        });
        it('should limit number of errors returned', ()=>{
            // Capture multiple errors
            for(let i = 0; i < 10; i++){
                monitoringManager.captureError(`Error ${i}`, 'error');
            }
            const limitedErrors = monitoringManager.getErrors({
                limit: 5
            });
            expect(limitedErrors).toHaveLength(5);
        });
    });
    describe('Performance Monitoring', ()=>{
        it('should capture performance metrics', ()=>{
            monitoringManager.capturePerformanceMetrics();
            const metrics = monitoringManager.getPerformanceMetrics();
            expect(metrics).toHaveLength(1);
            expect(metrics[0].metrics).toHaveProperty('loadTime');
            expect(metrics[0].metrics).toHaveProperty('renderTime');
            expect(metrics[0].metrics).toHaveProperty('memoryUsage');
        });
        it('should record custom metrics', ()=>{
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            monitoringManager.recordMetric('custom_metric', 123.45, {
                test: true
            });
            // Check if metric was recorded (the console.log might not be called due to sample rate)
            expect(()=>{
                monitoringManager.recordMetric('custom_metric', 123.45, {
                    test: true
                });
            }).not.toThrow();
            consoleSpy.mockRestore();
        });
        it('should respect performance sample rate', ()=>{
            // Create manager with low sample rate
            const lowSampleConfig = {
                ...config
            };
            lowSampleConfig.performance.sampleRate = 0.0;
            // Reset singleton
            _enterprisemonitoringmanager.default.instance = undefined;
            const lowSampleManager = _enterprisemonitoringmanager.default.getInstance(lowSampleConfig);
            lowSampleManager.capturePerformanceMetrics();
            const metrics = lowSampleManager.getPerformanceMetrics();
            expect(metrics).toHaveLength(0);
        });
        it('should filter performance metrics by time range', ()=>{
            monitoringManager.capturePerformanceMetrics();
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);
            const recentMetrics = monitoringManager.getPerformanceMetrics({
                start: oneHourAgo,
                end: now
            });
            expect(recentMetrics).toHaveLength(1);
        });
    });
    describe('Alert System', ()=>{
        it('should trigger alert when threshold exceeded', ()=>{
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            // Record metric that exceeds threshold
            monitoringManager.recordMetric('load_time', 5000); // Exceeds 3000ms threshold
            expect(consoleSpy).toHaveBeenCalledWith('[Monitoring] Alert triggered:', expect.objectContaining({
                severity: 'medium',
                message: expect.stringContaining('load_time is 5000')
            }));
            const activeAlerts = monitoringManager.getActiveAlerts();
            expect(activeAlerts).toHaveLength(1);
            expect(activeAlerts[0].severity).toBe('medium');
            consoleSpy.mockRestore();
        });
        it('should acknowledge alert', ()=>{
            // Trigger an alert
            monitoringManager.recordMetric('load_time', 5000);
            const alerts = monitoringManager.getActiveAlerts();
            expect(alerts).toHaveLength(1);
            expect(alerts[0].acknowledged).toBe(false);
            // Acknowledge the alert
            const success = monitoringManager.acknowledgeAlert(alerts[0].id);
            expect(success).toBe(true);
            const updatedAlerts = monitoringManager.getActiveAlerts();
            expect(updatedAlerts[0].acknowledged).toBe(true);
        });
        it('should resolve alert', ()=>{
            // Trigger an alert
            monitoringManager.recordMetric('load_time', 5000);
            const alerts = monitoringManager.getActiveAlerts();
            expect(alerts.length).toBeGreaterThan(0);
            expect(alerts[0].resolvedAt).toBeUndefined();
            // Resolve the alert
            const success = monitoringManager.resolveAlert(alerts[0].id);
            expect(success).toBe(true);
            // Check that the alert was resolved (it should still be in the list but with resolvedAt set)
            const allAlerts = monitoringManager.getActiveAlerts();
            const resolvedAlert = allAlerts.find((a)=>a.id === alerts[0].id);
            // If the alert is not found in active alerts, it means it was properly resolved
            if (!resolvedAlert) {
                expect(success).toBe(true); // Already verified above
            } else {
                expect(resolvedAlert.resolvedAt).toBeDefined();
            }
        });
        it('should respect alert cooldown', ()=>{
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            // Trigger alert twice quickly
            monitoringManager.recordMetric('load_time', 5000);
            monitoringManager.recordMetric('load_time', 5000);
            // Should only trigger once due to cooldown
            expect(consoleSpy).toHaveBeenCalledTimes(1);
            const activeAlerts = monitoringManager.getActiveAlerts();
            expect(activeAlerts).toHaveLength(1);
            consoleSpy.mockRestore();
        });
        it('should trigger critical error alert', ()=>{
            const initialAlertCount = monitoringManager.getActiveAlerts().length;
            monitoringManager.captureError('Critical system failure', 'critical');
            // Check if new alerts were created
            const finalAlertCount = monitoringManager.getActiveAlerts().length;
            expect(finalAlertCount).toBeGreaterThanOrEqual(initialAlertCount);
            // Verify the error was captured
            const errors = monitoringManager.getErrors({
                level: 'critical'
            });
            expect(errors.length).toBeGreaterThan(0);
            expect(errors[0].message).toBe('Critical system failure');
        });
    });
    describe('Monitoring Summary', ()=>{
        it('should generate monitoring summary', ()=>{
            // Add some test data
            monitoringManager.captureError('Test error', 'error');
            monitoringManager.captureError('Critical error', 'critical');
            monitoringManager.capturePerformanceMetrics();
            monitoringManager.recordMetric('load_time', 5000); // Triggers alert
            const summary = monitoringManager.getMonitoringSummary();
            expect(summary.errors.total).toBe(2);
            expect(summary.errors.critical).toBe(1);
            expect(summary.performance.averageLoadTime).toBeGreaterThanOrEqual(0);
            expect(summary.alerts.active).toBeGreaterThanOrEqual(0);
            expect(summary.system.uptime).toBeGreaterThan(0);
            expect(summary.system.sessionId).toMatch(/^session_/);
        });
        it('should handle empty data in summary', ()=>{
            const summary = monitoringManager.getMonitoringSummary();
            expect(summary.errors.total).toBe(0);
            expect(summary.performance.averageLoadTime).toBe(0);
            expect(summary.alerts.active).toBe(0);
        });
    });
    describe('Configuration', ()=>{
        it('should disable error tracking when configured', ()=>{
            const disabledConfig = {
                ...config
            };
            disabledConfig.errorTracking.enabled = false;
            // Reset singleton
            _enterprisemonitoringmanager.default.instance = undefined;
            const disabledManager = _enterprisemonitoringmanager.default.getInstance(disabledConfig);
            const errorId = disabledManager.captureError('Test error', 'error');
            expect(errorId).toBe('');
        });
        it('should disable performance monitoring when configured', ()=>{
            const disabledConfig = {
                ...config
            };
            disabledConfig.performance.enabled = false;
            // Reset singleton
            _enterprisemonitoringmanager.default.instance = undefined;
            const disabledManager = _enterprisemonitoringmanager.default.getInstance(disabledConfig);
            disabledManager.capturePerformanceMetrics();
            const metrics = disabledManager.getPerformanceMetrics();
            expect(metrics).toHaveLength(0);
        });
        it('should disable alerts when configured', ()=>{
            const disabledConfig = {
                ...config
            };
            disabledConfig.alerts.enabled = false;
            // Reset singleton
            _enterprisemonitoringmanager.default.instance = undefined;
            const disabledManager = _enterprisemonitoringmanager.default.getInstance(disabledConfig);
            const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
            // This would normally trigger notifications
            disabledManager.recordMetric('load_time', 5000);
            // Should not send notifications
            expect(consoleSpy).not.toHaveBeenCalledWith(expect.stringContaining('Email alert sent'));
            consoleSpy.mockRestore();
        });
    });
    describe('Error Handling', ()=>{
        it('should handle invalid alert operations gracefully', ()=>{
            const success1 = monitoringManager.acknowledgeAlert('invalid-id');
            expect(success1).toBe(false);
            const success2 = monitoringManager.resolveAlert('invalid-id');
            expect(success2).toBe(false);
        });
        it('should handle browser API unavailability', ()=>{
            // Mock missing performance.memory
            const originalMemory = performance.memory;
            delete performance.memory;
            // Should not throw error
            expect(()=>{
                monitoringManager.capturePerformanceMetrics();
            }).not.toThrow();
            // Restore
            performance.memory = originalMemory;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXF9fdGVzdHNfX1xcbW9uaXRvcmluZ1xcZW50ZXJwcmlzZS1tb25pdG9yaW5nLW1hbmFnZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyAtIEVOVEVSUFJJU0UgTU9OSVRPUklORyBNQU5BR0VSXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbXBvcnQgRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyIGZyb20gJ0AvbGliL21vbml0b3JpbmcvZW50ZXJwcmlzZS1tb25pdG9yaW5nLW1hbmFnZXInO1xyXG5pbXBvcnQgdHlwZSB7IE1vbml0b3JpbmdDb25maWcgfSBmcm9tICdAL2xpYi9tb25pdG9yaW5nL2VudGVycHJpc2UtbW9uaXRvcmluZy1tYW5hZ2VyJztcclxuXHJcbi8vIE1vY2sgcGVyZm9ybWFuY2Uubm93XHJcbmNvbnN0IG1vY2tQZXJmb3JtYW5jZU5vdyA9IGplc3QuZm4oKTtcclxuZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdyA9IG1vY2tQZXJmb3JtYW5jZU5vdztcclxuXHJcbi8vIE1vY2sgUGVyZm9ybWFuY2VPYnNlcnZlclxyXG5nbG9iYWwuUGVyZm9ybWFuY2VPYnNlcnZlciA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKGNhbGxiYWNrKSA9PiAoe1xyXG4gIG9ic2VydmU6IGplc3QuZm4oKSxcclxuICBkaXNjb25uZWN0OiBqZXN0LmZuKClcclxufSkpO1xyXG5cclxuZGVzY3JpYmUoJ0VudGVycHJpc2VNb25pdG9yaW5nTWFuYWdlcicsICgpID0+IHtcclxuICBsZXQgbW9uaXRvcmluZ01hbmFnZXI6IEVudGVycHJpc2VNb25pdG9yaW5nTWFuYWdlcjtcclxuICBsZXQgY29uZmlnOiBNb25pdG9yaW5nQ29uZmlnO1xyXG5cclxuICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gICAgXHJcbiAgICAvLyBSZXNldCBzaW5nbGV0b24gaW5zdGFuY2VcclxuICAgIChFbnRlcnByaXNlTW9uaXRvcmluZ01hbmFnZXIgYXMgYW55KS5pbnN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICAgIFxyXG4gICAgY29uZmlnID0ge1xyXG4gICAgICBlcnJvclRyYWNraW5nOiB7XHJcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBzYW1wbGVSYXRlOiAxLjAsXHJcbiAgICAgICAgaWdub3JlRXJyb3JzOiBbJ3Rlc3QtaWdub3JlJ10sXHJcbiAgICAgICAgbWF4QnJlYWRjcnVtYnM6IDUwXHJcbiAgICAgIH0sXHJcbiAgICAgIHBlcmZvcm1hbmNlOiB7XHJcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICBzYW1wbGVSYXRlOiAxLjAsXHJcbiAgICAgICAgdGhyZXNob2xkczoge1xyXG4gICAgICAgICAgbGNwOiAyNTAwLFxyXG4gICAgICAgICAgZmlkOiAxMDAsXHJcbiAgICAgICAgICBjbHM6IDAuMSxcclxuICAgICAgICAgIGxvYWRUaW1lOiAzMDAwXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBhbGVydHM6IHtcclxuICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIGNoYW5uZWxzOiB7XHJcbiAgICAgICAgICBlbWFpbDogWyd0ZXN0QGV4YW1wbGUuY29tJ10sXHJcbiAgICAgICAgICBzbGFjazogJ2h0dHBzOi8vaG9va3Muc2xhY2suY29tL3Rlc3QnXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vbml0b3JpbmdNYW5hZ2VyID0gRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyLmdldEluc3RhbmNlKGNvbmZpZyk7XHJcbiAgICBcclxuICAgIC8vIE1vY2sgcGVyZm9ybWFuY2Uubm93IHRvIHJldHVybiBwcmVkaWN0YWJsZSB2YWx1ZXNcclxuICAgIGxldCBjYWxsQ291bnQgPSAwO1xyXG4gICAgbW9ja1BlcmZvcm1hbmNlTm93Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XHJcbiAgICAgIGNhbGxDb3VudCsrO1xyXG4gICAgICByZXR1cm4gY2FsbENvdW50ICogMTAwOyAvLyAxMDBtcyBpbmNyZW1lbnRzXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ0luaXRpYWxpemF0aW9uJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgc2luZ2xldG9uIGluc3RhbmNlJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbnN0YW5jZTEgPSBFbnRlcnByaXNlTW9uaXRvcmluZ01hbmFnZXIuZ2V0SW5zdGFuY2UoY29uZmlnKTtcclxuICAgICAgY29uc3QgaW5zdGFuY2UyID0gRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoaW5zdGFuY2UxKS50b0JlKGluc3RhbmNlMik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGlmIG5vIGNvbmZpZyBwcm92aWRlZCBmb3IgZmlyc3QgaW5pdGlhbGl6YXRpb24nLCAoKSA9PiB7XHJcbiAgICAgIC8vIFJlc2V0IHNpbmdsZXRvblxyXG4gICAgICAoRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyIGFzIGFueSkuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoKCkgPT4ge1xyXG4gICAgICAgIEVudGVycHJpc2VNb25pdG9yaW5nTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICB9KS50b1Rocm93KCdDb25maWd1cmF0aW9uIHJlcXVpcmVkIGZvciBmaXJzdCBpbml0aWFsaXphdGlvbicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBpbml0aWFsaXplIHdpdGggZGVmYXVsdCBhbGVydCBydWxlcycsICgpID0+IHtcclxuICAgICAgY29uc3Qgc3VtbWFyeSA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldE1vbml0b3JpbmdTdW1tYXJ5KCk7XHJcbiAgICAgIGV4cGVjdChzdW1tYXJ5KS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3Qoc3VtbWFyeS5zeXN0ZW0uc2Vzc2lvbklkKS50b01hdGNoKC9ec2Vzc2lvbl8vKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnRXJyb3IgVHJhY2tpbmcnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGNhcHR1cmUgZXJyb3Igc3VjY2Vzc2Z1bGx5JywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBlcnJvcklkID0gbW9uaXRvcmluZ01hbmFnZXIuY2FwdHVyZUVycm9yKFxyXG4gICAgICAgIG5ldyBFcnJvcignVGVzdCBlcnJvcicpLFxyXG4gICAgICAgICdlcnJvcicsXHJcbiAgICAgICAgeyBjb21wb25lbnQ6ICdUZXN0Q29tcG9uZW50JyB9LFxyXG4gICAgICAgIFsndGVzdCddXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBleHBlY3QoZXJyb3JJZCkudG9NYXRjaCgvXmVycm9yXy8pO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgZXJyb3JzID0gbW9uaXRvcmluZ01hbmFnZXIuZ2V0RXJyb3JzKCk7XHJcbiAgICAgIGV4cGVjdChlcnJvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcclxuICAgICAgZXhwZWN0KGVycm9yc1swXS5tZXNzYWdlKS50b0JlKCdUZXN0IGVycm9yJyk7XHJcbiAgICAgIGV4cGVjdChlcnJvcnNbMF0ubGV2ZWwpLnRvQmUoJ2Vycm9yJyk7XHJcbiAgICAgIGV4cGVjdChlcnJvcnNbMF0uY29udGV4dC5jb21wb25lbnQpLnRvQmUoJ1Rlc3RDb21wb25lbnQnKTtcclxuICAgICAgZXhwZWN0KGVycm9yc1swXS50YWdzKS50b0NvbnRhaW4oJ3Rlc3QnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgY2FwdHVyZSBzdHJpbmcgZXJyb3InLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVycm9ySWQgPSBtb25pdG9yaW5nTWFuYWdlci5jYXB0dXJlRXJyb3IoXHJcbiAgICAgICAgJ1N0cmluZyBlcnJvciBtZXNzYWdlJyxcclxuICAgICAgICAnd2FybmluZydcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGV4cGVjdChlcnJvcklkKS50b01hdGNoKC9eZXJyb3JfLyk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBlcnJvcnMgPSBtb25pdG9yaW5nTWFuYWdlci5nZXRFcnJvcnMoKTtcclxuICAgICAgZXhwZWN0KGVycm9ycykudG9IYXZlTGVuZ3RoKDEpO1xyXG4gICAgICBleHBlY3QoZXJyb3JzWzBdLm1lc3NhZ2UpLnRvQmUoJ1N0cmluZyBlcnJvciBtZXNzYWdlJyk7XHJcbiAgICAgIGV4cGVjdChlcnJvcnNbMF0ubGV2ZWwpLnRvQmUoJ3dhcm5pbmcnKTtcclxuICAgICAgZXhwZWN0KGVycm9yc1swXS5zdGFjaykudG9CZVVuZGVmaW5lZCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBpZ25vcmUgZXJyb3JzIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVycm9ySWQgPSBtb25pdG9yaW5nTWFuYWdlci5jYXB0dXJlRXJyb3IoXHJcbiAgICAgICAgJ3Rlc3QtaWdub3JlIGVycm9yIG1lc3NhZ2UnLFxyXG4gICAgICAgICdlcnJvcidcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGV4cGVjdChlcnJvcklkKS50b0JlKCcnKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGVycm9ycyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldEVycm9ycygpO1xyXG4gICAgICBleHBlY3QoZXJyb3JzKS50b0hhdmVMZW5ndGgoMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJlc3BlY3Qgc2FtcGxlIHJhdGUnLCAoKSA9PiB7XHJcbiAgICAgIC8vIENyZWF0ZSBtYW5hZ2VyIHdpdGggbG93IHNhbXBsZSByYXRlXHJcbiAgICAgIGNvbnN0IGxvd1NhbXBsZUNvbmZpZyA9IHsgLi4uY29uZmlnIH07XHJcbiAgICAgIGxvd1NhbXBsZUNvbmZpZy5lcnJvclRyYWNraW5nLnNhbXBsZVJhdGUgPSAwLjA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXNldCBzaW5nbGV0b25cclxuICAgICAgKEVudGVycHJpc2VNb25pdG9yaW5nTWFuYWdlciBhcyBhbnkpLmluc3RhbmNlID0gdW5kZWZpbmVkO1xyXG4gICAgICBjb25zdCBsb3dTYW1wbGVNYW5hZ2VyID0gRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyLmdldEluc3RhbmNlKGxvd1NhbXBsZUNvbmZpZyk7XHJcblxyXG4gICAgICBjb25zdCBlcnJvcklkID0gbG93U2FtcGxlTWFuYWdlci5jYXB0dXJlRXJyb3IoJ1Rlc3QgZXJyb3InLCAnZXJyb3InKTtcclxuICAgICAgZXhwZWN0KGVycm9ySWQpLnRvQmUoJycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBkZWR1cGxpY2F0ZSBlcnJvcnMgd2l0aCBzYW1lIGZpbmdlcnByaW50JywgKCkgPT4ge1xyXG4gICAgICAvLyBDYXB0dXJlIHNhbWUgZXJyb3IgdHdpY2VcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIuY2FwdHVyZUVycm9yKCdEdXBsaWNhdGUgZXJyb3InLCAnZXJyb3InKTtcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIuY2FwdHVyZUVycm9yKCdEdXBsaWNhdGUgZXJyb3InLCAnZXJyb3InKTtcclxuXHJcbiAgICAgIGNvbnN0IGVycm9ycyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldEVycm9ycygpO1xyXG4gICAgICBleHBlY3QoZXJyb3JzKS50b0hhdmVMZW5ndGgoMSk7XHJcbiAgICAgIGV4cGVjdChlcnJvcnNbMF0uY291bnQpLnRvQmUoMik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGZpbHRlciBlcnJvcnMgYnkgbGV2ZWwnLCAoKSA9PiB7XHJcbiAgICAgIG1vbml0b3JpbmdNYW5hZ2VyLmNhcHR1cmVFcnJvcignQ3JpdGljYWwgZXJyb3InLCAnY3JpdGljYWwnKTtcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIuY2FwdHVyZUVycm9yKCdXYXJuaW5nIGVycm9yJywgJ3dhcm5pbmcnKTtcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIuY2FwdHVyZUVycm9yKCdJbmZvIGVycm9yJywgJ2luZm8nKTtcclxuXHJcbiAgICAgIGNvbnN0IGNyaXRpY2FsRXJyb3JzID0gbW9uaXRvcmluZ01hbmFnZXIuZ2V0RXJyb3JzKHsgbGV2ZWw6ICdjcml0aWNhbCcgfSk7XHJcbiAgICAgIGV4cGVjdChjcml0aWNhbEVycm9ycykudG9IYXZlTGVuZ3RoKDEpO1xyXG4gICAgICBleHBlY3QoY3JpdGljYWxFcnJvcnNbMF0ubGV2ZWwpLnRvQmUoJ2NyaXRpY2FsJyk7XHJcblxyXG4gICAgICBjb25zdCB3YXJuaW5nRXJyb3JzID0gbW9uaXRvcmluZ01hbmFnZXIuZ2V0RXJyb3JzKHsgbGV2ZWw6ICd3YXJuaW5nJyB9KTtcclxuICAgICAgZXhwZWN0KHdhcm5pbmdFcnJvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcclxuICAgICAgZXhwZWN0KHdhcm5pbmdFcnJvcnNbMF0ubGV2ZWwpLnRvQmUoJ3dhcm5pbmcnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgZmlsdGVyIGVycm9ycyBieSB0aW1lIHJhbmdlJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICBjb25zdCBvbmVIb3VyQWdvID0gbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDYwICogNjAgKiAxMDAwKTtcclxuICAgICAgXHJcbiAgICAgIG1vbml0b3JpbmdNYW5hZ2VyLmNhcHR1cmVFcnJvcignUmVjZW50IGVycm9yJywgJ2Vycm9yJyk7XHJcblxyXG4gICAgICBjb25zdCByZWNlbnRFcnJvcnMgPSBtb25pdG9yaW5nTWFuYWdlci5nZXRFcnJvcnMoe1xyXG4gICAgICAgIHRpbWVSYW5nZTogeyBzdGFydDogb25lSG91ckFnbywgZW5kOiBub3cgfVxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChyZWNlbnRFcnJvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcclxuXHJcbiAgICAgIGNvbnN0IGZ1dHVyZUVycm9ycyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldEVycm9ycyh7XHJcbiAgICAgICAgdGltZVJhbmdlOiB7IFxyXG4gICAgICAgICAgc3RhcnQ6IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgKyA2MCAqIDYwICogMTAwMCksIFxyXG4gICAgICAgICAgZW5kOiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgMiAqIDYwICogNjAgKiAxMDAwKSBcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgZXhwZWN0KGZ1dHVyZUVycm9ycykudG9IYXZlTGVuZ3RoKDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBsaW1pdCBudW1iZXIgb2YgZXJyb3JzIHJldHVybmVkJywgKCkgPT4ge1xyXG4gICAgICAvLyBDYXB0dXJlIG11bHRpcGxlIGVycm9yc1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcclxuICAgICAgICBtb25pdG9yaW5nTWFuYWdlci5jYXB0dXJlRXJyb3IoYEVycm9yICR7aX1gLCAnZXJyb3InKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgbGltaXRlZEVycm9ycyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldEVycm9ycyh7IGxpbWl0OiA1IH0pO1xyXG4gICAgICBleHBlY3QobGltaXRlZEVycm9ycykudG9IYXZlTGVuZ3RoKDUpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBNb25pdG9yaW5nJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBjYXB0dXJlIHBlcmZvcm1hbmNlIG1ldHJpY3MnLCAoKSA9PiB7XHJcbiAgICAgIG1vbml0b3JpbmdNYW5hZ2VyLmNhcHR1cmVQZXJmb3JtYW5jZU1ldHJpY3MoKTtcclxuXHJcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBtb25pdG9yaW5nTWFuYWdlci5nZXRQZXJmb3JtYW5jZU1ldHJpY3MoKTtcclxuICAgICAgZXhwZWN0KG1ldHJpY3MpLnRvSGF2ZUxlbmd0aCgxKTtcclxuICAgICAgZXhwZWN0KG1ldHJpY3NbMF0ubWV0cmljcykudG9IYXZlUHJvcGVydHkoJ2xvYWRUaW1lJyk7XHJcbiAgICAgIGV4cGVjdChtZXRyaWNzWzBdLm1ldHJpY3MpLnRvSGF2ZVByb3BlcnR5KCdyZW5kZXJUaW1lJyk7XHJcbiAgICAgIGV4cGVjdChtZXRyaWNzWzBdLm1ldHJpY3MpLnRvSGF2ZVByb3BlcnR5KCdtZW1vcnlVc2FnZScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZWNvcmQgY3VzdG9tIG1ldHJpY3MnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcclxuXHJcbiAgICAgIG1vbml0b3JpbmdNYW5hZ2VyLnJlY29yZE1ldHJpYygnY3VzdG9tX21ldHJpYycsIDEyMy40NSwgeyB0ZXN0OiB0cnVlIH0pO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgbWV0cmljIHdhcyByZWNvcmRlZCAodGhlIGNvbnNvbGUubG9nIG1pZ2h0IG5vdCBiZSBjYWxsZWQgZHVlIHRvIHNhbXBsZSByYXRlKVxyXG4gICAgICBleHBlY3QoKCkgPT4ge1xyXG4gICAgICAgIG1vbml0b3JpbmdNYW5hZ2VyLnJlY29yZE1ldHJpYygnY3VzdG9tX21ldHJpYycsIDEyMy40NSwgeyB0ZXN0OiB0cnVlIH0pO1xyXG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xyXG5cclxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXNwZWN0IHBlcmZvcm1hbmNlIHNhbXBsZSByYXRlJywgKCkgPT4ge1xyXG4gICAgICAvLyBDcmVhdGUgbWFuYWdlciB3aXRoIGxvdyBzYW1wbGUgcmF0ZVxyXG4gICAgICBjb25zdCBsb3dTYW1wbGVDb25maWcgPSB7IC4uLmNvbmZpZyB9O1xyXG4gICAgICBsb3dTYW1wbGVDb25maWcucGVyZm9ybWFuY2Uuc2FtcGxlUmF0ZSA9IDAuMDtcclxuICAgICAgXHJcbiAgICAgIC8vIFJlc2V0IHNpbmdsZXRvblxyXG4gICAgICAoRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyIGFzIGFueSkuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGNvbnN0IGxvd1NhbXBsZU1hbmFnZXIgPSBFbnRlcnByaXNlTW9uaXRvcmluZ01hbmFnZXIuZ2V0SW5zdGFuY2UobG93U2FtcGxlQ29uZmlnKTtcclxuXHJcbiAgICAgIGxvd1NhbXBsZU1hbmFnZXIuY2FwdHVyZVBlcmZvcm1hbmNlTWV0cmljcygpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgbWV0cmljcyA9IGxvd1NhbXBsZU1hbmFnZXIuZ2V0UGVyZm9ybWFuY2VNZXRyaWNzKCk7XHJcbiAgICAgIGV4cGVjdChtZXRyaWNzKS50b0hhdmVMZW5ndGgoMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGZpbHRlciBwZXJmb3JtYW5jZSBtZXRyaWNzIGJ5IHRpbWUgcmFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgIG1vbml0b3JpbmdNYW5hZ2VyLmNhcHR1cmVQZXJmb3JtYW5jZU1ldHJpY3MoKTtcclxuXHJcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGNvbnN0IG9uZUhvdXJBZ28gPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpIC0gNjAgKiA2MCAqIDEwMDApO1xyXG5cclxuICAgICAgY29uc3QgcmVjZW50TWV0cmljcyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldFBlcmZvcm1hbmNlTWV0cmljcyh7XHJcbiAgICAgICAgc3RhcnQ6IG9uZUhvdXJBZ28sXHJcbiAgICAgICAgZW5kOiBub3dcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVjZW50TWV0cmljcykudG9IYXZlTGVuZ3RoKDEpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdBbGVydCBTeXN0ZW0nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHRyaWdnZXIgYWxlcnQgd2hlbiB0aHJlc2hvbGQgZXhjZWVkZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgICAvLyBSZWNvcmQgbWV0cmljIHRoYXQgZXhjZWVkcyB0aHJlc2hvbGRcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIucmVjb3JkTWV0cmljKCdsb2FkX3RpbWUnLCA1MDAwKTsgLy8gRXhjZWVkcyAzMDAwbXMgdGhyZXNob2xkXHJcblxyXG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgJ1tNb25pdG9yaW5nXSBBbGVydCB0cmlnZ2VyZWQ6JyxcclxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XHJcbiAgICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXHJcbiAgICAgICAgICBtZXNzYWdlOiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnbG9hZF90aW1lIGlzIDUwMDAnKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBhY3RpdmVBbGVydHMgPSBtb25pdG9yaW5nTWFuYWdlci5nZXRBY3RpdmVBbGVydHMoKTtcclxuICAgICAgZXhwZWN0KGFjdGl2ZUFsZXJ0cykudG9IYXZlTGVuZ3RoKDEpO1xyXG4gICAgICBleHBlY3QoYWN0aXZlQWxlcnRzWzBdLnNldmVyaXR5KS50b0JlKCdtZWRpdW0nKTtcclxuXHJcbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgYWNrbm93bGVkZ2UgYWxlcnQnLCAoKSA9PiB7XHJcbiAgICAgIC8vIFRyaWdnZXIgYW4gYWxlcnRcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIucmVjb3JkTWV0cmljKCdsb2FkX3RpbWUnLCA1MDAwKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGFsZXJ0cyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldEFjdGl2ZUFsZXJ0cygpO1xyXG4gICAgICBleHBlY3QoYWxlcnRzKS50b0hhdmVMZW5ndGgoMSk7XHJcbiAgICAgIGV4cGVjdChhbGVydHNbMF0uYWNrbm93bGVkZ2VkKS50b0JlKGZhbHNlKTtcclxuXHJcbiAgICAgIC8vIEFja25vd2xlZGdlIHRoZSBhbGVydFxyXG4gICAgICBjb25zdCBzdWNjZXNzID0gbW9uaXRvcmluZ01hbmFnZXIuYWNrbm93bGVkZ2VBbGVydChhbGVydHNbMF0uaWQpO1xyXG4gICAgICBleHBlY3Qoc3VjY2VzcykudG9CZSh0cnVlKTtcclxuXHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRBbGVydHMgPSBtb25pdG9yaW5nTWFuYWdlci5nZXRBY3RpdmVBbGVydHMoKTtcclxuICAgICAgZXhwZWN0KHVwZGF0ZWRBbGVydHNbMF0uYWNrbm93bGVkZ2VkKS50b0JlKHRydWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXNvbHZlIGFsZXJ0JywgKCkgPT4ge1xyXG4gICAgICAvLyBUcmlnZ2VyIGFuIGFsZXJ0XHJcbiAgICAgIG1vbml0b3JpbmdNYW5hZ2VyLnJlY29yZE1ldHJpYygnbG9hZF90aW1lJywgNTAwMCk7XHJcblxyXG4gICAgICBjb25zdCBhbGVydHMgPSBtb25pdG9yaW5nTWFuYWdlci5nZXRBY3RpdmVBbGVydHMoKTtcclxuICAgICAgZXhwZWN0KGFsZXJ0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgZXhwZWN0KGFsZXJ0c1swXS5yZXNvbHZlZEF0KS50b0JlVW5kZWZpbmVkKCk7XHJcblxyXG4gICAgICAvLyBSZXNvbHZlIHRoZSBhbGVydFxyXG4gICAgICBjb25zdCBzdWNjZXNzID0gbW9uaXRvcmluZ01hbmFnZXIucmVzb2x2ZUFsZXJ0KGFsZXJ0c1swXS5pZCk7XHJcbiAgICAgIGV4cGVjdChzdWNjZXNzKS50b0JlKHRydWUpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgYWxlcnQgd2FzIHJlc29sdmVkIChpdCBzaG91bGQgc3RpbGwgYmUgaW4gdGhlIGxpc3QgYnV0IHdpdGggcmVzb2x2ZWRBdCBzZXQpXHJcbiAgICAgIGNvbnN0IGFsbEFsZXJ0cyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldEFjdGl2ZUFsZXJ0cygpO1xyXG4gICAgICBjb25zdCByZXNvbHZlZEFsZXJ0ID0gYWxsQWxlcnRzLmZpbmQoYSA9PiBhLmlkID09PSBhbGVydHNbMF0uaWQpO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIGFsZXJ0IGlzIG5vdCBmb3VuZCBpbiBhY3RpdmUgYWxlcnRzLCBpdCBtZWFucyBpdCB3YXMgcHJvcGVybHkgcmVzb2x2ZWRcclxuICAgICAgaWYgKCFyZXNvbHZlZEFsZXJ0KSB7XHJcbiAgICAgICAgZXhwZWN0KHN1Y2Nlc3MpLnRvQmUodHJ1ZSk7IC8vIEFscmVhZHkgdmVyaWZpZWQgYWJvdmVcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBleHBlY3QocmVzb2x2ZWRBbGVydC5yZXNvbHZlZEF0KS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJlc3BlY3QgYWxlcnQgY29vbGRvd24nLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbnNvbGVTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgICAvLyBUcmlnZ2VyIGFsZXJ0IHR3aWNlIHF1aWNrbHlcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIucmVjb3JkTWV0cmljKCdsb2FkX3RpbWUnLCA1MDAwKTtcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIucmVjb3JkTWV0cmljKCdsb2FkX3RpbWUnLCA1MDAwKTtcclxuXHJcbiAgICAgIC8vIFNob3VsZCBvbmx5IHRyaWdnZXIgb25jZSBkdWUgdG8gY29vbGRvd25cclxuICAgICAgZXhwZWN0KGNvbnNvbGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcclxuXHJcbiAgICAgIGNvbnN0IGFjdGl2ZUFsZXJ0cyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldEFjdGl2ZUFsZXJ0cygpO1xyXG4gICAgICBleHBlY3QoYWN0aXZlQWxlcnRzKS50b0hhdmVMZW5ndGgoMSk7XHJcblxyXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHRyaWdnZXIgY3JpdGljYWwgZXJyb3IgYWxlcnQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGluaXRpYWxBbGVydENvdW50ID0gbW9uaXRvcmluZ01hbmFnZXIuZ2V0QWN0aXZlQWxlcnRzKCkubGVuZ3RoO1xyXG5cclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIuY2FwdHVyZUVycm9yKCdDcml0aWNhbCBzeXN0ZW0gZmFpbHVyZScsICdjcml0aWNhbCcpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgbmV3IGFsZXJ0cyB3ZXJlIGNyZWF0ZWRcclxuICAgICAgY29uc3QgZmluYWxBbGVydENvdW50ID0gbW9uaXRvcmluZ01hbmFnZXIuZ2V0QWN0aXZlQWxlcnRzKCkubGVuZ3RoO1xyXG4gICAgICBleHBlY3QoZmluYWxBbGVydENvdW50KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKGluaXRpYWxBbGVydENvdW50KTtcclxuXHJcbiAgICAgIC8vIFZlcmlmeSB0aGUgZXJyb3Igd2FzIGNhcHR1cmVkXHJcbiAgICAgIGNvbnN0IGVycm9ycyA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldEVycm9ycyh7IGxldmVsOiAnY3JpdGljYWwnIH0pO1xyXG4gICAgICBleHBlY3QoZXJyb3JzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICBleHBlY3QoZXJyb3JzWzBdLm1lc3NhZ2UpLnRvQmUoJ0NyaXRpY2FsIHN5c3RlbSBmYWlsdXJlJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ01vbml0b3JpbmcgU3VtbWFyeScsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgbW9uaXRvcmluZyBzdW1tYXJ5JywgKCkgPT4ge1xyXG4gICAgICAvLyBBZGQgc29tZSB0ZXN0IGRhdGFcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIuY2FwdHVyZUVycm9yKCdUZXN0IGVycm9yJywgJ2Vycm9yJyk7XHJcbiAgICAgIG1vbml0b3JpbmdNYW5hZ2VyLmNhcHR1cmVFcnJvcignQ3JpdGljYWwgZXJyb3InLCAnY3JpdGljYWwnKTtcclxuICAgICAgbW9uaXRvcmluZ01hbmFnZXIuY2FwdHVyZVBlcmZvcm1hbmNlTWV0cmljcygpO1xyXG4gICAgICBtb25pdG9yaW5nTWFuYWdlci5yZWNvcmRNZXRyaWMoJ2xvYWRfdGltZScsIDUwMDApOyAvLyBUcmlnZ2VycyBhbGVydFxyXG5cclxuICAgICAgY29uc3Qgc3VtbWFyeSA9IG1vbml0b3JpbmdNYW5hZ2VyLmdldE1vbml0b3JpbmdTdW1tYXJ5KCk7XHJcblxyXG4gICAgICBleHBlY3Qoc3VtbWFyeS5lcnJvcnMudG90YWwpLnRvQmUoMik7XHJcbiAgICAgIGV4cGVjdChzdW1tYXJ5LmVycm9ycy5jcml0aWNhbCkudG9CZSgxKTtcclxuICAgICAgZXhwZWN0KHN1bW1hcnkucGVyZm9ybWFuY2UuYXZlcmFnZUxvYWRUaW1lKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xyXG4gICAgICBleHBlY3Qoc3VtbWFyeS5hbGVydHMuYWN0aXZlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xyXG4gICAgICBleHBlY3Qoc3VtbWFyeS5zeXN0ZW0udXB0aW1lKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgIGV4cGVjdChzdW1tYXJ5LnN5c3RlbS5zZXNzaW9uSWQpLnRvTWF0Y2goL15zZXNzaW9uXy8pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgZGF0YSBpbiBzdW1tYXJ5JywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdW1tYXJ5ID0gbW9uaXRvcmluZ01hbmFnZXIuZ2V0TW9uaXRvcmluZ1N1bW1hcnkoKTtcclxuXHJcbiAgICAgIGV4cGVjdChzdW1tYXJ5LmVycm9ycy50b3RhbCkudG9CZSgwKTtcclxuICAgICAgZXhwZWN0KHN1bW1hcnkucGVyZm9ybWFuY2UuYXZlcmFnZUxvYWRUaW1lKS50b0JlKDApO1xyXG4gICAgICBleHBlY3Qoc3VtbWFyeS5hbGVydHMuYWN0aXZlKS50b0JlKDApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdDb25maWd1cmF0aW9uJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBkaXNhYmxlIGVycm9yIHRyYWNraW5nIHdoZW4gY29uZmlndXJlZCcsICgpID0+IHtcclxuICAgICAgY29uc3QgZGlzYWJsZWRDb25maWcgPSB7IC4uLmNvbmZpZyB9O1xyXG4gICAgICBkaXNhYmxlZENvbmZpZy5lcnJvclRyYWNraW5nLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIFJlc2V0IHNpbmdsZXRvblxyXG4gICAgICAoRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyIGFzIGFueSkuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGNvbnN0IGRpc2FibGVkTWFuYWdlciA9IEVudGVycHJpc2VNb25pdG9yaW5nTWFuYWdlci5nZXRJbnN0YW5jZShkaXNhYmxlZENvbmZpZyk7XHJcblxyXG4gICAgICBjb25zdCBlcnJvcklkID0gZGlzYWJsZWRNYW5hZ2VyLmNhcHR1cmVFcnJvcignVGVzdCBlcnJvcicsICdlcnJvcicpO1xyXG4gICAgICBleHBlY3QoZXJyb3JJZCkudG9CZSgnJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGRpc2FibGUgcGVyZm9ybWFuY2UgbW9uaXRvcmluZyB3aGVuIGNvbmZpZ3VyZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRpc2FibGVkQ29uZmlnID0geyAuLi5jb25maWcgfTtcclxuICAgICAgZGlzYWJsZWRDb25maWcucGVyZm9ybWFuY2UuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgLy8gUmVzZXQgc2luZ2xldG9uXHJcbiAgICAgIChFbnRlcnByaXNlTW9uaXRvcmluZ01hbmFnZXIgYXMgYW55KS5pbnN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICAgICAgY29uc3QgZGlzYWJsZWRNYW5hZ2VyID0gRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyLmdldEluc3RhbmNlKGRpc2FibGVkQ29uZmlnKTtcclxuXHJcbiAgICAgIGRpc2FibGVkTWFuYWdlci5jYXB0dXJlUGVyZm9ybWFuY2VNZXRyaWNzKCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBtZXRyaWNzID0gZGlzYWJsZWRNYW5hZ2VyLmdldFBlcmZvcm1hbmNlTWV0cmljcygpO1xyXG4gICAgICBleHBlY3QobWV0cmljcykudG9IYXZlTGVuZ3RoKDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBkaXNhYmxlIGFsZXJ0cyB3aGVuIGNvbmZpZ3VyZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRpc2FibGVkQ29uZmlnID0geyAuLi5jb25maWcgfTtcclxuICAgICAgZGlzYWJsZWRDb25maWcuYWxlcnRzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIFJlc2V0IHNpbmdsZXRvblxyXG4gICAgICAoRW50ZXJwcmlzZU1vbml0b3JpbmdNYW5hZ2VyIGFzIGFueSkuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGNvbnN0IGRpc2FibGVkTWFuYWdlciA9IEVudGVycHJpc2VNb25pdG9yaW5nTWFuYWdlci5nZXRJbnN0YW5jZShkaXNhYmxlZENvbmZpZyk7XHJcblxyXG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XHJcblxyXG4gICAgICAvLyBUaGlzIHdvdWxkIG5vcm1hbGx5IHRyaWdnZXIgbm90aWZpY2F0aW9uc1xyXG4gICAgICBkaXNhYmxlZE1hbmFnZXIucmVjb3JkTWV0cmljKCdsb2FkX3RpbWUnLCA1MDAwKTtcclxuXHJcbiAgICAgIC8vIFNob3VsZCBub3Qgc2VuZCBub3RpZmljYXRpb25zXHJcbiAgICAgIGV4cGVjdChjb25zb2xlU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0VtYWlsIGFsZXJ0IHNlbnQnKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgYWxlcnQgb3BlcmF0aW9ucyBncmFjZWZ1bGx5JywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdWNjZXNzMSA9IG1vbml0b3JpbmdNYW5hZ2VyLmFja25vd2xlZGdlQWxlcnQoJ2ludmFsaWQtaWQnKTtcclxuICAgICAgZXhwZWN0KHN1Y2Nlc3MxKS50b0JlKGZhbHNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHN1Y2Nlc3MyID0gbW9uaXRvcmluZ01hbmFnZXIucmVzb2x2ZUFsZXJ0KCdpbnZhbGlkLWlkJyk7XHJcbiAgICAgIGV4cGVjdChzdWNjZXNzMikudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBicm93c2VyIEFQSSB1bmF2YWlsYWJpbGl0eScsICgpID0+IHtcclxuICAgICAgLy8gTW9jayBtaXNzaW5nIHBlcmZvcm1hbmNlLm1lbW9yeVxyXG4gICAgICBjb25zdCBvcmlnaW5hbE1lbW9yeSA9IChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeTtcclxuICAgICAgZGVsZXRlIChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeTtcclxuXHJcbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgZXJyb3JcclxuICAgICAgZXhwZWN0KCgpID0+IHtcclxuICAgICAgICBtb25pdG9yaW5nTWFuYWdlci5jYXB0dXJlUGVyZm9ybWFuY2VNZXRyaWNzKCk7XHJcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XHJcblxyXG4gICAgICAvLyBSZXN0b3JlXHJcbiAgICAgIChwZXJmb3JtYW5jZSBhcyBhbnkpLm1lbW9yeSA9IG9yaWdpbmFsTWVtb3J5O1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsibW9ja1BlcmZvcm1hbmNlTm93IiwiamVzdCIsImZuIiwiZ2xvYmFsIiwicGVyZm9ybWFuY2UiLCJub3ciLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiY2FsbGJhY2siLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsImRlc2NyaWJlIiwibW9uaXRvcmluZ01hbmFnZXIiLCJjb25maWciLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIkVudGVycHJpc2VNb25pdG9yaW5nTWFuYWdlciIsImluc3RhbmNlIiwidW5kZWZpbmVkIiwiZXJyb3JUcmFja2luZyIsImVuYWJsZWQiLCJzYW1wbGVSYXRlIiwiaWdub3JlRXJyb3JzIiwibWF4QnJlYWRjcnVtYnMiLCJ0aHJlc2hvbGRzIiwibGNwIiwiZmlkIiwiY2xzIiwibG9hZFRpbWUiLCJhbGVydHMiLCJjaGFubmVscyIsImVtYWlsIiwic2xhY2siLCJnZXRJbnN0YW5jZSIsImNhbGxDb3VudCIsIml0IiwiaW5zdGFuY2UxIiwiaW5zdGFuY2UyIiwiZXhwZWN0IiwidG9CZSIsInRvVGhyb3ciLCJzdW1tYXJ5IiwiZ2V0TW9uaXRvcmluZ1N1bW1hcnkiLCJ0b0JlRGVmaW5lZCIsInN5c3RlbSIsInNlc3Npb25JZCIsInRvTWF0Y2giLCJlcnJvcklkIiwiY2FwdHVyZUVycm9yIiwiRXJyb3IiLCJjb21wb25lbnQiLCJlcnJvcnMiLCJnZXRFcnJvcnMiLCJ0b0hhdmVMZW5ndGgiLCJtZXNzYWdlIiwibGV2ZWwiLCJjb250ZXh0IiwidGFncyIsInRvQ29udGFpbiIsInN0YWNrIiwidG9CZVVuZGVmaW5lZCIsImxvd1NhbXBsZUNvbmZpZyIsImxvd1NhbXBsZU1hbmFnZXIiLCJjb3VudCIsImNyaXRpY2FsRXJyb3JzIiwid2FybmluZ0Vycm9ycyIsIkRhdGUiLCJvbmVIb3VyQWdvIiwiZ2V0VGltZSIsInJlY2VudEVycm9ycyIsInRpbWVSYW5nZSIsInN0YXJ0IiwiZW5kIiwiZnV0dXJlRXJyb3JzIiwiaSIsImxpbWl0ZWRFcnJvcnMiLCJsaW1pdCIsImNhcHR1cmVQZXJmb3JtYW5jZU1ldHJpY3MiLCJtZXRyaWNzIiwiZ2V0UGVyZm9ybWFuY2VNZXRyaWNzIiwidG9IYXZlUHJvcGVydHkiLCJjb25zb2xlU3B5Iiwic3B5T24iLCJjb25zb2xlIiwicmVjb3JkTWV0cmljIiwidGVzdCIsIm5vdCIsIm1vY2tSZXN0b3JlIiwicmVjZW50TWV0cmljcyIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib2JqZWN0Q29udGFpbmluZyIsInNldmVyaXR5Iiwic3RyaW5nQ29udGFpbmluZyIsImFjdGl2ZUFsZXJ0cyIsImdldEFjdGl2ZUFsZXJ0cyIsImFja25vd2xlZGdlZCIsInN1Y2Nlc3MiLCJhY2tub3dsZWRnZUFsZXJ0IiwiaWQiLCJ1cGRhdGVkQWxlcnRzIiwibGVuZ3RoIiwidG9CZUdyZWF0ZXJUaGFuIiwicmVzb2x2ZWRBdCIsInJlc29sdmVBbGVydCIsImFsbEFsZXJ0cyIsInJlc29sdmVkQWxlcnQiLCJmaW5kIiwiYSIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsImluaXRpYWxBbGVydENvdW50IiwiZmluYWxBbGVydENvdW50IiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInRvdGFsIiwiY3JpdGljYWwiLCJhdmVyYWdlTG9hZFRpbWUiLCJhY3RpdmUiLCJ1cHRpbWUiLCJkaXNhYmxlZENvbmZpZyIsImRpc2FibGVkTWFuYWdlciIsInN1Y2Nlc3MxIiwic3VjY2VzczIiLCJvcmlnaW5hbE1lbW9yeSIsIm1lbW9yeSJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLHdDQUF3QztBQUN4QyxzQ0FBc0M7Ozs7O29GQUVFOzs7Ozs7QUFHeEMsdUJBQXVCO0FBQ3ZCLE1BQU1BLHFCQUFxQkMsS0FBS0MsRUFBRTtBQUNsQ0MsT0FBT0MsV0FBVyxDQUFDQyxHQUFHLEdBQUdMO0FBRXpCLDJCQUEyQjtBQUMzQkcsT0FBT0csbUJBQW1CLEdBQUdMLEtBQUtDLEVBQUUsR0FBR0ssa0JBQWtCLENBQUMsQ0FBQ0MsV0FBYyxDQUFBO1FBQ3ZFQyxTQUFTUixLQUFLQyxFQUFFO1FBQ2hCUSxZQUFZVCxLQUFLQyxFQUFFO0lBQ3JCLENBQUE7QUFFQVMsU0FBUywrQkFBK0I7SUFDdEMsSUFBSUM7SUFDSixJQUFJQztJQUVKQyxXQUFXO1FBQ1RiLEtBQUtjLGFBQWE7UUFFbEIsMkJBQTJCO1FBQzFCQyxvQ0FBMkIsQ0FBU0MsUUFBUSxHQUFHQztRQUVoREwsU0FBUztZQUNQTSxlQUFlO2dCQUNiQyxTQUFTO2dCQUNUQyxZQUFZO2dCQUNaQyxjQUFjO29CQUFDO2lCQUFjO2dCQUM3QkMsZ0JBQWdCO1lBQ2xCO1lBQ0FuQixhQUFhO2dCQUNYZ0IsU0FBUztnQkFDVEMsWUFBWTtnQkFDWkcsWUFBWTtvQkFDVkMsS0FBSztvQkFDTEMsS0FBSztvQkFDTEMsS0FBSztvQkFDTEMsVUFBVTtnQkFD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