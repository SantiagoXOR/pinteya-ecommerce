0ea496b3501ed587631658a071535931
/**
 * Test independiente para useProductList sin dependencias de configuración global
 * Ejecutar con: npx jest src/hooks/admin/__tests__/useProductList.standalone.test.ts --no-cache --no-coverage
 */ // Mock React hooks
"use strict";
jest.mock('react', ()=>({
        useState: mockUseState,
        useEffect: mockUseEffect
    }));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockUseState = jest.fn();
const mockUseEffect = jest.fn();
// Mock fetch
global.fetch = jest.fn();
describe('useProductList Hook - Standalone Tests', ()=>{
    let mockSetProducts;
    let mockSetIsLoading;
    let mockSetError;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock useState calls
        mockSetProducts = jest.fn();
        mockSetIsLoading = jest.fn();
        mockSetError = jest.fn();
        mockUseState.mockReturnValueOnce([
            [],
            mockSetProducts
        ]) // products state
        .mockReturnValueOnce([
            true,
            mockSetIsLoading
        ]) // isLoading state
        .mockReturnValueOnce([
            null,
            mockSetError
        ]); // error state
        // Mock useEffect to immediately call the effect
        mockUseEffect.mockImplementation((effect)=>{
            effect();
        });
    });
    afterEach(()=>{
        jest.restoreAllMocks();
    });
    it('should initialize with correct default state', async ()=>{
        // Mock successful API response
        ;
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: [],
                        total: 0
                    }
                })
        });
        // Import and execute the hook
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        const result = useProductList();
        // Verify initial state setup
        expect(mockUseState).toHaveBeenCalledTimes(3);
        expect(mockUseState).toHaveBeenNthCalledWith(1, []); // products
        expect(mockUseState).toHaveBeenNthCalledWith(2, true); // isLoading
        expect(mockUseState).toHaveBeenNthCalledWith(3, null); // error
        // Verify return value structure
        expect(result).toEqual({
            products: [],
            isLoading: true,
            error: null
        });
    });
    it('should call fetch with correct URL', async ()=>{
        ;
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: [],
                        total: 0
                    }
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        expect(global.fetch).toHaveBeenCalledWith('/api/admin/products-direct?limit=25');
    });
    it('should handle successful API response', async ()=>{
        const mockProducts = [
            {
                id: 1,
                name: 'Test Product',
                description: 'Test Description',
                price: 1000,
                stock: 50,
                category_id: 1,
                images: {
                    main: '/test.jpg',
                    gallery: [],
                    previews: [],
                    thumbnails: []
                },
                created_at: '2025-01-01T00:00:00Z',
                updated_at: '2025-01-01T00:00:00Z',
                category_name: 'Test Category'
            }
        ];
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: mockProducts,
                        total: 1
                    }
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetIsLoading).toHaveBeenCalledWith(true);
        expect(mockSetError).toHaveBeenCalledWith(null);
        expect(mockSetProducts).toHaveBeenCalledWith(mockProducts);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle API errors', async ()=>{
        ;
        global.fetch.mockResolvedValueOnce({
            ok: false,
            status: 500,
            statusText: 'Internal Server Error'
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Error 500: Internal Server Error');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle network errors', async ()=>{
        ;
        global.fetch.mockRejectedValueOnce(new Error('Network error'));
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Network error');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle invalid response structure', async ()=>{
        ;
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: false,
                    error: 'Invalid request'
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Estructura de respuesta inválida');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should export correct TypeScript types', async ()=>{
        const module = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        expect(typeof module.useProductList).toBe('function');
        expect(module.Product).toBeDefined;
        expect(module.ProductListResponse).toBeDefined;
    });
    it('should follow React Hooks best practices', async ()=>{
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        // Hook should be a function
        expect(typeof useProductList).toBe('function');
        // Hook name should start with 'use'
        expect(useProductList.name).toBe('useProductList');
        // Hook follows React best practices
        expect(useProductList.name).toMatch(/^use/);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcaG9va3NcXGFkbWluXFxfX3Rlc3RzX19cXHVzZVByb2R1Y3RMaXN0LnN0YW5kYWxvbmUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3QgaW5kZXBlbmRpZW50ZSBwYXJhIHVzZVByb2R1Y3RMaXN0IHNpbiBkZXBlbmRlbmNpYXMgZGUgY29uZmlndXJhY2nDs24gZ2xvYmFsXG4gKiBFamVjdXRhciBjb246IG5weCBqZXN0IHNyYy9ob29rcy9hZG1pbi9fX3Rlc3RzX18vdXNlUHJvZHVjdExpc3Quc3RhbmRhbG9uZS50ZXN0LnRzIC0tbm8tY2FjaGUgLS1uby1jb3ZlcmFnZVxuICovXG5cbi8vIE1vY2sgUmVhY3QgaG9va3NcbmNvbnN0IG1vY2tVc2VTdGF0ZSA9IGplc3QuZm4oKVxuY29uc3QgbW9ja1VzZUVmZmVjdCA9IGplc3QuZm4oKVxuXG5qZXN0Lm1vY2soJ3JlYWN0JywgKCkgPT4gKHtcbiAgdXNlU3RhdGU6IG1vY2tVc2VTdGF0ZSxcbiAgdXNlRWZmZWN0OiBtb2NrVXNlRWZmZWN0LFxufSkpXG5cbi8vIE1vY2sgZmV0Y2hcbmdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKVxuXG5kZXNjcmliZSgndXNlUHJvZHVjdExpc3QgSG9vayAtIFN0YW5kYWxvbmUgVGVzdHMnLCAoKSA9PiB7XG4gIGxldCBtb2NrU2V0UHJvZHVjdHM6IGplc3QuTW9ja1xuICBsZXQgbW9ja1NldElzTG9hZGluZzogamVzdC5Nb2NrXG4gIGxldCBtb2NrU2V0RXJyb3I6IGplc3QuTW9ja1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG5cbiAgICAvLyBNb2NrIHVzZVN0YXRlIGNhbGxzXG4gICAgbW9ja1NldFByb2R1Y3RzID0gamVzdC5mbigpXG4gICAgbW9ja1NldElzTG9hZGluZyA9IGplc3QuZm4oKVxuICAgIG1vY2tTZXRFcnJvciA9IGplc3QuZm4oKVxuXG4gICAgbW9ja1VzZVN0YXRlXG4gICAgICAubW9ja1JldHVyblZhbHVlT25jZShbW10sIG1vY2tTZXRQcm9kdWN0c10pIC8vIHByb2R1Y3RzIHN0YXRlXG4gICAgICAubW9ja1JldHVyblZhbHVlT25jZShbdHJ1ZSwgbW9ja1NldElzTG9hZGluZ10pIC8vIGlzTG9hZGluZyBzdGF0ZVxuICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoW251bGwsIG1vY2tTZXRFcnJvcl0pIC8vIGVycm9yIHN0YXRlXG5cbiAgICAvLyBNb2NrIHVzZUVmZmVjdCB0byBpbW1lZGlhdGVseSBjYWxsIHRoZSBlZmZlY3RcbiAgICBtb2NrVXNlRWZmZWN0Lm1vY2tJbXBsZW1lbnRhdGlvbihlZmZlY3QgPT4ge1xuICAgICAgZWZmZWN0KClcbiAgICB9KVxuICB9KVxuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIGNvcnJlY3QgZGVmYXVsdCBzdGF0ZScsIGFzeW5jICgpID0+IHtcbiAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgQVBJIHJlc3BvbnNlXG4gICAgOyhnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcHJvZHVjdHM6IFtdLFxuICAgICAgICAgIHRvdGFsOiAwLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgfSlcblxuICAgIC8vIEltcG9ydCBhbmQgZXhlY3V0ZSB0aGUgaG9va1xuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKVxuICAgIGNvbnN0IHJlc3VsdCA9IHVzZVByb2R1Y3RMaXN0KClcblxuICAgIC8vIFZlcmlmeSBpbml0aWFsIHN0YXRlIHNldHVwXG4gICAgZXhwZWN0KG1vY2tVc2VTdGF0ZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpXG4gICAgZXhwZWN0KG1vY2tVc2VTdGF0ZSkudG9IYXZlQmVlbk50aENhbGxlZFdpdGgoMSwgW10pIC8vIHByb2R1Y3RzXG4gICAgZXhwZWN0KG1vY2tVc2VTdGF0ZSkudG9IYXZlQmVlbk50aENhbGxlZFdpdGgoMiwgdHJ1ZSkgLy8gaXNMb2FkaW5nXG4gICAgZXhwZWN0KG1vY2tVc2VTdGF0ZSkudG9IYXZlQmVlbk50aENhbGxlZFdpdGgoMywgbnVsbCkgLy8gZXJyb3JcblxuICAgIC8vIFZlcmlmeSByZXR1cm4gdmFsdWUgc3RydWN0dXJlXG4gICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICBwcm9kdWN0czogW10sXG4gICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICB9KVxuICB9KVxuXG4gIGl0KCdzaG91bGQgY2FsbCBmZXRjaCB3aXRoIGNvcnJlY3QgVVJMJywgYXN5bmMgKCkgPT4ge1xuICAgIDsoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHByb2R1Y3RzOiBbXSxcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IHVzZVByb2R1Y3RMaXN0IH0gPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0JylcbiAgICB1c2VQcm9kdWN0TGlzdCgpXG5cbiAgICBleHBlY3QoZ2xvYmFsLmZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9hZG1pbi9wcm9kdWN0cy1kaXJlY3Q/bGltaXQ9MjUnKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgaGFuZGxlIHN1Y2Nlc3NmdWwgQVBJIHJlc3BvbnNlJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tQcm9kdWN0cyA9IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Rlc3QgRGVzY3JpcHRpb24nLFxuICAgICAgICBwcmljZTogMTAwMCxcbiAgICAgICAgc3RvY2s6IDUwLFxuICAgICAgICBjYXRlZ29yeV9pZDogMSxcbiAgICAgICAgaW1hZ2VzOiB7IG1haW46ICcvdGVzdC5qcGcnLCBnYWxsZXJ5OiBbXSwgcHJldmlld3M6IFtdLCB0aHVtYm5haWxzOiBbXSB9LFxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICB1cGRhdGVkX2F0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICBjYXRlZ29yeV9uYW1lOiAnVGVzdCBDYXRlZ29yeScsXG4gICAgICB9LFxuICAgIF1cblxuICAgIDsoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHByb2R1Y3RzOiBtb2NrUHJvZHVjdHMsXG4gICAgICAgICAgdG90YWw6IDEsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICB9KVxuXG4gICAgY29uc3QgeyB1c2VQcm9kdWN0TGlzdCB9ID0gYXdhaXQgaW1wb3J0KCcuLi91c2VQcm9kdWN0TGlzdCcpXG4gICAgdXNlUHJvZHVjdExpc3QoKVxuXG4gICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSlcblxuICAgIGV4cGVjdChtb2NrU2V0SXNMb2FkaW5nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh0cnVlKVxuICAgIGV4cGVjdChtb2NrU2V0RXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG51bGwpXG4gICAgZXhwZWN0KG1vY2tTZXRQcm9kdWN0cykudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1Byb2R1Y3RzKVxuICAgIGV4cGVjdChtb2NrU2V0SXNMb2FkaW5nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmYWxzZSlcbiAgfSlcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBBUEkgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgIDsoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiBmYWxzZSxcbiAgICAgIHN0YXR1czogNTAwLFxuICAgICAgc3RhdHVzVGV4dDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgfSlcblxuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKVxuICAgIHVzZVByb2R1Y3RMaXN0KClcblxuICAgIC8vIFdhaXQgZm9yIGFzeW5jIG9wZXJhdGlvbnNcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpXG5cbiAgICBleHBlY3QobW9ja1NldEVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgNTAwOiBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InKVxuICAgIGV4cGVjdChtb2NrU2V0UHJvZHVjdHMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFtdKVxuICAgIGV4cGVjdChtb2NrU2V0SXNMb2FkaW5nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmYWxzZSlcbiAgfSlcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBuZXR3b3JrIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICA7KGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKSlcblxuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKVxuICAgIHVzZVByb2R1Y3RMaXN0KClcblxuICAgIC8vIFdhaXQgZm9yIGFzeW5jIG9wZXJhdGlvbnNcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpXG5cbiAgICBleHBlY3QobW9ja1NldEVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnTmV0d29yayBlcnJvcicpXG4gICAgZXhwZWN0KG1vY2tTZXRQcm9kdWN0cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoW10pXG4gICAgZXhwZWN0KG1vY2tTZXRJc0xvYWRpbmcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGZhbHNlKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgcmVzcG9uc2Ugc3RydWN0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgIDsoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnSW52YWxpZCByZXF1ZXN0JyxcbiAgICAgIH0pLFxuICAgIH0pXG5cbiAgICBjb25zdCB7IHVzZVByb2R1Y3RMaXN0IH0gPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0JylcbiAgICB1c2VQcm9kdWN0TGlzdCgpXG5cbiAgICAvLyBXYWl0IGZvciBhc3luYyBvcGVyYXRpb25zXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKVxuXG4gICAgZXhwZWN0KG1vY2tTZXRFcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0VzdHJ1Y3R1cmEgZGUgcmVzcHVlc3RhIGludsOhbGlkYScpXG4gICAgZXhwZWN0KG1vY2tTZXRQcm9kdWN0cykudG9IYXZlQmVlbkNhbGxlZFdpdGgoW10pXG4gICAgZXhwZWN0KG1vY2tTZXRJc0xvYWRpbmcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGZhbHNlKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgZXhwb3J0IGNvcnJlY3QgVHlwZVNjcmlwdCB0eXBlcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0JylcblxuICAgIGV4cGVjdCh0eXBlb2YgbW9kdWxlLnVzZVByb2R1Y3RMaXN0KS50b0JlKCdmdW5jdGlvbicpXG4gICAgZXhwZWN0KG1vZHVsZS5Qcm9kdWN0KS50b0JlRGVmaW5lZFxuICAgIGV4cGVjdChtb2R1bGUuUHJvZHVjdExpc3RSZXNwb25zZSkudG9CZURlZmluZWRcbiAgfSlcblxuICBpdCgnc2hvdWxkIGZvbGxvdyBSZWFjdCBIb29rcyBiZXN0IHByYWN0aWNlcycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHVzZVByb2R1Y3RMaXN0IH0gPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0JylcblxuICAgIC8vIEhvb2sgc2hvdWxkIGJlIGEgZnVuY3Rpb25cbiAgICBleHBlY3QodHlwZW9mIHVzZVByb2R1Y3RMaXN0KS50b0JlKCdmdW5jdGlvbicpXG5cbiAgICAvLyBIb29rIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggJ3VzZSdcbiAgICBleHBlY3QodXNlUHJvZHVjdExpc3QubmFtZSkudG9CZSgndXNlUHJvZHVjdExpc3QnKVxuXG4gICAgLy8gSG9vayBmb2xsb3dzIFJlYWN0IGJlc3QgcHJhY3RpY2VzXG4gICAgZXhwZWN0KHVzZVByb2R1Y3RMaXN0Lm5hbWUpLnRvTWF0Y2goL151c2UvKVxuICB9KVxufSlcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInVzZVN0YXRlIiwibW9ja1VzZVN0YXRlIiwidXNlRWZmZWN0IiwibW9ja1VzZUVmZmVjdCIsImZuIiwiZ2xvYmFsIiwiZmV0Y2giLCJkZXNjcmliZSIsIm1vY2tTZXRQcm9kdWN0cyIsIm1vY2tTZXRJc0xvYWRpbmciLCJtb2NrU2V0RXJyb3IiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJlZmZlY3QiLCJhZnRlckVhY2giLCJyZXN0b3JlQWxsTW9ja3MiLCJpdCIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsIm9rIiwianNvbiIsInN1Y2Nlc3MiLCJkYXRhIiwicHJvZHVjdHMiLCJ0b3RhbCIsInVzZVByb2R1Y3RMaXN0IiwicmVzdWx0IiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwidG9IYXZlQmVlbk50aENhbGxlZFdpdGgiLCJ0b0VxdWFsIiwiaXNMb2FkaW5nIiwiZXJyb3IiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm1vY2tQcm9kdWN0cyIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwicHJpY2UiLCJzdG9jayIsImNhdGVnb3J5X2lkIiwiaW1hZ2VzIiwibWFpbiIsImdhbGxlcnkiLCJwcmV2aWV3cyIsInRodW1ibmFpbHMiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsImNhdGVnb3J5X25hbWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwiRXJyb3IiLCJtb2R1bGUiLCJ0b0JlIiwiUHJvZHVjdCIsInRvQmVEZWZpbmVkIiwiUHJvZHVjdExpc3RSZXNwb25zZSIsInRvTWF0Y2giXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQyxHQUVELG1CQUFtQjs7QUFJbkJBLEtBQUtDLElBQUksQ0FBQyxTQUFTLElBQU8s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