45572e766bda7ff7a55d445c7dc525ac
// ===================================
// PINTEYA E-COMMERCE - CACHE MANAGER TESTS
// ===================================
"use strict";
// Mock Redis
jest.mock('@/lib/redis', ()=>({
        redisCache: {
            get: jest.fn(),
            set: jest.fn(),
            del: jest.fn()
        }
    }));
// Mock logger
jest.mock('@/lib/enterprise/logger', ()=>({
        logger: {
            debug: jest.fn(),
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            DEBUG: 'debug',
            INFO: 'info',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            CACHE: 'cache',
            SYSTEM: 'system'
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _cachemanager = require("../../lib/cache-manager");
describe('CacheManager', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Singleton Pattern', ()=>{
        it('should return the same instance', ()=>{
            const instance1 = _cachemanager.CacheManager.getInstance();
            const instance2 = _cachemanager.CacheManager.getInstance();
            expect(instance1).toBe(instance2);
            expect(instance1).toBe(_cachemanager.cacheManager);
        });
    });
    describe('get', ()=>{
        it('should return cached value when available', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const testData = {
                id: 1,
                name: 'Test'
            };
            redisCache.get.mockResolvedValue(JSON.stringify(testData));
            const result = await _cachemanager.cacheManager.get('test-key', _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toEqual(testData);
            expect(redisCache.get).toHaveBeenCalledWith('cache:product:test-key');
        });
        it('should return null when cache miss', async ()=>{
            const { redisCache } = require('@/lib/redis');
            redisCache.get.mockResolvedValue(null);
            const result = await _cachemanager.cacheManager.get('missing-key', _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toBeNull();
        });
        it('should handle errors gracefully', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const { logger } = require('@/lib/enterprise/logger');
            redisCache.get.mockRejectedValue(new Error('Redis error'));
            const result = await _cachemanager.cacheManager.get('error-key', _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toBeNull();
            expect(logger.error).toHaveBeenCalled();
        });
    });
    describe('set', ()=>{
        it('should store value in cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const testData = {
                id: 1,
                name: 'Test'
            };
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.cacheManager.set('test-key', testData, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toBe(true);
            expect(redisCache.set).toHaveBeenCalledWith('cache:product:test-key', JSON.stringify(testData), _cachemanager.CACHE_CONFIGS.PRODUCT_DATA.ttl);
        });
        it('should handle serialization errors', async ()=>{
            const { logger } = require('@/lib/enterprise/logger');
            // Crear objeto circular que no se puede serializar
            const circularObj = {
                name: 'test'
            };
            circularObj.self = circularObj;
            await expect(_cachemanager.cacheManager.set('circular-key', circularObj, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA)).resolves.toBe(false);
            expect(logger.error).toHaveBeenCalled();
        });
    });
    describe('delete', ()=>{
        it('should delete value from cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            redisCache.del.mockResolvedValue(true);
            const result = await _cachemanager.cacheManager.delete('test-key', _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toBe(true);
            expect(redisCache.del).toHaveBeenCalledWith('cache:product:test-key');
        });
    });
    describe('getOrSet', ()=>{
        it('should return cached value if available', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const cachedData = {
                id: 1,
                name: 'Cached'
            };
            const fetcherFn = jest.fn().mockResolvedValue({
                id: 1,
                name: 'Fresh'
            });
            redisCache.get.mockResolvedValue(JSON.stringify(cachedData));
            const result = await _cachemanager.cacheManager.getOrSet('test-key', fetcherFn, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toEqual(cachedData);
            expect(fetcherFn).not.toHaveBeenCalled();
        });
        it('should fetch and cache value if not in cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const freshData = {
                id: 1,
                name: 'Fresh'
            };
            const fetcherFn = jest.fn().mockResolvedValue(freshData);
            redisCache.get.mockResolvedValue(null);
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.cacheManager.getOrSet('test-key', fetcherFn, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toEqual(freshData);
            expect(fetcherFn).toHaveBeenCalled();
        });
        it('should propagate fetcher errors', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const fetcherError = new Error('Fetcher failed');
            const fetcherFn = jest.fn().mockRejectedValue(fetcherError);
            redisCache.get.mockResolvedValue(null);
            await expect(_cachemanager.cacheManager.getOrSet('test-key', fetcherFn, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA)).rejects.toThrow('Fetcher failed');
        });
    });
    describe('Cache Configurations', ()=>{
        it('should have MercadoPago response config', ()=>{
            const config = _cachemanager.CACHE_CONFIGS.MERCADOPAGO_RESPONSE;
            expect(config.ttl).toBe(300);
            expect(config.prefix).toBe('mp_response');
            expect(config.compress).toBe(true);
            expect(config.serialize).toBe(true);
        });
        it('should have payment info config', ()=>{
            const config = _cachemanager.CACHE_CONFIGS.PAYMENT_INFO;
            expect(config.ttl).toBe(1800);
            expect(config.prefix).toBe('payment_info');
            expect(config.serialize).toBe(true);
        });
        it('should have product data config', ()=>{
            const config = _cachemanager.CACHE_CONFIGS.PRODUCT_DATA;
            expect(config.ttl).toBe(900);
            expect(config.prefix).toBe('product');
            expect(config.compress).toBe(true);
            expect(config.serialize).toBe(true);
        });
    });
    describe('Compression', ()=>{
        it('should compress large data when enabled', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const largeData = 'x'.repeat(2000) // String > 1000 chars
            ;
            redisCache.set.mockResolvedValue(true);
            await _cachemanager.cacheManager.set('large-key', largeData, {
                ..._cachemanager.CACHE_CONFIGS.PRODUCT_DATA,
                compress: true
            });
            const setCall = redisCache.set.mock.calls[0];
            expect(setCall[1]).toContain('COMPRESSED:');
        });
        it('should decompress data when retrieving', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const originalData = 'test data';
            const compressedData = `COMPRESSED:"${originalData}"`;
            redisCache.get.mockResolvedValue(compressedData);
            const result = await _cachemanager.cacheManager.get('compressed-key', {
                ..._cachemanager.CACHE_CONFIGS.PRODUCT_DATA,
                compress: true
            });
            expect(result).toBe(originalData);
        });
    });
});
describe('CacheUtils', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('cacheMercadoPagoResponse', ()=>{
        it('should cache MercadoPago response', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const responseData = {
                id: 'mp123',
                status: 'approved'
            };
            const fetcherFn = jest.fn().mockResolvedValue(responseData);
            redisCache.get.mockResolvedValue(null);
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.cacheMercadoPagoResponse('test-key', fetcherFn);
            expect(result).toEqual(responseData);
            expect(fetcherFn).toHaveBeenCalled();
        });
    });
    describe('cachePaymentInfo', ()=>{
        it('should cache payment info with payment ID', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const paymentData = {
                id: '123',
                amount: 100
            };
            const fetcherFn = jest.fn().mockResolvedValue(paymentData);
            redisCache.get.mockResolvedValue(null);
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.cachePaymentInfo('123', fetcherFn);
            expect(result).toEqual(paymentData);
            expect(redisCache.get).toHaveBeenCalledWith('cache:payment_info:payment:123');
        });
    });
    describe('cacheProductData', ()=>{
        it('should cache product data with product ID', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const productData = {
                id: '456',
                name: 'Test Product'
            };
            const fetcherFn = jest.fn().mockResolvedValue(productData);
            redisCache.get.mockResolvedValue(null);
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.cacheProductData('456', fetcherFn);
            expect(result).toEqual(productData);
            expect(redisCache.get).toHaveBeenCalledWith('cache:product:product:456');
        });
    });
    describe('invalidatePayment', ()=>{
        it('should invalidate payment cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            redisCache.del.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.invalidatePayment('123');
            expect(result).toBe(true);
            expect(redisCache.del).toHaveBeenCalledWith('cache:payment_info:payment:123');
        });
    });
    describe('invalidateProduct', ()=>{
        it('should invalidate product cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            redisCache.del.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.invalidateProduct('456');
            expect(result).toBe(true);
            expect(redisCache.del).toHaveBeenCalledWith('cache:product:product:456');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxsaWJcXGNhY2hlLW1hbmFnZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUElOVEVZQSBFLUNPTU1FUkNFIC0gQ0FDSEUgTUFOQUdFUiBURVNUU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuaW1wb3J0IHsgQ2FjaGVNYW5hZ2VyLCBjYWNoZU1hbmFnZXIsIENBQ0hFX0NPTkZJR1MsIENhY2hlVXRpbHMgfSBmcm9tICdAL2xpYi9jYWNoZS1tYW5hZ2VyJ1xuXG4vLyBNb2NrIFJlZGlzXG5qZXN0Lm1vY2soJ0AvbGliL3JlZGlzJywgKCkgPT4gKHtcbiAgcmVkaXNDYWNoZToge1xuICAgIGdldDogamVzdC5mbigpLFxuICAgIHNldDogamVzdC5mbigpLFxuICAgIGRlbDogamVzdC5mbigpLFxuICB9LFxufSkpXG5cbi8vIE1vY2sgbG9nZ2VyXG5qZXN0Lm1vY2soJ0AvbGliL2VudGVycHJpc2UvbG9nZ2VyJywgKCkgPT4gKHtcbiAgbG9nZ2VyOiB7XG4gICAgZGVidWc6IGplc3QuZm4oKSxcbiAgICBpbmZvOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gIH0sXG4gIExvZ0xldmVsOiB7XG4gICAgREVCVUc6ICdkZWJ1ZycsXG4gICAgSU5GTzogJ2luZm8nLFxuICAgIFdBUk46ICd3YXJuJyxcbiAgICBFUlJPUjogJ2Vycm9yJyxcbiAgfSxcbiAgTG9nQ2F0ZWdvcnk6IHtcbiAgICBDQUNIRTogJ2NhY2hlJyxcbiAgICBTWVNURU06ICdzeXN0ZW0nLFxuICB9LFxufSkpXG5cbmRlc2NyaWJlKCdDYWNoZU1hbmFnZXInLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1NpbmdsZXRvbiBQYXR0ZXJuJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UxID0gQ2FjaGVNYW5hZ2VyLmdldEluc3RhbmNlKClcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IENhY2hlTWFuYWdlci5nZXRJbnN0YW5jZSgpXG5cbiAgICAgIGV4cGVjdChpbnN0YW5jZTEpLnRvQmUoaW5zdGFuY2UyKVxuICAgICAgZXhwZWN0KGluc3RhbmNlMSkudG9CZShjYWNoZU1hbmFnZXIpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnZ2V0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGNhY2hlZCB2YWx1ZSB3aGVuIGF2YWlsYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKVxuICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnVGVzdCcgfVxuXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShKU09OLnN0cmluZ2lmeSh0ZXN0RGF0YSkpXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlTWFuYWdlci5nZXQoJ3Rlc3Qta2V5JywgQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEEpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwodGVzdERhdGEpXG4gICAgICBleHBlY3QocmVkaXNDYWNoZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdjYWNoZTpwcm9kdWN0OnRlc3Qta2V5JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCB3aGVuIGNhY2hlIG1pc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcblxuICAgICAgcmVkaXNDYWNoZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbClcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVNYW5hZ2VyLmdldCgnbWlzc2luZy1rZXknLCBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSlcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKVxuICAgICAgY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJ0AvbGliL2VudGVycHJpc2UvbG9nZ2VyJylcblxuICAgICAgcmVkaXNDYWNoZS5nZXQubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdSZWRpcyBlcnJvcicpKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZU1hbmFnZXIuZ2V0KCdlcnJvci1rZXknLCBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSlcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKVxuICAgICAgZXhwZWN0KGxvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnc2V0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc3RvcmUgdmFsdWUgaW4gY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ1Rlc3QnIH1cblxuICAgICAgcmVkaXNDYWNoZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVNYW5hZ2VyLnNldCgndGVzdC1rZXknLCB0ZXN0RGF0YSwgQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEEpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdjYWNoZTpwcm9kdWN0OnRlc3Qta2V5JyxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodGVzdERhdGEpLFxuICAgICAgICBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQS50dGxcbiAgICAgIClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VyaWFsaXphdGlvbiBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnQC9saWIvZW50ZXJwcmlzZS9sb2dnZXInKVxuXG4gICAgICAvLyBDcmVhciBvYmpldG8gY2lyY3VsYXIgcXVlIG5vIHNlIHB1ZWRlIHNlcmlhbGl6YXJcbiAgICAgIGNvbnN0IGNpcmN1bGFyT2JqOiBhbnkgPSB7IG5hbWU6ICd0ZXN0JyB9XG4gICAgICBjaXJjdWxhck9iai5zZWxmID0gY2lyY3VsYXJPYmpcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBjYWNoZU1hbmFnZXIuc2V0KCdjaXJjdWxhci1rZXknLCBjaXJjdWxhck9iaiwgQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEEpXG4gICAgICApLnJlc29sdmVzLnRvQmUoZmFsc2UpXG5cbiAgICAgIGV4cGVjdChsb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ2RlbGV0ZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGRlbGV0ZSB2YWx1ZSBmcm9tIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpXG5cbiAgICAgIHJlZGlzQ2FjaGUuZGVsLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlTWFuYWdlci5kZWxldGUoJ3Rlc3Qta2V5JywgQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEEpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLmRlbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2NhY2hlOnByb2R1Y3Q6dGVzdC1rZXknKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ2dldE9yU2V0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGNhY2hlZCB2YWx1ZSBpZiBhdmFpbGFibGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcbiAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnQ2FjaGVkJyB9XG4gICAgICBjb25zdCBmZXRjaGVyRm4gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpZDogMSwgbmFtZTogJ0ZyZXNoJyB9KVxuXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShKU09OLnN0cmluZ2lmeShjYWNoZWREYXRhKSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVNYW5hZ2VyLmdldE9yU2V0KCd0ZXN0LWtleScsIGZldGNoZXJGbiwgQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEEpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY2FjaGVkRGF0YSlcbiAgICAgIGV4cGVjdChmZXRjaGVyRm4pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBmZXRjaCBhbmQgY2FjaGUgdmFsdWUgaWYgbm90IGluIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpXG4gICAgICBjb25zdCBmcmVzaERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnRnJlc2gnIH1cbiAgICAgIGNvbnN0IGZldGNoZXJGbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShmcmVzaERhdGEpXG5cbiAgICAgIHJlZGlzQ2FjaGUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpXG4gICAgICByZWRpc0NhY2hlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZU1hbmFnZXIuZ2V0T3JTZXQoJ3Rlc3Qta2V5JywgZmV0Y2hlckZuLCBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSlcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChmcmVzaERhdGEpXG4gICAgICBleHBlY3QoZmV0Y2hlckZuKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBwcm9wYWdhdGUgZmV0Y2hlciBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcbiAgICAgIGNvbnN0IGZldGNoZXJFcnJvciA9IG5ldyBFcnJvcignRmV0Y2hlciBmYWlsZWQnKVxuICAgICAgY29uc3QgZmV0Y2hlckZuID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKGZldGNoZXJFcnJvcilcblxuICAgICAgcmVkaXNDYWNoZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbClcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBjYWNoZU1hbmFnZXIuZ2V0T3JTZXQoJ3Rlc3Qta2V5JywgZmV0Y2hlckZuLCBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdGZXRjaGVyIGZhaWxlZCcpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnQ2FjaGUgQ29uZmlndXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYXZlIE1lcmNhZG9QYWdvIHJlc3BvbnNlIGNvbmZpZycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IENBQ0hFX0NPTkZJR1MuTUVSQ0FET1BBR09fUkVTUE9OU0VcblxuICAgICAgZXhwZWN0KGNvbmZpZy50dGwpLnRvQmUoMzAwKVxuICAgICAgZXhwZWN0KGNvbmZpZy5wcmVmaXgpLnRvQmUoJ21wX3Jlc3BvbnNlJylcbiAgICAgIGV4cGVjdChjb25maWcuY29tcHJlc3MpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChjb25maWcuc2VyaWFsaXplKS50b0JlKHRydWUpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGF2ZSBwYXltZW50IGluZm8gY29uZmlnJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0gQ0FDSEVfQ09ORklHUy5QQVlNRU5UX0lORk9cblxuICAgICAgZXhwZWN0KGNvbmZpZy50dGwpLnRvQmUoMTgwMClcbiAgICAgIGV4cGVjdChjb25maWcucHJlZml4KS50b0JlKCdwYXltZW50X2luZm8nKVxuICAgICAgZXhwZWN0KGNvbmZpZy5zZXJpYWxpemUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYXZlIHByb2R1Y3QgZGF0YSBjb25maWcnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQVxuXG4gICAgICBleHBlY3QoY29uZmlnLnR0bCkudG9CZSg5MDApXG4gICAgICBleHBlY3QoY29uZmlnLnByZWZpeCkudG9CZSgncHJvZHVjdCcpXG4gICAgICBleHBlY3QoY29uZmlnLmNvbXByZXNzKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QoY29uZmlnLnNlcmlhbGl6ZSkudG9CZSh0cnVlKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0NvbXByZXNzaW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY29tcHJlc3MgbGFyZ2UgZGF0YSB3aGVuIGVuYWJsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcbiAgICAgIGNvbnN0IGxhcmdlRGF0YSA9ICd4Jy5yZXBlYXQoMjAwMCkgLy8gU3RyaW5nID4gMTAwMCBjaGFyc1xuXG4gICAgICByZWRpc0NhY2hlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKVxuXG4gICAgICBhd2FpdCBjYWNoZU1hbmFnZXIuc2V0KCdsYXJnZS1rZXknLCBsYXJnZURhdGEsIHtcbiAgICAgICAgLi4uQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEEsXG4gICAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgfSlcblxuICAgICAgY29uc3Qgc2V0Q2FsbCA9IHJlZGlzQ2FjaGUuc2V0Lm1vY2suY2FsbHNbMF1cbiAgICAgIGV4cGVjdChzZXRDYWxsWzFdKS50b0NvbnRhaW4oJ0NPTVBSRVNTRUQ6JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBkZWNvbXByZXNzIGRhdGEgd2hlbiByZXRyaWV2aW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpXG4gICAgICBjb25zdCBvcmlnaW5hbERhdGEgPSAndGVzdCBkYXRhJ1xuICAgICAgY29uc3QgY29tcHJlc3NlZERhdGEgPSBgQ09NUFJFU1NFRDpcIiR7b3JpZ2luYWxEYXRhfVwiYFxuXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShjb21wcmVzc2VkRGF0YSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVNYW5hZ2VyLmdldCgnY29tcHJlc3NlZC1rZXknLCB7XG4gICAgICAgIC4uLkNBQ0hFX0NPTkZJR1MuUFJPRFVDVF9EQVRBLFxuICAgICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUob3JpZ2luYWxEYXRhKVxuICAgIH0pXG4gIH0pXG59KVxuXG5kZXNjcmliZSgnQ2FjaGVVdGlscycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgfSlcblxuICBkZXNjcmliZSgnY2FjaGVNZXJjYWRvUGFnb1Jlc3BvbnNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY2FjaGUgTWVyY2Fkb1BhZ28gcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHsgaWQ6ICdtcDEyMycsIHN0YXR1czogJ2FwcHJvdmVkJyB9XG4gICAgICBjb25zdCBmZXRjaGVyRm4gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUocmVzcG9uc2VEYXRhKVxuXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKVxuICAgICAgcmVkaXNDYWNoZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQ2FjaGVVdGlscy5jYWNoZU1lcmNhZG9QYWdvUmVzcG9uc2UoJ3Rlc3Qta2V5JywgZmV0Y2hlckZuKVxuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHJlc3BvbnNlRGF0YSlcbiAgICAgIGV4cGVjdChmZXRjaGVyRm4pLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ2NhY2hlUGF5bWVudEluZm8nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjYWNoZSBwYXltZW50IGluZm8gd2l0aCBwYXltZW50IElEJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpXG4gICAgICBjb25zdCBwYXltZW50RGF0YSA9IHsgaWQ6ICcxMjMnLCBhbW91bnQ6IDEwMCB9XG4gICAgICBjb25zdCBmZXRjaGVyRm4gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUocGF5bWVudERhdGEpXG5cbiAgICAgIHJlZGlzQ2FjaGUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpXG4gICAgICByZWRpc0NhY2hlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBDYWNoZVV0aWxzLmNhY2hlUGF5bWVudEluZm8oJzEyMycsIGZldGNoZXJGbilcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChwYXltZW50RGF0YSlcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2NhY2hlOnBheW1lbnRfaW5mbzpwYXltZW50OjEyMycpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnY2FjaGVQcm9kdWN0RGF0YScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNhY2hlIHByb2R1Y3QgZGF0YSB3aXRoIHByb2R1Y3QgSUQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcbiAgICAgIGNvbnN0IHByb2R1Y3REYXRhID0geyBpZDogJzQ1NicsIG5hbWU6ICdUZXN0IFByb2R1Y3QnIH1cbiAgICAgIGNvbnN0IGZldGNoZXJGbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZShwcm9kdWN0RGF0YSlcblxuICAgICAgcmVkaXNDYWNoZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbClcbiAgICAgIHJlZGlzQ2FjaGUuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IENhY2hlVXRpbHMuY2FjaGVQcm9kdWN0RGF0YSgnNDU2JywgZmV0Y2hlckZuKVxuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHByb2R1Y3REYXRhKVxuICAgICAgZXhwZWN0KHJlZGlzQ2FjaGUuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnY2FjaGU6cHJvZHVjdDpwcm9kdWN0OjQ1NicpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnaW52YWxpZGF0ZVBheW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpbnZhbGlkYXRlIHBheW1lbnQgY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcblxuICAgICAgcmVkaXNDYWNoZS5kZWwubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQ2FjaGVVdGlscy5pbnZhbGlkYXRlUGF5bWVudCgnMTIzJylcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlZGlzQ2FjaGUuZGVsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnY2FjaGU6cGF5bWVudF9pbmZvOnBheW1lbnQ6MTIzJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdpbnZhbGlkYXRlUHJvZHVjdCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGludmFsaWRhdGUgcHJvZHVjdCBjYWNoZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKVxuXG4gICAgICByZWRpc0NhY2hlLmRlbC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBDYWNoZVV0aWxzLmludmFsaWRhdGVQcm9kdWN0KCc0NTYnKVxuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpXG4gICAgICBleHBlY3QocmVkaXNDYWNoZS5kZWwpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdjYWNoZTpwcm9kdWN0OnByb2R1Y3Q6NDU2JylcbiAgICB9KVxuICB9KVxufSlcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInJlZGlzQ2FjaGUiLCJnZXQiLCJmbiIsInNldCIsImRlbCIsImxvZ2dlciIsImRlYnVnIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsIkxvZ0xldmVsIiwiREVCVUciLCJJTkZPIiwiV0FSTiIsIkVSUk9SIiwiTG9nQ2F0ZWdvcnkiLCJDQUNIRSIsIlNZU1RFTSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImluc3RhbmNlMSIsIkNhY2hlTWFuYWdlciIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UyIiwiZXhwZWN0IiwidG9CZSIsImNhY2hlTWFuYWdlciIsInJlcXVpcmUiLCJ0ZXN0RGF0YSIsImlkIiwibmFtZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3VsdCIsIkNBQ0hFX0NPTkZJR1MiLCJQUk9EVUNUX0RBVEEiLCJ0b0VxdWFsIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0JlTnVsbCIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwidHRsIiwiY2lyY3VsYXJPYmoiLCJzZWxmIiwicmVzb2x2ZXMiLCJkZWxldGUiLCJjYWNoZWREYXRhIiwiZmV0Y2hlckZuIiwiZ2V0T3JTZXQiLCJub3QiLCJmcmVzaERhdGEiLCJmZXRjaGVyRXJyb3IiLCJyZWplY3RzIiwidG9UaHJvdyIsImNvbmZpZyIsIk1FUkNBRE9QQUdPX1JFU1BPTlNFIiwicHJlZml4IiwiY29tcHJlc3MiLCJzZXJpYWxpemUiLCJQQVlNRU5UX0lORk8iLCJsYXJnZURhdGEiLCJyZXBlYXQiLCJzZXRDYWxsIiwiY2FsbHMiLCJ0b0NvbnRhaW4iLCJvcmlnaW5hbERhdGEiLCJjb21wcmVzc2VkRGF0YSIsInJlc3BvbnNlRGF0YSIsInN0YXR1cyIsIkNhY2hlVXRpbHMiLCJjYWNoZU1lcmNhZG9QYWdvUmVzcG9uc2UiLCJwYXltZW50RGF0YSIsImFtb3VudCIsImNhY2hlUGF5bWVudEluZm8iLCJwcm9kdWN0RGF0YSIsImNhY2hlUHJvZHVjdERhdGEiLCJpbnZhbGlkYXRlUGF5bWVudCIsImludmFsaWRhdGVQcm9kdWN0Il0sIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0M7QUFDdEMsMkNBQTJDO0FBQzNDLHNDQUFzQzs7QUFJdEMsYUFBYTtBQUNiQSxLQUFLQyxJQUFJLENBQUMsZUFBZSxJQUFPLENBQUE7UUFDOUJDLFlBQVk7WUFDVkMsS0FBS0gsS0FBS0ksRUFBRTtZQUNaQyxLQUFLTCxLQUFLSSxFQUFFO1lBQ1pFLEtBQUtOLEtBQUtJLEVBQUU7UUFDZDtJQUNGLENBQUE7QUFFQSxjQUFjO0FBQ2RKLEtBQUtDLElBQUksQ0FBQywyQkFBMkIsSUFBTyxDQUFBO1FBQzFDTSxRQUFRO1lBQ05DLE9BQU9SLEtBQUtJLEVBQUU7WUFDZEssTUFBTVQsS0FBS0ksRUFBRTtZQUNiTSxNQUFNVixLQUFLSSxFQUFFO1lBQ2JPLE9BQU9YLEtBQUtJLEVBQUU7UUFDaEI7UUFDQVEsVUFBVTtZQUNSQyxPQUFPO1lBQ1BDLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxPQUFPO1FBQ1Q7UUFDQUMsYUFBYTtZQUNYQyxPQUFPO1lBQ1BDLFFBQVE7UUFDVjtJQUNGLENBQUE7Ozs7OEJBN0JzRTtBQStCdEVDLFNBQVMsZ0JBQWdCO0lBQ3ZCQyxXQUFXO1FBQ1RyQixLQUFLc0IsYUFBYTtJQUNwQjtJQUVBRixTQUFTLHFCQUFxQjtRQUM1QkcsR0FBRyxtQ0FBbUM7WUFDcEMsTUFBTUMsWUFBWUMsMEJBQVksQ0FBQ0MsV0FBVztZQUMxQyxNQUFNQyxZQUFZRiwwQkFBWSxDQUFDQyxXQUFXO1lBRTFDRSxPQUFPSixXQUFXSyxJQUFJLENBQUNGO1lBQ3ZCQyxPQUFPSixXQUFXSyxJQUFJLENBQUNDLDBCQUFZO1FBQ3JDO0lBQ0Y7SUFFQVYsU0FBUyxPQUFPO1FBQ2RHLEdBQUcsNkNBQTZDO1lBQzlDLE1BQU0sRUFBRXJCLFVBQVUsRUFBRSxHQUFHNkIs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