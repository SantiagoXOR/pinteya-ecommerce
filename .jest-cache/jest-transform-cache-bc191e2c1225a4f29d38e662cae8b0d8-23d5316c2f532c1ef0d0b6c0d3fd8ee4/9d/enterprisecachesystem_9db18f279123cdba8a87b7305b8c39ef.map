{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\optimization\\enterprise-cache-system.ts"],"sourcesContent":["/**\r\n * Sistema Enterprise de Caché Inteligente\r\n * Extiende el cache manager existente con funcionalidades enterprise avanzadas\r\n */\r\n\r\nimport { cacheManager, CACHE_CONFIGS, type CacheConfig } from '@/lib/cache-manager';\r\nimport { redisCache } from '@/lib/integrations/redis';\r\nimport { enterpriseAuditSystem } from '@/lib/security/enterprise-audit-system';\r\nimport { metricsCollector } from '@/lib/rate-limiting/enterprise-rate-limiter';\r\nimport type { EnterpriseAuthContext } from '@/lib/auth/enterprise-auth-utils';\r\n\r\n// =====================================================\r\n// TIPOS Y INTERFACES ENTERPRISE\r\n// =====================================================\r\n\r\nexport interface EnterpriseCacheConfig extends CacheConfig {\r\n  // Configuraciones enterprise\r\n  enableAuditLogging?: boolean;\r\n  enableMetrics?: boolean;\r\n  enableInvalidation?: boolean;\r\n  enableWarmup?: boolean;\r\n  \r\n  // Configuraciones de invalidación\r\n  invalidationPatterns?: string[];\r\n  dependentKeys?: string[];\r\n  \r\n  // Configuraciones de warmup\r\n  warmupStrategy?: 'eager' | 'lazy' | 'scheduled';\r\n  warmupInterval?: number;\r\n  \r\n  // Configuraciones de seguridad\r\n  securityLevel?: 'basic' | 'standard' | 'high' | 'critical';\r\n  encryptData?: boolean;\r\n  \r\n  // Configuraciones de performance\r\n  compressionLevel?: number;\r\n  maxMemoryUsage?: number;\r\n  evictionPolicy?: 'lru' | 'lfu' | 'ttl' | 'random';\r\n}\r\n\r\nexport interface CacheMetrics {\r\n  hits: number;\r\n  misses: number;\r\n  hitRate: number;\r\n  avgResponseTime: number;\r\n  memoryUsage: number;\r\n  evictions: number;\r\n  errors: number;\r\n  lastAccess: string;\r\n}\r\n\r\nexport interface CacheInvalidationEvent {\r\n  pattern: string;\r\n  reason: 'manual' | 'ttl_expired' | 'dependency_changed' | 'memory_pressure';\r\n  affectedKeys: string[];\r\n  timestamp: string;\r\n  triggeredBy?: string;\r\n}\r\n\r\nexport interface CacheWarmupJob {\r\n  id: string;\r\n  pattern: string;\r\n  strategy: 'eager' | 'lazy' | 'scheduled';\r\n  interval?: number;\r\n  lastRun?: string;\r\n  nextRun?: string;\r\n  status: 'pending' | 'running' | 'completed' | 'failed';\r\n}\r\n\r\n// =====================================================\r\n// CONFIGURACIONES ENTERPRISE PREDEFINIDAS\r\n// =====================================================\r\n\r\nexport const ENTERPRISE_CACHE_CONFIGS: Record<string, EnterpriseCacheConfig> = {\r\n  // Cache crítico para datos de autenticación\r\n  AUTH_CRITICAL: {\r\n    ...CACHE_CONFIGS.SYSTEM_CONFIG,\r\n    ttl: 300, // 5 minutos\r\n    prefix: 'auth_critical',\r\n    enableAuditLogging: true,\r\n    enableMetrics: true,\r\n    enableInvalidation: true,\r\n    securityLevel: 'critical',\r\n    encryptData: true,\r\n    compressionLevel: 9,\r\n    evictionPolicy: 'ttl'\r\n  },\r\n\r\n  // Cache para datos de productos con invalidación inteligente\r\n  PRODUCTS_SMART: {\r\n    ...CACHE_CONFIGS.PRODUCT_DATA,\r\n    ttl: 1800, // 30 minutos\r\n    prefix: 'products_smart',\r\n    enableAuditLogging: false,\r\n    enableMetrics: true,\r\n    enableInvalidation: true,\r\n    enableWarmup: true,\r\n    invalidationPatterns: ['product:*', 'category:*', 'inventory:*'],\r\n    dependentKeys: ['categories', 'brands', 'pricing'],\r\n    warmupStrategy: 'scheduled',\r\n    warmupInterval: 3600, // 1 hora\r\n    securityLevel: 'standard',\r\n    compressionLevel: 6,\r\n    evictionPolicy: 'lru'\r\n  },\r\n\r\n  // Cache para APIs públicas con alta performance\r\n  PUBLIC_PERFORMANCE: {\r\n    ttl: 600, // 10 minutos\r\n    prefix: 'public_perf',\r\n    compress: true,\r\n    serialize: true,\r\n    enableAuditLogging: false,\r\n    enableMetrics: true,\r\n    enableInvalidation: true,\r\n    enableWarmup: true,\r\n    warmupStrategy: 'eager',\r\n    securityLevel: 'basic',\r\n    compressionLevel: 3,\r\n    maxMemoryUsage: 100 * 1024 * 1024, // 100MB\r\n    evictionPolicy: 'lfu'\r\n  },\r\n\r\n  // Cache para sesiones de usuario\r\n  USER_SESSIONS: {\r\n    ttl: 7200, // 2 horas\r\n    prefix: 'user_sessions',\r\n    compress: false,\r\n    serialize: true,\r\n    enableAuditLogging: true,\r\n    enableMetrics: true,\r\n    enableInvalidation: true,\r\n    securityLevel: 'high',\r\n    encryptData: true,\r\n    evictionPolicy: 'ttl'\r\n  },\r\n\r\n  // Cache para métricas y analytics\r\n  ANALYTICS_DATA: {\r\n    ttl: 900, // 15 minutos\r\n    prefix: 'analytics',\r\n    compress: true,\r\n    serialize: true,\r\n    enableAuditLogging: false,\r\n    enableMetrics: true,\r\n    enableInvalidation: true,\r\n    enableWarmup: true,\r\n    warmupStrategy: 'lazy',\r\n    securityLevel: 'standard',\r\n    compressionLevel: 8,\r\n    evictionPolicy: 'lru'\r\n  }\r\n};\r\n\r\n// =====================================================\r\n// SISTEMA ENTERPRISE DE CACHÉ\r\n// =====================================================\r\n\r\nexport class EnterpriseCacheSystem {\r\n  private static instance: EnterpriseCacheSystem;\r\n  private metrics: Map<string, CacheMetrics> = new Map();\r\n  private invalidationJobs: Map<string, CacheInvalidationEvent> = new Map();\r\n  private warmupJobs: Map<string, CacheWarmupJob> = new Map();\r\n  private isInitialized = false;\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): EnterpriseCacheSystem {\r\n    if (!EnterpriseCacheSystem.instance) {\r\n      EnterpriseCacheSystem.instance = new EnterpriseCacheSystem();\r\n    }\r\n    return EnterpriseCacheSystem.instance;\r\n  }\r\n\r\n  /**\r\n   * Inicializa el sistema enterprise de caché\r\n   */\r\n  async initialize(): Promise<void> {\r\n    if (this.isInitialized) {return;}\r\n\r\n    try {\r\n      // Inicializar jobs de warmup programados\r\n      await this.initializeWarmupJobs();\r\n      \r\n      // Inicializar limpieza automática\r\n      this.startCleanupScheduler();\r\n      \r\n      // Inicializar monitoreo de memoria\r\n      this.startMemoryMonitoring();\r\n      \r\n      this.isInitialized = true;\r\n      console.log('[ENTERPRISE_CACHE] Sistema inicializado correctamente');\r\n    } catch (error) {\r\n      console.error('[ENTERPRISE_CACHE] Error inicializando sistema:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obtiene datos del caché con funcionalidades enterprise\r\n   */\r\n  async get<T>(\r\n    key: string, \r\n    config: EnterpriseCacheConfig,\r\n    context?: EnterpriseAuthContext\r\n  ): Promise<T | null> {\r\n    const startTime = Date.now();\r\n    const fullKey = this.generateKey(config, key);\r\n\r\n    try {\r\n      // Verificar permisos de acceso si es necesario\r\n      if (config.securityLevel === 'critical' && context) {\r\n        await this.verifyAccess(fullKey, context);\r\n      }\r\n\r\n      // Intentar obtener del caché\r\n      const result = await cacheManager.get<T>(key, config);\r\n      const responseTime = Date.now() - startTime;\r\n\r\n      // Actualizar métricas\r\n      if (config.enableMetrics) {\r\n        this.updateMetrics(fullKey, result !== null, responseTime);\r\n      }\r\n\r\n      // Registrar acceso si está habilitado\r\n      if (config.enableAuditLogging && context) {\r\n        await this.logCacheAccess('GET', fullKey, result !== null, context);\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      const responseTime = Date.now() - startTime;\r\n      \r\n      // Actualizar métricas de error\r\n      if (config.enableMetrics) {\r\n        this.updateErrorMetrics(fullKey, responseTime);\r\n      }\r\n\r\n      console.error('[ENTERPRISE_CACHE] Error en get:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Establece datos en el caché con funcionalidades enterprise\r\n   */\r\n  async set<T>(\r\n    key: string, \r\n    value: T, \r\n    config: EnterpriseCacheConfig,\r\n    context?: EnterpriseAuthContext\r\n  ): Promise<boolean> {\r\n    const startTime = Date.now();\r\n    const fullKey = this.generateKey(config, key);\r\n\r\n    try {\r\n      // Verificar permisos de escritura si es necesario\r\n      if (config.securityLevel === 'critical' && context) {\r\n        await this.verifyWriteAccess(fullKey, context);\r\n      }\r\n\r\n      // Encriptar datos si está configurado\r\n      let processedValue = value;\r\n      if (config.encryptData) {\r\n        processedValue = await this.encryptData(value) as T;\r\n      }\r\n\r\n      // Establecer en caché\r\n      const success = await cacheManager.set(key, processedValue, config);\r\n      const responseTime = Date.now() - startTime;\r\n\r\n      // Actualizar métricas\r\n      if (config.enableMetrics) {\r\n        this.updateSetMetrics(fullKey, success, responseTime);\r\n      }\r\n\r\n      // Registrar escritura si está habilitado\r\n      if (config.enableAuditLogging && context) {\r\n        await this.logCacheAccess('SET', fullKey, success, context);\r\n      }\r\n\r\n      // Programar invalidación de dependencias si es necesario\r\n      if (config.enableInvalidation && config.dependentKeys) {\r\n        await this.scheduleDependencyInvalidation(fullKey, config.dependentKeys);\r\n      }\r\n\r\n      return success;\r\n    } catch (error) {\r\n      const responseTime = Date.now() - startTime;\r\n      \r\n      // Actualizar métricas de error\r\n      if (config.enableMetrics) {\r\n        this.updateErrorMetrics(fullKey, responseTime);\r\n      }\r\n\r\n      console.error('[ENTERPRISE_CACHE] Error en set:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Invalidación inteligente de caché\r\n   */\r\n  async invalidate(\r\n    pattern: string, \r\n    reason: CacheInvalidationEvent['reason'] = 'manual',\r\n    context?: EnterpriseAuthContext\r\n  ): Promise<string[]> {\r\n    try {\r\n      const affectedKeys = await this.findKeysByPattern(pattern);\r\n      \r\n      // Eliminar claves del caché\r\n      const deletionPromises = affectedKeys.map(key => redisCache.del(key));\r\n      await Promise.all(deletionPromises);\r\n\r\n      // Registrar evento de invalidación\r\n      const invalidationEvent: CacheInvalidationEvent = {\r\n        pattern,\r\n        reason,\r\n        affectedKeys,\r\n        timestamp: new Date().toISOString(),\r\n        triggeredBy: context?.userId\r\n      };\r\n\r\n      this.invalidationJobs.set(\r\n        `inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        invalidationEvent\r\n      );\r\n\r\n      // Registrar en auditoría si hay contexto\r\n      if (context) {\r\n        await enterpriseAuditSystem.logEnterpriseEvent({\r\n          user_id: context.userId,\r\n          event_type: 'CACHE_INVALIDATION' as any,\r\n          event_category: 'system_operation',\r\n          severity: 'medium' as any,\r\n          description: `Cache invalidation: ${pattern}`,\r\n          metadata: {\r\n            pattern,\r\n            reason,\r\n            affected_keys_count: affectedKeys.length,\r\n            affected_keys: affectedKeys.slice(0, 10) // Primeras 10 para no saturar\r\n          },\r\n          ip_address: context.ipAddress,\r\n          user_agent: context.userAgent\r\n        }, context);\r\n      }\r\n\r\n      console.log(`[ENTERPRISE_CACHE] Invalidated ${affectedKeys.length} keys for pattern: ${pattern}`);\r\n      return affectedKeys;\r\n    } catch (error) {\r\n      console.error('[ENTERPRISE_CACHE] Error en invalidación:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Warmup inteligente de caché\r\n   */\r\n  async warmup(\r\n    keys: string[], \r\n    config: EnterpriseCacheConfig,\r\n    dataFetcher: (key: string) => Promise<any>\r\n  ): Promise<void> {\r\n    const jobId = `warmup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    \r\n    const warmupJob: CacheWarmupJob = {\r\n      id: jobId,\r\n      pattern: keys.join(','),\r\n      strategy: config.warmupStrategy || 'lazy',\r\n      interval: config.warmupInterval,\r\n      lastRun: new Date().toISOString(),\r\n      status: 'running'\r\n    };\r\n\r\n    this.warmupJobs.set(jobId, warmupJob);\r\n\r\n    try {\r\n      const warmupPromises = keys.map(async (key) => {\r\n        try {\r\n          // Verificar si ya existe en caché\r\n          const existing = await this.get(key, config);\r\n          if (existing !== null) {\r\n            return; // Ya está en caché\r\n          }\r\n\r\n          // Obtener datos y cachear\r\n          const data = await dataFetcher(key);\r\n          await this.set(key, data, config);\r\n        } catch (error) {\r\n          console.warn(`[ENTERPRISE_CACHE] Error warming up key ${key}:`, error);\r\n        }\r\n      });\r\n\r\n      await Promise.all(warmupPromises);\r\n      \r\n      // Actualizar estado del job\r\n      warmupJob.status = 'completed';\r\n      warmupJob.nextRun = config.warmupInterval ? \r\n        new Date(Date.now() + config.warmupInterval * 1000).toISOString() : \r\n        undefined;\r\n\r\n      console.log(`[ENTERPRISE_CACHE] Warmup completed for ${keys.length} keys`);\r\n    } catch (error) {\r\n      warmupJob.status = 'failed';\r\n      console.error('[ENTERPRISE_CACHE] Error en warmup:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obtiene métricas del sistema de caché\r\n   */\r\n  getMetrics(): Record<string, CacheMetrics> {\r\n    return Object.fromEntries(this.metrics);\r\n  }\r\n\r\n  /**\r\n   * Obtiene estadísticas de invalidación\r\n   */\r\n  getInvalidationStats(): CacheInvalidationEvent[] {\r\n    return Array.from(this.invalidationJobs.values());\r\n  }\r\n\r\n  /**\r\n   * Obtiene estadísticas de warmup\r\n   */\r\n  getWarmupStats(): CacheWarmupJob[] {\r\n    return Array.from(this.warmupJobs.values());\r\n  }\r\n\r\n  // =====================================================\r\n  // MÉTODOS PRIVADOS\r\n  // =====================================================\r\n\r\n  private generateKey(config: EnterpriseCacheConfig, key: string): string {\r\n    return `${config.prefix}:${key}`;\r\n  }\r\n\r\n  private async verifyAccess(key: string, context: EnterpriseAuthContext): Promise<void> {\r\n    // Verificar permisos de acceso para datos críticos\r\n    if (!context.permissions.includes('cache_access') && \r\n        !context.permissions.includes('admin_access')) {\r\n      throw new Error('Insufficient permissions for cache access');\r\n    }\r\n  }\r\n\r\n  private async verifyWriteAccess(key: string, context: EnterpriseAuthContext): Promise<void> {\r\n    // Verificar permisos de escritura para datos críticos\r\n    if (!context.permissions.includes('cache_write') && \r\n        !context.permissions.includes('admin_access')) {\r\n      throw new Error('Insufficient permissions for cache write');\r\n    }\r\n  }\r\n\r\n  private async encryptData(data: any): Promise<any> {\r\n    // Implementación básica de encriptación\r\n    // En producción, usar una librería de encriptación robusta\r\n    try {\r\n      const jsonString = JSON.stringify(data);\r\n      const encoded = Buffer.from(jsonString).toString('base64');\r\n      return { encrypted: true, data: encoded };\r\n    } catch (error) {\r\n      console.warn('[ENTERPRISE_CACHE] Error encriptando datos:', error);\r\n      return data;\r\n    }\r\n  }\r\n\r\n  private updateMetrics(key: string, hit: boolean, responseTime: number): void {\r\n    const existing = this.metrics.get(key) || {\r\n      hits: 0,\r\n      misses: 0,\r\n      hitRate: 0,\r\n      avgResponseTime: 0,\r\n      memoryUsage: 0,\r\n      evictions: 0,\r\n      errors: 0,\r\n      lastAccess: new Date().toISOString()\r\n    };\r\n\r\n    if (hit) {\r\n      existing.hits++;\r\n    } else {\r\n      existing.misses++;\r\n    }\r\n\r\n    const totalRequests = existing.hits + existing.misses;\r\n    existing.hitRate = totalRequests > 0 ? existing.hits / totalRequests : 0;\r\n    existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;\r\n    existing.lastAccess = new Date().toISOString();\r\n\r\n    this.metrics.set(key, existing);\r\n  }\r\n\r\n  private updateSetMetrics(key: string, success: boolean, responseTime: number): void {\r\n    const existing = this.metrics.get(key) || {\r\n      hits: 0,\r\n      misses: 0,\r\n      hitRate: 0,\r\n      avgResponseTime: 0,\r\n      memoryUsage: 0,\r\n      evictions: 0,\r\n      errors: 0,\r\n      lastAccess: new Date().toISOString()\r\n    };\r\n\r\n    existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;\r\n    existing.lastAccess = new Date().toISOString();\r\n\r\n    if (!success) {\r\n      existing.errors++;\r\n    }\r\n\r\n    this.metrics.set(key, existing);\r\n  }\r\n\r\n  private updateErrorMetrics(key: string, responseTime: number): void {\r\n    const existing = this.metrics.get(key) || {\r\n      hits: 0,\r\n      misses: 0,\r\n      hitRate: 0,\r\n      avgResponseTime: 0,\r\n      memoryUsage: 0,\r\n      evictions: 0,\r\n      errors: 0,\r\n      lastAccess: new Date().toISOString()\r\n    };\r\n\r\n    existing.errors++;\r\n    existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;\r\n    existing.lastAccess = new Date().toISOString();\r\n\r\n    this.metrics.set(key, existing);\r\n  }\r\n\r\n  private async logCacheAccess(\r\n    operation: 'GET' | 'SET',\r\n    key: string,\r\n    success: boolean,\r\n    context: EnterpriseAuthContext\r\n  ): Promise<void> {\r\n    try {\r\n      await enterpriseAuditSystem.logEnterpriseEvent({\r\n        user_id: context.userId,\r\n        event_type: 'CACHE_ACCESS' as any,\r\n        event_category: 'system_operation',\r\n        severity: 'low' as any,\r\n        description: `Cache ${operation}: ${key}`,\r\n        metadata: {\r\n          operation,\r\n          key,\r\n          success,\r\n          cache_system: 'enterprise'\r\n        },\r\n        ip_address: context.ipAddress,\r\n        user_agent: context.userAgent\r\n      }, context);\r\n    } catch (error) {\r\n      console.warn('[ENTERPRISE_CACHE] Error logging cache access:', error);\r\n    }\r\n  }\r\n\r\n  private async findKeysByPattern(pattern: string): Promise<string[]> {\r\n    try {\r\n      // Usar Redis SCAN para encontrar claves por patrón\r\n      const keys: string[] = [];\r\n      const client = redisCache['client']; // Acceder al cliente Redis interno\r\n      \r\n      if (client && typeof client.scanStream === 'function') {\r\n        const stream = client.scanStream({\r\n          match: pattern,\r\n          count: 100\r\n        });\r\n\r\n        return new Promise((resolve, reject) => {\r\n          stream.on('data', (resultKeys: string[]) => {\r\n            keys.push(...resultKeys);\r\n          });\r\n\r\n          stream.on('end', () => {\r\n            resolve(keys);\r\n          });\r\n\r\n          stream.on('error', (error: Error) => {\r\n            reject(error);\r\n          });\r\n        });\r\n      }\r\n\r\n      return keys;\r\n    } catch (error) {\r\n      console.error('[ENTERPRISE_CACHE] Error finding keys by pattern:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private async scheduleDependencyInvalidation(key: string, dependentKeys: string[]): Promise<void> {\r\n    // Programar invalidación de claves dependientes\r\n    // Esto se podría implementar con un job queue como Bull o Agenda\r\n    setTimeout(async () => {\r\n      for (const depKey of dependentKeys) {\r\n        await this.invalidate(depKey, 'dependency_changed');\r\n      }\r\n    }, 1000); // 1 segundo de delay\r\n  }\r\n\r\n  private async initializeWarmupJobs(): Promise<void> {\r\n    // Inicializar jobs de warmup programados\r\n    // En una implementación real, esto se cargaría desde una base de datos\r\n    console.log('[ENTERPRISE_CACHE] Warmup jobs initialized');\r\n  }\r\n\r\n  private startCleanupScheduler(): void {\r\n    // Limpiar métricas antiguas cada hora\r\n    setInterval(() => {\r\n      const oneHourAgo = Date.now() - 60 * 60 * 1000;\r\n      \r\n      for (const [key, metrics] of this.metrics.entries()) {\r\n        const lastAccessTime = new Date(metrics.lastAccess).getTime();\r\n        if (lastAccessTime < oneHourAgo) {\r\n          this.metrics.delete(key);\r\n        }\r\n      }\r\n    }, 60 * 60 * 1000); // 1 hora\r\n  }\r\n\r\n  private startMemoryMonitoring(): void {\r\n    // Monitorear uso de memoria cada 5 minutos\r\n    setInterval(() => {\r\n      const memoryUsage = process.memoryUsage();\r\n      \r\n      if (memoryUsage.heapUsed > 500 * 1024 * 1024) { // 500MB\r\n        console.warn('[ENTERPRISE_CACHE] High memory usage detected:', memoryUsage);\r\n        // Aquí se podría implementar limpieza automática\r\n      }\r\n    }, 5 * 60 * 1000); // 5 minutos\r\n  }\r\n}\r\n\r\n// =====================================================\r\n// INSTANCIA SINGLETON Y UTILIDADES\r\n// =====================================================\r\n\r\nexport const enterpriseCacheSystem = EnterpriseCacheSystem.getInstance();\r\n\r\n/**\r\n * Funciones de utilidad para casos comunes\r\n */\r\nexport const EnterpriseCacheUtils = {\r\n  /**\r\n   * Cache para datos de autenticación críticos\r\n   */\r\n  async cacheAuthData<T>(key: string, fetcher: () => Promise<T>, context: EnterpriseAuthContext): Promise<T> {\r\n    const cached = await enterpriseCacheSystem.get<T>(key, ENTERPRISE_CACHE_CONFIGS.AUTH_CRITICAL, context);\r\n    if (cached !== null) {return cached;}\r\n\r\n    const data = await fetcher();\r\n    await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.AUTH_CRITICAL, context);\r\n    return data;\r\n  },\r\n\r\n  /**\r\n   * Cache inteligente para productos\r\n   */\r\n  async cacheProductData<T>(key: string, fetcher: () => Promise<T>): Promise<T> {\r\n    const cached = await enterpriseCacheSystem.get<T>(key, ENTERPRISE_CACHE_CONFIGS.PRODUCTS_SMART);\r\n    if (cached !== null) {return cached;}\r\n\r\n    const data = await fetcher();\r\n    await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.PRODUCTS_SMART);\r\n    return data;\r\n  },\r\n\r\n  /**\r\n   * Cache de alta performance para APIs públicas\r\n   */\r\n  async cachePublicData<T>(key: string, fetcher: () => Promise<T>): Promise<T> {\r\n    const cached = await enterpriseCacheSystem.get<T>(key, ENTERPRISE_CACHE_CONFIGS.PUBLIC_PERFORMANCE);\r\n    if (cached !== null) {return cached;}\r\n\r\n    const data = await fetcher();\r\n    await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.PUBLIC_PERFORMANCE);\r\n    return data;\r\n  },\r\n\r\n  /**\r\n   * Invalidación masiva por patrones\r\n   */\r\n  async invalidateByPatterns(patterns: string[], context?: EnterpriseAuthContext): Promise<void> {\r\n    const invalidationPromises = patterns.map(pattern => \r\n      enterpriseCacheSystem.invalidate(pattern, 'manual', context)\r\n    );\r\n    await Promise.all(invalidationPromises);\r\n  }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":["ENTERPRISE_CACHE_CONFIGS","EnterpriseCacheSystem","EnterpriseCacheUtils","enterpriseCacheSystem","AUTH_CRITICAL","CACHE_CONFIGS","SYSTEM_CONFIG","ttl","prefix","enableAuditLogging","enableMetrics","enableInvalidation","securityLevel","encryptData","compressionLevel","evictionPolicy","PRODUCTS_SMART","PRODUCT_DATA","enableWarmup","invalidationPatterns","dependentKeys","warmupStrategy","warmupInterval","PUBLIC_PERFORMANCE","compress","serialize","maxMemoryUsage","USER_SESSIONS","ANALYTICS_DATA","metrics","Map","invalidationJobs","warmupJobs","isInitialized","getInstance","instance","initialize","initializeWarmupJobs","startCleanupScheduler","startMemoryMonitoring","console","log","error","get","key","config","context","startTime","Date","now","fullKey","generateKey","verifyAccess","result","cacheManager","responseTime","updateMetrics","logCacheAccess","updateErrorMetrics","set","value","verifyWriteAccess","processedValue","success","updateSetMetrics","scheduleDependencyInvalidation","invalidate","pattern","reason","affectedKeys","findKeysByPattern","deletionPromises","map","redisCache","del","Promise","all","invalidationEvent","timestamp","toISOString","triggeredBy","userId","Math","random","toString","substr","enterpriseAuditSystem","logEnterpriseEvent","user_id","event_type","event_category","severity","description","metadata","affected_keys_count","length","affected_keys","slice","ip_address","ipAddress","user_agent","userAgent","warmup","keys","dataFetcher","jobId","warmupJob","id","join","strategy","interval","lastRun","status","warmupPromises","existing","data","warn","nextRun","undefined","getMetrics","Object","fromEntries","getInvalidationStats","Array","from","values","getWarmupStats","permissions","includes","Error","jsonString","JSON","stringify","encoded","Buffer","encrypted","hit","hits","misses","hitRate","avgResponseTime","memoryUsage","evictions","errors","lastAccess","totalRequests","operation","cache_system","client","scanStream","stream","match","count","resolve","reject","on","resultKeys","push","setTimeout","depKey","setInterval","oneHourAgo","entries","lastAccessTime","getTime","delete","process","heapUsed","cacheAuthData","fetcher","cached","cacheProductData","cachePublicData","invalidateByPatterns","patterns","invalidationPromises"],"mappings":"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"}