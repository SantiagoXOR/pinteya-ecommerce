5c556a432ac2df60f00edbe87c595d08
/**
 * Sistema Enterprise de Caché Inteligente
 * Extiende el cache manager existente con funcionalidades enterprise avanzadas
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get ENTERPRISE_CACHE_CONFIGS () {
        return ENTERPRISE_CACHE_CONFIGS;
    },
    get EnterpriseCacheSystem () {
        return EnterpriseCacheSystem;
    },
    get EnterpriseCacheUtils () {
        return EnterpriseCacheUtils;
    },
    get enterpriseCacheSystem () {
        return enterpriseCacheSystem;
    }
});
const _cachemanager = require("../cache-manager");
const _redis = require("../integrations/redis");
const _enterpriseauditsystem = require("../security/enterprise-audit-system");
const ENTERPRISE_CACHE_CONFIGS = {
    // Cache crítico para datos de autenticación
    AUTH_CRITICAL: {
        ..._cachemanager.CACHE_CONFIGS.SYSTEM_CONFIG,
        ttl: 300,
        prefix: 'auth_critical',
        enableAuditLogging: true,
        enableMetrics: true,
        enableInvalidation: true,
        securityLevel: 'critical',
        encryptData: true,
        compressionLevel: 9,
        evictionPolicy: 'ttl'
    },
    // Cache para datos de productos con invalidación inteligente
    PRODUCTS_SMART: {
        ..._cachemanager.CACHE_CONFIGS.PRODUCT_DATA,
        ttl: 1800,
        prefix: 'products_smart',
        enableAuditLogging: false,
        enableMetrics: true,
        enableInvalidation: true,
        enableWarmup: true,
        invalidationPatterns: [
            'product:*',
            'category:*',
            'inventory:*'
        ],
        dependentKeys: [
            'categories',
            'brands',
            'pricing'
        ],
        warmupStrategy: 'scheduled',
        warmupInterval: 3600,
        securityLevel: 'standard',
        compressionLevel: 6,
        evictionPolicy: 'lru'
    },
    // Cache para APIs públicas con alta performance
    PUBLIC_PERFORMANCE: {
        ttl: 600,
        prefix: 'public_perf',
        compress: true,
        serialize: true,
        enableAuditLogging: false,
        enableMetrics: true,
        enableInvalidation: true,
        enableWarmup: true,
        warmupStrategy: 'eager',
        securityLevel: 'basic',
        compressionLevel: 3,
        maxMemoryUsage: 100 * 1024 * 1024,
        evictionPolicy: 'lfu'
    },
    // Cache para sesiones de usuario
    USER_SESSIONS: {
        ttl: 7200,
        prefix: 'user_sessions',
        compress: false,
        serialize: true,
        enableAuditLogging: true,
        enableMetrics: true,
        enableInvalidation: true,
        securityLevel: 'high',
        encryptData: true,
        evictionPolicy: 'ttl'
    },
    // Cache para métricas y analytics
    ANALYTICS_DATA: {
        ttl: 900,
        prefix: 'analytics',
        compress: true,
        serialize: true,
        enableAuditLogging: false,
        enableMetrics: true,
        enableInvalidation: true,
        enableWarmup: true,
        warmupStrategy: 'lazy',
        securityLevel: 'standard',
        compressionLevel: 8,
        evictionPolicy: 'lru'
    }
};
class EnterpriseCacheSystem {
    constructor(){
        this.metrics = new Map();
        this.invalidationJobs = new Map();
        this.warmupJobs = new Map();
        this.isInitialized = false;
    }
    static getInstance() {
        if (!EnterpriseCacheSystem.instance) {
            EnterpriseCacheSystem.instance = new EnterpriseCacheSystem();
        }
        return EnterpriseCacheSystem.instance;
    }
    /**
   * Inicializa el sistema enterprise de caché
   */ async initialize() {
        if (this.isInitialized) {
            return;
        }
        try {
            // Inicializar jobs de warmup programados
            await this.initializeWarmupJobs();
            // Inicializar limpieza automática
            this.startCleanupScheduler();
            // Inicializar monitoreo de memoria
            this.startMemoryMonitoring();
            this.isInitialized = true;
            console.log('[ENTERPRISE_CACHE] Sistema inicializado correctamente');
        } catch (error) {
            console.error('[ENTERPRISE_CACHE] Error inicializando sistema:', error);
            throw error;
        }
    }
    /**
   * Obtiene datos del caché con funcionalidades enterprise
   */ async get(key, config, context) {
        const startTime = Date.now();
        const fullKey = this.generateKey(config, key);
        try {
            // Verificar permisos de acceso si es necesario
            if (config.securityLevel === 'critical' && context) {
                await this.verifyAccess(fullKey, context);
            }
            // Intentar obtener del caché
            const result = await _cachemanager.cacheManager.get(key, config);
            const responseTime = Date.now() - startTime;
            // Actualizar métricas
            if (config.enableMetrics) {
                this.updateMetrics(fullKey, result !== null, responseTime);
            }
            // Registrar acceso si está habilitado
            if (config.enableAuditLogging && context) {
                await this.logCacheAccess('GET', fullKey, result !== null, context);
            }
            return result;
        } catch (error) {
            const responseTime = Date.now() - startTime;
            // Actualizar métricas de error
            if (config.enableMetrics) {
                this.updateErrorMetrics(fullKey, responseTime);
            }
            console.error('[ENTERPRISE_CACHE] Error en get:', error);
            return null;
        }
    }
    /**
   * Establece datos en el caché con funcionalidades enterprise
   */ async set(key, value, config, context) {
        const startTime = Date.now();
        const fullKey = this.generateKey(config, key);
        try {
            // Verificar permisos de escritura si es necesario
            if (config.securityLevel === 'critical' && context) {
                await this.verifyWriteAccess(fullKey, context);
            }
            // Encriptar datos si está configurado
            let processedValue = value;
            if (config.encryptData) {
                processedValue = await this.encryptData(value);
            }
            // Establecer en caché
            const success = await _cachemanager.cacheManager.set(key, processedValue, config);
            const responseTime = Date.now() - startTime;
            // Actualizar métricas
            if (config.enableMetrics) {
                this.updateSetMetrics(fullKey, success, responseTime);
            }
            // Registrar escritura si está habilitado
            if (config.enableAuditLogging && context) {
                await this.logCacheAccess('SET', fullKey, success, context);
            }
            // Programar invalidación de dependencias si es necesario
            if (config.enableInvalidation && config.dependentKeys) {
                await this.scheduleDependencyInvalidation(fullKey, config.dependentKeys);
            }
            return success;
        } catch (error) {
            const responseTime = Date.now() - startTime;
            // Actualizar métricas de error
            if (config.enableMetrics) {
                this.updateErrorMetrics(fullKey, responseTime);
            }
            console.error('[ENTERPRISE_CACHE] Error en set:', error);
            return false;
        }
    }
    /**
   * Invalidación inteligente de caché
   */ async invalidate(pattern, reason = 'manual', context) {
        try {
            const affectedKeys = await this.findKeysByPattern(pattern);
            // Eliminar claves del caché
            const deletionPromises = affectedKeys.map((key)=>_redis.redisCache.del(key));
            await Promise.all(deletionPromises);
            // Registrar evento de invalidación
            const invalidationEvent = {
                pattern,
                reason,
                affectedKeys,
                timestamp: new Date().toISOString(),
                triggeredBy: context?.userId
            };
            this.invalidationJobs.set(`inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, invalidationEvent);
            // Registrar en auditoría si hay contexto
            if (context) {
                await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent({
                    user_id: context.userId,
                    event_type: 'CACHE_INVALIDATION',
                    event_category: 'system_operation',
                    severity: 'medium',
                    description: `Cache invalidation: ${pattern}`,
                    metadata: {
                        pattern,
                        reason,
                        affected_keys_count: affectedKeys.length,
                        affected_keys: affectedKeys.slice(0, 10) // Primeras 10 para no saturar
                    },
                    ip_address: context.ipAddress,
                    user_agent: context.userAgent
                }, context);
            }
            console.log(`[ENTERPRISE_CACHE] Invalidated ${affectedKeys.length} keys for pattern: ${pattern}`);
            return affectedKeys;
        } catch (error) {
            console.error('[ENTERPRISE_CACHE] Error en invalidación:', error);
            return [];
        }
    }
    /**
   * Warmup inteligente de caché
   */ async warmup(keys, config, dataFetcher) {
        const jobId = `warmup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const warmupJob = {
            id: jobId,
            pattern: keys.join(','),
            strategy: config.warmupStrategy || 'lazy',
            interval: config.warmupInterval,
            lastRun: new Date().toISOString(),
            status: 'running'
        };
        this.warmupJobs.set(jobId, warmupJob);
        try {
            const warmupPromises = keys.map(async (key)=>{
                try {
                    // Verificar si ya existe en caché
                    const existing = await this.get(key, config);
                    if (existing !== null) {
                        return; // Ya está en caché
                    }
                    // Obtener datos y cachear
                    const data = await dataFetcher(key);
                    await this.set(key, data, config);
                } catch (error) {
                    console.warn(`[ENTERPRISE_CACHE] Error warming up key ${key}:`, error);
                }
            });
            await Promise.all(warmupPromises);
            // Actualizar estado del job
            warmupJob.status = 'completed';
            warmupJob.nextRun = config.warmupInterval ? new Date(Date.now() + config.warmupInterval * 1000).toISOString() : undefined;
            console.log(`[ENTERPRISE_CACHE] Warmup completed for ${keys.length} keys`);
        } catch (error) {
            warmupJob.status = 'failed';
            console.error('[ENTERPRISE_CACHE] Error en warmup:', error);
        }
    }
    /**
   * Obtiene métricas del sistema de caché
   */ getMetrics() {
        return Object.fromEntries(this.metrics);
    }
    /**
   * Obtiene estadísticas de invalidación
   */ getInvalidationStats() {
        return Array.from(this.invalidationJobs.values());
    }
    /**
   * Obtiene estadísticas de warmup
   */ getWarmupStats() {
        return Array.from(this.warmupJobs.values());
    }
    // =====================================================
    // MÉTODOS PRIVADOS
    // =====================================================
    generateKey(config, key) {
        return `${config.prefix}:${key}`;
    }
    async verifyAccess(key, context) {
        // Verificar permisos de acceso para datos críticos
        if (!context.permissions.includes('cache_access') && !context.permissions.includes('admin_access')) {
            throw new Error('Insufficient permissions for cache access');
        }
    }
    async verifyWriteAccess(key, context) {
        // Verificar permisos de escritura para datos críticos
        if (!context.permissions.includes('cache_write') && !context.permissions.includes('admin_access')) {
            throw new Error('Insufficient permissions for cache write');
        }
    }
    async encryptData(data) {
        // Implementación básica de encriptación
        // En producción, usar una librería de encriptación robusta
        try {
            const jsonString = JSON.stringify(data);
            const encoded = Buffer.from(jsonString).toString('base64');
            return {
                encrypted: true,
                data: encoded
            };
        } catch (error) {
            console.warn('[ENTERPRISE_CACHE] Error encriptando datos:', error);
            return data;
        }
    }
    updateMetrics(key, hit, responseTime) {
        const existing = this.metrics.get(key) || {
            hits: 0,
            misses: 0,
            hitRate: 0,
            avgResponseTime: 0,
            memoryUsage: 0,
            evictions: 0,
            errors: 0,
            lastAccess: new Date().toISOString()
        };
        if (hit) {
            existing.hits++;
        } else {
            existing.misses++;
        }
        const totalRequests = existing.hits + existing.misses;
        existing.hitRate = totalRequests > 0 ? existing.hits / totalRequests : 0;
        existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;
        existing.lastAccess = new Date().toISOString();
        this.metrics.set(key, existing);
    }
    updateSetMetrics(key, success, responseTime) {
        const existing = this.metrics.get(key) || {
            hits: 0,
            misses: 0,
            hitRate: 0,
            avgResponseTime: 0,
            memoryUsage: 0,
            evictions: 0,
            errors: 0,
            lastAccess: new Date().toISOString()
        };
        existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;
        existing.lastAccess = new Date().toISOString();
        if (!success) {
            existing.errors++;
        }
        this.metrics.set(key, existing);
    }
    updateErrorMetrics(key, responseTime) {
        const existing = this.metrics.get(key) || {
            hits: 0,
            misses: 0,
            hitRate: 0,
            avgResponseTime: 0,
            memoryUsage: 0,
            evictions: 0,
            errors: 0,
            lastAccess: new Date().toISOString()
        };
        existing.errors++;
        existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;
        existing.lastAccess = new Date().toISOString();
        this.metrics.set(key, existing);
    }
    async logCacheAccess(operation, key, success, context) {
        try {
            await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent({
                user_id: context.userId,
                event_type: 'CACHE_ACCESS',
                event_category: 'system_operation',
                severity: 'low',
                description: `Cache ${operation}: ${key}`,
                metadata: {
                    operation,
                    key,
                    success,
                    cache_system: 'enterprise'
                },
                ip_address: context.ipAddress,
                user_agent: context.userAgent
            }, context);
        } catch (error) {
            console.warn('[ENTERPRISE_CACHE] Error logging cache access:', error);
        }
    }
    async findKeysByPattern(pattern) {
        try {
            // Usar Redis SCAN para encontrar claves por patrón
            const keys = [];
            const client = _redis.redisCache['client']; // Acceder al cliente Redis interno
            if (client && typeof client.scanStream === 'function') {
                const stream = client.scanStream({
                    match: pattern,
                    count: 100
                });
                return new Promise((resolve, reject)=>{
                    stream.on('data', (resultKeys)=>{
                        keys.push(...resultKeys);
                    });
                    stream.on('end', ()=>{
                        resolve(keys);
                    });
                    stream.on('error', (error)=>{
                        reject(error);
                    });
                });
            }
            return keys;
        } catch (error) {
            console.error('[ENTERPRISE_CACHE] Error finding keys by pattern:', error);
            return [];
        }
    }
    async scheduleDependencyInvalidation(key, dependentKeys) {
        // Programar invalidación de claves dependientes
        // Esto se podría implementar con un job queue como Bull o Agenda
        setTimeout(async ()=>{
            for (const depKey of dependentKeys){
                await this.invalidate(depKey, 'dependency_changed');
            }
        }, 1000); // 1 segundo de delay
    }
    async initializeWarmupJobs() {
        // Inicializar jobs de warmup programados
        // En una implementación real, esto se cargaría desde una base de datos
        console.log('[ENTERPRISE_CACHE] Warmup jobs initialized');
    }
    startCleanupScheduler() {
        // Limpiar métricas antiguas cada hora
        setInterval(()=>{
            const oneHourAgo = Date.now() - 60 * 60 * 1000;
            for (const [key, metrics] of this.metrics.entries()){
                const lastAccessTime = new Date(metrics.lastAccess).getTime();
                if (lastAccessTime < oneHourAgo) {
                    this.metrics.delete(key);
                }
            }
        }, 60 * 60 * 1000); // 1 hora
    }
    startMemoryMonitoring() {
        // Monitorear uso de memoria cada 5 minutos
        setInterval(()=>{
            const memoryUsage = process.memoryUsage();
            if (memoryUsage.heapUsed > 500 * 1024 * 1024) {
                console.warn('[ENTERPRISE_CACHE] High memory usage detected:', memoryUsage);
            // Aquí se podría implementar limpieza automática
            }
        }, 5 * 60 * 1000); // 5 minutos
    }
}
const enterpriseCacheSystem = EnterpriseCacheSystem.getInstance();
const EnterpriseCacheUtils = {
    /**
   * Cache para datos de autenticación críticos
   */ async cacheAuthData (key, fetcher, context) {
        const cached = await enterpriseCacheSystem.get(key, ENTERPRISE_CACHE_CONFIGS.AUTH_CRITICAL, context);
        if (cached !== null) {
            return cached;
        }
        const data = await fetcher();
        await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.AUTH_CRITICAL, context);
        return data;
    },
    /**
   * Cache inteligente para productos
   */ async cacheProductData (key, fetcher) {
        const cached = await enterpriseCacheSystem.get(key, ENTERPRISE_CACHE_CONFIGS.PRODUCTS_SMART);
        if (cached !== null) {
            return cached;
        }
        const data = await fetcher();
        await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.PRODUCTS_SMART);
        return data;
    },
    /**
   * Cache de alta performance para APIs públicas
   */ async cachePublicData (key, fetcher) {
        const cached = await enterpriseCacheSystem.get(key, ENTERPRISE_CACHE_CONFIGS.PUBLIC_PERFORMANCE);
        if (cached !== null) {
            return cached;
        }
        const data = await fetcher();
        await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.PUBLIC_PERFORMANCE);
        return data;
    },
    /**
   * Invalidación masiva por patrones
   */ async invalidateByPatterns (patterns, context) {
        const invalidationPromises = patterns.map((pattern)=>enterpriseCacheSystem.invalidate(pattern, 'manual', context));
        await Promise.all(invalidationPromises);
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcbGliXFxvcHRpbWl6YXRpb25cXGVudGVycHJpc2UtY2FjaGUtc3lzdGVtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTaXN0ZW1hIEVudGVycHJpc2UgZGUgQ2FjaMOpIEludGVsaWdlbnRlXHJcbiAqIEV4dGllbmRlIGVsIGNhY2hlIG1hbmFnZXIgZXhpc3RlbnRlIGNvbiBmdW5jaW9uYWxpZGFkZXMgZW50ZXJwcmlzZSBhdmFuemFkYXNcclxuICovXHJcblxyXG5pbXBvcnQgeyBjYWNoZU1hbmFnZXIsIENBQ0hFX0NPTkZJR1MsIHR5cGUgQ2FjaGVDb25maWcgfSBmcm9tICdAL2xpYi9jYWNoZS1tYW5hZ2VyJztcclxuaW1wb3J0IHsgcmVkaXNDYWNoZSB9IGZyb20gJ0AvbGliL2ludGVncmF0aW9ucy9yZWRpcyc7XHJcbmltcG9ydCB7IGVudGVycHJpc2VBdWRpdFN5c3RlbSB9IGZyb20gJ0AvbGliL3NlY3VyaXR5L2VudGVycHJpc2UtYXVkaXQtc3lzdGVtJztcclxuaW1wb3J0IHsgbWV0cmljc0NvbGxlY3RvciB9IGZyb20gJ0AvbGliL3JhdGUtbGltaXRpbmcvZW50ZXJwcmlzZS1yYXRlLWxpbWl0ZXInO1xyXG5pbXBvcnQgdHlwZSB7IEVudGVycHJpc2VBdXRoQ29udGV4dCB9IGZyb20gJ0AvbGliL2F1dGgvZW50ZXJwcmlzZS1hdXRoLXV0aWxzJztcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFRJUE9TIFkgSU5URVJGQUNFUyBFTlRFUlBSSVNFXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVudGVycHJpc2VDYWNoZUNvbmZpZyBleHRlbmRzIENhY2hlQ29uZmlnIHtcclxuICAvLyBDb25maWd1cmFjaW9uZXMgZW50ZXJwcmlzZVxyXG4gIGVuYWJsZUF1ZGl0TG9nZ2luZz86IGJvb2xlYW47XHJcbiAgZW5hYmxlTWV0cmljcz86IGJvb2xlYW47XHJcbiAgZW5hYmxlSW52YWxpZGF0aW9uPzogYm9vbGVhbjtcclxuICBlbmFibGVXYXJtdXA/OiBib29sZWFuO1xyXG4gIFxyXG4gIC8vIENvbmZpZ3VyYWNpb25lcyBkZSBpbnZhbGlkYWNpw7NuXHJcbiAgaW52YWxpZGF0aW9uUGF0dGVybnM/OiBzdHJpbmdbXTtcclxuICBkZXBlbmRlbnRLZXlzPzogc3RyaW5nW107XHJcbiAgXHJcbiAgLy8gQ29uZmlndXJhY2lvbmVzIGRlIHdhcm11cFxyXG4gIHdhcm11cFN0cmF0ZWd5PzogJ2VhZ2VyJyB8ICdsYXp5JyB8ICdzY2hlZHVsZWQnO1xyXG4gIHdhcm11cEludGVydmFsPzogbnVtYmVyO1xyXG4gIFxyXG4gIC8vIENvbmZpZ3VyYWNpb25lcyBkZSBzZWd1cmlkYWRcclxuICBzZWN1cml0eUxldmVsPzogJ2Jhc2ljJyB8ICdzdGFuZGFyZCcgfCAnaGlnaCcgfCAnY3JpdGljYWwnO1xyXG4gIGVuY3J5cHREYXRhPzogYm9vbGVhbjtcclxuICBcclxuICAvLyBDb25maWd1cmFjaW9uZXMgZGUgcGVyZm9ybWFuY2VcclxuICBjb21wcmVzc2lvbkxldmVsPzogbnVtYmVyO1xyXG4gIG1heE1lbW9yeVVzYWdlPzogbnVtYmVyO1xyXG4gIGV2aWN0aW9uUG9saWN5PzogJ2xydScgfCAnbGZ1JyB8ICd0dGwnIHwgJ3JhbmRvbSc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVNZXRyaWNzIHtcclxuICBoaXRzOiBudW1iZXI7XHJcbiAgbWlzc2VzOiBudW1iZXI7XHJcbiAgaGl0UmF0ZTogbnVtYmVyO1xyXG4gIGF2Z1Jlc3BvbnNlVGltZTogbnVtYmVyO1xyXG4gIG1lbW9yeVVzYWdlOiBudW1iZXI7XHJcbiAgZXZpY3Rpb25zOiBudW1iZXI7XHJcbiAgZXJyb3JzOiBudW1iZXI7XHJcbiAgbGFzdEFjY2Vzczogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlSW52YWxpZGF0aW9uRXZlbnQge1xyXG4gIHBhdHRlcm46IHN0cmluZztcclxuICByZWFzb246ICdtYW51YWwnIHwgJ3R0bF9leHBpcmVkJyB8ICdkZXBlbmRlbmN5X2NoYW5nZWQnIHwgJ21lbW9yeV9wcmVzc3VyZSc7XHJcbiAgYWZmZWN0ZWRLZXlzOiBzdHJpbmdbXTtcclxuICB0aW1lc3RhbXA6IHN0cmluZztcclxuICB0cmlnZ2VyZWRCeT86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDYWNoZVdhcm11cEpvYiB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBwYXR0ZXJuOiBzdHJpbmc7XHJcbiAgc3RyYXRlZ3k6ICdlYWdlcicgfCAnbGF6eScgfCAnc2NoZWR1bGVkJztcclxuICBpbnRlcnZhbD86IG51bWJlcjtcclxuICBsYXN0UnVuPzogc3RyaW5nO1xyXG4gIG5leHRSdW4/OiBzdHJpbmc7XHJcbiAgc3RhdHVzOiAncGVuZGluZycgfCAncnVubmluZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnO1xyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBDT05GSUdVUkFDSU9ORVMgRU5URVJQUklTRSBQUkVERUZJTklEQVNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmV4cG9ydCBjb25zdCBFTlRFUlBSSVNFX0NBQ0hFX0NPTkZJR1M6IFJlY29yZDxzdHJpbmcsIEVudGVycHJpc2VDYWNoZUNvbmZpZz4gPSB7XHJcbiAgLy8gQ2FjaGUgY3LDrXRpY28gcGFyYSBkYXRvcyBkZSBhdXRlbnRpY2FjacOzblxyXG4gIEFVVEhfQ1JJVElDQUw6IHtcclxuICAgIC4uLkNBQ0hFX0NPTkZJR1MuU1lTVEVNX0NPTkZJRyxcclxuICAgIHR0bDogMzAwLCAvLyA1IG1pbnV0b3NcclxuICAgIHByZWZpeDogJ2F1dGhfY3JpdGljYWwnLFxyXG4gICAgZW5hYmxlQXVkaXRMb2dnaW5nOiB0cnVlLFxyXG4gICAgZW5hYmxlTWV0cmljczogdHJ1ZSxcclxuICAgIGVuYWJsZUludmFsaWRhdGlvbjogdHJ1ZSxcclxuICAgIHNlY3VyaXR5TGV2ZWw6ICdjcml0aWNhbCcsXHJcbiAgICBlbmNyeXB0RGF0YTogdHJ1ZSxcclxuICAgIGNvbXByZXNzaW9uTGV2ZWw6IDksXHJcbiAgICBldmljdGlvblBvbGljeTogJ3R0bCdcclxuICB9LFxyXG5cclxuICAvLyBDYWNoZSBwYXJhIGRhdG9zIGRlIHByb2R1Y3RvcyBjb24gaW52YWxpZGFjacOzbiBpbnRlbGlnZW50ZVxyXG4gIFBST0RVQ1RTX1NNQVJUOiB7XHJcbiAgICAuLi5DQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSxcclxuICAgIHR0bDogMTgwMCwgLy8gMzAgbWludXRvc1xyXG4gICAgcHJlZml4OiAncHJvZHVjdHNfc21hcnQnLFxyXG4gICAgZW5hYmxlQXVkaXRMb2dnaW5nOiBmYWxzZSxcclxuICAgIGVuYWJsZU1ldHJpY3M6IHRydWUsXHJcbiAgICBlbmFibGVJbnZhbGlkYXRpb246IHRydWUsXHJcbiAgICBlbmFibGVXYXJtdXA6IHRydWUsXHJcbiAgICBpbnZhbGlkYXRpb25QYXR0ZXJuczogWydwcm9kdWN0OionLCAnY2F0ZWdvcnk6KicsICdpbnZlbnRvcnk6KiddLFxyXG4gICAgZGVwZW5kZW50S2V5czogWydjYXRlZ29yaWVzJywgJ2JyYW5kcycsICdwcmljaW5nJ10sXHJcbiAgICB3YXJtdXBTdHJhdGVneTogJ3NjaGVkdWxlZCcsXHJcbiAgICB3YXJtdXBJbnRlcnZhbDogMzYwMCwgLy8gMSBob3JhXHJcbiAgICBzZWN1cml0eUxldmVsOiAnc3RhbmRhcmQnLFxyXG4gICAgY29tcHJlc3Npb25MZXZlbDogNixcclxuICAgIGV2aWN0aW9uUG9saWN5OiAnbHJ1J1xyXG4gIH0sXHJcblxyXG4gIC8vIENhY2hlIHBhcmEgQVBJcyBww7pibGljYXMgY29uIGFsdGEgcGVyZm9ybWFuY2VcclxuICBQVUJMSUNfUEVSRk9STUFOQ0U6IHtcclxuICAgIHR0bDogNjAwLCAvLyAxMCBtaW51dG9zXHJcbiAgICBwcmVmaXg6ICdwdWJsaWNfcGVyZicsXHJcbiAgICBjb21wcmVzczogdHJ1ZSxcclxuICAgIHNlcmlhbGl6ZTogdHJ1ZSxcclxuICAgIGVuYWJsZUF1ZGl0TG9nZ2luZzogZmFsc2UsXHJcbiAgICBlbmFibGVNZXRyaWNzOiB0cnVlLFxyXG4gICAgZW5hYmxlSW52YWxpZGF0aW9uOiB0cnVlLFxyXG4gICAgZW5hYmxlV2FybXVwOiB0cnVlLFxyXG4gICAgd2FybXVwU3RyYXRlZ3k6ICdlYWdlcicsXHJcbiAgICBzZWN1cml0eUxldmVsOiAnYmFzaWMnLFxyXG4gICAgY29tcHJlc3Npb25MZXZlbDogMyxcclxuICAgIG1heE1lbW9yeVVzYWdlOiAxMDAgKiAxMDI0ICogMTAyNCwgLy8gMTAwTUJcclxuICAgIGV2aWN0aW9uUG9saWN5OiAnbGZ1J1xyXG4gIH0sXHJcblxyXG4gIC8vIENhY2hlIHBhcmEgc2VzaW9uZXMgZGUgdXN1YXJpb1xyXG4gIFVTRVJfU0VTU0lPTlM6IHtcclxuICAgIHR0bDogNzIwMCwgLy8gMiBob3Jhc1xyXG4gICAgcHJlZml4OiAndXNlcl9zZXNzaW9ucycsXHJcbiAgICBjb21wcmVzczogZmFsc2UsXHJcbiAgICBzZXJpYWxpemU6IHRydWUsXHJcbiAgICBlbmFibGVBdWRpdExvZ2dpbmc6IHRydWUsXHJcbiAgICBlbmFibGVNZXRyaWNzOiB0cnVlLFxyXG4gICAgZW5hYmxlSW52YWxpZGF0aW9uOiB0cnVlLFxyXG4gICAgc2VjdXJpdHlMZXZlbDogJ2hpZ2gnLFxyXG4gICAgZW5jcnlwdERhdGE6IHRydWUsXHJcbiAgICBldmljdGlvblBvbGljeTogJ3R0bCdcclxuICB9LFxyXG5cclxuICAvLyBDYWNoZSBwYXJhIG3DqXRyaWNhcyB5IGFuYWx5dGljc1xyXG4gIEFOQUxZVElDU19EQVRBOiB7XHJcbiAgICB0dGw6IDkwMCwgLy8gMTUgbWludXRvc1xyXG4gICAgcHJlZml4OiAnYW5hbHl0aWNzJyxcclxuICAgIGNvbXByZXNzOiB0cnVlLFxyXG4gICAgc2VyaWFsaXplOiB0cnVlLFxyXG4gICAgZW5hYmxlQXVkaXRMb2dnaW5nOiBmYWxzZSxcclxuICAgIGVuYWJsZU1ldHJpY3M6IHRydWUsXHJcbiAgICBlbmFibGVJbnZhbGlkYXRpb246IHRydWUsXHJcbiAgICBlbmFibGVXYXJtdXA6IHRydWUsXHJcbiAgICB3YXJtdXBTdHJhdGVneTogJ2xhenknLFxyXG4gICAgc2VjdXJpdHlMZXZlbDogJ3N0YW5kYXJkJyxcclxuICAgIGNvbXByZXNzaW9uTGV2ZWw6IDgsXHJcbiAgICBldmljdGlvblBvbGljeTogJ2xydSdcclxuICB9XHJcbn07XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBTSVNURU1BIEVOVEVSUFJJU0UgREUgQ0FDSMOJXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5leHBvcnQgY2xhc3MgRW50ZXJwcmlzZUNhY2hlU3lzdGVtIHtcclxuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRW50ZXJwcmlzZUNhY2hlU3lzdGVtO1xyXG4gIHByaXZhdGUgbWV0cmljczogTWFwPHN0cmluZywgQ2FjaGVNZXRyaWNzPiA9IG5ldyBNYXAoKTtcclxuICBwcml2YXRlIGludmFsaWRhdGlvbkpvYnM6IE1hcDxzdHJpbmcsIENhY2hlSW52YWxpZGF0aW9uRXZlbnQ+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgd2FybXVwSm9iczogTWFwPHN0cmluZywgQ2FjaGVXYXJtdXBKb2I+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG5cclxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cclxuXHJcbiAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBFbnRlcnByaXNlQ2FjaGVTeXN0ZW0ge1xyXG4gICAgaWYgKCFFbnRlcnByaXNlQ2FjaGVTeXN0ZW0uaW5zdGFuY2UpIHtcclxuICAgICAgRW50ZXJwcmlzZUNhY2hlU3lzdGVtLmluc3RhbmNlID0gbmV3IEVudGVycHJpc2VDYWNoZVN5c3RlbSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEVudGVycHJpc2VDYWNoZVN5c3RlbS5pbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaWNpYWxpemEgZWwgc2lzdGVtYSBlbnRlcnByaXNlIGRlIGNhY2jDqVxyXG4gICAqL1xyXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSB7cmV0dXJuO31cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBJbmljaWFsaXphciBqb2JzIGRlIHdhcm11cCBwcm9ncmFtYWRvc1xyXG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVXYXJtdXBKb2JzKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBJbmljaWFsaXphciBsaW1waWV6YSBhdXRvbcOhdGljYVxyXG4gICAgICB0aGlzLnN0YXJ0Q2xlYW51cFNjaGVkdWxlcigpO1xyXG4gICAgICBcclxuICAgICAgLy8gSW5pY2lhbGl6YXIgbW9uaXRvcmVvIGRlIG1lbW9yaWFcclxuICAgICAgdGhpcy5zdGFydE1lbW9yeU1vbml0b3JpbmcoKTtcclxuICAgICAgXHJcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbRU5URVJQUklTRV9DQUNIRV0gU2lzdGVtYSBpbmljaWFsaXphZG8gY29ycmVjdGFtZW50ZScpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGluaWNpYWxpemFuZG8gc2lzdGVtYTonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT2J0aWVuZSBkYXRvcyBkZWwgY2FjaMOpIGNvbiBmdW5jaW9uYWxpZGFkZXMgZW50ZXJwcmlzZVxyXG4gICAqL1xyXG4gIGFzeW5jIGdldDxUPihcclxuICAgIGtleTogc3RyaW5nLCBcclxuICAgIGNvbmZpZzogRW50ZXJwcmlzZUNhY2hlQ29uZmlnLFxyXG4gICAgY29udGV4dD86IEVudGVycHJpc2VBdXRoQ29udGV4dFxyXG4gICk6IFByb21pc2U8VCB8IG51bGw+IHtcclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCBmdWxsS2V5ID0gdGhpcy5nZW5lcmF0ZUtleShjb25maWcsIGtleSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVmVyaWZpY2FyIHBlcm1pc29zIGRlIGFjY2VzbyBzaSBlcyBuZWNlc2FyaW9cclxuICAgICAgaWYgKGNvbmZpZy5zZWN1cml0eUxldmVsID09PSAnY3JpdGljYWwnICYmIGNvbnRleHQpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnZlcmlmeUFjY2VzcyhmdWxsS2V5LCBjb250ZXh0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW50ZW50YXIgb2J0ZW5lciBkZWwgY2FjaMOpXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlTWFuYWdlci5nZXQ8VD4oa2V5LCBjb25maWcpO1xyXG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG5cclxuICAgICAgLy8gQWN0dWFsaXphciBtw6l0cmljYXNcclxuICAgICAgaWYgKGNvbmZpZy5lbmFibGVNZXRyaWNzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNZXRyaWNzKGZ1bGxLZXksIHJlc3VsdCAhPT0gbnVsbCwgcmVzcG9uc2VUaW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVnaXN0cmFyIGFjY2VzbyBzaSBlc3TDoSBoYWJpbGl0YWRvXHJcbiAgICAgIGlmIChjb25maWcuZW5hYmxlQXVkaXRMb2dnaW5nICYmIGNvbnRleHQpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvZ0NhY2hlQWNjZXNzKCdHRVQnLCBmdWxsS2V5LCByZXN1bHQgIT09IG51bGwsIGNvbnRleHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcclxuICAgICAgXHJcbiAgICAgIC8vIEFjdHVhbGl6YXIgbcOpdHJpY2FzIGRlIGVycm9yXHJcbiAgICAgIGlmIChjb25maWcuZW5hYmxlTWV0cmljcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlRXJyb3JNZXRyaWNzKGZ1bGxLZXksIHJlc3BvbnNlVGltZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tFTlRFUlBSSVNFX0NBQ0hFXSBFcnJvciBlbiBnZXQ6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVzdGFibGVjZSBkYXRvcyBlbiBlbCBjYWNow6kgY29uIGZ1bmNpb25hbGlkYWRlcyBlbnRlcnByaXNlXHJcbiAgICovXHJcbiAgYXN5bmMgc2V0PFQ+KFxyXG4gICAga2V5OiBzdHJpbmcsIFxyXG4gICAgdmFsdWU6IFQsIFxyXG4gICAgY29uZmlnOiBFbnRlcnByaXNlQ2FjaGVDb25maWcsXHJcbiAgICBjb250ZXh0PzogRW50ZXJwcmlzZUF1dGhDb250ZXh0XHJcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgZnVsbEtleSA9IHRoaXMuZ2VuZXJhdGVLZXkoY29uZmlnLCBrZXkpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZlcmlmaWNhciBwZXJtaXNvcyBkZSBlc2NyaXR1cmEgc2kgZXMgbmVjZXNhcmlvXHJcbiAgICAgIGlmIChjb25maWcuc2VjdXJpdHlMZXZlbCA9PT0gJ2NyaXRpY2FsJyAmJiBjb250ZXh0KSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy52ZXJpZnlXcml0ZUFjY2VzcyhmdWxsS2V5LCBjb250ZXh0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRW5jcmlwdGFyIGRhdG9zIHNpIGVzdMOhIGNvbmZpZ3VyYWRvXHJcbiAgICAgIGxldCBwcm9jZXNzZWRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICBpZiAoY29uZmlnLmVuY3J5cHREYXRhKSB7XHJcbiAgICAgICAgcHJvY2Vzc2VkVmFsdWUgPSBhd2FpdCB0aGlzLmVuY3J5cHREYXRhKHZhbHVlKSBhcyBUO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFc3RhYmxlY2VyIGVuIGNhY2jDqVxyXG4gICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgY2FjaGVNYW5hZ2VyLnNldChrZXksIHByb2Nlc3NlZFZhbHVlLCBjb25maWcpO1xyXG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xyXG5cclxuICAgICAgLy8gQWN0dWFsaXphciBtw6l0cmljYXNcclxuICAgICAgaWYgKGNvbmZpZy5lbmFibGVNZXRyaWNzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTZXRNZXRyaWNzKGZ1bGxLZXksIHN1Y2Nlc3MsIHJlc3BvbnNlVGltZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlZ2lzdHJhciBlc2NyaXR1cmEgc2kgZXN0w6EgaGFiaWxpdGFkb1xyXG4gICAgICBpZiAoY29uZmlnLmVuYWJsZUF1ZGl0TG9nZ2luZyAmJiBjb250ZXh0KSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5sb2dDYWNoZUFjY2VzcygnU0VUJywgZnVsbEtleSwgc3VjY2VzcywgY29udGV4dCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByb2dyYW1hciBpbnZhbGlkYWNpw7NuIGRlIGRlcGVuZGVuY2lhcyBzaSBlcyBuZWNlc2FyaW9cclxuICAgICAgaWYgKGNvbmZpZy5lbmFibGVJbnZhbGlkYXRpb24gJiYgY29uZmlnLmRlcGVuZGVudEtleXMpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlRGVwZW5kZW5jeUludmFsaWRhdGlvbihmdWxsS2V5LCBjb25maWcuZGVwZW5kZW50S2V5cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdWNjZXNzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcclxuICAgICAgXHJcbiAgICAgIC8vIEFjdHVhbGl6YXIgbcOpdHJpY2FzIGRlIGVycm9yXHJcbiAgICAgIGlmIChjb25maWcuZW5hYmxlTWV0cmljcykge1xyXG4gICAgICAgIHRoaXMudXBkYXRlRXJyb3JNZXRyaWNzKGZ1bGxLZXksIHJlc3BvbnNlVGltZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tFTlRFUlBSSVNFX0NBQ0hFXSBFcnJvciBlbiBzZXQ6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZhbGlkYWNpw7NuIGludGVsaWdlbnRlIGRlIGNhY2jDqVxyXG4gICAqL1xyXG4gIGFzeW5jIGludmFsaWRhdGUoXHJcbiAgICBwYXR0ZXJuOiBzdHJpbmcsIFxyXG4gICAgcmVhc29uOiBDYWNoZUludmFsaWRhdGlvbkV2ZW50WydyZWFzb24nXSA9ICdtYW51YWwnLFxyXG4gICAgY29udGV4dD86IEVudGVycHJpc2VBdXRoQ29udGV4dFxyXG4gICk6IFByb21pc2U8c3RyaW5nW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGFmZmVjdGVkS2V5cyA9IGF3YWl0IHRoaXMuZmluZEtleXNCeVBhdHRlcm4ocGF0dGVybik7XHJcbiAgICAgIFxyXG4gICAgICAvLyBFbGltaW5hciBjbGF2ZXMgZGVsIGNhY2jDqVxyXG4gICAgICBjb25zdCBkZWxldGlvblByb21pc2VzID0gYWZmZWN0ZWRLZXlzLm1hcChrZXkgPT4gcmVkaXNDYWNoZS5kZWwoa2V5KSk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGRlbGV0aW9uUHJvbWlzZXMpO1xyXG5cclxuICAgICAgLy8gUmVnaXN0cmFyIGV2ZW50byBkZSBpbnZhbGlkYWNpw7NuXHJcbiAgICAgIGNvbnN0IGludmFsaWRhdGlvbkV2ZW50OiBDYWNoZUludmFsaWRhdGlvbkV2ZW50ID0ge1xyXG4gICAgICAgIHBhdHRlcm4sXHJcbiAgICAgICAgcmVhc29uLFxyXG4gICAgICAgIGFmZmVjdGVkS2V5cyxcclxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB0cmlnZ2VyZWRCeTogY29udGV4dD8udXNlcklkXHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLmludmFsaWRhdGlvbkpvYnMuc2V0KFxyXG4gICAgICAgIGBpbnZfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxyXG4gICAgICAgIGludmFsaWRhdGlvbkV2ZW50XHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBSZWdpc3RyYXIgZW4gYXVkaXRvcsOtYSBzaSBoYXkgY29udGV4dG9cclxuICAgICAgaWYgKGNvbnRleHQpIHtcclxuICAgICAgICBhd2FpdCBlbnRlcnByaXNlQXVkaXRTeXN0ZW0ubG9nRW50ZXJwcmlzZUV2ZW50KHtcclxuICAgICAgICAgIHVzZXJfaWQ6IGNvbnRleHQudXNlcklkLFxyXG4gICAgICAgICAgZXZlbnRfdHlwZTogJ0NBQ0hFX0lOVkFMSURBVElPTicgYXMgYW55LFxyXG4gICAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdzeXN0ZW1fb3BlcmF0aW9uJyxcclxuICAgICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyBhcyBhbnksXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENhY2hlIGludmFsaWRhdGlvbjogJHtwYXR0ZXJufWAsXHJcbiAgICAgICAgICBtZXRhZGF0YToge1xyXG4gICAgICAgICAgICBwYXR0ZXJuLFxyXG4gICAgICAgICAgICByZWFzb24sXHJcbiAgICAgICAgICAgIGFmZmVjdGVkX2tleXNfY291bnQ6IGFmZmVjdGVkS2V5cy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGFmZmVjdGVkX2tleXM6IGFmZmVjdGVkS2V5cy5zbGljZSgwLCAxMCkgLy8gUHJpbWVyYXMgMTAgcGFyYSBubyBzYXR1cmFyXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgaXBfYWRkcmVzczogY29udGV4dC5pcEFkZHJlc3MsXHJcbiAgICAgICAgICB1c2VyX2FnZW50OiBjb250ZXh0LnVzZXJBZ2VudFxyXG4gICAgICAgIH0sIGNvbnRleHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgW0VOVEVSUFJJU0VfQ0FDSEVdIEludmFsaWRhdGVkICR7YWZmZWN0ZWRLZXlzLmxlbmd0aH0ga2V5cyBmb3IgcGF0dGVybjogJHtwYXR0ZXJufWApO1xyXG4gICAgICByZXR1cm4gYWZmZWN0ZWRLZXlzO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGVuIGludmFsaWRhY2nDs246JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXYXJtdXAgaW50ZWxpZ2VudGUgZGUgY2FjaMOpXHJcbiAgICovXHJcbiAgYXN5bmMgd2FybXVwKFxyXG4gICAga2V5czogc3RyaW5nW10sIFxyXG4gICAgY29uZmlnOiBFbnRlcnByaXNlQ2FjaGVDb25maWcsXHJcbiAgICBkYXRhRmV0Y2hlcjogKGtleTogc3RyaW5nKSA9PiBQcm9taXNlPGFueT5cclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IGpvYklkID0gYHdhcm11cF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XHJcbiAgICBcclxuICAgIGNvbnN0IHdhcm11cEpvYjogQ2FjaGVXYXJtdXBKb2IgPSB7XHJcbiAgICAgIGlkOiBqb2JJZCxcclxuICAgICAgcGF0dGVybjoga2V5cy5qb2luKCcsJyksXHJcbiAgICAgIHN0cmF0ZWd5OiBjb25maWcud2FybXVwU3RyYXRlZ3kgfHwgJ2xhenknLFxyXG4gICAgICBpbnRlcnZhbDogY29uZmlnLndhcm11cEludGVydmFsLFxyXG4gICAgICBsYXN0UnVuOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgIHN0YXR1czogJ3J1bm5pbmcnXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMud2FybXVwSm9icy5zZXQoam9iSWQsIHdhcm11cEpvYik7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgd2FybXVwUHJvbWlzZXMgPSBrZXlzLm1hcChhc3luYyAoa2V5KSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSB5YSBleGlzdGUgZW4gY2FjaMOpXHJcbiAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGF3YWl0IHRoaXMuZ2V0KGtleSwgY29uZmlnKTtcclxuICAgICAgICAgIGlmIChleGlzdGluZyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIFlhIGVzdMOhIGVuIGNhY2jDqVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE9idGVuZXIgZGF0b3MgeSBjYWNoZWFyXHJcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZGF0YUZldGNoZXIoa2V5KTtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KGtleSwgZGF0YSwgY29uZmlnKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKGBbRU5URVJQUklTRV9DQUNIRV0gRXJyb3Igd2FybWluZyB1cCBrZXkgJHtrZXl9OmAsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod2FybXVwUHJvbWlzZXMpO1xyXG4gICAgICBcclxuICAgICAgLy8gQWN0dWFsaXphciBlc3RhZG8gZGVsIGpvYlxyXG4gICAgICB3YXJtdXBKb2Iuc3RhdHVzID0gJ2NvbXBsZXRlZCc7XHJcbiAgICAgIHdhcm11cEpvYi5uZXh0UnVuID0gY29uZmlnLndhcm11cEludGVydmFsID8gXHJcbiAgICAgICAgbmV3IERhdGUoRGF0ZS5ub3coKSArIGNvbmZpZy53YXJtdXBJbnRlcnZhbCAqIDEwMDApLnRvSVNPU3RyaW5nKCkgOiBcclxuICAgICAgICB1bmRlZmluZWQ7XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhgW0VOVEVSUFJJU0VfQ0FDSEVdIFdhcm11cCBjb21wbGV0ZWQgZm9yICR7a2V5cy5sZW5ndGh9IGtleXNgKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHdhcm11cEpvYi5zdGF0dXMgPSAnZmFpbGVkJztcclxuICAgICAgY29uc29sZS5lcnJvcignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGVuIHdhcm11cDonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPYnRpZW5lIG3DqXRyaWNhcyBkZWwgc2lzdGVtYSBkZSBjYWNow6lcclxuICAgKi9cclxuICBnZXRNZXRyaWNzKCk6IFJlY29yZDxzdHJpbmcsIENhY2hlTWV0cmljcz4ge1xyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLm1ldHJpY3MpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT2J0aWVuZSBlc3RhZMOtc3RpY2FzIGRlIGludmFsaWRhY2nDs25cclxuICAgKi9cclxuICBnZXRJbnZhbGlkYXRpb25TdGF0cygpOiBDYWNoZUludmFsaWRhdGlvbkV2ZW50W10ge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5pbnZhbGlkYXRpb25Kb2JzLnZhbHVlcygpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgZXN0YWTDrXN0aWNhcyBkZSB3YXJtdXBcclxuICAgKi9cclxuICBnZXRXYXJtdXBTdGF0cygpOiBDYWNoZVdhcm11cEpvYltdIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMud2FybXVwSm9icy52YWx1ZXMoKSk7XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIE3DiVRPRE9TIFBSSVZBRE9TXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZUtleShjb25maWc6IEVudGVycHJpc2VDYWNoZUNvbmZpZywga2V5OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGAke2NvbmZpZy5wcmVmaXh9OiR7a2V5fWA7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHZlcmlmeUFjY2VzcyhrZXk6IHN0cmluZywgY29udGV4dDogRW50ZXJwcmlzZUF1dGhDb250ZXh0KTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAvLyBWZXJpZmljYXIgcGVybWlzb3MgZGUgYWNjZXNvIHBhcmEgZGF0b3MgY3LDrXRpY29zXHJcbiAgICBpZiAoIWNvbnRleHQucGVybWlzc2lvbnMuaW5jbHVkZXMoJ2NhY2hlX2FjY2VzcycpICYmIFxyXG4gICAgICAgICFjb250ZXh0LnBlcm1pc3Npb25zLmluY2x1ZGVzKCdhZG1pbl9hY2Nlc3MnKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3VmZmljaWVudCBwZXJtaXNzaW9ucyBmb3IgY2FjaGUgYWNjZXNzJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHZlcmlmeVdyaXRlQWNjZXNzKGtleTogc3RyaW5nLCBjb250ZXh0OiBFbnRlcnByaXNlQXV0aENvbnRleHQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIFZlcmlmaWNhciBwZXJtaXNvcyBkZSBlc2NyaXR1cmEgcGFyYSBkYXRvcyBjcsOtdGljb3NcclxuICAgIGlmICghY29udGV4dC5wZXJtaXNzaW9ucy5pbmNsdWRlcygnY2FjaGVfd3JpdGUnKSAmJiBcclxuICAgICAgICAhY29udGV4dC5wZXJtaXNzaW9ucy5pbmNsdWRlcygnYWRtaW5fYWNjZXNzJykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMgZm9yIGNhY2hlIHdyaXRlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGVuY3J5cHREYXRhKGRhdGE6IGFueSk6IFByb21pc2U8YW55PiB7XHJcbiAgICAvLyBJbXBsZW1lbnRhY2nDs24gYsOhc2ljYSBkZSBlbmNyaXB0YWNpw7NuXHJcbiAgICAvLyBFbiBwcm9kdWNjacOzbiwgdXNhciB1bmEgbGlicmVyw61hIGRlIGVuY3JpcHRhY2nDs24gcm9idXN0YVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICBjb25zdCBlbmNvZGVkID0gQnVmZmVyLmZyb20oanNvblN0cmluZykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG4gICAgICByZXR1cm4geyBlbmNyeXB0ZWQ6IHRydWUsIGRhdGE6IGVuY29kZWQgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGVuY3JpcHRhbmRvIGRhdG9zOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZU1ldHJpY3Moa2V5OiBzdHJpbmcsIGhpdDogYm9vbGVhbiwgcmVzcG9uc2VUaW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5tZXRyaWNzLmdldChrZXkpIHx8IHtcclxuICAgICAgaGl0czogMCxcclxuICAgICAgbWlzc2VzOiAwLFxyXG4gICAgICBoaXRSYXRlOiAwLFxyXG4gICAgICBhdmdSZXNwb25zZVRpbWU6IDAsXHJcbiAgICAgIG1lbW9yeVVzYWdlOiAwLFxyXG4gICAgICBldmljdGlvbnM6IDAsXHJcbiAgICAgIGVycm9yczogMCxcclxuICAgICAgbGFzdEFjY2VzczogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChoaXQpIHtcclxuICAgICAgZXhpc3RpbmcuaGl0cysrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXhpc3RpbmcubWlzc2VzKys7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdG90YWxSZXF1ZXN0cyA9IGV4aXN0aW5nLmhpdHMgKyBleGlzdGluZy5taXNzZXM7XHJcbiAgICBleGlzdGluZy5oaXRSYXRlID0gdG90YWxSZXF1ZXN0cyA+IDAgPyBleGlzdGluZy5oaXRzIC8gdG90YWxSZXF1ZXN0cyA6IDA7XHJcbiAgICBleGlzdGluZy5hdmdSZXNwb25zZVRpbWUgPSAoZXhpc3RpbmcuYXZnUmVzcG9uc2VUaW1lICsgcmVzcG9uc2VUaW1lKSAvIDI7XHJcbiAgICBleGlzdGluZy5sYXN0QWNjZXNzID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG5cclxuICAgIHRoaXMubWV0cmljcy5zZXQoa2V5LCBleGlzdGluZyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZVNldE1ldHJpY3Moa2V5OiBzdHJpbmcsIHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3BvbnNlVGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMubWV0cmljcy5nZXQoa2V5KSB8fCB7XHJcbiAgICAgIGhpdHM6IDAsXHJcbiAgICAgIG1pc3NlczogMCxcclxuICAgICAgaGl0UmF0ZTogMCxcclxuICAgICAgYXZnUmVzcG9uc2VUaW1lOiAwLFxyXG4gICAgICBtZW1vcnlVc2FnZTogMCxcclxuICAgICAgZXZpY3Rpb25zOiAwLFxyXG4gICAgICBlcnJvcnM6IDAsXHJcbiAgICAgIGxhc3RBY2Nlc3M6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfTtcclxuXHJcbiAgICBleGlzdGluZy5hdmdSZXNwb25zZVRpbWUgPSAoZXhpc3RpbmcuYXZnUmVzcG9uc2VUaW1lICsgcmVzcG9uc2VUaW1lKSAvIDI7XHJcbiAgICBleGlzdGluZy5sYXN0QWNjZXNzID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG5cclxuICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICBleGlzdGluZy5lcnJvcnMrKztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1ldHJpY3Muc2V0KGtleSwgZXhpc3RpbmcpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB1cGRhdGVFcnJvck1ldHJpY3Moa2V5OiBzdHJpbmcsIHJlc3BvbnNlVGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMubWV0cmljcy5nZXQoa2V5KSB8fCB7XHJcbiAgICAgIGhpdHM6IDAsXHJcbiAgICAgIG1pc3NlczogMCxcclxuICAgICAgaGl0UmF0ZTogMCxcclxuICAgICAgYXZnUmVzcG9uc2VUaW1lOiAwLFxyXG4gICAgICBtZW1vcnlVc2FnZTogMCxcclxuICAgICAgZXZpY3Rpb25zOiAwLFxyXG4gICAgICBlcnJvcnM6IDAsXHJcbiAgICAgIGxhc3RBY2Nlc3M6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfTtcclxuXHJcbiAgICBleGlzdGluZy5lcnJvcnMrKztcclxuICAgIGV4aXN0aW5nLmF2Z1Jlc3BvbnNlVGltZSA9IChleGlzdGluZy5hdmdSZXNwb25zZVRpbWUgKyByZXNwb25zZVRpbWUpIC8gMjtcclxuICAgIGV4aXN0aW5nLmxhc3RBY2Nlc3MgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcblxyXG4gICAgdGhpcy5tZXRyaWNzLnNldChrZXksIGV4aXN0aW5nKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgbG9nQ2FjaGVBY2Nlc3MoXHJcbiAgICBvcGVyYXRpb246ICdHRVQnIHwgJ1NFVCcsXHJcbiAgICBrZXk6IHN0cmluZyxcclxuICAgIHN1Y2Nlc3M6IGJvb2xlYW4sXHJcbiAgICBjb250ZXh0OiBFbnRlcnByaXNlQXV0aENvbnRleHRcclxuICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5sb2dFbnRlcnByaXNlRXZlbnQoe1xyXG4gICAgICAgIHVzZXJfaWQ6IGNvbnRleHQudXNlcklkLFxyXG4gICAgICAgIGV2ZW50X3R5cGU6ICdDQUNIRV9BQ0NFU1MnIGFzIGFueSxcclxuICAgICAgICBldmVudF9jYXRlZ29yeTogJ3N5c3RlbV9vcGVyYXRpb24nLFxyXG4gICAgICAgIHNldmVyaXR5OiAnbG93JyBhcyBhbnksXHJcbiAgICAgICAgZGVzY3JpcHRpb246IGBDYWNoZSAke29wZXJhdGlvbn06ICR7a2V5fWAsXHJcbiAgICAgICAgbWV0YWRhdGE6IHtcclxuICAgICAgICAgIG9wZXJhdGlvbixcclxuICAgICAgICAgIGtleSxcclxuICAgICAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgICAgICBjYWNoZV9zeXN0ZW06ICdlbnRlcnByaXNlJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXBfYWRkcmVzczogY29udGV4dC5pcEFkZHJlc3MsXHJcbiAgICAgICAgdXNlcl9hZ2VudDogY29udGV4dC51c2VyQWdlbnRcclxuICAgICAgfSwgY29udGV4dCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1tFTlRFUlBSSVNFX0NBQ0hFXSBFcnJvciBsb2dnaW5nIGNhY2hlIGFjY2VzczonLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGZpbmRLZXlzQnlQYXR0ZXJuKHBhdHRlcm46IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFVzYXIgUmVkaXMgU0NBTiBwYXJhIGVuY29udHJhciBjbGF2ZXMgcG9yIHBhdHLDs25cclxuICAgICAgY29uc3Qga2V5czogc3RyaW5nW10gPSBbXTtcclxuICAgICAgY29uc3QgY2xpZW50ID0gcmVkaXNDYWNoZVsnY2xpZW50J107IC8vIEFjY2VkZXIgYWwgY2xpZW50ZSBSZWRpcyBpbnRlcm5vXHJcbiAgICAgIFxyXG4gICAgICBpZiAoY2xpZW50ICYmIHR5cGVvZiBjbGllbnQuc2NhblN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNsaWVudC5zY2FuU3RyZWFtKHtcclxuICAgICAgICAgIG1hdGNoOiBwYXR0ZXJuLFxyXG4gICAgICAgICAgY291bnQ6IDEwMFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgKHJlc3VsdEtleXM6IHN0cmluZ1tdKSA9PiB7XHJcbiAgICAgICAgICAgIGtleXMucHVzaCguLi5yZXN1bHRLZXlzKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlKGtleXMpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIChlcnJvcjogRXJyb3IpID0+IHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ga2V5cztcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tFTlRFUlBSSVNFX0NBQ0hFXSBFcnJvciBmaW5kaW5nIGtleXMgYnkgcGF0dGVybjonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc2NoZWR1bGVEZXBlbmRlbmN5SW52YWxpZGF0aW9uKGtleTogc3RyaW5nLCBkZXBlbmRlbnRLZXlzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgLy8gUHJvZ3JhbWFyIGludmFsaWRhY2nDs24gZGUgY2xhdmVzIGRlcGVuZGllbnRlc1xyXG4gICAgLy8gRXN0byBzZSBwb2Ryw61hIGltcGxlbWVudGFyIGNvbiB1biBqb2IgcXVldWUgY29tbyBCdWxsIG8gQWdlbmRhXHJcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcclxuICAgICAgZm9yIChjb25zdCBkZXBLZXkgb2YgZGVwZW5kZW50S2V5cykge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuaW52YWxpZGF0ZShkZXBLZXksICdkZXBlbmRlbmN5X2NoYW5nZWQnKTtcclxuICAgICAgfVxyXG4gICAgfSwgMTAwMCk7IC8vIDEgc2VndW5kbyBkZSBkZWxheVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplV2FybXVwSm9icygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIEluaWNpYWxpemFyIGpvYnMgZGUgd2FybXVwIHByb2dyYW1hZG9zXHJcbiAgICAvLyBFbiB1bmEgaW1wbGVtZW50YWNpw7NuIHJlYWwsIGVzdG8gc2UgY2FyZ2Fyw61hIGRlc2RlIHVuYSBiYXNlIGRlIGRhdG9zXHJcbiAgICBjb25zb2xlLmxvZygnW0VOVEVSUFJJU0VfQ0FDSEVdIFdhcm11cCBqb2JzIGluaXRpYWxpemVkJyk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXJ0Q2xlYW51cFNjaGVkdWxlcigpOiB2b2lkIHtcclxuICAgIC8vIExpbXBpYXIgbcOpdHJpY2FzIGFudGlndWFzIGNhZGEgaG9yYVxyXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG4gICAgICBjb25zdCBvbmVIb3VyQWdvID0gRGF0ZS5ub3coKSAtIDYwICogNjAgKiAxMDAwO1xyXG4gICAgICBcclxuICAgICAgZm9yIChjb25zdCBba2V5LCBtZXRyaWNzXSBvZiB0aGlzLm1ldHJpY3MuZW50cmllcygpKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdEFjY2Vzc1RpbWUgPSBuZXcgRGF0ZShtZXRyaWNzLmxhc3RBY2Nlc3MpLmdldFRpbWUoKTtcclxuICAgICAgICBpZiAobGFzdEFjY2Vzc1RpbWUgPCBvbmVIb3VyQWdvKSB7XHJcbiAgICAgICAgICB0aGlzLm1ldHJpY3MuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LCA2MCAqIDYwICogMTAwMCk7IC8vIDEgaG9yYVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGFydE1lbW9yeU1vbml0b3JpbmcoKTogdm9pZCB7XHJcbiAgICAvLyBNb25pdG9yZWFyIHVzbyBkZSBtZW1vcmlhIGNhZGEgNSBtaW51dG9zXHJcbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1lbW9yeVVzYWdlID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xyXG4gICAgICBcclxuICAgICAgaWYgKG1lbW9yeVVzYWdlLmhlYXBVc2VkID4gNTAwICogMTAyNCAqIDEwMjQpIHsgLy8gNTAwTUJcclxuICAgICAgICBjb25zb2xlLndhcm4oJ1tFTlRFUlBSSVNFX0NBQ0hFXSBIaWdoIG1lbW9yeSB1c2FnZSBkZXRlY3RlZDonLCBtZW1vcnlVc2FnZSk7XHJcbiAgICAgICAgLy8gQXF1w60gc2UgcG9kcsOtYSBpbXBsZW1lbnRhciBsaW1waWV6YSBhdXRvbcOhdGljYVxyXG4gICAgICB9XHJcbiAgICB9LCA1ICogNjAgKiAxMDAwKTsgLy8gNSBtaW51dG9zXHJcbiAgfVxyXG59XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBJTlNUQU5DSUEgU0lOR0xFVE9OIFkgVVRJTElEQURFU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZXhwb3J0IGNvbnN0IGVudGVycHJpc2VDYWNoZVN5c3RlbSA9IEVudGVycHJpc2VDYWNoZVN5c3RlbS5nZXRJbnN0YW5jZSgpO1xyXG5cclxuLyoqXHJcbiAqIEZ1bmNpb25lcyBkZSB1dGlsaWRhZCBwYXJhIGNhc29zIGNvbXVuZXNcclxuICovXHJcbmV4cG9ydCBjb25zdCBFbnRlcnByaXNlQ2FjaGVVdGlscyA9IHtcclxuICAvKipcclxuICAgKiBDYWNoZSBwYXJhIGRhdG9zIGRlIGF1dGVudGljYWNpw7NuIGNyw610aWNvc1xyXG4gICAqL1xyXG4gIGFzeW5jIGNhY2hlQXV0aERhdGE8VD4oa2V5OiBzdHJpbmcsIGZldGNoZXI6ICgpID0+IFByb21pc2U8VD4sIGNvbnRleHQ6IEVudGVycHJpc2VBdXRoQ29udGV4dCk6IFByb21pc2U8VD4ge1xyXG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgZW50ZXJwcmlzZUNhY2hlU3lzdGVtLmdldDxUPihrZXksIEVOVEVSUFJJU0VfQ0FDSEVfQ09ORklHUy5BVVRIX0NSSVRJQ0FMLCBjb250ZXh0KTtcclxuICAgIGlmIChjYWNoZWQgIT09IG51bGwpIHtyZXR1cm4gY2FjaGVkO31cclxuXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hlcigpO1xyXG4gICAgYXdhaXQgZW50ZXJwcmlzZUNhY2hlU3lzdGVtLnNldChrZXksIGRhdGEsIEVOVEVSUFJJU0VfQ0FDSEVfQ09ORklHUy5BVVRIX0NSSVRJQ0FMLCBjb250ZXh0KTtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENhY2hlIGludGVsaWdlbnRlIHBhcmEgcHJvZHVjdG9zXHJcbiAgICovXHJcbiAgYXN5bmMgY2FjaGVQcm9kdWN0RGF0YTxUPihrZXk6IHN0cmluZywgZmV0Y2hlcjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xyXG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgZW50ZXJwcmlzZUNhY2hlU3lzdGVtLmdldDxUPihrZXksIEVOVEVSUFJJU0VfQ0FDSEVfQ09ORklHUy5QUk9EVUNUU19TTUFSVCk7XHJcbiAgICBpZiAoY2FjaGVkICE9PSBudWxsKSB7cmV0dXJuIGNhY2hlZDt9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoZXIoKTtcclxuICAgIGF3YWl0IGVudGVycHJpc2VDYWNoZVN5c3RlbS5zZXQoa2V5LCBkYXRhLCBFTlRFUlBSSVNFX0NBQ0hFX0NPTkZJR1MuUFJPRFVDVFNfU01BUlQpO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FjaGUgZGUgYWx0YSBwZXJmb3JtYW5jZSBwYXJhIEFQSXMgcMO6YmxpY2FzXHJcbiAgICovXHJcbiAgYXN5bmMgY2FjaGVQdWJsaWNEYXRhPFQ+KGtleTogc3RyaW5nLCBmZXRjaGVyOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBhd2FpdCBlbnRlcnByaXNlQ2FjaGVTeXN0ZW0uZ2V0PFQ+KGtleSwgRU5URVJQUklTRV9DQUNIRV9DT05GSUdTLlBVQkxJQ19QRVJGT1JNQU5DRSk7XHJcbiAgICBpZiAoY2FjaGVkICE9PSBudWxsKSB7cmV0dXJuIGNhY2hlZDt9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoZXIoKTtcclxuICAgIGF3YWl0IGVudGVycHJpc2VDYWNoZVN5c3RlbS5zZXQoa2V5LCBkYXRhLCBFTlRFUlBSSVNFX0NBQ0hFX0NPTkZJR1MuUFVCTElDX1BFUkZPUk1BTkNFKTtcclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEludmFsaWRhY2nDs24gbWFzaXZhIHBvciBwYXRyb25lc1xyXG4gICAqL1xyXG4gIGFzeW5jIGludmFsaWRhdGVCeVBhdHRlcm5zKHBhdHRlcm5zOiBzdHJpbmdbXSwgY29udGV4dD86IEVudGVycHJpc2VBdXRoQ29udGV4dCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgaW52YWxpZGF0aW9uUHJvbWlzZXMgPSBwYXR0ZXJucy5tYXAocGF0dGVybiA9PiBcclxuICAgICAgZW50ZXJwcmlzZUNhY2hlU3lzdGVtLmludmFsaWRhdGUocGF0dGVybiwgJ21hbnVhbCcsIGNvbnRleHQpXHJcbiAgICApO1xyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoaW52YWxpZGF0aW9uUHJvbWlzZXMpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIkVOVEVSUFJJU0VfQ0FDSEVfQ09ORklHUyIsIkVudGVycHJpc2VDYWNoZVN5c3RlbSIsIkVudGVycHJpc2VDYWNoZVV0aWxzIiwiZW50ZXJwcmlzZUNhY2hlU3lzdGVtIiwiQVVUSF9DUklUSUNBTCIsIkNBQ0hFX0NPTkZJR1MiLCJTWVNURU1fQ09ORklHIiwidHRsIiwicHJlZml4IiwiZW5hYmxlQXVkaXRMb2dnaW5nIiwiZW5hYmxlTWV0cmljcyIsImVuYWJsZUludmFsaWRhdGlvbiIsInNlY3VyaXR5TGV2ZWwiLCJlbmNyeXB0RGF0YSIsImNvbXByZXNzaW9uTGV2ZWwiLCJldmljdGlvblBvbGljeSIsIlBST0RVQ1RTX1NNQVJUIiwiUFJPRFVDVF9EQVRBIiwiZW5hYmxlV2FybXVwIiwiaW52YWxpZGF0aW9uUGF0dGVybnMiLCJkZXBlbmRlbnRLZXlzIiwid2FybXVwU3RyYXRlZ3kiLCJ3YXJtdXBJbnRlcnZhbCIsIlBVQkxJQ19QRVJGT1JNQU5DRSIsImNvbXByZXNzIiwic2VyaWFsaXplIiwibWF4TWVtb3J5VXNhZ2UiLCJVU0VSX1NFU1NJT05TIiwiQU5BTFlUSUNTX0RBVEEiLCJtZXRyaWNzIiwiTWFwIiwiaW52YWxpZGF0aW9uSm9icyIsIndhcm11cEpvYnMiLCJpc0luaXRpYWxpemVkIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImluaXRpYWxpemUiLCJpbml0aWFsaXplV2FybXVwSm9icyIsInN0YXJ0Q2xlYW51cFNjaGVkdWxlciIsInN0YXJ0TWVtb3J5TW9uaXRvcmluZyIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsImdldCIsImtleSIsImNvbmZpZyIsImNvbnRleHQiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiZnVsbEtleSIsImdlbmVyYXRlS2V5IiwidmVyaWZ5QWNjZXNzIiwicmVzdWx0IiwiY2FjaGVNYW5hZ2VyIiwicmVzcG9uc2VUaW1lIiwidXBkYXRlTWV0cmljcyIsImxvZ0NhY2hlQWNjZXNzIiwidXBkYXRlRXJyb3JNZXRyaWNzIiwic2V0IiwidmFsdWUiLCJ2ZXJpZnlXcml0ZUFjY2VzcyIsInByb2Nlc3NlZFZhbHVlIiwic3VjY2VzcyIsInVwZGF0ZVNldE1ldHJpY3MiLCJzY2hlZHVsZURlcGVuZGVuY3lJbnZhbGlkYXRpb24iLCJpbnZhbGlkYXRlIiwicGF0dGVybiIsInJlYXNvbiIsImFmZmVjdGVkS2V5cyIsImZpbmRLZXlzQnlQYXR0ZXJuIiwiZGVsZXRpb25Qcm9taXNlcyIsIm1hcCIsInJlZGlzQ2FjaGUiLCJkZWwiLCJQcm9taXNlIiwiYWxsIiwiaW52YWxpZGF0aW9uRXZlbnQiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInRyaWdnZXJlZEJ5IiwidXNlcklkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiZW50ZXJwcmlzZUF1ZGl0U3lzdGVtIiwibG9nRW50ZXJwcmlzZUV2ZW50IiwidXNlcl9pZCIsImV2ZW50X3R5cGUiLCJldmVudF9jYXRlZ29yeSIsInNldmVyaXR5IiwiZGVzY3JpcHRpb24iLCJtZXRhZGF0YSIsImFmZmVjdGVkX2tleXNfY291bnQiLCJsZW5ndGgiLCJhZmZlY3RlZF9rZXlzIiwic2xpY2UiLCJpcF9hZGRyZXNzIiwiaXBBZGRyZXNzIiwidXNlcl9hZ2VudCIsInVzZXJBZ2VudCIsIndhcm11cCIsImtleXMiLCJkYXRhRmV0Y2hlciIsImpvYklkIiwid2FybXVwSm9iIiwiaWQiLCJqb2luIiwic3RyYXRlZ3kiLCJpbnRlcnZhbCIsImxhc3RSdW4iLCJzdGF0dXMiLCJ3YXJtdXBQcm9taXNlcyIsImV4aXN0aW5nIiwiZGF0YSIsIndhcm4iLCJuZXh0UnVuIiwidW5kZWZpbmVkIiwiZ2V0TWV0cmljcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZ2V0SW52YWxpZGF0aW9uU3RhdHMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJnZXRXYXJtdXBTdGF0cyIsInBlcm1pc3Npb25zIiwiaW5jbHVkZXMiLCJFcnJvciIsImpzb25TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiZW5jb2RlZCIsIkJ1ZmZlciIsImVuY3J5cHRlZCIsImhpdCIsImhpdHMiLCJtaXNzZXMiLCJoaXRSYXRlIiwiYXZnUmVzcG9uc2VUaW1lIiwibWVtb3J5VXNhZ2UiLCJldmljdGlvbnMiLCJlcnJvcnMiLCJsYXN0QWNjZXNzIiwidG90YWxSZXF1ZXN0cyIsIm9wZXJhdGlvbiIsImNhY2hlX3N5c3RlbSIsImNsaWVudCIsInNjYW5TdHJlYW0iLCJzdHJlYW0iLCJtYXRjaCIsImNvdW50IiwicmVzb2x2ZSIsInJlamVjdCIsIm9uIiwicmVzdWx0S2V5cyIsInB1c2giLCJzZXRUaW1lb3V0IiwiZGVwS2V5Iiwic2V0SW50ZXJ2YWwiLCJvbmVIb3VyQWdvIiwiZW50cmllcyIsImxhc3RBY2Nlc3NUaW1lIiwiZ2V0VGltZSIsImRlbGV0ZSIsInByb2Nlc3MiLCJoZWFwVXNlZCIsImNhY2hlQXV0aERhdGEiLCJmZXRjaGVyIiwiY2FjaGVkIiwiY2FjaGVQcm9kdWN0RGF0YSIsImNhY2hlUHVibGljRGF0YSIsImludmFsaWRhdGVCeVBhdHRlcm5zIiwicGF0dGVybnMiLCJpbnZhbGlkYXRpb25Qcm9taXNlcyJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDOzs7Ozs7Ozs7OztRQXNFWUE7ZUFBQUE7O1FBcUZBQztlQUFBQTs7UUF5ZUFDO2VBQUFBOztRQUxBQztlQUFBQTs7OzhCQTduQmlEO3VCQUNuQzt1Q0FDVztBQWtFL0IsTUFBTUgsMkJBQWtFO0lBQzdFLDRDQUE0QztJQUM1Q0ksZUFBZTtRQUNiLEdBQUdDLDJCQUFhLENBQUNDLGFBQWE7UUFDOUJDLEtBQUs7UUFDTEMsUUFBUTtRQUNSQyxvQkFBb0I7UUFDcEJDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCQyxlQUFlO1FBQ2ZDLGFBQWE7UUFDYkMsa0JBQWtCO1FBQ2xCQyxnQkFBZ0I7SUFDbEI7SUFFQSw2REFBNkQ7SUFDN0RDLGdCQUFnQjtRQUNkLEdBQUdYLDJCQUFhLENBQUNZLFlBQVk7UUFDN0JWLEtBQUs7UUFDTEMsUUFBUTtRQUNSQyxvQkFBb0I7UUFDcEJDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCTyxjQUFjO1FBQ2RDLHNCQUFzQjtZQUFDO1lBQWE7WUFBYztTQUFjO1FBQ2hFQyxlQUFlO1lBQUM7WUFBYztZQUFVO1NBQVU7UUFDbERDLGdCQUFnQjtRQUNoQkMsZ0JBQWdCO1FBQ2hCVixlQUFlO1FBQ2ZFLGtCQUFrQjtRQUNsQkMsZ0JBQWdCO0lBQ2xCO0lBRUEsZ0RBQWdEO0lBQ2hEUSxvQkFBb0I7UUFDbEJoQixLQUFLO1FBQ0xDLFFBQVE7UUFDUmdCLFVBQVU7UUFDVkMsV0FBVztRQUNY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