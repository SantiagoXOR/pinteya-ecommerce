{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\api\\product-variants.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - FUNCIONES DE API PARA VARIANTES DE PRODUCTOS\n// ===================================\n\nimport { ApiResponse } from '@/types/api'\nimport { safeApiResponseJson } from '@/lib/json-utils'\n\n// Tipo para variante de producto\nexport interface ProductVariant {\n  id: number\n  name: string\n  price: string\n  discounted_price: string | null\n  capacity: string\n  stock: number\n  is_active: boolean\n}\n\n/**\n * Obtiene las variantes de un producto por ID\n * @param productId - ID del producto\n * @returns Promise<ApiResponse<ProductVariant[]>>\n */\nexport async function getProductVariants(\n  productId: number\n): Promise<ApiResponse<ProductVariant[]>> {\n  try {\n    const response = await fetch(`/api/products/${productId}/variants`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n\n    // Usar parsing seguro de JSON\n    const result = await safeApiResponseJson<ApiResponse<ProductVariant[]>>(response)\n\n    if (!result || !result.success || !result.data) {\n      throw new Error(result?.error || 'Error parsing API response')\n    }\n\n    return result.data\n  } catch (error) {\n    console.error(`Error obteniendo variantes del producto ${productId}:`, error)\n    throw error\n  }\n}\n\n/**\n * Encuentra la variante con el precio más bajo\n * @param variants - Array de variantes\n * @returns ProductVariant | null\n */\nexport function findCheapestVariant(variants: ProductVariant[]): ProductVariant | null {\n  if (!variants || variants.length === 0) return null\n\n  return variants.reduce((cheapest, current) => {\n    const cheapestPrice = parseFloat(cheapest.discounted_price || cheapest.price)\n    const currentPrice = parseFloat(current.discounted_price || current.price)\n\n    return currentPrice < cheapestPrice ? current : cheapest\n  })\n}\n\n/**\n * Encuentra la variante con el precio más alto\n * @param variants - Array de variantes\n * @returns ProductVariant | null\n */\nexport function findMostExpensiveVariant(variants: ProductVariant[]): ProductVariant | null {\n  if (!variants || variants.length === 0) return null\n\n  return variants.reduce((expensive, current) => {\n    const expensivePrice = parseFloat(expensive.discounted_price || expensive.price)\n    const currentPrice = parseFloat(current.discounted_price || current.price)\n\n    return currentPrice > expensivePrice ? current : expensive\n  })\n}\n\n/**\n * Busca una variante por capacidad específica\n * @param variants - Array de variantes\n * @param capacity - Capacidad a buscar (ej: \"4L\", \"10L\")\n * @returns ProductVariant | null\n */\nexport function findVariantByCapacity(\n  variants: ProductVariant[],\n  capacity: string\n): ProductVariant | null {\n  if (!variants || variants.length === 0) return null\n\n  return variants.find(variant => variant.capacity.toLowerCase() === capacity.toLowerCase()) || null\n}\n\n/**\n * Obtiene todas las capacidades disponibles de las variantes\n * @param variants - Array de variantes\n * @returns string[]\n */\nexport function getAvailableCapacities(variants: ProductVariant[]): string[] {\n  if (!variants || variants.length === 0) return []\n\n  return variants\n    .map(variant => variant.capacity)\n    .filter((capacity, index, array) => array.indexOf(capacity) === index)\n    .sort((a, b) => {\n      // Ordenar por capacidad numérica\n      const aNum = parseInt(a.replace(/[^\\d]/g, '')) || 0\n      const bNum = parseInt(b.replace(/[^\\d]/g, '')) || 0\n      return aNum - bNum\n    })\n}\n\n/**\n * Calcula el precio efectivo de una variante (con descuento si existe)\n * @param variant - Variante del producto\n * @returns number\n */\nexport function getEffectivePrice(variant: ProductVariant): number {\n  return parseFloat(variant.discounted_price || variant.price)\n}\n\n/**\n * Verifica si una variante tiene descuento\n * @param variant - Variante del producto\n * @returns boolean\n */\nexport function hasDiscount(variant: ProductVariant): boolean {\n  return (\n    variant.discounted_price !== null &&\n    parseFloat(variant.discounted_price) < parseFloat(variant.price)\n  )\n}\n\n/**\n * Calcula el porcentaje de descuento de una variante\n * @param variant - Variante del producto\n * @returns number (porcentaje de descuento)\n */\nexport function getDiscountPercentage(variant: ProductVariant): number {\n  if (!hasDiscount(variant)) return 0\n\n  const originalPrice = parseFloat(variant.price)\n  const discountedPrice = parseFloat(variant.discounted_price!)\n\n  return Math.round(((originalPrice - discountedPrice) / originalPrice) * 100)\n}\n"],"names":["findCheapestVariant","findMostExpensiveVariant","findVariantByCapacity","getAvailableCapacities","getDiscountPercentage","getEffectivePrice","getProductVariants","hasDiscount","productId","response","fetch","method","headers","result","safeApiResponseJson","success","data","Error","error","console","variants","length","reduce","cheapest","current","cheapestPrice","parseFloat","discounted_price","price","currentPrice","expensive","expensivePrice","capacity","find","variant","toLowerCase","map","filter","index","array","indexOf","sort","a","b","aNum","parseInt","replace","bNum","originalPrice","discountedPrice","Math","round"],"mappings":"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"}