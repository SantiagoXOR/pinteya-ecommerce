e834bcdce5b7b138b917a20a7e266aed
// ===================================
// PINTEYA E-COMMERCE - LAZY LOADING PERFORMANCE TEST
// Tests para verificar que el lazy loading funciona correctamente
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// ===================================
// MOCKS
// ===================================
// Mock de performance para medir tiempos de carga
const mockPerformanceNow = _globals.jest.fn();
Object.defineProperty(global, 'performance', {
    value: {
        now: mockPerformanceNow
    },
    writable: true
});
// Mock de console para capturar logs de lazy loading
const mockConsoleLog = _globals.jest.spyOn(console, 'log').mockImplementation(()=>{});
// Mock de dynamic imports
const mockDynamicImport = _globals.jest.fn();
_globals.jest.mock('next/dynamic', ()=>{
    return (importFn, options)=>{
        const LazyComponent = /*#__PURE__*/ _react.default.lazy(()=>{
            mockDynamicImport();
            return importFn();
        });
        return /*#__PURE__*/ _react.default.forwardRef((props, ref)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_react.default.Suspense, {
                fallback: options?.loading?.() || /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    children: "Loading..."
                }),
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyComponent, {
                    ...props,
                    ref: ref
                })
            }));
    };
});
// ===================================
// SETUP Y CLEANUP
// ===================================
(0, _globals.beforeEach)(()=>{
    _globals.jest.clearAllMocks();
    mockPerformanceNow.mockReturnValue(1000);
});
(0, _globals.afterEach)(()=>{
    _globals.jest.clearAllTimers();
});
// ===================================
// TESTS DE LAZY LOADING
// ===================================
(0, _globals.describe)('Lazy Loading Performance Tests', ()=>{
    (0, _globals.it)('debe cargar componentes admin bajo demanda', async ()=>{
        _globals.jest.useFakeTimers();
        // Simular tiempo de carga inicial
        mockPerformanceNow.mockReturnValueOnce(1000);
        // Importar componente lazy
        const { LazyAdminDashboard } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/LazyAdminDashboard")));
        // Renderizar componente
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyAdminDashboard, {}));
        // Verificar que muestra skeleton inicialmente
        (0, _globals.expect)(_react1.screen.getByText(/cargando/i) || _react1.screen.getAllByRole('generic').length > 0).toBeTruthy();
        // Simular tiempo después de la carga
        mockPerformanceNow.mockReturnValueOnce(1200);
        // Avanzar timers para que se complete la carga
        _globals.jest.advanceTimersByTime(1000);
        // Verificar que el componente se carga
        await (0, _react1.waitFor)(()=>{
            // El componente debería estar cargado o mostrar contenido
            (0, _globals.expect)(_react1.screen.queryByText(/cargando/i)).toBeFalsy();
        }, {
            timeout: 3000
        });
        _globals.jest.useRealTimers();
    });
    (0, _globals.it)('debe mostrar skeletons apropiados durante la carga', async ()=>{
        const { LazyProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/products/LazyProductComponents")));
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyProductList, {}));
        // Verificar que muestra skeleton de productos
        const skeletonElements = _react1.screen.getAllByRole('generic');
        (0, _globals.expect)(skeletonElements.length).toBeGreaterThan(0);
        // Verificar estructura del skeleton
        (0, _globals.expect)(_react1.screen.getByText(/filtros/i) || skeletonElements.length > 4).toBeTruthy();
    });
    (0, _globals.it)('debe manejar errores de carga gracefully', async ()=>{
        // Mock de error en import dinámico
        const originalImport = _globals.jest.requireActual('next/dynamic');
        _globals.jest.doMock('next/dynamic', ()=>{
            return ()=>{
                throw new Error('Failed to load component');
            };
        });
        try {
            const { LazyLogisticsMap } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")));
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyLogisticsMap, {}));
            // Verificar que muestra error boundary
            await (0, _react1.waitFor)(()=>{
                (0, _globals.expect)(_react1.screen.getByText(/error de carga/i) || _react1.screen.getByText(/error/i)).toBeInTheDocument();
            });
        } catch (error) {
            // Error esperado durante el test
            (0, _globals.expect)(error).toBeDefined();
        }
    });
    (0, _globals.it)('debe precargar componentes cuando se solicita', async ()=>{
        const { usePreloadAdminComponents } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/LazyAdminDashboard")));
        // Crear componente de prueba que usa el hook
        function TestComponent() {
            const { preloadAdmin, preloadMonitoring } = usePreloadAdminComponents();
            _react.default.useEffect(()=>{
                preloadAdmin();
                preloadMonitoring();
            }, [
                preloadAdmin,
                preloadMonitoring
            ]);
            return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                children: "Test Component"
            });
        }
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
        // Verificar que el componente se renderiza
        (0, _globals.expect)(_react1.screen.getByText('Test Component')).toBeInTheDocument();
        // Los imports dinámicos deberían haberse llamado
        await (0, _react1.waitFor)(()=>{
            // Verificar que se intentó precargar (esto es difícil de testear directamente)
            (0, _globals.expect)(true).toBe(true); // Placeholder - en un entorno real verificaríamos network requests
        });
    });
    (0, _globals.it)('debe tener performance aceptable en carga de componentes', async ()=>{
        const startTime = 1000;
        const endTime = 1200;
        mockPerformanceNow.mockReturnValueOnce(startTime).mockReturnValueOnce(endTime);
        const { LazyCarrierPerformanceTable } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")));
        const start = performance.now();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyCarrierPerformanceTable, {}));
        const end = performance.now();
        // Verificar que el tiempo de render inicial es rápido (< 200ms)
        const renderTime = end - start;
        (0, _globals.expect)(renderTime).toBeLessThan(200);
    });
    (0, _globals.it)('debe limpiar recursos correctamente al desmontar', async ()=>{
        const { LazyRealTimeDashboard } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")));
        const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyRealTimeDashboard, {}));
        // Desmontar componente
        unmount();
        // Verificar que no hay memory leaks (esto es más conceptual en el test)
        (0, _globals.expect)(mockConsoleLog).not.toHaveBeenCalledWith(_globals.expect.stringContaining('memory leak'));
    });
    (0, _globals.it)('debe manejar múltiples componentes lazy simultáneamente', async ()=>{
        const components = await Promise.all([
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/LazyAdminDashboard"))),
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/products/LazyProductComponents"))),
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")))
        ]);
        const [{ LazyAdminDashboard }, { LazyProductList }, { LazyLogisticsMap }] = components;
        // Renderizar múltiples componentes lazy
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyAdminDashboard, {}),
                /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyProductList, {}),
                /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyLogisticsMap, {})
            ]
        }));
        // Verificar que todos muestran skeletons inicialmente
        const loadingElements = _react1.screen.getAllByText(/cargando/i);
        (0, _globals.expect)(loadingElements.length).toBeGreaterThanOrEqual(0); // Pueden ser skeletons sin texto "cargando"
        // Verificar que no hay conflictos entre componentes
        (0, _globals.expect)(_react1.screen.getByRole('main') || document.body).toBeInTheDocument();
    });
    (0, _globals.it)('debe optimizar bundle size con lazy loading', async ()=>{
        // Este test es más conceptual - verificamos que los imports son dinámicos
        const modulePromises = [
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/LazyAdminDashboard"))),
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/products/LazyProductComponents"))),
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")))
        ];
        // Verificar que los imports son promesas (lazy)
        modulePromises.forEach((modulePromise)=>{
            (0, _globals.expect)(modulePromise).toBeInstanceOf(Promise);
        });
        // Verificar que se resuelven correctamente
        const modules = await Promise.all(modulePromises);
        modules.forEach((module)=>{
            (0, _globals.expect)(module).toBeDefined();
            (0, _globals.expect)(typeof module).toBe('object');
        });
    });
    (0, _globals.it)('debe funcionar correctamente con Suspense boundaries', async ()=>{
        const { LazyProductForm } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/products/LazyProductComponents")));
        // Renderizar con Suspense personalizado
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_react.default.Suspense, {
            fallback: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                children: "Custom Loading..."
            }),
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyProductForm, {})
        }));
        // Verificar que muestra el fallback personalizado o el del componente
        (0, _globals.expect)(_react1.screen.getByText(/custom loading/i) || _react1.screen.getByText(/loading/i) || _react1.screen.getAllByRole('generic').length > 0).toBeTruthy();
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxwZXJmb3JtYW5jZVxcbGF6eS1sb2FkaW5nLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBMQVpZIExPQURJTkcgUEVSRk9STUFOQ0UgVEVTVFxuLy8gVGVzdHMgcGFyYSB2ZXJpZmljYXIgcXVlIGVsIGxhenkgbG9hZGluZyBmdW5jaW9uYSBjb3JyZWN0YW1lbnRlXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnXG5pbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlRWFjaCwgYWZ0ZXJFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscydcbmltcG9ydCB7IGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJ1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTU9DS1Ncbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8vIE1vY2sgZGUgcGVyZm9ybWFuY2UgcGFyYSBtZWRpciB0aWVtcG9zIGRlIGNhcmdhXG5jb25zdCBtb2NrUGVyZm9ybWFuY2VOb3cgPSBqZXN0LmZuKClcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsICdwZXJmb3JtYW5jZScsIHtcbiAgdmFsdWU6IHsgbm93OiBtb2NrUGVyZm9ybWFuY2VOb3cgfSxcbiAgd3JpdGFibGU6IHRydWUsXG59KVxuXG4vLyBNb2NrIGRlIGNvbnNvbGUgcGFyYSBjYXB0dXJhciBsb2dzIGRlIGxhenkgbG9hZGluZ1xuY29uc3QgbW9ja0NvbnNvbGVMb2cgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pXG5cbi8vIE1vY2sgZGUgZHluYW1pYyBpbXBvcnRzXG5jb25zdCBtb2NrRHluYW1pY0ltcG9ydCA9IGplc3QuZm4oKVxuamVzdC5tb2NrKCduZXh0L2R5bmFtaWMnLCAoKSA9PiB7XG4gIHJldHVybiAoaW1wb3J0Rm46ICgpID0+IFByb21pc2U8YW55Piwgb3B0aW9ucz86IGFueSkgPT4ge1xuICAgIGNvbnN0IExhenlDb21wb25lbnQgPSBSZWFjdC5sYXp5KCgpID0+IHtcbiAgICAgIG1vY2tEeW5hbWljSW1wb3J0KClcbiAgICAgIHJldHVybiBpbXBvcnRGbigpXG4gICAgfSlcblxuICAgIHJldHVybiBSZWFjdC5mb3J3YXJkUmVmKChwcm9wczogYW55LCByZWY6IGFueSkgPT4gKFxuICAgICAgPFJlYWN0LlN1c3BlbnNlIGZhbGxiYWNrPXtvcHRpb25zPy5sb2FkaW5nPy4oKSB8fCA8ZGl2PkxvYWRpbmcuLi48L2Rpdj59PlxuICAgICAgICA8TGF6eUNvbXBvbmVudCB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPlxuICAgICAgPC9SZWFjdC5TdXNwZW5zZT5cbiAgICApKVxuICB9XG59KVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU0VUVVAgWSBDTEVBTlVQXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5iZWZvcmVFYWNoKCgpID0+IHtcbiAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgbW9ja1BlcmZvcm1hbmNlTm93Lm1vY2tSZXR1cm5WYWx1ZSgxMDAwKVxufSlcblxuYWZ0ZXJFYWNoKCgpID0+IHtcbiAgamVzdC5jbGVhckFsbFRpbWVycygpXG59KVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVEVTVFMgREUgTEFaWSBMT0FESU5HXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5kZXNjcmliZSgnTGF6eSBMb2FkaW5nIFBlcmZvcm1hbmNlIFRlc3RzJywgKCkgPT4ge1xuICBpdCgnZGViZSBjYXJnYXIgY29tcG9uZW50ZXMgYWRtaW4gYmFqbyBkZW1hbmRhJywgYXN5bmMgKCkgPT4ge1xuICAgIGplc3QudXNlRmFrZVRpbWVycygpXG5cbiAgICAvLyBTaW11bGFyIHRpZW1wbyBkZSBjYXJnYSBpbmljaWFsXG4gICAgbW9ja1BlcmZvcm1hbmNlTm93Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoMTAwMClcblxuICAgIC8vIEltcG9ydGFyIGNvbXBvbmVudGUgbGF6eVxuICAgIGNvbnN0IHsgTGF6eUFkbWluRGFzaGJvYXJkIH0gPSBhd2FpdCBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9MYXp5QWRtaW5EYXNoYm9hcmQnKVxuXG4gICAgLy8gUmVuZGVyaXphciBjb21wb25lbnRlXG4gICAgcmVuZGVyKDxMYXp5QWRtaW5EYXNoYm9hcmQgLz4pXG5cbiAgICAvLyBWZXJpZmljYXIgcXVlIG11ZXN0cmEgc2tlbGV0b24gaW5pY2lhbG1lbnRlXG4gICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL2NhcmdhbmRvL2kpIHx8IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2dlbmVyaWMnKS5sZW5ndGggPiAwKS50b0JlVHJ1dGh5KClcblxuICAgIC8vIFNpbXVsYXIgdGllbXBvIGRlc3B1w6lzIGRlIGxhIGNhcmdhXG4gICAgbW9ja1BlcmZvcm1hbmNlTm93Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoMTIwMClcblxuICAgIC8vIEF2YW56YXIgdGltZXJzIHBhcmEgcXVlIHNlIGNvbXBsZXRlIGxhIGNhcmdhXG4gICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMDApXG5cbiAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGNvbXBvbmVudGUgc2UgY2FyZ2FcbiAgICBhd2FpdCB3YWl0Rm9yKFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBFbCBjb21wb25lbnRlIGRlYmVyw61hIGVzdGFyIGNhcmdhZG8gbyBtb3N0cmFyIGNvbnRlbmlkb1xuICAgICAgICBleHBlY3Qoc2NyZWVuLnF1ZXJ5QnlUZXh0KC9jYXJnYW5kby9pKSkudG9CZUZhbHN5KClcbiAgICAgIH0sXG4gICAgICB7IHRpbWVvdXQ6IDMwMDAgfVxuICAgIClcblxuICAgIGplc3QudXNlUmVhbFRpbWVycygpXG4gIH0pXG5cbiAgaXQoJ2RlYmUgbW9zdHJhciBza2VsZXRvbnMgYXByb3BpYWRvcyBkdXJhbnRlIGxhIGNhcmdhJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgTGF6eVByb2R1Y3RMaXN0IH0gPSBhd2FpdCBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9wcm9kdWN0cy9MYXp5UHJvZHVjdENvbXBvbmVudHMnKVxuXG4gICAgcmVuZGVyKDxMYXp5UHJvZHVjdExpc3QgLz4pXG5cbiAgICAvLyBWZXJpZmljYXIgcXVlIG11ZXN0cmEgc2tlbGV0b24gZGUgcHJvZHVjdG9zXG4gICAgY29uc3Qgc2tlbGV0b25FbGVtZW50cyA9IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2dlbmVyaWMnKVxuICAgIGV4cGVjdChza2VsZXRvbkVsZW1lbnRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApXG5cbiAgICAvLyBWZXJpZmljYXIgZXN0cnVjdHVyYSBkZWwgc2tlbGV0b25cbiAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvZmlsdHJvcy9pKSB8fCBza2VsZXRvbkVsZW1lbnRzLmxlbmd0aCA+IDQpLnRvQmVUcnV0aHkoKVxuICB9KVxuXG4gIGl0KCdkZWJlIG1hbmVqYXIgZXJyb3JlcyBkZSBjYXJnYSBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIE1vY2sgZGUgZXJyb3IgZW4gaW1wb3J0IGRpbsOhbWljb1xuICAgIGNvbnN0IG9yaWdpbmFsSW1wb3J0ID0gamVzdC5yZXF1aXJlQWN0dWFsKCduZXh0L2R5bmFtaWMnKVxuICAgIGplc3QuZG9Nb2NrKCduZXh0L2R5bmFtaWMnLCAoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGNvbXBvbmVudCcpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IExhenlMb2dpc3RpY3NNYXAgfSA9IGF3YWl0IGltcG9ydChcbiAgICAgICAgJ0AvY29tcG9uZW50cy9hZG1pbi9sb2dpc3RpY3MvTGF6eUxvZ2lzdGljc0NvbXBvbmVudHMnXG4gICAgICApXG5cbiAgICAgIHJlbmRlcig8TGF6eUxvZ2lzdGljc01hcCAvPilcblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBtdWVzdHJhIGVycm9yIGJvdW5kYXJ5XG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KFxuICAgICAgICAgIHNjcmVlbi5nZXRCeVRleHQoL2Vycm9yIGRlIGNhcmdhL2kpIHx8IHNjcmVlbi5nZXRCeVRleHQoL2Vycm9yL2kpXG4gICAgICAgICkudG9CZUluVGhlRG9jdW1lbnQoKVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRXJyb3IgZXNwZXJhZG8gZHVyYW50ZSBlbCB0ZXN0XG4gICAgICBleHBlY3QoZXJyb3IpLnRvQmVEZWZpbmVkKClcbiAgICB9XG4gIH0pXG5cbiAgaXQoJ2RlYmUgcHJlY2FyZ2FyIGNvbXBvbmVudGVzIGN1YW5kbyBzZSBzb2xpY2l0YScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHVzZVByZWxvYWRBZG1pbkNvbXBvbmVudHMgfSA9IGF3YWl0IGltcG9ydCgnQC9jb21wb25lbnRzL2FkbWluL0xhenlBZG1pbkRhc2hib2FyZCcpXG5cbiAgICAvLyBDcmVhciBjb21wb25lbnRlIGRlIHBydWViYSBxdWUgdXNhIGVsIGhvb2tcbiAgICBmdW5jdGlvbiBUZXN0Q29tcG9uZW50KCkge1xuICAgICAgY29uc3QgeyBwcmVsb2FkQWRtaW4sIHByZWxvYWRNb25pdG9yaW5nIH0gPSB1c2VQcmVsb2FkQWRtaW5Db21wb25lbnRzKClcblxuICAgICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJlbG9hZEFkbWluKClcbiAgICAgICAgcHJlbG9hZE1vbml0b3JpbmcoKVxuICAgICAgfSwgW3ByZWxvYWRBZG1pbiwgcHJlbG9hZE1vbml0b3JpbmddKVxuXG4gICAgICByZXR1cm4gPGRpdj5UZXN0IENvbXBvbmVudDwvZGl2PlxuICAgIH1cblxuICAgIHJlbmRlcig8VGVzdENvbXBvbmVudCAvPilcblxuICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgY29tcG9uZW50ZSBzZSByZW5kZXJpemFcbiAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVGVzdCBDb21wb25lbnQnKSkudG9CZUluVGhlRG9jdW1lbnQoKVxuXG4gICAgLy8gTG9zIGltcG9ydHMgZGluw6FtaWNvcyBkZWJlcsOtYW4gaGFiZXJzZSBsbGFtYWRvXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAvLyBWZXJpZmljYXIgcXVlIHNlIGludGVudMOzIHByZWNhcmdhciAoZXN0byBlcyBkaWbDrWNpbCBkZSB0ZXN0ZWFyIGRpcmVjdGFtZW50ZSlcbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpIC8vIFBsYWNlaG9sZGVyIC0gZW4gdW4gZW50b3JubyByZWFsIHZlcmlmaWNhcsOtYW1vcyBuZXR3b3JrIHJlcXVlc3RzXG4gICAgfSlcbiAgfSlcblxuICBpdCgnZGViZSB0ZW5lciBwZXJmb3JtYW5jZSBhY2VwdGFibGUgZW4gY2FyZ2EgZGUgY29tcG9uZW50ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gMTAwMFxuICAgIGNvbnN0IGVuZFRpbWUgPSAxMjAwXG5cbiAgICBtb2NrUGVyZm9ybWFuY2VOb3cubW9ja1JldHVyblZhbHVlT25jZShzdGFydFRpbWUpLm1vY2tSZXR1cm5WYWx1ZU9uY2UoZW5kVGltZSlcblxuICAgIGNvbnN0IHsgTGF6eUNhcnJpZXJQZXJmb3JtYW5jZVRhYmxlIH0gPSBhd2FpdCBpbXBvcnQoXG4gICAgICAnQC9jb21wb25lbnRzL2FkbWluL2xvZ2lzdGljcy9MYXp5TG9naXN0aWNzQ29tcG9uZW50cydcbiAgICApXG5cbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgcmVuZGVyKDxMYXp5Q2FycmllclBlcmZvcm1hbmNlVGFibGUgLz4pXG4gICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIC8vIFZlcmlmaWNhciBxdWUgZWwgdGllbXBvIGRlIHJlbmRlciBpbmljaWFsIGVzIHLDoXBpZG8gKDwgMjAwbXMpXG4gICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZCAtIHN0YXJ0XG4gICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbigyMDApXG4gIH0pXG5cbiAgaXQoJ2RlYmUgbGltcGlhciByZWN1cnNvcyBjb3JyZWN0YW1lbnRlIGFsIGRlc21vbnRhcicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IExhenlSZWFsVGltZURhc2hib2FyZCB9ID0gYXdhaXQgaW1wb3J0KFxuICAgICAgJ0AvY29tcG9uZW50cy9hZG1pbi9sb2dpc3RpY3MvTGF6eUxvZ2lzdGljc0NvbXBvbmVudHMnXG4gICAgKVxuXG4gICAgY29uc3QgeyB1bm1vdW50IH0gPSByZW5kZXIoPExhenlSZWFsVGltZURhc2hib2FyZCAvPilcblxuICAgIC8vIERlc21vbnRhciBjb21wb25lbnRlXG4gICAgdW5tb3VudCgpXG5cbiAgICAvLyBWZXJpZmljYXIgcXVlIG5vIGhheSBtZW1vcnkgbGVha3MgKGVzdG8gZXMgbcOhcyBjb25jZXB0dWFsIGVuIGVsIHRlc3QpXG4gICAgZXhwZWN0KG1vY2tDb25zb2xlTG9nKS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ21lbW9yeSBsZWFrJykpXG4gIH0pXG5cbiAgaXQoJ2RlYmUgbWFuZWphciBtw7psdGlwbGVzIGNvbXBvbmVudGVzIGxhenkgc2ltdWx0w6FuZWFtZW50ZScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgaW1wb3J0KCdAL2NvbXBvbmVudHMvYWRtaW4vTGF6eUFkbWluRGFzaGJvYXJkJyksXG4gICAgICBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9wcm9kdWN0cy9MYXp5UHJvZHVjdENvbXBvbmVudHMnKSxcbiAgICAgIGltcG9ydCgnQC9jb21wb25lbnRzL2FkbWluL2xvZ2lzdGljcy9MYXp5TG9naXN0aWNzQ29tcG9uZW50cycpLFxuICAgIF0pXG5cbiAgICBjb25zdCBbeyBMYXp5QWRtaW5EYXNoYm9hcmQgfSwgeyBMYXp5UHJvZHVjdExpc3QgfSwgeyBMYXp5TG9naXN0aWNzTWFwIH1dID0gY29tcG9uZW50c1xuXG4gICAgLy8gUmVuZGVyaXphciBtw7psdGlwbGVzIGNvbXBvbmVudGVzIGxhenlcbiAgICByZW5kZXIoXG4gICAgICA8ZGl2PlxuICAgICAgICA8TGF6eUFkbWluRGFzaGJvYXJkIC8+XG4gICAgICAgIDxMYXp5UHJvZHVjdExpc3QgLz5cbiAgICAgICAgPExhenlMb2dpc3RpY3NNYXAgLz5cbiAgICAgIDwvZGl2PlxuICAgIClcblxuICAgIC8vIFZlcmlmaWNhciBxdWUgdG9kb3MgbXVlc3RyYW4gc2tlbGV0b25zIGluaWNpYWxtZW50ZVxuICAgIGNvbnN0IGxvYWRpbmdFbGVtZW50cyA9IHNjcmVlbi5nZXRBbGxCeVRleHQoL2NhcmdhbmRvL2kpXG4gICAgZXhwZWN0KGxvYWRpbmdFbGVtZW50cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCkgLy8gUHVlZGVuIHNlciBza2VsZXRvbnMgc2luIHRleHRvIFwiY2FyZ2FuZG9cIlxuXG4gICAgLy8gVmVyaWZpY2FyIHF1ZSBubyBoYXkgY29uZmxpY3RvcyBlbnRyZSBjb21wb25lbnRlc1xuICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlSb2xlKCdtYWluJykgfHwgZG9jdW1lbnQuYm9keSkudG9CZUluVGhlRG9jdW1lbnQoKVxuICB9KVxuXG4gIGl0KCdkZWJlIG9wdGltaXphciBidW5kbGUgc2l6ZSBjb24gbGF6eSBsb2FkaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEVzdGUgdGVzdCBlcyBtw6FzIGNvbmNlcHR1YWwgLSB2ZXJpZmljYW1vcyBxdWUgbG9zIGltcG9ydHMgc29uIGRpbsOhbWljb3NcbiAgICBjb25zdCBtb2R1bGVQcm9taXNlcyA9IFtcbiAgICAgIGltcG9ydCgnQC9jb21wb25lbnRzL2FkbWluL0xhenlBZG1pbkRhc2hib2FyZCcpLFxuICAgICAgaW1wb3J0KCdAL2NvbXBvbmVudHMvYWRtaW4vcHJvZHVjdHMvTGF6eVByb2R1Y3RDb21wb25lbnRzJyksXG4gICAgICBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9sb2dpc3RpY3MvTGF6eUxvZ2lzdGljc0NvbXBvbmVudHMnKSxcbiAgICBdXG5cbiAgICAvLyBWZXJpZmljYXIgcXVlIGxvcyBpbXBvcnRzIHNvbiBwcm9tZXNhcyAobGF6eSlcbiAgICBtb2R1bGVQcm9taXNlcy5mb3JFYWNoKG1vZHVsZVByb21pc2UgPT4ge1xuICAgICAgZXhwZWN0KG1vZHVsZVByb21pc2UpLnRvQmVJbnN0YW5jZU9mKFByb21pc2UpXG4gICAgfSlcblxuICAgIC8vIFZlcmlmaWNhciBxdWUgc2UgcmVzdWVsdmVuIGNvcnJlY3RhbWVudGVcbiAgICBjb25zdCBtb2R1bGVzID0gYXdhaXQgUHJvbWlzZS5hbGwobW9kdWxlUHJvbWlzZXMpXG4gICAgbW9kdWxlcy5mb3JFYWNoKG1vZHVsZSA9PiB7XG4gICAgICBleHBlY3QobW9kdWxlKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QodHlwZW9mIG1vZHVsZSkudG9CZSgnb2JqZWN0JylcbiAgICB9KVxuICB9KVxuXG4gIGl0KCdkZWJlIGZ1bmNpb25hciBjb3JyZWN0YW1lbnRlIGNvbiBTdXNwZW5zZSBib3VuZGFyaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgTGF6eVByb2R1Y3RGb3JtIH0gPSBhd2FpdCBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9wcm9kdWN0cy9MYXp5UHJvZHVjdENvbXBvbmVudHMnKVxuXG4gICAgLy8gUmVuZGVyaXphciBjb24gU3VzcGVuc2UgcGVyc29uYWxpemFkb1xuICAgIHJlbmRlcihcbiAgICAgIDxSZWFjdC5TdXNwZW5zZSBmYWxsYmFjaz17PGRpdj5DdXN0b20gTG9hZGluZy4uLjwvZGl2Pn0+XG4gICAgICAgIDxMYXp5UHJvZHVjdEZvcm0gLz5cbiAgICAgIDwvUmVhY3QuU3VzcGVuc2U+XG4gICAgKVxuXG4gICAgLy8gVmVyaWZpY2FyIHF1ZSBtdWVzdHJhIGVsIGZhbGxiYWNrIHBlcnNvbmFsaXphZG8gbyBlbCBkZWwgY29tcG9uZW50ZVxuICAgIGV4cGVjdChcbiAgICAgIHNjcmVlbi5nZXRCeVRleHQoL2N1c3RvbSBsb2FkaW5nL2kpIHx8XG4gICAgICAgIHNjcmVlbi5nZXRCeVRleHQoL2xvYWRpbmcvaSkgfHxcbiAgICAgICAgc2NyZWVuLmdldEFsbEJ5Um9sZSgnZ2VuZXJpYycpLmxlbmd0aCA+IDBcbiAgICApLnRvQmVUcnV0aHkoKVxuICB9KVxufSlcbiJdLCJuYW1lcyI6WyJtb2NrUGVyZm9ybWFuY2VOb3ciLCJqZXN0IiwiZm4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdsb2JhbCIsInZhbHVlIiwibm93Iiwid3JpdGFibGUiLCJtb2NrQ29uc29sZUxvZyIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIm1vY2tEeW5hbWljSW1wb3J0IiwibW9jayIsImltcG9ydEZuIiwib3B0aW9ucyIsIkxhenlDb21wb25lbnQiLCJSZWFjdCIsImxhenkiLCJmb3J3YXJkUmVmIiwicHJvcHMiLCJyZWYiLCJTdXNwZW5zZSIsImZhbGxiYWNrIiwibG9hZGluZyIsImRpdiIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja1JldHVyblZhbHVlIiwiYWZ0ZXJFYWNoIiwiY2xlYXJBbGxUaW1lcnMiLCJkZXNjcmliZSIsIml0IiwidXNlRmFrZVRpbWVycyIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJMYXp5QWRtaW5EYXNoYm9hcmQiLCJyZW5kZXIiLCJleHBlY3QiLCJzY3JlZW4iLCJnZXRCeVRleHQiLCJnZXRBbGxCeVJvbGUiLCJsZW5ndGgiLCJ0b0JlVHJ1dGh5IiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsIndhaXRGb3IiLCJxdWVyeUJ5VGV4dCIsInRvQmVGYWxzeSIsInRpbWVvdXQiLCJ1c2VSZWFsVGltZXJzIiwiTGF6eVByb2R1Y3RMaXN0Iiwic2tlbGV0b25FbGVtZW50cyIsInRvQmVHcmVhdGVyVGhhbiIsIm9yaWdpbmFsSW1wb3J0IiwicmVxdWlyZUFjdHVhbCIsImRvTW9jayIsIkVycm9yIiwiTGF6eUxvZ2lzdGljc01hcCIsInRvQmVJblRoZURvY3VtZW50IiwiZXJyb3IiLCJ0b0JlRGVmaW5lZCIsInVzZVByZWxvYWRBZG1pbkNvbXBvbmVudHMiLCJUZXN0Q29tcG9uZW50IiwicHJlbG9hZEFkbWluIiwicHJlbG9hZE1vbml0b3JpbmciLCJ1c2VFZmZlY3QiLCJ0b0JlIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsIkxhenlDYXJyaWVyUGVyZm9ybWFuY2VUYWJsZSIsInN0YXJ0IiwicGVyZm9ybWFuY2UiLCJlbmQiLCJyZW5kZXJUaW1lIiwidG9CZUxlc3NUaGFuIiwiTGF6eVJlYWxUaW1lRGFzaGJvYXJkIiwidW5tb3VudCIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwic3RyaW5nQ29udGFpbmluZyIsImNvbXBvbmVudHMiLCJQcm9taXNlIiwiYWxsIiwibG9hZGluZ0VsZW1lbnRzIiwiZ2V0QWxsQnlUZXh0IiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsImdldEJ5Um9sZSIsImRvY3VtZW50IiwiYm9keSIsIm1vZHVsZVByb21pc2VzIiwiZm9yRWFjaCIsIm1vZHVsZVByb21pc2UiLCJ0b0JlSW5zdGFuY2VPZiIsIm1vZHVsZXMiLCJtb2R1bGUiLCJMYXp5UHJvZHVjdEZvcm0iXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0QyxxREFBcUQ7QUFDckQsa0VBQWtFO0FBQ2xFLHNDQUFzQzs7Ozs7OzhEQUVwQjt3QkFDc0I7eUJBQ29COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUc1RCxzQ0FBc0M7QUFDdEMsUUFBUTtBQUNSLHNDQUFzQztBQUV0QyxrREFBa0Q7QUFDbEQsTUFBTUEscUJBQXFCQyxhQUFJLENBQUNDLEVBQUU7QUFDbENDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUSxlQUFlO0lBQzNDQyxPQUFPO1FBQUVDLEtBQUtQO0lBQW1CO0lBQ2pDUSxVQUFVO0FBQ1o7QUFFQSxxREFBcUQ7QUFDckQsTUFBTUMsaUJBQWlCUixhQUFJLENBQUNTLEtBQUssQ0FBQ0MsU0FBUyxPQUFPQyxrQkFBa0IsQ0FBQyxLQUFPO0FBRTVFLDBCQUEwQjtBQUMxQixNQUFNQyxvQkFBb0JaLGFBQUksQ0FBQ0MsRUFBRTtBQUNqQ0QsYUFBSSxDQUFDYSxJQUFJLENBQUMsZ0JBQWdCO0lBQ3hCLE9BQU8sQ0FBQ0MsVUFBOEJDO1FBQ3BDLE1BQU1DLDhCQUFnQkMsY0FBSyxDQUFDQyxJQUFJLENBQUM7WUFDL0JOO1lBQ0EsT0FBT0U7UUFDVDtRQUVBLHFCQUFPRyxjQUFLLENBQUNFLFVBQVUsQ0FBQyxDQUFDQyxPQUFZQyxvQkFDbkMscUJBQUNKLGNBQUssQ0FBQ0ssUUFBUTtnQkFBQ0MsVUFBVVIsU0FBU1MsNkJBQWUscUJBQUNDOzhCQUFJOzswQkFDckQsY0FBQSxxQkFBQ1Q7b0JBQWUsR0FBR0ksS0FBSztvQkFBRUMsS0FBS0E7OztJQUdyQztBQUNGO0FBRUEsc0NBQXNDO0FBQ3RDLGtCQUFrQjtBQUNsQixzQ0FBc0M7QUFFdENLLElBQUFBLG1CQUFVLEVBQUM7SUFDVDFCLGFBQUksQ0FBQzJCLGFBQWE7SUFDbEI1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