16080c0d7e1418c95d922d56bd924fb1
// ===================================
// PINTEYA E-COMMERCE - USE ORDERS ENTERPRISE HOOK TESTS
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useOrdersEnterprise = require("../../hooks/useOrdersEnterprise");
const _ordersmocks = require("../setup/orders-mocks.js");
// ===================================
// SETUP MOCKS
// ===================================
const mockFetch = (0, _ordersmocks.createMockFetch)();
global.fetch = mockFetch;
// ===================================
// TESTS BÁSICOS useOrdersEnterprise
// ===================================
describe('useOrdersEnterprise', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should initialize with default state', async ()=>{
        // Arrange & Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Assert initial state
        expect(result.current.orders).toEqual([]);
        expect(result.current.loading).toBe(true);
        expect(result.current.error).toBe(null);
        expect(result.current.filters).toEqual({
            page: 1,
            limit: 20,
            sort_by: 'created_at',
            sort_order: 'desc'
        });
    });
    test('should fetch orders on mount', async ()=>{
        // Arrange & Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/api/admin/orders'));
        expect(result.current.orders).toEqual(_ordersmocks.mockOrders);
        expect(result.current.error).toBe(null);
    });
    test('should handle fetch errors', async ()=>{
        // Arrange
        mockFetch.mockImplementationOnce(()=>Promise.resolve({
                ok: false,
                status: 500,
                json: ()=>Promise.resolve({
                        error: 'Server error'
                    })
            }));
        // Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert
        expect(result.current.error).toBe('Error al cargar órdenes');
        expect(result.current.orders).toEqual([]);
    });
    test('should accept initial filters', async ()=>{
        // Arrange
        const initialFilters = {
            status: 'pending',
            page: 2,
            limit: 10
        };
        // Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)(initialFilters));
        // Assert
        expect(result.current.filters).toEqual({
            page: 2,
            limit: 10,
            sort_by: 'created_at',
            sort_order: 'desc',
            status: 'pending'
        });
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('status=pending'));
        });
    });
});
// ===================================
// TESTS DE FILTROS
// ===================================
describe('useOrdersEnterprise - Filters', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should update search filter', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setSearch('test search');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('search=test'));
    });
    test('should update status filter', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setStatus('pending');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('status=pending'));
    });
    test('should update payment status filter', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setPaymentStatus('paid');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('payment_status=paid'));
    });
    test('should update sorting', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setSorting('total_amount', 'asc');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('sort_by=total_amount'));
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('sort_order=asc'));
    });
    test('should update date range', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setDateRange('2024-01-01', '2024-01-31');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('date_from=2024-01-01'));
    });
    test('should clear all filters', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)({
                status: 'pending',
                search: 'test',
                page: 3
            }));
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.clearFilters();
        });
        // Assert - Verificar que se llamó a fetch con filtros limpiados
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/api/admin/orders'));
    });
});
// ===================================
// TESTS DE PAGINACIÓN
// ===================================
describe('useOrdersEnterprise - Pagination', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should handle page changes', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            result.current.setPage(2);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('page=2'));
    });
    test('should provide pagination helpers', async ()=>{
        // Arrange
        mockFetch.mockImplementationOnce(()=>Promise.resolve({
                ok: true,
                status: 200,
                json: ()=>Promise.resolve({
                        data: {
                            orders: _ordersmocks.mockOrders,
                            pagination: {
                                page: 2,
                                limit: 20,
                                total: 50,
                                totalPages: 3,
                                hasNextPage: true,
                                hasPreviousPage: true
                            },
                            filters: {}
                        },
                        success: true,
                        error: null
                    })
            }));
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert pagination helpers
        expect(result.current.hasNextPage).toBe(true);
        expect(result.current.hasPreviousPage).toBe(true);
        expect(result.current.totalOrders).toBe(50);
        expect(result.current.currentPage).toBe(2);
        expect(result.current.totalPages).toBe(3);
    });
});
// ===================================
// TESTS DE OPERACIONES CRUD
// ===================================
describe('useOrdersEnterprise - CRUD Operations', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should create order', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const orderData = {
            user_id: 'test-user-id',
            items: [
                {
                    product_id: 1,
                    quantity: 1,
                    unit_price: 15000
                }
            ]
        };
        // Act
        let createdOrder;
        await (0, _react.act)(async ()=>{
            createdOrder = await result.current.createOrder(orderData);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders', expect.objectContaining({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(orderData)
        }));
        expect(createdOrder).toBeDefined();
    });
    test('should update order', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const updateData = {
            notes: 'Updated notes'
        };
        // Act
        let updatedOrder;
        await (0, _react.act)(async ()=>{
            updatedOrder = await result.current.updateOrder('order-1', updateData);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/order-1', expect.objectContaining({
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updateData)
        }));
        expect(updatedOrder).toBeDefined();
    });
    test('should change order status', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        await (0, _react.act)(async ()=>{
            await result.current.changeOrderStatus('order-1', 'confirmed', 'Payment confirmed');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/order-1/status', expect.objectContaining({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                status: 'confirmed',
                reason: 'Payment confirmed'
            })
        }));
    });
    test('should handle bulk status update', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const bulkData = {
            order_ids: [
                'order-1',
                'order-2'
            ],
            status: 'confirmed',
            reason: 'Bulk confirmation'
        };
        // Act
        let bulkResult;
        await (0, _react.act)(async ()=>{
            bulkResult = await result.current.bulkUpdateStatus(bulkData);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/bulk?operation=status_update', expect.objectContaining({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(bulkData)
        }));
        expect(bulkResult).toBeDefined();
    });
    test('should export orders', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        let exportResult;
        await (0, _react.act)(async ()=>{
            exportResult = await result.current.exportOrders('csv');
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/bulk?operation=export', expect.objectContaining({
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                format: 'csv',
                filters: result.current.filters,
                include_items: true
            })
        }));
        expect(exportResult).toBeDefined();
    });
});
// ===================================
// TESTS DE UTILIDADES
// ===================================
describe('useOrdersEnterprise - Utilities', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should get order by id', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        const order = result.current.getOrderById('order-1');
        // Assert
        expect(order).toEqual(_ordersmocks.mockOrders[0]);
    });
    test('should get orders by status', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        const pendingOrders = result.current.getOrdersByStatus('pending');
        // Assert
        expect(pendingOrders).toEqual(_ordersmocks.mockOrders.filter((order)=>order.status === 'pending'));
    });
    test('should calculate total revenue', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        const totalRevenue = result.current.getTotalRevenue();
        // Assert
        const expectedRevenue = _ordersmocks.mockOrders.filter((order)=>order.status !== 'cancelled').reduce((sum, order)=>sum + order.total_amount, 0);
        expect(totalRevenue).toBe(expectedRevenue);
    });
    test('should calculate average order value', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Act
        const avgOrderValue = result.current.getAverageOrderValue();
        // Assert
        const validOrders = _ordersmocks.mockOrders.filter((order)=>order.status !== 'cancelled');
        const expectedAvg = validOrders.reduce((sum, order)=>sum + order.total_amount, 0) / validOrders.length;
        expect(avgOrderValue).toBe(expectedAvg);
    });
    test('should refresh data', async ()=>{
        // Arrange
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrdersEnterprise)());
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const initialCallCount = mockFetch.mock.calls.length;
        // Act
        await (0, _react.act)(async ()=>{
            result.current.refresh();
        });
        // Assert
        expect(mockFetch.mock.calls.length).toBe(initialCallCount + 1);
    });
});
// ===================================
// TESTS useOrderDetail
// ===================================
describe('useOrderDetail', ()=>{
    beforeEach(()=>{
        (0, _ordersmocks.resetAllMocks)();
        mockFetch.mockClear();
    });
    test('should fetch order detail', async ()=>{
        // Arrange
        mockFetch.mockImplementationOnce(()=>Promise.resolve({
                ok: true,
                status: 200,
                json: ()=>Promise.resolve({
                        data: {
                            order: _ordersmocks.mockOrders[0],
                            statusHistory: [],
                            notes: []
                        },
                        success: true,
                        error: null
                    })
            }));
        // Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrderDetail)('order-1'));
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert
        expect(mockFetch).toHaveBeenCalledWith('/api/admin/orders/order-1');
        expect(result.current.order).toEqual(_ordersmocks.mockOrders[0]);
        expect(result.current.error).toBe(null);
    });
    test('should handle fetch error', async ()=>{
        // Arrange
        mockFetch.mockImplementationOnce(()=>Promise.resolve({
                ok: false,
                status: 404,
                json: ()=>Promise.resolve({
                        error: 'Order not found'
                    })
            }));
        // Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrderDetail)('order-1'));
        // Wait for fetch to complete
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Assert
        expect(result.current.error).toBe('Order not found');
        expect(result.current.order).toBe(null);
    });
    test('should not fetch if no orderId provided', async ()=>{
        // Arrange & Act
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrderDetail)(''));
        // Wait a bit to ensure no fetch is made
        await new Promise((resolve)=>setTimeout(resolve, 100));
        // Assert
        expect(mockFetch).not.toHaveBeenCalled();
        expect(result.current.loading).toBe(true);
    });
    test('should refresh order detail', async ()=>{
        // Arrange
        mockFetch.mockImplementation(()=>Promise.resolve({
                ok: true,
                status: 200,
                json: ()=>Promise.resolve({
                        data: {
                            order: _ordersmocks.mockOrders[0],
                            statusHistory: [],
                            notes: []
                        },
                        success: true,
                        error: null
                    })
            }));
        const { result } = (0, _react.renderHook)(()=>(0, _useOrdersEnterprise.useOrderDetail)('order-1'));
        // Wait for initial fetch
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        const initialCallCount = mockFetch.mock.calls.length;
        // Act
        await (0, _react.act)(async ()=>{
            result.current.refresh();
        });
        // Assert
        expect(mockFetch.mock.calls.length).toBe(initialCallCount + 1);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlT3JkZXJzRW50ZXJwcmlzZS50ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBJTlRFWUEgRS1DT01NRVJDRSAtIFVTRSBPUkRFUlMgRU5URVJQUklTRSBIT09LIFRFU1RTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbXBvcnQgeyByZW5kZXJIb29rLCBhY3QsIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcclxuaW1wb3J0IHsgdXNlT3JkZXJzRW50ZXJwcmlzZSwgdXNlT3JkZXJEZXRhaWwgfSBmcm9tICdAL2hvb2tzL3VzZU9yZGVyc0VudGVycHJpc2UnO1xyXG5pbXBvcnQgeyBcclxuICBtb2NrT3JkZXJzLCBcclxuICBjcmVhdGVNb2NrRmV0Y2gsIFxyXG4gIHJlc2V0QWxsTW9ja3MgXHJcbn0gZnJvbSAnLi4vc2V0dXAvb3JkZXJzLW1vY2tzJztcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFNFVFVQIE1PQ0tTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5jb25zdCBtb2NrRmV0Y2ggPSBjcmVhdGVNb2NrRmV0Y2goKTtcclxuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgQsOBU0lDT1MgdXNlT3JkZXJzRW50ZXJwcmlzZVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICByZXNldEFsbE1vY2tzKCk7XHJcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBpbml0aWFsaXplIHdpdGggZGVmYXVsdCBzdGF0ZScsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2UgJiBBY3RcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyc0VudGVycHJpc2UoKSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0IGluaXRpYWwgc3RhdGVcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5vcmRlcnMpLnRvRXF1YWwoW10pO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUodHJ1ZSk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmUobnVsbCk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZmlsdGVycykudG9FcXVhbCh7XHJcbiAgICAgIHBhZ2U6IDEsXHJcbiAgICAgIGxpbWl0OiAyMCxcclxuICAgICAgc29ydF9ieTogJ2NyZWF0ZWRfYXQnLFxyXG4gICAgICBzb3J0X29yZGVyOiAnZGVzYydcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgZmV0Y2ggb3JkZXJzIG9uIG1vdW50JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZSAmIEFjdFxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBmZXRjaCB0byBjb21wbGV0ZVxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCcvYXBpL2FkbWluL29yZGVycycpXHJcbiAgICApO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lm9yZGVycykudG9FcXVhbChtb2NrT3JkZXJzKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZShudWxsKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIGhhbmRsZSBmZXRjaCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBtb2NrRmV0Y2gubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiBcclxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICBvazogZmFsc2UsXHJcbiAgICAgICAgc3RhdHVzOiA1MDAsXHJcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZXJyb3I6ICdTZXJ2ZXIgZXJyb3InIH0pXHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBmZXRjaCB0byBjb21wbGV0ZVxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlKCdFcnJvciBhbCBjYXJnYXIgw7NyZGVuZXMnKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5vcmRlcnMpLnRvRXF1YWwoW10pO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgYWNjZXB0IGluaXRpYWwgZmlsdGVycycsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2VcclxuICAgIGNvbnN0IGluaXRpYWxGaWx0ZXJzID0ge1xyXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcclxuICAgICAgcGFnZTogMixcclxuICAgICAgbGltaXQ6IDEwXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZShpbml0aWFsRmlsdGVycykpO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmZpbHRlcnMpLnRvRXF1YWwoe1xyXG4gICAgICBwYWdlOiAyLFxyXG4gICAgICBsaW1pdDogMTAsXHJcbiAgICAgIHNvcnRfYnk6ICdjcmVhdGVkX2F0JyxcclxuICAgICAgc29ydF9vcmRlcjogJ2Rlc2MnLFxyXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJ1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgZmV0Y2ggdG8gY29tcGxldGVcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnc3RhdHVzPXBlbmRpbmcnKVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgRklMVFJPU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UgLSBGaWx0ZXJzJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgcmVzZXRBbGxNb2NrcygpO1xyXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgdXBkYXRlIHNlYXJjaCBmaWx0ZXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNldFNlYXJjaCgndGVzdCBzZWFyY2gnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdzZWFyY2g9dGVzdCcpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgdXBkYXRlIHN0YXR1cyBmaWx0ZXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNldFN0YXR1cygncGVuZGluZycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ3N0YXR1cz1wZW5kaW5nJylcclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCB1cGRhdGUgcGF5bWVudCBzdGF0dXMgZmlsdGVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBpbml0aWFsIGZldGNoXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWN0XHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICByZXN1bHQuY3VycmVudC5zZXRQYXltZW50U3RhdHVzKCdwYWlkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygncGF5bWVudF9zdGF0dXM9cGFpZCcpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgdXBkYXRlIHNvcnRpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNldFNvcnRpbmcoJ3RvdGFsX2Ftb3VudCcsICdhc2MnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdzb3J0X2J5PXRvdGFsX2Ftb3VudCcpXHJcbiAgICApO1xyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdzb3J0X29yZGVyPWFzYycpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgdXBkYXRlIGRhdGUgcmFuZ2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNldERhdGVSYW5nZSgnMjAyNC0wMS0wMScsICcyMDI0LTAxLTMxJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnZGF0ZV9mcm9tPTIwMjQtMDEtMDEnKVxyXG4gICAgKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIGNsZWFyIGFsbCBmaWx0ZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSh7XHJcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxyXG4gICAgICBzZWFyY2g6ICd0ZXN0JyxcclxuICAgICAgcGFnZTogM1xyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LmNsZWFyRmlsdGVycygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0IC0gVmVyaWZpY2FyIHF1ZSBzZSBsbGFtw7MgYSBmZXRjaCBjb24gZmlsdHJvcyBsaW1waWFkb3NcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnL2FwaS9hZG1pbi9vcmRlcnMnKVxyXG4gICAgKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBQQUdJTkFDScOTTlxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UgLSBQYWdpbmF0aW9uJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgcmVzZXRBbGxNb2NrcygpO1xyXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgaGFuZGxlIHBhZ2UgY2hhbmdlcycsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2VcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyc0VudGVycHJpc2UoKSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBmZXRjaFxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgcmVzdWx0LmN1cnJlbnQuc2V0UGFnZSgyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdwYWdlPTInKVxyXG4gICAgKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIHByb3ZpZGUgcGFnaW5hdGlvbiBoZWxwZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4gXHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgb3JkZXJzOiBtb2NrT3JkZXJzLFxyXG4gICAgICAgICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgcGFnZTogMixcclxuICAgICAgICAgICAgICBsaW1pdDogMjAsXHJcbiAgICAgICAgICAgICAgdG90YWw6IDUwLFxyXG4gICAgICAgICAgICAgIHRvdGFsUGFnZXM6IDMsXHJcbiAgICAgICAgICAgICAgaGFzTmV4dFBhZ2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgaGFzUHJldmlvdXNQYWdlOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZpbHRlcnM6IHt9XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcclxuICAgICAgICAgIGVycm9yOiBudWxsXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBmZXRjaCB0byBjb21wbGV0ZVxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydCBwYWdpbmF0aW9uIGhlbHBlcnNcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNOZXh0UGFnZSkudG9CZSh0cnVlKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNQcmV2aW91c1BhZ2UpLnRvQmUodHJ1ZSk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQudG90YWxPcmRlcnMpLnRvQmUoNTApO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmN1cnJlbnRQYWdlKS50b0JlKDIpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnRvdGFsUGFnZXMpLnRvQmUoMyk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgT1BFUkFDSU9ORVMgQ1JVRFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UgLSBDUlVEIE9wZXJhdGlvbnMnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICByZXNldEFsbE1vY2tzKCk7XHJcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBjcmVhdGUgb3JkZXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBvcmRlckRhdGEgPSB7XHJcbiAgICAgIHVzZXJfaWQ6ICd0ZXN0LXVzZXItaWQnLFxyXG4gICAgICBpdGVtczogW3sgcHJvZHVjdF9pZDogMSwgcXVhbnRpdHk6IDEsIHVuaXRfcHJpY2U6IDE1MDAwIH1dXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgbGV0IGNyZWF0ZWRPcmRlcjtcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNyZWF0ZWRPcmRlciA9IGF3YWl0IHJlc3VsdC5jdXJyZW50LmNyZWF0ZU9yZGVyKG9yZGVyRGF0YSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAnL2FwaS9hZG1pbi9vcmRlcnMnLFxyXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkob3JkZXJEYXRhKVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICAgIGV4cGVjdChjcmVhdGVkT3JkZXIpLnRvQmVEZWZpbmVkKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCB1cGRhdGUgb3JkZXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0geyBub3RlczogJ1VwZGF0ZWQgbm90ZXMnIH07XHJcblxyXG4gICAgLy8gQWN0XHJcbiAgICBsZXQgdXBkYXRlZE9yZGVyO1xyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgdXBkYXRlZE9yZGVyID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQudXBkYXRlT3JkZXIoJ29yZGVyLTEnLCB1cGRhdGVEYXRhKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICcvYXBpL2FkbWluL29yZGVycy9vcmRlci0xJyxcclxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xyXG4gICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICAgIGV4cGVjdCh1cGRhdGVkT3JkZXIpLnRvQmVEZWZpbmVkKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBjaGFuZ2Ugb3JkZXIgc3RhdHVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBpbml0aWFsIGZldGNoXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWN0XHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5jaGFuZ2VPcmRlclN0YXR1cygnb3JkZXItMScsICdjb25maXJtZWQnLCAnUGF5bWVudCBjb25maXJtZWQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICcvYXBpL2FkbWluL29yZGVycy9vcmRlci0xL3N0YXR1cycsXHJcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBzdGF0dXM6ICdjb25maXJtZWQnLFxyXG4gICAgICAgICAgcmVhc29uOiAnUGF5bWVudCBjb25maXJtZWQnXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBoYW5kbGUgYnVsayBzdGF0dXMgdXBkYXRlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlT3JkZXJzRW50ZXJwcmlzZSgpKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBpbml0aWFsIGZldGNoXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgYnVsa0RhdGEgPSB7XHJcbiAgICAgIG9yZGVyX2lkczogWydvcmRlci0xJywgJ29yZGVyLTInXSxcclxuICAgICAgc3RhdHVzOiAnY29uZmlybWVkJyxcclxuICAgICAgcmVhc29uOiAnQnVsayBjb25maXJtYXRpb24nXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgbGV0IGJ1bGtSZXN1bHQ7XHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBidWxrUmVzdWx0ID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQuYnVsa1VwZGF0ZVN0YXR1cyhidWxrRGF0YSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICAnL2FwaS9hZG1pbi9vcmRlcnMvYnVsaz9vcGVyYXRpb249c3RhdHVzX3VwZGF0ZScsXHJcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShidWxrRGF0YSlcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgICBleHBlY3QoYnVsa1Jlc3VsdCkudG9CZURlZmluZWQoKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIGV4cG9ydCBvcmRlcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGxldCBleHBvcnRSZXN1bHQ7XHJcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xyXG4gICAgICBleHBvcnRSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5leHBvcnRPcmRlcnMoJ2NzdicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgJy9hcGkvYWRtaW4vb3JkZXJzL2J1bGs/b3BlcmF0aW9uPWV4cG9ydCcsXHJcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICBmb3JtYXQ6ICdjc3YnLFxyXG4gICAgICAgICAgZmlsdGVyczogcmVzdWx0LmN1cnJlbnQuZmlsdGVycyxcclxuICAgICAgICAgIGluY2x1ZGVfaXRlbXM6IHRydWVcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICAgIGV4cGVjdChleHBvcnRSZXN1bHQpLnRvQmVEZWZpbmVkKCk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgVVRJTElEQURFU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyc0VudGVycHJpc2UgLSBVdGlsaXRpZXMnLCAoKSA9PiB7XHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICByZXNldEFsbE1vY2tzKCk7XHJcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKCk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBnZXQgb3JkZXIgYnkgaWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGNvbnN0IG9yZGVyID0gcmVzdWx0LmN1cnJlbnQuZ2V0T3JkZXJCeUlkKCdvcmRlci0xJyk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3Qob3JkZXIpLnRvRXF1YWwobW9ja09yZGVyc1swXSk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBnZXQgb3JkZXJzIGJ5IHN0YXR1cycsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2VcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyc0VudGVycHJpc2UoKSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBmZXRjaFxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgY29uc3QgcGVuZGluZ09yZGVycyA9IHJlc3VsdC5jdXJyZW50LmdldE9yZGVyc0J5U3RhdHVzKCdwZW5kaW5nJyk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QocGVuZGluZ09yZGVycykudG9FcXVhbChcclxuICAgICAgbW9ja09yZGVycy5maWx0ZXIob3JkZXIgPT4gb3JkZXIuc3RhdHVzID09PSAncGVuZGluZycpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgY2FsY3VsYXRlIHRvdGFsIHJldmVudWUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGNvbnN0IHRvdGFsUmV2ZW51ZSA9IHJlc3VsdC5jdXJyZW50LmdldFRvdGFsUmV2ZW51ZSgpO1xyXG5cclxuICAgIC8vIEFzc2VydFxyXG4gICAgY29uc3QgZXhwZWN0ZWRSZXZlbnVlID0gbW9ja09yZGVyc1xyXG4gICAgICAuZmlsdGVyKG9yZGVyID0+IG9yZGVyLnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpXHJcbiAgICAgIC5yZWR1Y2UoKHN1bSwgb3JkZXIpID0+IHN1bSArIG9yZGVyLnRvdGFsX2Ftb3VudCwgMCk7XHJcbiAgICBleHBlY3QodG90YWxSZXZlbnVlKS50b0JlKGV4cGVjdGVkUmV2ZW51ZSk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCBjYWxjdWxhdGUgYXZlcmFnZSBvcmRlciB2YWx1ZScsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEFycmFuZ2VcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyc0VudGVycHJpc2UoKSk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBmZXRjaFxyXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgY29uc3QgYXZnT3JkZXJWYWx1ZSA9IHJlc3VsdC5jdXJyZW50LmdldEF2ZXJhZ2VPcmRlclZhbHVlKCk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBjb25zdCB2YWxpZE9yZGVycyA9IG1vY2tPcmRlcnMuZmlsdGVyKG9yZGVyID0+IG9yZGVyLnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRBdmcgPSB2YWxpZE9yZGVycy5yZWR1Y2UoKHN1bSwgb3JkZXIpID0+IHN1bSArIG9yZGVyLnRvdGFsX2Ftb3VudCwgMCkgLyB2YWxpZE9yZGVycy5sZW5ndGg7XHJcbiAgICBleHBlY3QoYXZnT3JkZXJWYWx1ZSkudG9CZShleHBlY3RlZEF2Zyk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Nob3VsZCByZWZyZXNoIGRhdGEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlXHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlcnNFbnRlcnByaXNlKCkpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsQ2FsbENvdW50ID0gbW9ja0ZldGNoLm1vY2suY2FsbHMubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgcmVzdWx0LmN1cnJlbnQucmVmcmVzaCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoLm1vY2suY2FsbHMubGVuZ3RoKS50b0JlKGluaXRpYWxDYWxsQ291bnQgKyAxKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyB1c2VPcmRlckRldGFpbFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZU9yZGVyRGV0YWlsJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgcmVzZXRBbGxNb2NrcygpO1xyXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgZmV0Y2ggb3JkZXIgZGV0YWlsJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4gXHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgb2s6IHRydWUsXHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgb3JkZXI6IG1vY2tPcmRlcnNbMF0sXHJcbiAgICAgICAgICAgIHN0YXR1c0hpc3Rvcnk6IFtdLFxyXG4gICAgICAgICAgICBub3RlczogW11cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgICAgZXJyb3I6IG51bGxcclxuICAgICAgICB9KVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyRGV0YWlsKCdvcmRlci0xJykpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGZldGNoIHRvIGNvbXBsZXRlXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2FwaS9hZG1pbi9vcmRlcnMvb3JkZXItMScpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lm9yZGVyKS50b0VxdWFsKG1vY2tPcmRlcnNbMF0pO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlKG51bGwpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgaGFuZGxlIGZldGNoIGVycm9yJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4gXHJcbiAgICAgIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgb2s6IGZhbHNlLFxyXG4gICAgICAgIHN0YXR1czogNDA0LFxyXG4gICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IGVycm9yOiAnT3JkZXIgbm90IGZvdW5kJyB9KVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBBY3RcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyRGV0YWlsKCdvcmRlci0xJykpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGZldGNoIHRvIGNvbXBsZXRlXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmUoJ09yZGVyIG5vdCBmb3VuZCcpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lm9yZGVyKS50b0JlKG51bGwpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdzaG91bGQgbm90IGZldGNoIGlmIG5vIG9yZGVySWQgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBBcnJhbmdlICYgQWN0XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VPcmRlckRldGFpbCgnJykpO1xyXG5cclxuICAgIC8vIFdhaXQgYSBiaXQgdG8gZW5zdXJlIG5vIGZldGNoIGlzIG1hZGVcclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcclxuXHJcbiAgICAvLyBBc3NlcnRcclxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZSh0cnVlKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgnc2hvdWxkIHJlZnJlc2ggb3JkZXIgZGV0YWlsJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgLy8gQXJyYW5nZVxyXG4gICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBcclxuICAgICAgUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICBvazogdHJ1ZSxcclxuICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICBvcmRlcjogbW9ja09yZGVyc1swXSxcclxuICAgICAgICAgICAgc3RhdHVzSGlzdG9yeTogW10sXHJcbiAgICAgICAgICAgIG5vdGVzOiBbXVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgICBlcnJvcjogbnVsbFxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU9yZGVyRGV0YWlsKCdvcmRlci0xJykpO1xyXG5cclxuICAgIC8vIFdhaXQgZm9yIGluaXRpYWwgZmV0Y2hcclxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpbml0aWFsQ2FsbENvdW50ID0gbW9ja0ZldGNoLm1vY2suY2FsbHMubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFjdFxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgcmVzdWx0LmN1cnJlbnQucmVmcmVzaCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXNzZXJ0XHJcbiAgICBleHBlY3QobW9ja0ZldGNoLm1vY2suY2FsbHMubGVuZ3RoKS50b0JlKGluaXRpYWxDYWxsQ291bnQgKyAxKTtcclxuICB9KTtcclxufSk7XHJcblxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsibW9ja0ZldGNoIiwiY3JlYXRlTW9ja0ZldGNoIiwiZ2xvYmFsIiwiZmV0Y2giLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJyZXNldEFsbE1vY2tzIiwibW9ja0NsZWFyIiwidGVzdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VPcmRlcnNFbnRlcnByaXNlIiwiZXhwZWN0IiwiY3VycmVudCIsIm9yZGVycyIsInRvRXF1YWwiLCJsb2FkaW5nIiwidG9CZSIsImVycm9yIiwiZmlsdGVycyIsInBhZ2UiLCJsaW1pdCIsInNvcnRfYnkiLCJzb3J0X29yZGVyIiwid2FpdEZvciIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwic3RyaW5nQ29udGFpbmluZyIsIm1vY2tPcmRlcnMiLCJtb2NrSW1wbGVtZW50YXRpb25PbmNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJvayIsInN0YXR1cyIsImpzb24iLCJpbml0aWFsRmlsdGVycyIsImFjdCIsInNldFNlYXJjaCIsInNldFN0YXR1cyIsInNldFBheW1lbnRTdGF0dXMiLCJzZXRTb3J0aW5nIiwic2V0RGF0ZVJhbmdlIiwic2VhcmNoIiwiY2xlYXJGaWx0ZXJzIiwic2V0UGFnZSIsImRhdGEiLCJwYWdpbmF0aW9uIiwidG90YWwiLCJ0b3RhbFBhZ2VzIiwiaGFzTmV4dFBhZ2UiLCJoYXNQcmV2aW91c1BhZ2UiLCJzdWNjZXNzIiwidG90YWxPcmRlcnMiLCJjdXJyZW50UGFnZSIsIm9yZGVyRGF0YSIsInVzZXJfaWQiLCJpdGVtcyIsInByb2R1Y3RfaWQiLCJxdWFudGl0eSIsInVuaXRfcHJpY2UiLCJjcmVhdGVkT3JkZXIiLCJjcmVhdGVPcmRlciIsIm9iamVjdENvbnRhaW5pbmciLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0b0JlRGVmaW5lZCIsInVwZGF0ZURhdGEiLCJub3RlcyIsInVwZGF0ZWRPcmRlciIsInVwZGF0ZU9yZGVyIiwiY2hhbmdlT3JkZXJTdGF0dXMiLCJyZWFzb24iLCJidWxrRGF0YSIsIm9yZGVyX2lkcyIsImJ1bGtSZXN1bHQiLCJidWxrVXBkYXRlU3RhdHVzIiwiZXhwb3J0UmVzdWx0IiwiZXhwb3J0T3JkZXJzIiwiZm9ybWF0IiwiaW5jbHVkZV9pdGVtcyIsIm9yZGVyIiwiZ2V0T3JkZXJCeUlkIiwicGVuZGluZ09yZGVycyIsImdldE9yZGVyc0J5U3RhdHVzIiwiZmlsdGVyIiwidG90YWxSZXZlbnVlIiwiZ2V0VG90YWxSZXZlbnVlIiwiZXhwZWN0ZWRSZXZlbnVlIiwicmVkdWNlIiwic3VtIiwidG90YWxfYW1vdW50IiwiYXZnT3JkZXJWYWx1ZSIsImdldEF2ZXJhZ2VPcmRlclZhbHVlIiwidmFsaWRPcmRlcnMiLCJleHBlY3RlZEF2ZyIsImxlbmd0aCIsImluaXRpYWxDYWxsQ291bnQiLCJtb2NrIiwiY2FsbHMiLCJyZWZyZXNoIiwic3RhdHVzSGlzdG9yeSIsInVzZU9yZGVyRGV0YWlsIiwic2V0VGltZW91dCIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJtb2NrSW1wbGVtZW50YXRpb24iXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0Qyx3REFBd0Q7QUFDeEQsc0NBQXNDOzs7Ozt1QkFFRztxQ0FDVzs2QkFLN0M7QUFFUCxzQ0FBc0M7QUFDdEMsY0FBYztBQUNkLHNDQUFzQztBQUV0QyxNQUFNQSxZQUFZQyxJQUFBQSw0QkFBZTtBQUNqQ0MsT0FBT0MsS0FBSyxHQUFHSDtBQUVmLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBRXRDSSxTQUFTLHVCQUF1QjtJQUM5QkMsV0FBVztRQUNUQyxJQUFBQSwwQkFBYTtRQUNiTixVQUFVTyxTQUFTO0lBQ3JCO0lBRUFDLEtBQUssd0NBQXdDO1FBQzNDLGdCQUFnQjtRQUNoQixNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxJQUFBQSxpQkFBVSxFQUFDLElBQU1DLElBQUFBLHdDQUFtQjtRQUV2RCx1QkFBdUI7UUFDdkJDLE9BQU9ILE9BQU9JLE9BQU8sQ0FBQ0MsTUFBTSxFQUFFQyxPQUFPLENB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