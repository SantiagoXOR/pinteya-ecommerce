32c94a1e361580d76cc64ecf5a7d0d68
// ===================================
// PINTEYA E-COMMERCE - RETRY LOGIC TESTS
// ===================================
"use strict";
// Mock logger
jest.mock('@/lib/enterprise/logger', ()=>({
        logger: {
            info: jest.fn(),
            debug: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            INFO: 'info',
            DEBUG: 'debug',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            SYSTEM: 'system',
            PAYMENT: 'payment'
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _retrylogic = require("../../lib/retry-logic");
describe('Retry Logic', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('retryWithBackoff', ()=>{
        const basicConfig = {
            maxRetries: 2,
            baseDelayMs: 100,
            maxDelayMs: 1000,
            backoffMultiplier: 2,
            jitterMs: 50,
            retryableErrors: [
                'ECONNRESET',
                '500'
            ],
            nonRetryableErrors: [
                '400',
                '401'
            ]
        };
        it('should succeed on first attempt', async ()=>{
            const mockOperation = jest.fn().mockResolvedValue('success');
            const promise = (0, _retrylogic.retryWithBackoff)(mockOperation, basicConfig, 'test-operation');
            const result = await promise;
            expect(result.success).toBe(true);
            expect(result.data).toBe('success');
            expect(result.attempts).toBe(1);
            expect(mockOperation).toHaveBeenCalledTimes(1);
        });
        it('should retry on retryable errors', async ()=>{
            // Usar configuración con delays muy pequeños para tests rápidos
            const fastConfig = {
                ...basicConfig,
                baseDelayMs: 1,
                maxDelayMs: 5,
                jitterMs: 0
            };
            const mockOperation = jest.fn().mockRejectedValueOnce(new Error('ECONNRESET')).mockResolvedValue('success');
            const result = await (0, _retrylogic.retryWithBackoff)(mockOperation, fastConfig, 'test-operation');
            expect(result.success).toBe(true);
            expect(result.data).toBe('success');
            expect(result.attempts).toBe(2);
            expect(mockOperation).toHaveBeenCalledTimes(2);
        });
        it('should not retry on non-retryable errors', async ()=>{
            const mockOperation = jest.fn().mockRejectedValue(new Error('400 Bad Request'));
            const result = await (0, _retrylogic.retryWithBackoff)(mockOperation, basicConfig, 'test-operation');
            expect(result.success).toBe(false);
            expect(result.attempts).toBe(1);
            expect(result.error?.message).toContain('400');
            expect(mockOperation).toHaveBeenCalledTimes(1);
        });
        it('should fail after max retries', async ()=>{
            const fastConfig = {
                ...basicConfig,
                baseDelayMs: 1,
                maxDelayMs: 5,
                jitterMs: 0
            };
            const mockOperation = jest.fn().mockRejectedValue(new Error('ECONNRESET'));
            const result = await (0, _retrylogic.retryWithBackoff)(mockOperation, fastConfig, 'test-operation');
            expect(result.success).toBe(false);
            expect(result.attempts).toBe(3); // Intento inicial + 2 retries
            expect(result.error?.message).toContain('ECONNRESET');
            expect(mockOperation).toHaveBeenCalledTimes(3);
        });
        it('should calculate exponential backoff delays', async ()=>{
            const delays = [];
            const originalSetTimeout = global.setTimeout;
            // Mock setTimeout para capturar delays
            global.setTimeout = jest.fn((callback, delay)=>{
                delays.push(delay);
                return originalSetTimeout(callback, 0); // Ejecutar inmediatamente
            });
            const fastConfig = {
                ...basicConfig,
                baseDelayMs: 10,
                maxDelayMs: 100,
                jitterMs: 5
            };
            const mockOperation = jest.fn().mockRejectedValueOnce(new Error('500')).mockRejectedValueOnce(new Error('500')).mockResolvedValue('success');
            await (0, _retrylogic.retryWithBackoff)(mockOperation, fastConfig, 'test-operation');
            // Verificar que los delays aumentan exponencialmente
            expect(delays.length).toBe(2);
            expect(delays[0]).toBeGreaterThanOrEqual(10); // baseDelay + jitter
            expect(delays[1]).toBeGreaterThanOrEqual(20); // baseDelay * 2 + jitter
            global.setTimeout = originalSetTimeout;
        });
        it('should respect max delay limit', async ()=>{
            const configWithLowMaxDelay = {
                ...basicConfig,
                baseDelayMs: 10,
                maxDelayMs: 15,
                backoffMultiplier: 10,
                jitterMs: 5
            };
            const delays = [];
            const originalSetTimeout = global.setTimeout;
            global.setTimeout = jest.fn((callback, delay)=>{
                delays.push(delay);
                return originalSetTimeout(callback, 0);
            });
            const mockOperation = jest.fn().mockRejectedValueOnce(new Error('500')).mockResolvedValue('success');
            await (0, _retrylogic.retryWithBackoff)(mockOperation, configWithLowMaxDelay, 'test-operation');
            // El delay no debe exceder maxDelayMs + jitter
            expect(delays[0]).toBeLessThanOrEqual(15 + 5);
            global.setTimeout = originalSetTimeout;
        });
    });
    describe('Retry Configurations', ()=>{
        it('should have MercadoPago critical config', ()=>{
            const config = _retrylogic.RETRY_CONFIGS.MERCADOPAGO_CRITICAL;
            expect(config.maxRetries).toBe(3);
            expect(config.baseDelayMs).toBe(1000);
            expect(config.retryableErrors).toContain('500');
            expect(config.retryableErrors).toContain('ECONNRESET');
            expect(config.nonRetryableErrors).toContain('400');
            expect(config.nonRetryableErrors).toContain('401');
        });
        it('should have MercadoPago query config', ()=>{
            const config = _retrylogic.RETRY_CONFIGS.MERCADOPAGO_QUERY;
            expect(config.maxRetries).toBe(2);
            expect(config.baseDelayMs).toBe(500);
            expect(config.retryableErrors).toContain('500');
            expect(config.nonRetryableErrors).toContain('400');
        });
        it('should have webhook processing config', ()=>{
            const config = _retrylogic.RETRY_CONFIGS.WEBHOOK_PROCESSING;
            expect(config.maxRetries).toBe(1);
            expect(config.baseDelayMs).toBe(2000);
            expect(config.retryableErrors).toContain('500');
            expect(config.nonRetryableErrors).toContain('DUPLICATE_WEBHOOK');
        });
    });
    describe('retryMercadoPagoOperation', ()=>{
        it('should use critical config for critical operations', async ()=>{
            const mockOperation = jest.fn().mockResolvedValue('success');
            const result = await (0, _retrylogic.retryMercadoPagoOperation)(mockOperation, 'test', true);
            expect(result.success).toBe(true);
            expect(result.data).toBe('success');
            expect(mockOperation).toHaveBeenCalledTimes(1);
        });
        it('should use query config for non-critical operations', async ()=>{
            const mockOperation = jest.fn().mockResolvedValue('success');
            const result = await (0, _retrylogic.retryMercadoPagoOperation)(mockOperation, 'test', false);
            expect(result.success).toBe(true);
            expect(result.data).toBe('success');
            expect(mockOperation).toHaveBeenCalledTimes(1);
        });
        it('should retry critical operations more times', async ()=>{
            // Mock la configuración para hacer el test más rápido
            const originalConfig = require('@/lib/retry-logic').RETRY_CONFIGS.MERCADOPAGO_CRITICAL;
            require('@/lib/retry-logic').RETRY_CONFIGS.MERCADOPAGO_CRITICAL = {
                ...originalConfig,
                baseDelayMs: 1,
                maxDelayMs: 5,
                jitterMs: 0
            };
            const mockOperation = jest.fn().mockRejectedValue(new Error('500'));
            const result = await (0, _retrylogic.retryMercadoPagoOperation)(mockOperation, 'test', true);
            expect(result.success).toBe(false);
            expect(result.attempts).toBe(4); // 1 inicial + 3 retries para críticas
            expect(mockOperation).toHaveBeenCalledTimes(4);
            // Restaurar configuración original
            require('@/lib/retry-logic').RETRY_CONFIGS.MERCADOPAGO_CRITICAL = originalConfig;
        });
    });
    describe('retryWebhookOperation', ()=>{
        it('should use webhook config', async ()=>{
            const mockOperation = jest.fn().mockResolvedValue('success');
            const result = await (0, _retrylogic.retryWebhookOperation)(mockOperation, 'test');
            expect(result.success).toBe(true);
            expect(result.data).toBe('success');
            expect(mockOperation).toHaveBeenCalledTimes(1);
        });
        it('should retry webhook operations limited times', async ()=>{
            // Mock la configuración para hacer el test más rápido
            const originalConfig = require('@/lib/retry-logic').RETRY_CONFIGS.WEBHOOK_PROCESSING;
            require('@/lib/retry-logic').RETRY_CONFIGS.WEBHOOK_PROCESSING = {
                ...originalConfig,
                baseDelayMs: 1,
                maxDelayMs: 5,
                jitterMs: 0
            };
            const mockOperation = jest.fn().mockRejectedValue(new Error('500'));
            const result = await (0, _retrylogic.retryWebhookOperation)(mockOperation, 'test');
            expect(result.success).toBe(false);
            expect(result.attempts).toBe(2); // 1 inicial + 1 retry para webhooks
            expect(mockOperation).toHaveBeenCalledTimes(2);
            // Restaurar configuración original
            require('@/lib/retry-logic').RETRY_CONFIGS.WEBHOOK_PROCESSING = originalConfig;
        });
    });
    describe('Error Classification', ()=>{
        const basicConfig = {
            maxRetries: 2,
            baseDelayMs: 100,
            maxDelayMs: 1000,
            backoffMultiplier: 2,
            jitterMs: 50,
            retryableErrors: [
                'ECONNRESET',
                '500'
            ],
            nonRetryableErrors: [
                '400',
                '401'
            ]
        };
        it('should identify network errors as retryable', async ()=>{
            const fastConfig = {
                ...basicConfig,
                baseDelayMs: 1,
                maxDelayMs: 5,
                jitterMs: 0,
                retryableErrors: [
                    'ECONNRESET',
                    'ENOTFOUND',
                    'ETIMEDOUT'
                ],
                nonRetryableErrors: [
                    '400',
                    '401'
                ]
            };
            const networkErrors = [
                'ECONNRESET',
                'ENOTFOUND',
                'ETIMEDOUT'
            ];
            for (const errorCode of networkErrors){
                const mockOperation = jest.fn().mockRejectedValueOnce(new Error(errorCode)).mockResolvedValue('success');
                const result = await (0, _retrylogic.retryWithBackoff)(mockOperation, fastConfig, 'test');
                expect(result.success).toBe(true);
                expect(result.attempts).toBe(2);
                jest.clearAllMocks();
            }
        });
        it('should identify HTTP 4xx errors as non-retryable', async ()=>{
            const clientErrors = [
                '400',
                '401',
                '403',
                '404'
            ];
            for (const errorCode of clientErrors){
                const mockOperation = jest.fn().mockRejectedValue(new Error(`${errorCode} Error`));
                const result = await (0, _retrylogic.retryWithBackoff)(mockOperation, _retrylogic.RETRY_CONFIGS.MERCADOPAGO_CRITICAL, 'test');
                expect(result.success).toBe(false);
                expect(result.attempts).toBe(1); // No retry
                jest.clearAllMocks();
            }
        });
        it('should identify HTTP 5xx errors as retryable', async ()=>{
            const fastConfig = {
                maxRetries: 2,
                baseDelayMs: 1,
                maxDelayMs: 5,
                backoffMultiplier: 2,
                jitterMs: 0,
                retryableErrors: [
                    '500',
                    '502',
                    '503',
                    '504'
                ],
                nonRetryableErrors: [
                    '400',
                    '401'
                ]
            };
            const serverErrors = [
                '500',
                '502',
                '503',
                '504'
            ];
            for (const errorCode of serverErrors){
                const mockOperation = jest.fn().mockRejectedValueOnce(new Error(`${errorCode} Error`)).mockResolvedValue('success');
                const result = await (0, _retrylogic.retryWithBackoff)(mockOperation, fastConfig, 'test');
                expect(result.success).toBe(true);
                expect(result.attempts).toBe(2);
                jest.clearAllMocks();
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxsaWJcXHJldHJ5LWxvZ2ljLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gUElOVEVZQSBFLUNPTU1FUkNFIC0gUkVUUlkgTE9HSUMgVEVTVFNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmltcG9ydCB7XHJcbiAgcmV0cnlXaXRoQmFja29mZixcclxuICByZXRyeU1lcmNhZG9QYWdvT3BlcmF0aW9uLFxyXG4gIHJldHJ5V2ViaG9va09wZXJhdGlvbixcclxuICBSRVRSWV9DT05GSUdTLFxyXG4gIFJldHJ5Q29uZmlnXHJcbn0gZnJvbSAnQC9saWIvcmV0cnktbG9naWMnO1xyXG5cclxuLy8gTW9jayBsb2dnZXJcclxuamVzdC5tb2NrKCdAL2xpYi9lbnRlcnByaXNlL2xvZ2dlcicsICgpID0+ICh7XHJcbiAgbG9nZ2VyOiB7XHJcbiAgICBpbmZvOiBqZXN0LmZuKCksXHJcbiAgICBkZWJ1ZzogamVzdC5mbigpLFxyXG4gICAgd2FybjogamVzdC5mbigpLFxyXG4gICAgZXJyb3I6IGplc3QuZm4oKSxcclxuICB9LFxyXG4gIExvZ0xldmVsOiB7XHJcbiAgICBJTkZPOiAnaW5mbycsXHJcbiAgICBERUJVRzogJ2RlYnVnJyxcclxuICAgIFdBUk46ICd3YXJuJyxcclxuICAgIEVSUk9SOiAnZXJyb3InLFxyXG4gIH0sXHJcbiAgTG9nQ2F0ZWdvcnk6IHtcclxuICAgIFNZU1RFTTogJ3N5c3RlbScsXHJcbiAgICBQQVlNRU5UOiAncGF5bWVudCcsXHJcbiAgfSxcclxufSkpO1xyXG5cclxuZGVzY3JpYmUoJ1JldHJ5IExvZ2ljJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdyZXRyeVdpdGhCYWNrb2ZmJywgKCkgPT4ge1xyXG4gICAgY29uc3QgYmFzaWNDb25maWc6IFJldHJ5Q29uZmlnID0ge1xyXG4gICAgICBtYXhSZXRyaWVzOiAyLFxyXG4gICAgICBiYXNlRGVsYXlNczogMTAwLFxyXG4gICAgICBtYXhEZWxheU1zOiAxMDAwLFxyXG4gICAgICBiYWNrb2ZmTXVsdGlwbGllcjogMixcclxuICAgICAgaml0dGVyTXM6IDUwLFxyXG4gICAgICByZXRyeWFibGVFcnJvcnM6IFsnRUNPTk5SRVNFVCcsICc1MDAnXSxcclxuICAgICAgbm9uUmV0cnlhYmxlRXJyb3JzOiBbJzQwMCcsICc0MDEnXVxyXG4gICAgfTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHN1Y2NlZWQgb24gZmlyc3QgYXR0ZW1wdCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnc3VjY2VzcycpO1xyXG5cclxuICAgICAgY29uc3QgcHJvbWlzZSA9IHJldHJ5V2l0aEJhY2tvZmYobW9ja09wZXJhdGlvbiwgYmFzaWNDb25maWcsICd0ZXN0LW9wZXJhdGlvbicpO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xyXG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQmUoJ3N1Y2Nlc3MnKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5hdHRlbXB0cykudG9CZSgxKTtcclxuICAgICAgZXhwZWN0KG1vY2tPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0cnkgb24gcmV0cnlhYmxlIGVycm9ycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgLy8gVXNhciBjb25maWd1cmFjacOzbiBjb24gZGVsYXlzIG11eSBwZXF1ZcOxb3MgcGFyYSB0ZXN0cyByw6FwaWRvc1xyXG4gICAgICBjb25zdCBmYXN0Q29uZmlnOiBSZXRyeUNvbmZpZyA9IHtcclxuICAgICAgICAuLi5iYXNpY0NvbmZpZyxcclxuICAgICAgICBiYXNlRGVsYXlNczogMSxcclxuICAgICAgICBtYXhEZWxheU1zOiA1LFxyXG4gICAgICAgIGppdHRlck1zOiAwXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpXHJcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ0VDT05OUkVTRVQnKSlcclxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWUoJ3N1Y2Nlc3MnKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5V2l0aEJhY2tvZmYobW9ja09wZXJhdGlvbiwgZmFzdENvbmZpZywgJ3Rlc3Qtb3BlcmF0aW9uJyk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZSgnc3VjY2VzcycpO1xyXG4gICAgICBleHBlY3QocmVzdWx0LmF0dGVtcHRzKS50b0JlKDIpO1xyXG4gICAgICBleHBlY3QobW9ja09wZXJhdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBub3QgcmV0cnkgb24gbm9uLXJldHJ5YWJsZSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCc0MDAgQmFkIFJlcXVlc3QnKSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeVdpdGhCYWNrb2ZmKG1vY2tPcGVyYXRpb24sIGJhc2ljQ29uZmlnLCAndGVzdC1vcGVyYXRpb24nKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuYXR0ZW1wdHMpLnRvQmUoMSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3I/Lm1lc3NhZ2UpLnRvQ29udGFpbignNDAwJyk7XHJcbiAgICAgIGV4cGVjdChtb2NrT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGZhaWwgYWZ0ZXIgbWF4IHJldHJpZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGZhc3RDb25maWc6IFJldHJ5Q29uZmlnID0ge1xyXG4gICAgICAgIC4uLmJhc2ljQ29uZmlnLFxyXG4gICAgICAgIGJhc2VEZWxheU1zOiAxLFxyXG4gICAgICAgIG1heERlbGF5TXM6IDUsXHJcbiAgICAgICAgaml0dGVyTXM6IDBcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IG1vY2tPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdFQ09OTlJFU0VUJykpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnlXaXRoQmFja29mZihtb2NrT3BlcmF0aW9uLCBmYXN0Q29uZmlnLCAndGVzdC1vcGVyYXRpb24nKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuYXR0ZW1wdHMpLnRvQmUoMyk7IC8vIEludGVudG8gaW5pY2lhbCArIDIgcmV0cmllc1xyXG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yPy5tZXNzYWdlKS50b0NvbnRhaW4oJ0VDT05OUkVTRVQnKTtcclxuICAgICAgZXhwZWN0KG1vY2tPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgY2FsY3VsYXRlIGV4cG9uZW50aWFsIGJhY2tvZmYgZGVsYXlzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBkZWxheXM6IG51bWJlcltdID0gW107XHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsU2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xyXG5cclxuICAgICAgLy8gTW9jayBzZXRUaW1lb3V0IHBhcmEgY2FwdHVyYXIgZGVsYXlzXHJcbiAgICAgIGdsb2JhbC5zZXRUaW1lb3V0ID0gamVzdC5mbigoY2FsbGJhY2ssIGRlbGF5KSA9PiB7XHJcbiAgICAgICAgZGVsYXlzLnB1c2goZGVsYXkpO1xyXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFNldFRpbWVvdXQoY2FsbGJhY2ssIDApOyAvLyBFamVjdXRhciBpbm1lZGlhdGFtZW50ZVxyXG4gICAgICB9KSBhcyBhbnk7XHJcblxyXG4gICAgICBjb25zdCBmYXN0Q29uZmlnOiBSZXRyeUNvbmZpZyA9IHtcclxuICAgICAgICAuLi5iYXNpY0NvbmZpZyxcclxuICAgICAgICBiYXNlRGVsYXlNczogMTAsXHJcbiAgICAgICAgbWF4RGVsYXlNczogMTAwLFxyXG4gICAgICAgIGppdHRlck1zOiA1XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpXHJcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJzUwMCcpKVxyXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCc1MDAnKSlcclxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWUoJ3N1Y2Nlc3MnKTtcclxuXHJcbiAgICAgIGF3YWl0IHJldHJ5V2l0aEJhY2tvZmYobW9ja09wZXJhdGlvbiwgZmFzdENvbmZpZywgJ3Rlc3Qtb3BlcmF0aW9uJyk7XHJcblxyXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIGxvcyBkZWxheXMgYXVtZW50YW4gZXhwb25lbmNpYWxtZW50ZVxyXG4gICAgICBleHBlY3QoZGVsYXlzLmxlbmd0aCkudG9CZSgyKTtcclxuICAgICAgZXhwZWN0KGRlbGF5c1swXSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgxMCk7IC8vIGJhc2VEZWxheSArIGppdHRlclxyXG4gICAgICBleHBlY3QoZGVsYXlzWzFdKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDIwKTsgLy8gYmFzZURlbGF5ICogMiArIGppdHRlclxyXG5cclxuICAgICAgZ2xvYmFsLnNldFRpbWVvdXQgPSBvcmlnaW5hbFNldFRpbWVvdXQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJlc3BlY3QgbWF4IGRlbGF5IGxpbWl0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb25maWdXaXRoTG93TWF4RGVsYXk6IFJldHJ5Q29uZmlnID0ge1xyXG4gICAgICAgIC4uLmJhc2ljQ29uZmlnLFxyXG4gICAgICAgIGJhc2VEZWxheU1zOiAxMCxcclxuICAgICAgICBtYXhEZWxheU1zOiAxNSwgLy8gTMOtbWl0ZSBiYWpvXHJcbiAgICAgICAgYmFja29mZk11bHRpcGxpZXI6IDEwLCAvLyBNdWx0aXBsaWNhZG9yIGFsdG9cclxuICAgICAgICBqaXR0ZXJNczogNVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgZGVsYXlzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICBjb25zdCBvcmlnaW5hbFNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcclxuXHJcbiAgICAgIGdsb2JhbC5zZXRUaW1lb3V0ID0gamVzdC5mbigoY2FsbGJhY2ssIGRlbGF5KSA9PiB7XHJcbiAgICAgICAgZGVsYXlzLnB1c2goZGVsYXkpO1xyXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xyXG4gICAgICB9KSBhcyBhbnk7XHJcblxyXG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpXHJcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJzUwMCcpKVxyXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZSgnc3VjY2VzcycpO1xyXG5cclxuICAgICAgYXdhaXQgcmV0cnlXaXRoQmFja29mZihtb2NrT3BlcmF0aW9uLCBjb25maWdXaXRoTG93TWF4RGVsYXksICd0ZXN0LW9wZXJhdGlvbicpO1xyXG5cclxuICAgICAgLy8gRWwgZGVsYXkgbm8gZGViZSBleGNlZGVyIG1heERlbGF5TXMgKyBqaXR0ZXJcclxuICAgICAgZXhwZWN0KGRlbGF5c1swXSkudG9CZUxlc3NUaGFuT3JFcXVhbCgxNSArIDUpO1xyXG5cclxuICAgICAgZ2xvYmFsLnNldFRpbWVvdXQgPSBvcmlnaW5hbFNldFRpbWVvdXQ7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1JldHJ5IENvbmZpZ3VyYXRpb25zJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBoYXZlIE1lcmNhZG9QYWdvIGNyaXRpY2FsIGNvbmZpZycsICgpID0+IHtcclxuICAgICAgY29uc3QgY29uZmlnID0gUkVUUllfQ09ORklHUy5NRVJDQURPUEFHT19DUklUSUNBTDtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChjb25maWcubWF4UmV0cmllcykudG9CZSgzKTtcclxuICAgICAgZXhwZWN0KGNvbmZpZy5iYXNlRGVsYXlNcykudG9CZSgxMDAwKTtcclxuICAgICAgZXhwZWN0KGNvbmZpZy5yZXRyeWFibGVFcnJvcnMpLnRvQ29udGFpbignNTAwJyk7XHJcbiAgICAgIGV4cGVjdChjb25maWcucmV0cnlhYmxlRXJyb3JzKS50b0NvbnRhaW4oJ0VDT05OUkVTRVQnKTtcclxuICAgICAgZXhwZWN0KGNvbmZpZy5ub25SZXRyeWFibGVFcnJvcnMpLnRvQ29udGFpbignNDAwJyk7XHJcbiAgICAgIGV4cGVjdChjb25maWcubm9uUmV0cnlhYmxlRXJyb3JzKS50b0NvbnRhaW4oJzQwMScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYXZlIE1lcmNhZG9QYWdvIHF1ZXJ5IGNvbmZpZycsICgpID0+IHtcclxuICAgICAgY29uc3QgY29uZmlnID0gUkVUUllfQ09ORklHUy5NRVJDQURPUEFHT19RVUVSWTtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChjb25maWcubWF4UmV0cmllcykudG9CZSgyKTtcclxuICAgICAgZXhwZWN0KGNvbmZpZy5iYXNlRGVsYXlNcykudG9CZSg1MDApO1xyXG4gICAgICBleHBlY3QoY29uZmlnLnJldHJ5YWJsZUVycm9ycykudG9Db250YWluKCc1MDAnKTtcclxuICAgICAgZXhwZWN0KGNvbmZpZy5ub25SZXRyeWFibGVFcnJvcnMpLnRvQ29udGFpbignNDAwJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhdmUgd2ViaG9vayBwcm9jZXNzaW5nIGNvbmZpZycsICgpID0+IHtcclxuICAgICAgY29uc3QgY29uZmlnID0gUkVUUllfQ09ORklHUy5XRUJIT09LX1BST0NFU1NJTkc7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoY29uZmlnLm1heFJldHJpZXMpLnRvQmUoMSk7XHJcbiAgICAgIGV4cGVjdChjb25maWcuYmFzZURlbGF5TXMpLnRvQmUoMjAwMCk7XHJcbiAgICAgIGV4cGVjdChjb25maWcucmV0cnlhYmxlRXJyb3JzKS50b0NvbnRhaW4oJzUwMCcpO1xyXG4gICAgICBleHBlY3QoY29uZmlnLm5vblJldHJ5YWJsZUVycm9ycykudG9Db250YWluKCdEVVBMSUNBVEVfV0VCSE9PSycpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdyZXRyeU1lcmNhZG9QYWdvT3BlcmF0aW9uJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCB1c2UgY3JpdGljYWwgY29uZmlnIGZvciBjcml0aWNhbCBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdzdWNjZXNzJyk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeU1lcmNhZG9QYWdvT3BlcmF0aW9uKG1vY2tPcGVyYXRpb24sICd0ZXN0JywgdHJ1ZSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZSgnc3VjY2VzcycpO1xyXG4gICAgICBleHBlY3QobW9ja09wZXJhdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCB1c2UgcXVlcnkgY29uZmlnIGZvciBub24tY3JpdGljYWwgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnc3VjY2VzcycpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnlNZXJjYWRvUGFnb09wZXJhdGlvbihtb2NrT3BlcmF0aW9uLCAndGVzdCcsIGZhbHNlKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0JlKCdzdWNjZXNzJyk7XHJcbiAgICAgIGV4cGVjdChtb2NrT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJldHJ5IGNyaXRpY2FsIG9wZXJhdGlvbnMgbW9yZSB0aW1lcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgLy8gTW9jayBsYSBjb25maWd1cmFjacOzbiBwYXJhIGhhY2VyIGVsIHRlc3QgbcOhcyByw6FwaWRvXHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ29uZmlnID0gcmVxdWlyZSgnQC9saWIvcmV0cnktbG9naWMnKS5SRVRSWV9DT05GSUdTLk1FUkNBRE9QQUdPX0NSSVRJQ0FMO1xyXG4gICAgICByZXF1aXJlKCdAL2xpYi9yZXRyeS1sb2dpYycpLlJFVFJZX0NPTkZJR1MuTUVSQ0FET1BBR09fQ1JJVElDQUwgPSB7XHJcbiAgICAgICAgLi4ub3JpZ2luYWxDb25maWcsXHJcbiAgICAgICAgYmFzZURlbGF5TXM6IDEsXHJcbiAgICAgICAgbWF4RGVsYXlNczogNSxcclxuICAgICAgICBqaXR0ZXJNczogMFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJzUwMCcpKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5TWVyY2Fkb1BhZ29PcGVyYXRpb24obW9ja09wZXJhdGlvbiwgJ3Rlc3QnLCB0cnVlKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuYXR0ZW1wdHMpLnRvQmUoNCk7IC8vIDEgaW5pY2lhbCArIDMgcmV0cmllcyBwYXJhIGNyw610aWNhc1xyXG4gICAgICBleHBlY3QobW9ja09wZXJhdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDQpO1xyXG5cclxuICAgICAgLy8gUmVzdGF1cmFyIGNvbmZpZ3VyYWNpw7NuIG9yaWdpbmFsXHJcbiAgICAgIHJlcXVpcmUoJ0AvbGliL3JldHJ5LWxvZ2ljJykuUkVUUllfQ09ORklHUy5NRVJDQURPUEFHT19DUklUSUNBTCA9IG9yaWdpbmFsQ29uZmlnO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdyZXRyeVdlYmhvb2tPcGVyYXRpb24nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHVzZSB3ZWJob29rIGNvbmZpZycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnc3VjY2VzcycpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnlXZWJob29rT3BlcmF0aW9uKG1vY2tPcGVyYXRpb24sICd0ZXN0Jyk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZSgnc3VjY2VzcycpO1xyXG4gICAgICBleHBlY3QobW9ja09wZXJhdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXRyeSB3ZWJob29rIG9wZXJhdGlvbnMgbGltaXRlZCB0aW1lcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgLy8gTW9jayBsYSBjb25maWd1cmFjacOzbiBwYXJhIGhhY2VyIGVsIHRlc3QgbcOhcyByw6FwaWRvXHJcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ29uZmlnID0gcmVxdWlyZSgnQC9saWIvcmV0cnktbG9naWMnKS5SRVRSWV9DT05GSUdTLldFQkhPT0tfUFJPQ0VTU0lORztcclxuICAgICAgcmVxdWlyZSgnQC9saWIvcmV0cnktbG9naWMnKS5SRVRSWV9DT05GSUdTLldFQkhPT0tfUFJPQ0VTU0lORyA9IHtcclxuICAgICAgICAuLi5vcmlnaW5hbENvbmZpZyxcclxuICAgICAgICBiYXNlRGVsYXlNczogMSxcclxuICAgICAgICBtYXhEZWxheU1zOiA1LFxyXG4gICAgICAgIGppdHRlck1zOiAwXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignNTAwJykpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnlXZWJob29rT3BlcmF0aW9uKG1vY2tPcGVyYXRpb24sICd0ZXN0Jyk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QocmVzdWx0LmF0dGVtcHRzKS50b0JlKDIpOyAvLyAxIGluaWNpYWwgKyAxIHJldHJ5IHBhcmEgd2ViaG9va3NcclxuICAgICAgZXhwZWN0KG1vY2tPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcclxuXHJcbiAgICAgIC8vIFJlc3RhdXJhciBjb25maWd1cmFjacOzbiBvcmlnaW5hbFxyXG4gICAgICByZXF1aXJlKCdAL2xpYi9yZXRyeS1sb2dpYycpLlJFVFJZX0NPTkZJR1MuV0VCSE9PS19QUk9DRVNTSU5HID0gb3JpZ2luYWxDb25maWc7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ0Vycm9yIENsYXNzaWZpY2F0aW9uJywgKCkgPT4ge1xyXG4gICAgY29uc3QgYmFzaWNDb25maWc6IFJldHJ5Q29uZmlnID0ge1xyXG4gICAgICBtYXhSZXRyaWVzOiAyLFxyXG4gICAgICBiYXNlRGVsYXlNczogMTAwLFxyXG4gICAgICBtYXhEZWxheU1zOiAxMDAwLFxyXG4gICAgICBiYWNrb2ZmTXVsdGlwbGllcjogMixcclxuICAgICAgaml0dGVyTXM6IDUwLFxyXG4gICAgICByZXRyeWFibGVFcnJvcnM6IFsnRUNPTk5SRVNFVCcsICc1MDAnXSxcclxuICAgICAgbm9uUmV0cnlhYmxlRXJyb3JzOiBbJzQwMCcsICc0MDEnXVxyXG4gICAgfTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGlkZW50aWZ5IG5ldHdvcmsgZXJyb3JzIGFzIHJldHJ5YWJsZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgZmFzdENvbmZpZzogUmV0cnlDb25maWcgPSB7XHJcbiAgICAgICAgLi4uYmFzaWNDb25maWcsXHJcbiAgICAgICAgYmFzZURlbGF5TXM6IDEsXHJcbiAgICAgICAgbWF4RGVsYXlNczogNSxcclxuICAgICAgICBqaXR0ZXJNczogMCxcclxuICAgICAgICByZXRyeWFibGVFcnJvcnM6IFsnRUNPTk5SRVNFVCcsICdFTk9URk9VTkQnLCAnRVRJTUVET1VUJ10sXHJcbiAgICAgICAgbm9uUmV0cnlhYmxlRXJyb3JzOiBbJzQwMCcsICc0MDEnXVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgbmV0d29ya0Vycm9ycyA9IFsnRUNPTk5SRVNFVCcsICdFTk9URk9VTkQnLCAnRVRJTUVET1VUJ107XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IGVycm9yQ29kZSBvZiBuZXR3b3JrRXJyb3JzKSB7XHJcbiAgICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKVxyXG4gICAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoZXJyb3JDb2RlKSlcclxuICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZSgnc3VjY2VzcycpO1xyXG5cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeVdpdGhCYWNrb2ZmKG1vY2tPcGVyYXRpb24sIGZhc3RDb25maWcsICd0ZXN0Jyk7XHJcblxyXG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmF0dGVtcHRzKS50b0JlKDIpO1xyXG5cclxuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBpZGVudGlmeSBIVFRQIDR4eCBlcnJvcnMgYXMgbm9uLXJldHJ5YWJsZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY2xpZW50RXJyb3JzID0gWyc0MDAnLCAnNDAxJywgJzQwMycsICc0MDQnXTtcclxuICAgICAgXHJcbiAgICAgIGZvciAoY29uc3QgZXJyb3JDb2RlIG9mIGNsaWVudEVycm9ycykge1xyXG4gICAgICAgIGNvbnN0IG1vY2tPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKGAke2Vycm9yQ29kZX0gRXJyb3JgKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5V2l0aEJhY2tvZmYobW9ja09wZXJhdGlvbiwgUkVUUllfQ09ORklHUy5NRVJDQURPUEFHT19DUklUSUNBTCwgJ3Rlc3QnKTtcclxuXHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmF0dGVtcHRzKS50b0JlKDEpOyAvLyBObyByZXRyeVxyXG4gICAgICAgIFxyXG4gICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGlkZW50aWZ5IEhUVFAgNXh4IGVycm9ycyBhcyByZXRyeWFibGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGZhc3RDb25maWc6IFJldHJ5Q29uZmlnID0ge1xyXG4gICAgICAgIG1heFJldHJpZXM6IDIsXHJcbiAgICAgICAgYmFzZURlbGF5TXM6IDEsXHJcbiAgICAgICAgbWF4RGVsYXlNczogNSxcclxuICAgICAgICBiYWNrb2ZmTXVsdGlwbGllcjogMixcclxuICAgICAgICBqaXR0ZXJNczogMCxcclxuICAgICAgICByZXRyeWFibGVFcnJvcnM6IFsnNTAwJywgJzUwMicsICc1MDMnLCAnNTA0J10sXHJcbiAgICAgICAgbm9uUmV0cnlhYmxlRXJyb3JzOiBbJzQwMCcsICc0MDEnXVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3Qgc2VydmVyRXJyb3JzID0gWyc1MDAnLCAnNTAyJywgJzUwMycsICc1MDQnXTtcclxuXHJcbiAgICAgIGZvciAoY29uc3QgZXJyb3JDb2RlIG9mIHNlcnZlckVycm9ycykge1xyXG4gICAgICAgIGNvbnN0IG1vY2tPcGVyYXRpb24gPSBqZXN0LmZuKClcclxuICAgICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKGAke2Vycm9yQ29kZX0gRXJyb3JgKSlcclxuICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZSgnc3VjY2VzcycpO1xyXG5cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeVdpdGhCYWNrb2ZmKG1vY2tPcGVyYXRpb24sIGZhc3RDb25maWcsICd0ZXN0Jyk7XHJcblxyXG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcclxuICAgICAgICBleHBlY3QocmVzdWx0LmF0dGVtcHRzKS50b0JlKDIpO1xyXG5cclxuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJsb2dnZXIiLCJpbmZvIiwiZm4iLCJkZWJ1ZyIsIndhcm4iLCJlcnJvciIsIkxvZ0xldmVsIiwiSU5GTyIsIkRFQlVHIiwiV0FSTiIsIkVSUk9SIiwiTG9nQ2F0ZWdvcnkiLCJTWVNURU0iLCJQQVlNRU5UIiwiZGVzY3JpYmUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImJhc2ljQ29uZmlnIiwibWF4UmV0cmllcyIsImJhc2VEZWxheU1zIiwibWF4RGVsYXlNcyIsImJhY2tvZmZNdWx0aXBsaWVyIiwiaml0dGVyTXMiLCJyZXRyeWFibGVFcnJvcnMiLCJub25SZXRyeWFibGVFcnJvcnMiLCJpdCIsIm1vY2tPcGVyYXRpb24iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInByb21pc2UiLCJyZXRyeVdpdGhCYWNrb2ZmIiwicmVzdWx0IiwiZXhwZWN0Iiwic3VjY2VzcyIsInRvQmUiLCJkYXRhIiwiYXR0ZW1wdHMiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJmYXN0Q29uZmlnIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwiRXJyb3IiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIm1lc3NhZ2UiLCJ0b0NvbnRhaW4iLCJkZWxheXMiLCJvcmlnaW5hbFNldFRpbWVvdXQiLCJnbG9iYWwiLCJzZXRUaW1lb3V0IiwiY2FsbGJhY2siLCJkZWxheSIsInB1c2giLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwiY29uZmlnV2l0aExvd01heERlbGF5IiwidG9CZUxlc3NUaGFuT3JFcXVhbCIsImNvbmZpZyIsIlJFVFJZX0NPTkZJR1MiLCJNRVJDQURPUEFHT19DUklUSUNBTCIsIk1FUkNBRE9QQUdPX1FVRVJZIiwiV0VCSE9PS19QUk9DRVNTSU5HIiwicmV0cnlNZXJjYWRvUGFnb09wZXJhdGlvbiIsIm9yaWdpbmFsQ29uZmlnIiwicmVxdWlyZSIsInJldHJ5V2ViaG9va09wZXJhdGlvbiIsIm5ldHdvcmtFcnJvcnMiLCJlcnJvckNvZGUiLCJjbGllbnRFcnJvcnMiLCJzZXJ2ZXJFcnJvcnMiXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsc0NBQXNDOztBQVV0QyxjQUFjO0FBQ2RBLEtBQUtDLElBQUksQ0FBQywyQkFBMkIsSUFBTyxDQUFBO1FBQzFDQyxRQUFRO1lBQ05DLE1BQU1ILEtBQUtJLEVBQUU7WUFDYkMsT0FBT0wsS0FBS0ksRUFBRTtZQUNkRSxNQUFNTixLQUFLSSxFQUFFO1lBQ2JHLE9BQU9QLEtBQUtJLEVBQUU7UUFDaEI7UUFDQUksVUFBVTtZQUNSQyxNQUFNO1lBQ05DLE9BQU87WUFDUEMsTUFBTTtZQUNOQyxPQUFPO1FBQ1Q7UUFDQUMsYUFBYTtZQUNYQyxRQUFRO1lBQ1JDLFNBQVM7UUFDWDtJQUNGLENBQUE7Ozs7NEJBcEJPO0FBc0JQQyxTQUFTLGVBQWU7SUFDdEJDLFdBQVc7UUFDVGpCLEtBQUtrQixhQUFhO0lBQ3BCO0lBRUFGLFNBQVMsb0JBQW9CO1FBQzNCLE1BQU1HLGNBQTJCO1lBQy9CQyxZQUFZO1lBQ1pDLGFBQWE7WUFDYkMsWUFBWTtZQUNaQyxtQkFBbUI7WUFDbkJDLFVBQVU7WUFDVkMsaUJBQWlCO2dCQUFDO2dCQUFjO2FBQU07WUFDdENDLG9CQUFvQjtnQkFBQztnQkFBTzthQUFNO1FBQ3BDO1FB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