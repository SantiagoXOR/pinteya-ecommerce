48cdaf3f5a150f49ac2ec08eba122b14
// ===================================
// HOOK: useBrandFilter
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get brandsToUrlString () {
        return brandsToUrlString;
    },
    get filterValidBrands () {
        return filterValidBrands;
    },
    get urlStringToBrands () {
        return urlStringToBrands;
    },
    get useBrandFilter () {
        return useBrandFilter;
    },
    get useSimpleBrandFilter () {
        return useSimpleBrandFilter;
    },
    get validateBrand () {
        return validateBrand;
    }
});
const _react = require("react");
const _brands = require("../lib/api/brands");
const _navigation = require("next/navigation");
function useBrandFilter(options = {}) {
    const { autoLoad = true, syncWithUrl = false, urlParam = 'brands', minProducts = 1, onBrandsChange } = options;
    const router = (0, _navigation.useRouter)();
    const searchParams = (0, _navigation.useSearchParams)();
    // Estados
    const [brands, setBrands] = (0, _react.useState)([]);
    const [selectedBrands, setSelectedBrandsState] = (0, _react.useState)([]);
    const [isLoading, setIsLoading] = (0, _react.useState)(false);
    const [error, setError] = (0, _react.useState)(null);
    // Inicializar marcas seleccionadas desde URL
    (0, _react.useEffect)(()=>{
        if (syncWithUrl && searchParams) {
            const urlBrands = searchParams.get(urlParam);
            if (urlBrands) {
                const brandsArray = urlBrands.split(',').filter(Boolean);
                setSelectedBrandsState(brandsArray);
            }
        }
    }, [
        syncWithUrl,
        urlParam,
        searchParams
    ]);
    // Cargar marcas
    const fetchBrands = (0, _react.useCallback)(async ()=>{
        setIsLoading(true);
        setError(null);
        try {
            const response = await (0, _brands.getBrands)({
                minProducts
            });
            if (response.success && response.data) {
                setBrands(response.data);
            } else {
                setError(response.error || 'Error cargando marcas');
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error desconocido');
        } finally{
            setIsLoading(false);
        }
    }, [
        minProducts
    ]);
    // Cargar marcas automáticamente
    (0, _react.useEffect)(()=>{
        if (autoLoad) {
            fetchBrands();
        }
    }, [
        autoLoad,
        fetchBrands
    ]);
    // Actualizar URL cuando cambian las marcas seleccionadas
    const updateUrl = (0, _react.useCallback)((newBrands)=>{
        if (!syncWithUrl) {
            return;
        }
        const params = new URLSearchParams(searchParams?.toString());
        if (newBrands.length > 0) {
            params.set(urlParam, newBrands.join(','));
        } else {
            params.delete(urlParam);
        }
        const newUrl = `${window.location.pathname}?${params.toString()}`;
        router.push(newUrl, {
            scroll: false
        });
    }, [
        syncWithUrl,
        urlParam,
        searchParams,
        router
    ]);
    // Función para cambiar marcas seleccionadas
    const setSelectedBrands = (0, _react.useCallback)((newBrands)=>{
        setSelectedBrandsState(newBrands);
        updateUrl(newBrands);
        onBrandsChange?.(newBrands);
    }, [
        updateUrl,
        onBrandsChange
    ]);
    // Función para alternar una marca
    const toggleBrand = (0, _react.useCallback)((brandName)=>{
        const newBrands = selectedBrands.includes(brandName) ? selectedBrands.filter((b)=>b !== brandName) : [
            ...selectedBrands,
            brandName
        ];
        setSelectedBrands(newBrands);
    }, [
        selectedBrands,
        setSelectedBrands
    ]);
    // Función para limpiar todas las marcas
    const clearBrands = (0, _react.useCallback)(()=>{
        setSelectedBrands([]);
    }, [
        setSelectedBrands
    ]);
    // Función para buscar marcas
    const searchBrands = (0, _react.useCallback)(async (searchTerm)=>{
        setIsLoading(true);
        setError(null);
        try {
            const response = await (0, _brands.getBrands)({
                search: searchTerm,
                minProducts
            });
            if (response.success && response.data) {
                setBrands(response.data);
            } else {
                setError(response.error || 'Error buscando marcas');
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error desconocido');
        } finally{
            setIsLoading(false);
        }
    }, [
        minProducts
    ]);
    return {
        brands,
        selectedBrands,
        isLoading,
        error,
        setSelectedBrands,
        toggleBrand,
        clearBrands,
        refetch: fetchBrands,
        searchBrands
    };
}
function useSimpleBrandFilter() {
    const [selectedBrands, setSelectedBrands] = (0, _react.useState)([]);
    const toggleBrand = (0, _react.useCallback)((brandName)=>{
        setSelectedBrands((prev)=>prev.includes(brandName) ? prev.filter((b)=>b !== brandName) : [
                ...prev,
                brandName
            ]);
    }, []);
    const clearBrands = (0, _react.useCallback)(()=>{
        setSelectedBrands([]);
    }, []);
    return {
        selectedBrands,
        setSelectedBrands,
        toggleBrand,
        clearBrands
    };
}
function brandsToUrlString(brands) {
    return brands.join(',');
}
function urlStringToBrands(urlString) {
    return urlString.split(',').filter(Boolean);
}
function validateBrand(brandName, availableBrands) {
    return availableBrands.some((brand)=>brand.name === brandName);
}
function filterValidBrands(brandNames, availableBrands) {
    return brandNames.filter((name)=>validateBrand(name, availableBrands));
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcaG9va3NcXHVzZUJyYW5kRmlsdGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIT09LOiB1c2VCcmFuZEZpbHRlclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGdldEJyYW5kcywgQnJhbmQgfSBmcm9tICdAL2xpYi9hcGkvYnJhbmRzJ1xuaW1wb3J0IHsgdXNlUm91dGVyLCB1c2VTZWFyY2hQYXJhbXMgfSBmcm9tICduZXh0L25hdmlnYXRpb24nXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUSVBPU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VCcmFuZEZpbHRlck9wdGlvbnMge1xuICAvKiogQ2FyZ2FyIG1hcmNhcyBhdXRvbcOhdGljYW1lbnRlIGFsIG1vbnRhciAqL1xuICBhdXRvTG9hZD86IGJvb2xlYW5cbiAgLyoqIFNpbmNyb25pemFyIGNvbiBVUkwgc2VhcmNoIHBhcmFtcyAqL1xuICBzeW5jV2l0aFVybD86IGJvb2xlYW5cbiAgLyoqIFBhcsOhbWV0cm8gZGUgVVJMIHBhcmEgbGFzIG1hcmNhcyAqL1xuICB1cmxQYXJhbT86IHN0cmluZ1xuICAvKiogTcOtbmltbyBuw7ptZXJvIGRlIHByb2R1Y3RvcyBwb3IgbWFyY2EgKi9cbiAgbWluUHJvZHVjdHM/OiBudW1iZXJcbiAgLyoqIENhbGxiYWNrIGN1YW5kbyBjYW1iaWFuIGxhcyBtYXJjYXMgc2VsZWNjaW9uYWRhcyAqL1xuICBvbkJyYW5kc0NoYW5nZT86IChicmFuZHM6IHN0cmluZ1tdKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQnJhbmRGaWx0ZXJSZXR1cm4ge1xuICAvKiogTGlzdGEgZGUgbWFyY2FzIGRpc3BvbmlibGVzICovXG4gIGJyYW5kczogQnJhbmRbXVxuICAvKiogTWFyY2FzIHNlbGVjY2lvbmFkYXMgKi9cbiAgc2VsZWN0ZWRCcmFuZHM6IHN0cmluZ1tdXG4gIC8qKiBFc3RhZG8gZGUgY2FyZ2EgKi9cbiAgaXNMb2FkaW5nOiBib29sZWFuXG4gIC8qKiBFcnJvciBzaSBvY3VycmUgKi9cbiAgZXJyb3I6IHN0cmluZyB8IG51bGxcbiAgLyoqIEZ1bmNpw7NuIHBhcmEgY2FtYmlhciBtYXJjYXMgc2VsZWNjaW9uYWRhcyAqL1xuICBzZXRTZWxlY3RlZEJyYW5kczogKGJyYW5kczogc3RyaW5nW10pID0+IHZvaWRcbiAgLyoqIEZ1bmNpw7NuIHBhcmEgYWx0ZXJuYXIgdW5hIG1hcmNhICovXG4gIHRvZ2dsZUJyYW5kOiAoYnJhbmROYW1lOiBzdHJpbmcpID0+IHZvaWRcbiAgLyoqIEZ1bmNpw7NuIHBhcmEgbGltcGlhciB0b2RhcyBsYXMgbWFyY2FzICovXG4gIGNsZWFyQnJhbmRzOiAoKSA9PiB2b2lkXG4gIC8qKiBGdW5jacOzbiBwYXJhIHJlY2FyZ2FyIG1hcmNhcyAqL1xuICByZWZldGNoOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIC8qKiBGdW5jacOzbiBwYXJhIGJ1c2NhciBtYXJjYXMgKi9cbiAgc2VhcmNoQnJhbmRzOiAoc2VhcmNoVGVybTogc3RyaW5nKSA9PiB2b2lkXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIT09LIFBSSU5DSVBBTFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJyYW5kRmlsdGVyKG9wdGlvbnM6IFVzZUJyYW5kRmlsdGVyT3B0aW9ucyA9IHt9KTogVXNlQnJhbmRGaWx0ZXJSZXR1cm4ge1xuICBjb25zdCB7XG4gICAgYXV0b0xvYWQgPSB0cnVlLFxuICAgIHN5bmNXaXRoVXJsID0gZmFsc2UsXG4gICAgdXJsUGFyYW0gPSAnYnJhbmRzJyxcbiAgICBtaW5Qcm9kdWN0cyA9IDEsXG4gICAgb25CcmFuZHNDaGFuZ2UsXG4gIH0gPSBvcHRpb25zXG5cbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zKClcblxuICAvLyBFc3RhZG9zXG4gIGNvbnN0IFticmFuZHMsIHNldEJyYW5kc10gPSB1c2VTdGF0ZTxCcmFuZFtdPihbXSlcbiAgY29uc3QgW3NlbGVjdGVkQnJhbmRzLCBzZXRTZWxlY3RlZEJyYW5kc1N0YXRlXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSlcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpXG5cbiAgLy8gSW5pY2lhbGl6YXIgbWFyY2FzIHNlbGVjY2lvbmFkYXMgZGVzZGUgVVJMXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHN5bmNXaXRoVXJsICYmIHNlYXJjaFBhcmFtcykge1xuICAgICAgY29uc3QgdXJsQnJhbmRzID0gc2VhcmNoUGFyYW1zLmdldCh1cmxQYXJhbSlcbiAgICAgIGlmICh1cmxCcmFuZHMpIHtcbiAgICAgICAgY29uc3QgYnJhbmRzQXJyYXkgPSB1cmxCcmFuZHMuc3BsaXQoJywnKS5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgc2V0U2VsZWN0ZWRCcmFuZHNTdGF0ZShicmFuZHNBcnJheSlcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzeW5jV2l0aFVybCwgdXJsUGFyYW0sIHNlYXJjaFBhcmFtc10pXG5cbiAgLy8gQ2FyZ2FyIG1hcmNhc1xuICBjb25zdCBmZXRjaEJyYW5kcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSlcbiAgICBzZXRFcnJvcihudWxsKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0QnJhbmRzKHsgbWluUHJvZHVjdHMgfSlcblxuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MgJiYgcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICBzZXRCcmFuZHMocmVzcG9uc2UuZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdFcnJvciBjYXJnYW5kbyBtYXJjYXMnKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvciBkZXNjb25vY2lkbycpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICB9XG4gIH0sIFttaW5Qcm9kdWN0c10pXG5cbiAgLy8gQ2FyZ2FyIG1hcmNhcyBhdXRvbcOhdGljYW1lbnRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGF1dG9Mb2FkKSB7XG4gICAgICBmZXRjaEJyYW5kcygpXG4gICAgfVxuICB9LCBbYXV0b0xvYWQsIGZldGNoQnJhbmRzXSlcblxuICAvLyBBY3R1YWxpemFyIFVSTCBjdWFuZG8gY2FtYmlhbiBsYXMgbWFyY2FzIHNlbGVjY2lvbmFkYXNcbiAgY29uc3QgdXBkYXRlVXJsID0gdXNlQ2FsbGJhY2soXG4gICAgKG5ld0JyYW5kczogc3RyaW5nW10pID0+IHtcbiAgICAgIGlmICghc3luY1dpdGhVcmwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoUGFyYW1zPy50b1N0cmluZygpKVxuXG4gICAgICBpZiAobmV3QnJhbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFyYW1zLnNldCh1cmxQYXJhbSwgbmV3QnJhbmRzLmpvaW4oJywnKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5kZWxldGUodXJsUGFyYW0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1VybCA9IGAke3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZX0/JHtwYXJhbXMudG9TdHJpbmcoKX1gXG4gICAgICByb3V0ZXIucHVzaChuZXdVcmwsIHsgc2Nyb2xsOiBmYWxzZSB9KVxuICAgIH0sXG4gICAgW3N5bmNXaXRoVXJsLCB1cmxQYXJhbSwgc2VhcmNoUGFyYW1zLCByb3V0ZXJdXG4gIClcblxuICAvLyBGdW5jacOzbiBwYXJhIGNhbWJpYXIgbWFyY2FzIHNlbGVjY2lvbmFkYXNcbiAgY29uc3Qgc2V0U2VsZWN0ZWRCcmFuZHMgPSB1c2VDYWxsYmFjayhcbiAgICAobmV3QnJhbmRzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgc2V0U2VsZWN0ZWRCcmFuZHNTdGF0ZShuZXdCcmFuZHMpXG4gICAgICB1cGRhdGVVcmwobmV3QnJhbmRzKVxuICAgICAgb25CcmFuZHNDaGFuZ2U/LihuZXdCcmFuZHMpXG4gICAgfSxcbiAgICBbdXBkYXRlVXJsLCBvbkJyYW5kc0NoYW5nZV1cbiAgKVxuXG4gIC8vIEZ1bmNpw7NuIHBhcmEgYWx0ZXJuYXIgdW5hIG1hcmNhXG4gIGNvbnN0IHRvZ2dsZUJyYW5kID0gdXNlQ2FsbGJhY2soXG4gICAgKGJyYW5kTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBuZXdCcmFuZHMgPSBzZWxlY3RlZEJyYW5kcy5pbmNsdWRlcyhicmFuZE5hbWUpXG4gICAgICAgID8gc2VsZWN0ZWRCcmFuZHMuZmlsdGVyKGIgPT4gYiAhPT0gYnJhbmROYW1lKVxuICAgICAgICA6IFsuLi5zZWxlY3RlZEJyYW5kcywgYnJhbmROYW1lXVxuXG4gICAgICBzZXRTZWxlY3RlZEJyYW5kcyhuZXdCcmFuZHMpXG4gICAgfSxcbiAgICBbc2VsZWN0ZWRCcmFuZHMsIHNldFNlbGVjdGVkQnJhbmRzXVxuICApXG5cbiAgLy8gRnVuY2nDs24gcGFyYSBsaW1waWFyIHRvZGFzIGxhcyBtYXJjYXNcbiAgY29uc3QgY2xlYXJCcmFuZHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRCcmFuZHMoW10pXG4gIH0sIFtzZXRTZWxlY3RlZEJyYW5kc10pXG5cbiAgLy8gRnVuY2nDs24gcGFyYSBidXNjYXIgbWFyY2FzXG4gIGNvbnN0IHNlYXJjaEJyYW5kcyA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChzZWFyY2hUZXJtOiBzdHJpbmcpID0+IHtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKVxuICAgICAgc2V0RXJyb3IobnVsbClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRCcmFuZHMoe1xuICAgICAgICAgIHNlYXJjaDogc2VhcmNoVGVybSxcbiAgICAgICAgICBtaW5Qcm9kdWN0cyxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgc2V0QnJhbmRzKHJlc3BvbnNlLmRhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0RXJyb3IocmVzcG9uc2UuZXJyb3IgfHwgJ0Vycm9yIGJ1c2NhbmRvIG1hcmNhcycpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0Vycm9yIGRlc2Nvbm9jaWRvJylcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIFttaW5Qcm9kdWN0c11cbiAgKVxuXG4gIHJldHVybiB7XG4gICAgYnJhbmRzLFxuICAgIHNlbGVjdGVkQnJhbmRzLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBzZXRTZWxlY3RlZEJyYW5kcyxcbiAgICB0b2dnbGVCcmFuZCxcbiAgICBjbGVhckJyYW5kcyxcbiAgICByZWZldGNoOiBmZXRjaEJyYW5kcyxcbiAgICBzZWFyY2hCcmFuZHMsXG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhPT0sgU0lNUExJRklDQURPXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2ltcGxlQnJhbmRGaWx0ZXIoKSB7XG4gIGNvbnN0IFtzZWxlY3RlZEJyYW5kcywgc2V0U2VsZWN0ZWRCcmFuZHNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKVxuXG4gIGNvbnN0IHRvZ2dsZUJyYW5kID0gdXNlQ2FsbGJhY2soKGJyYW5kTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRCcmFuZHMocHJldiA9PlxuICAgICAgcHJldi5pbmNsdWRlcyhicmFuZE5hbWUpID8gcHJldi5maWx0ZXIoYiA9PiBiICE9PSBicmFuZE5hbWUpIDogWy4uLnByZXYsIGJyYW5kTmFtZV1cbiAgICApXG4gIH0sIFtdKVxuXG4gIGNvbnN0IGNsZWFyQnJhbmRzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFNlbGVjdGVkQnJhbmRzKFtdKVxuICB9LCBbXSlcblxuICByZXR1cm4ge1xuICAgIHNlbGVjdGVkQnJhbmRzLFxuICAgIHNldFNlbGVjdGVkQnJhbmRzLFxuICAgIHRvZ2dsZUJyYW5kLFxuICAgIGNsZWFyQnJhbmRzLFxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVVElMSURBREVTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIENvbnZpZXJ0ZSBhcnJheSBkZSBtYXJjYXMgYSBzdHJpbmcgcGFyYSBVUkxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJyYW5kc1RvVXJsU3RyaW5nKGJyYW5kczogc3RyaW5nW10pOiBzdHJpbmcge1xuICByZXR1cm4gYnJhbmRzLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENvbnZpZXJ0ZSBzdHJpbmcgZGUgVVJMIGEgYXJyYXkgZGUgbWFyY2FzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cmxTdHJpbmdUb0JyYW5kcyh1cmxTdHJpbmc6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIHVybFN0cmluZy5zcGxpdCgnLCcpLmZpbHRlcihCb29sZWFuKVxufVxuXG4vKipcbiAqIFZhbGlkYSBzaSB1bmEgbWFyY2EgZXhpc3RlIGVuIGxhIGxpc3RhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJyYW5kKGJyYW5kTmFtZTogc3RyaW5nLCBhdmFpbGFibGVCcmFuZHM6IEJyYW5kW10pOiBib29sZWFuIHtcbiAgcmV0dXJuIGF2YWlsYWJsZUJyYW5kcy5zb21lKGJyYW5kID0+IGJyYW5kLm5hbWUgPT09IGJyYW5kTmFtZSlcbn1cblxuLyoqXG4gKiBGaWx0cmEgbWFyY2FzIHbDoWxpZGFzIGRlIHVuYSBsaXN0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyVmFsaWRCcmFuZHMoYnJhbmROYW1lczogc3RyaW5nW10sIGF2YWlsYWJsZUJyYW5kczogQnJhbmRbXSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGJyYW5kTmFtZXMuZmlsdGVyKG5hbWUgPT4gdmFsaWRhdGVCcmFuZChuYW1lLCBhdmFpbGFibGVCcmFuZHMpKVxufVxuIl0sIm5hbWVzIjpbImJyYW5kc1RvVXJsU3RyaW5nIiwiZmlsdGVyVmFsaWRCcmFuZHMiLCJ1cmxTdHJpbmdUb0JyYW5kcyIsInVzZUJyYW5kRmlsdGVyIiwidXNlU2ltcGxlQnJhbmRGaWx0ZXIiLCJ2YWxpZGF0ZUJyYW5kIiwib3B0aW9ucyIsImF1dG9Mb2FkIiwic3luY1dpdGhVcmwiLCJ1cmxQYXJhbSIsIm1pblByb2R1Y3RzIiwib25CcmFuZHNDaGFuZ2UiLCJyb3V0ZXIiLCJ1c2VSb3V0ZXIiLCJzZWFyY2hQYXJhbXMiLCJ1c2VTZWFyY2hQYXJhbXMiLCJicmFuZHMiLCJzZXRCcmFuZHMiLCJ1c2VTdGF0ZSIsInNlbGVjdGVkQnJhbmRzIiwic2V0U2VsZWN0ZWRCcmFuZHNTdGF0ZSIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJ1c2VFZmZlY3QiLCJ1cmxCcmFuZHMiLCJnZXQiLCJicmFuZHNBcnJheSIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsImZldGNoQnJhbmRzIiwidXNlQ2FsbGJhY2siLCJyZXNwb25zZSIsImdldEJyYW5kcyIsInN1Y2Nlc3MiLCJkYXRhIiwiZXJyIiwiRXJyb3IiLCJtZXNzYWdlIiwidXBkYXRlVXJsIiwibmV3QnJhbmRzIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJsZW5ndGgiLCJzZXQiLCJqb2luIiwiZGVsZXRlIiwibmV3VXJsIiwid2luZG93IiwibG9jYXRpb24iLCJwYXRobmFtZSIsInB1c2giLCJzY3JvbGwiLCJzZXRTZWxlY3RlZEJyYW5kcyIsInRvZ2dsZUJyYW5kIiwiYnJhbmROYW1lIiwiaW5jbHVkZXMiLCJiIiwiY2xlYXJCcmFuZHMiLCJzZWFyY2hCcmFuZHMiLCJzZWFyY2hUZXJtIiwic2VhcmNoIiwicmVmZXRjaCIsInByZXYiLCJ1cmxTdHJpbmciLCJhdmFpbGFibGVCcmFuZHMiLCJzb21lIiwiYnJhbmQiLCJuYW1lIiwiYnJhbmROYW1lcyJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLHVCQUF1QjtBQUN2QixzQ0FBc0M7Ozs7Ozs7Ozs7OztRQStOdEJBO2VBQUFBOztRQXFCQUM7ZUFBQUE7O1FBZEFDO2VBQUFBOztRQXRMQUM7ZUFBQUE7O1FBbUpBQztlQUFBQTs7UUEwQ0FDO2VBQUFBOzs7dUJBM09pQzt3QkFDaEI7NEJBQ1U7QUE0Q3BDLFNBQVNGLGVBQWVHLFVBQWlDLENBQUMsQ0FBQztJQUNoRSxNQUFNLEVBQ0pDLFdBQVcsSUFBSSxFQUNm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