{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\hooks\\useBrandFilter.ts"],"sourcesContent":["// ===================================\n// HOOK: useBrandFilter\n// ===================================\n\nimport { useState, useEffect, useCallback } from 'react'\nimport { getBrands, Brand } from '@/lib/api/brands'\nimport { useRouter, useSearchParams } from 'next/navigation'\n\n// ===================================\n// TIPOS\n// ===================================\n\nexport interface UseBrandFilterOptions {\n  /** Cargar marcas automáticamente al montar */\n  autoLoad?: boolean\n  /** Sincronizar con URL search params */\n  syncWithUrl?: boolean\n  /** Parámetro de URL para las marcas */\n  urlParam?: string\n  /** Mínimo número de productos por marca */\n  minProducts?: number\n  /** Callback cuando cambian las marcas seleccionadas */\n  onBrandsChange?: (brands: string[]) => void\n}\n\nexport interface UseBrandFilterReturn {\n  /** Lista de marcas disponibles */\n  brands: Brand[]\n  /** Marcas seleccionadas */\n  selectedBrands: string[]\n  /** Estado de carga */\n  isLoading: boolean\n  /** Error si ocurre */\n  error: string | null\n  /** Función para cambiar marcas seleccionadas */\n  setSelectedBrands: (brands: string[]) => void\n  /** Función para alternar una marca */\n  toggleBrand: (brandName: string) => void\n  /** Función para limpiar todas las marcas */\n  clearBrands: () => void\n  /** Función para recargar marcas */\n  refetch: () => Promise<void>\n  /** Función para buscar marcas */\n  searchBrands: (searchTerm: string) => void\n}\n\n// ===================================\n// HOOK PRINCIPAL\n// ===================================\n\nexport function useBrandFilter(options: UseBrandFilterOptions = {}): UseBrandFilterReturn {\n  const {\n    autoLoad = true,\n    syncWithUrl = false,\n    urlParam = 'brands',\n    minProducts = 1,\n    onBrandsChange,\n  } = options\n\n  const router = useRouter()\n  const searchParams = useSearchParams()\n\n  // Estados\n  const [brands, setBrands] = useState<Brand[]>([])\n  const [selectedBrands, setSelectedBrandsState] = useState<string[]>([])\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  // Inicializar marcas seleccionadas desde URL\n  useEffect(() => {\n    if (syncWithUrl && searchParams) {\n      const urlBrands = searchParams.get(urlParam)\n      if (urlBrands) {\n        const brandsArray = urlBrands.split(',').filter(Boolean)\n        setSelectedBrandsState(brandsArray)\n      }\n    }\n  }, [syncWithUrl, urlParam, searchParams])\n\n  // Cargar marcas\n  const fetchBrands = useCallback(async () => {\n    setIsLoading(true)\n    setError(null)\n\n    try {\n      const response = await getBrands({ minProducts })\n\n      if (response.success && response.data) {\n        setBrands(response.data)\n      } else {\n        setError(response.error || 'Error cargando marcas')\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Error desconocido')\n    } finally {\n      setIsLoading(false)\n    }\n  }, [minProducts])\n\n  // Cargar marcas automáticamente\n  useEffect(() => {\n    if (autoLoad) {\n      fetchBrands()\n    }\n  }, [autoLoad, fetchBrands])\n\n  // Actualizar URL cuando cambian las marcas seleccionadas\n  const updateUrl = useCallback(\n    (newBrands: string[]) => {\n      if (!syncWithUrl) {\n        return\n      }\n\n      const params = new URLSearchParams(searchParams?.toString())\n\n      if (newBrands.length > 0) {\n        params.set(urlParam, newBrands.join(','))\n      } else {\n        params.delete(urlParam)\n      }\n\n      const newUrl = `${window.location.pathname}?${params.toString()}`\n      router.push(newUrl, { scroll: false })\n    },\n    [syncWithUrl, urlParam, searchParams, router]\n  )\n\n  // Función para cambiar marcas seleccionadas\n  const setSelectedBrands = useCallback(\n    (newBrands: string[]) => {\n      setSelectedBrandsState(newBrands)\n      updateUrl(newBrands)\n      onBrandsChange?.(newBrands)\n    },\n    [updateUrl, onBrandsChange]\n  )\n\n  // Función para alternar una marca\n  const toggleBrand = useCallback(\n    (brandName: string) => {\n      const newBrands = selectedBrands.includes(brandName)\n        ? selectedBrands.filter(b => b !== brandName)\n        : [...selectedBrands, brandName]\n\n      setSelectedBrands(newBrands)\n    },\n    [selectedBrands, setSelectedBrands]\n  )\n\n  // Función para limpiar todas las marcas\n  const clearBrands = useCallback(() => {\n    setSelectedBrands([])\n  }, [setSelectedBrands])\n\n  // Función para buscar marcas\n  const searchBrands = useCallback(\n    async (searchTerm: string) => {\n      setIsLoading(true)\n      setError(null)\n\n      try {\n        const response = await getBrands({\n          search: searchTerm,\n          minProducts,\n        })\n\n        if (response.success && response.data) {\n          setBrands(response.data)\n        } else {\n          setError(response.error || 'Error buscando marcas')\n        }\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Error desconocido')\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [minProducts]\n  )\n\n  return {\n    brands,\n    selectedBrands,\n    isLoading,\n    error,\n    setSelectedBrands,\n    toggleBrand,\n    clearBrands,\n    refetch: fetchBrands,\n    searchBrands,\n  }\n}\n\n// ===================================\n// HOOK SIMPLIFICADO\n// ===================================\n\nexport function useSimpleBrandFilter() {\n  const [selectedBrands, setSelectedBrands] = useState<string[]>([])\n\n  const toggleBrand = useCallback((brandName: string) => {\n    setSelectedBrands(prev =>\n      prev.includes(brandName) ? prev.filter(b => b !== brandName) : [...prev, brandName]\n    )\n  }, [])\n\n  const clearBrands = useCallback(() => {\n    setSelectedBrands([])\n  }, [])\n\n  return {\n    selectedBrands,\n    setSelectedBrands,\n    toggleBrand,\n    clearBrands,\n  }\n}\n\n// ===================================\n// UTILIDADES\n// ===================================\n\n/**\n * Convierte array de marcas a string para URL\n */\nexport function brandsToUrlString(brands: string[]): string {\n  return brands.join(',')\n}\n\n/**\n * Convierte string de URL a array de marcas\n */\nexport function urlStringToBrands(urlString: string): string[] {\n  return urlString.split(',').filter(Boolean)\n}\n\n/**\n * Valida si una marca existe en la lista\n */\nexport function validateBrand(brandName: string, availableBrands: Brand[]): boolean {\n  return availableBrands.some(brand => brand.name === brandName)\n}\n\n/**\n * Filtra marcas válidas de una lista\n */\nexport function filterValidBrands(brandNames: string[], availableBrands: Brand[]): string[] {\n  return brandNames.filter(name => validateBrand(name, availableBrands))\n}\n"],"names":["brandsToUrlString","filterValidBrands","urlStringToBrands","useBrandFilter","useSimpleBrandFilter","validateBrand","options","autoLoad","syncWithUrl","urlParam","minProducts","onBrandsChange","router","useRouter","searchParams","useSearchParams","brands","setBrands","useState","selectedBrands","setSelectedBrandsState","isLoading","setIsLoading","error","setError","useEffect","urlBrands","get","brandsArray","split","filter","Boolean","fetchBrands","useCallback","response","getBrands","success","data","err","Error","message","updateUrl","newBrands","params","URLSearchParams","toString","length","set","join","delete","newUrl","window","location","pathname","push","scroll","setSelectedBrands","toggleBrand","brandName","includes","b","clearBrands","searchBrands","searchTerm","search","refetch","prev","urlString","availableBrands","some","brand","name","brandNames"],"mappings":"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"}