2894c0cfc379604a5d7ab18d8597db04
// ===================================
// PINTEYA E-COMMERCE - ENTERPRISE METRICS TESTS
// ===================================
"use strict";
// Mock logger
jest.mock('@/lib/enterprise/logger', ()=>({
        logger: {
            debug: jest.fn(),
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            DEBUG: 'debug',
            INFO: 'info',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            SYSTEM: 'system'
        }
    }));
jest.mock('@/lib/supabase', ()=>({
        getSupabaseClient: jest.fn(()=>({
                from: mockSupabaseFrom,
                rpc: mockSupabaseRpc
            }))
    }));
// Mock cache
jest.mock('@/lib/cache-manager', ()=>({
        CacheUtils: {
            cacheMetricsAggregation: jest.fn((key, fn)=>fn())
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _enterprisemetrics = require("../../lib/monitoring/enterprise-metrics");
// Mock Supabase
const mockSupabaseInsert = jest.fn();
const mockSupabaseRpc = jest.fn();
const mockSupabaseFrom = jest.fn(()=>({
        insert: mockSupabaseInsert
    }));
describe('Enterprise Metrics System', ()=>{
    let metricsCollector;
    beforeEach(()=>{
        jest.clearAllMocks();
        metricsCollector = new _enterprisemetrics.EnterpriseMetricsCollector();
        // Mock successful database operations
        mockSupabaseInsert.mockResolvedValue({
            error: null
        });
        mockSupabaseRpc.mockResolvedValue({
            data: [],
            error: null
        });
    });
    afterEach(()=>{
        metricsCollector.destroy();
    });
    describe('EnterpriseMetricsCollector', ()=>{
        test('debe crear instancia singleton', ()=>{
            const instance1 = _enterprisemetrics.EnterpriseMetricsCollector.getInstance();
            const instance2 = _enterprisemetrics.EnterpriseMetricsCollector.getInstance();
            expect(instance1).toBe(instance2);
        });
        test('debe registrar métrica básica', async ()=>{
            await metricsCollector.recordMetric('test.metric', 100, _enterprisemetrics.MetricType.GAUGE, _enterprisemetrics.BusinessMetricCategory.PERFORMANCE, {
                environment: 'test'
            }, {
                source: 'unit-test'
            });
            // Verificar que se agregó al buffer (se flusheará automáticamente)
            expect(true).toBe(true); // La métrica se almacena en buffer interno
        });
        test('debe generar ID único para métricas', async ()=>{
            const metric1 = await metricsCollector.recordMetric('test1', 1);
            const metric2 = await metricsCollector.recordMetric('test2', 2);
            // Los IDs se generan internamente, verificamos que no hay errores
            expect(metric1).toBeUndefined(); // recordMetric no retorna valor
            expect(metric2).toBeUndefined();
        });
        test('debe manejar errores sin fallar', async ()=>{
            // Simular error en base de datos
            mockSupabaseInsert.mockResolvedValue({
                error: {
                    message: 'Database error'
                }
            });
            // No debe lanzar error
            await expect(metricsCollector.recordMetric('test.error', 1)).resolves.not.toThrow();
        });
    });
    describe('Métricas de Performance', ()=>{
        test('debe registrar métrica de performance', async ()=>{
            await (0, _enterprisemetrics.recordPerformanceMetric)('api_call', 1500, true, {
                endpoint: '/api/test'
            });
            // Verificar que no hay errores
            expect(true).toBe(true);
        });
        test('debe registrar métricas de duración y contador', async ()=>{
            await (0, _enterprisemetrics.recordPerformanceMetric)('database_query', 250, true, {
                table: 'products'
            });
            // Se registran dos métricas: duración y contador
            expect(true).toBe(true);
        });
    });
    describe('Métricas de Negocio', ()=>{
        test('debe registrar evento de negocio', async ()=>{
            await (0, _enterprisemetrics.recordBusinessMetric)('order_created', 1, {
                amount: '100.50',
                currency: 'ARS',
                method: 'mercadopago'
            });
            expect(true).toBe(true);
        });
        test('debe registrar métricas con valores personalizados', async ()=>{
            await (0, _enterprisemetrics.recordBusinessMetric)('revenue', 15000.75, {
                period: 'daily',
                source: 'ecommerce'
            });
            expect(true).toBe(true);
        });
    });
    describe('Métricas de Seguridad', ()=>{
        test('debe registrar evento de seguridad', async ()=>{
            await (0, _enterprisemetrics.recordSecurityMetric)('login_attempt', 'medium', {
                ip: '192.168.1.1',
                success: 'true'
            });
            expect(true).toBe(true);
        });
        test('debe registrar violación de seguridad crítica', async ()=>{
            await (0, _enterprisemetrics.recordSecurityMetric)('signature_validation_failed', 'critical', {
                endpoint: '/api/webhook',
                ip: '10.0.0.1'
            });
            expect(true).toBe(true);
        });
    });
    describe('Métricas de Experiencia de Usuario', ()=>{
        test('debe registrar métrica de UX', async ()=>{
            await (0, _enterprisemetrics.recordUserExperienceMetric)('page_load_time', 2500, 'user-123', {
                page: '/shop',
                device: 'mobile'
            });
            expect(true).toBe(true);
        });
        test('debe manejar usuarios anónimos', async ()=>{
            await (0, _enterprisemetrics.recordUserExperienceMetric)('bounce_rate', 0.25, undefined, {
                page: '/home',
                source: 'organic'
            });
            expect(true).toBe(true);
        });
    });
    describe('Sistema de Alertas', ()=>{
        test('debe configurar regla de alerta', ()=>{
            const rule = {
                id: 'test_alert',
                metricName: 'test.metric',
                condition: 'gt',
                threshold: 100,
                level: _enterprisemetrics.AlertLevel.WARNING,
                enabled: true,
                cooldownMinutes: 5,
                description: 'Test alert',
                actions: [
                    {
                        type: 'log',
                        config: {}
                    }
                ]
            };
            metricsCollector.setAlertRule(rule);
            // Verificar que no hay errores
            expect(true).toBe(true);
        });
        test('debe evaluar condiciones de alerta correctamente', async ()=>{
            // Configurar alerta para valores > 50
            const rule = {
                id: 'high_value_alert',
                metricName: 'test.value',
                condition: 'gt',
                threshold: 50,
                level: _enterprisemetrics.AlertLevel.WARNING,
                enabled: true,
                cooldownMinutes: 1,
                description: 'Value too high',
                actions: [
                    {
                        type: 'log',
                        config: {}
                    }
                ]
            };
            metricsCollector.setAlertRule(rule);
            // Registrar métrica que debería disparar alerta
            await metricsCollector.recordMetric('test.value', 75, _enterprisemetrics.MetricType.GAUGE, _enterprisemetrics.BusinessMetricCategory.PERFORMANCE);
            // La alerta se dispara internamente
            expect(true).toBe(true);
        });
    });
    describe('Agregación de Métricas', ()=>{
        test('debe obtener métricas agregadas', async ()=>{
            const mockAggregation = [
                {
                    period_start: '2025-01-01T00:00:00Z',
                    period_end: '2025-01-01T01:00:00Z',
                    count: 10,
                    sum: 1000,
                    avg: 100,
                    min: 50,
                    max: 150,
                    p50: 95,
                    p95: 140,
                    p99: 148
                }
            ];
            mockSupabaseRpc.mockResolvedValue({
                data: mockAggregation,
                error: null
            });
            const result = await metricsCollector.getAggregatedMetrics('test.metric', '1h', '2025-01-01T00:00:00Z', '2025-01-01T23:59:59Z');
            expect(mockSupabaseRpc).toHaveBeenCalledWith('aggregate_metrics', {
                metric_name: 'test.metric',
                period_interval: '1h',
                start_time: '2025-01-01T00:00:00Z',
                end_time: '2025-01-01T23:59:59Z'
            });
            expect(result).toEqual(mockAggregation);
        });
        test('debe manejar errores en agregación', async ()=>{
            mockSupabaseRpc.mockResolvedValue({
                data: null,
                error: {
                    message: 'Aggregation failed'
                }
            });
            await expect(metricsCollector.getAggregatedMetrics('test.metric', '1h', '2025-01-01T00:00:00Z', '2025-01-01T23:59:59Z')).rejects.toThrow('Failed to aggregate metrics: Aggregation failed');
        });
    });
    describe('Alertas por Defecto', ()=>{
        test('debe tener alertas predefinidas configuradas', ()=>{
            // Las alertas se configuran en el constructor
            expect(true).toBe(true);
        });
        test('debe disparar alerta de response time alto', async ()=>{
            // Registrar métrica que supera el umbral (5000ms)
            await metricsCollector.recordMetric('performance.api.duration', 6000, _enterprisemetrics.MetricType.TIMER, _enterprisemetrics.BusinessMetricCategory.PERFORMANCE);
            // La alerta se dispara automáticamente
            expect(true).toBe(true);
        });
        test('debe disparar alerta de error rate alto', async ()=>{
            // Registrar métrica que supera el umbral (5%)
            await metricsCollector.recordMetric('performance.api.error_rate', 0.08, _enterprisemetrics.MetricType.GAUGE, _enterprisemetrics.BusinessMetricCategory.PERFORMANCE);
            // La alerta se dispara automáticamente
            expect(true).toBe(true);
        });
        test('debe disparar alerta de violación de seguridad', async ()=>{
            // Registrar métrica de violación
            await metricsCollector.recordMetric('security.violation', 1, _enterprisemetrics.MetricType.COUNTER, _enterprisemetrics.BusinessMetricCategory.SECURITY);
            // La alerta se dispara automáticamente
            expect(true).toBe(true);
        });
    });
    describe('Limpieza de Recursos', ()=>{
        test('debe limpiar recursos correctamente', ()=>{
            const collector = new _enterprisemetrics.EnterpriseMetricsCollector();
            // Verificar que destroy no lanza errores
            expect(()=>collector.destroy()).not.toThrow();
        });
    });
    describe('Funciones de Conveniencia', ()=>{
        test('recordPerformanceMetric debe funcionar', async ()=>{
            await expect((0, _enterprisemetrics.recordPerformanceMetric)('test_op', 100, true, {
                tag: 'value'
            })).resolves.not.toThrow();
        });
        test('recordBusinessMetric debe funcionar', async ()=>{
            await expect((0, _enterprisemetrics.recordBusinessMetric)('test_event', 1, {
                tag: 'value'
            })).resolves.not.toThrow();
        });
        test('recordSecurityMetric debe funcionar', async ()=>{
            await expect((0, _enterprisemetrics.recordSecurityMetric)('test_security', 'medium', {
                tag: 'value'
            })).resolves.not.toThrow();
        });
        test('recordUserExperienceMetric debe funcionar', async ()=>{
            await expect((0, _enterprisemetrics.recordUserExperienceMetric)('test_ux', 100, 'user-123', {
                tag: 'value'
            })).resolves.not.toThrow();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxsaWJcXGVudGVycHJpc2UtbWV0cmljcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBFTlRFUlBSSVNFIE1FVFJJQ1MgVEVTVFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmltcG9ydCB7XG4gIEVudGVycHJpc2VNZXRyaWNzQ29sbGVjdG9yLFxuICBNZXRyaWNUeXBlLFxuICBCdXNpbmVzc01ldHJpY0NhdGVnb3J5LFxuICBBbGVydExldmVsLFxuICByZWNvcmRQZXJmb3JtYW5jZU1ldHJpYyxcbiAgcmVjb3JkQnVzaW5lc3NNZXRyaWMsXG4gIHJlY29yZFNlY3VyaXR5TWV0cmljLFxuICByZWNvcmRVc2VyRXhwZXJpZW5jZU1ldHJpYyxcbn0gZnJvbSAnQC9saWIvbW9uaXRvcmluZy9lbnRlcnByaXNlLW1ldHJpY3MnXG5cbi8vIE1vY2sgbG9nZ2VyXG5qZXN0Lm1vY2soJ0AvbGliL2VudGVycHJpc2UvbG9nZ2VyJywgKCkgPT4gKHtcbiAgbG9nZ2VyOiB7XG4gICAgZGVidWc6IGplc3QuZm4oKSxcbiAgICBpbmZvOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gIH0sXG4gIExvZ0xldmVsOiB7XG4gICAgREVCVUc6ICdkZWJ1ZycsXG4gICAgSU5GTzogJ2luZm8nLFxuICAgIFdBUk46ICd3YXJuJyxcbiAgICBFUlJPUjogJ2Vycm9yJyxcbiAgfSxcbiAgTG9nQ2F0ZWdvcnk6IHtcbiAgICBTWVNURU06ICdzeXN0ZW0nLFxuICB9LFxufSkpXG5cbi8vIE1vY2sgU3VwYWJhc2VcbmNvbnN0IG1vY2tTdXBhYmFzZUluc2VydCA9IGplc3QuZm4oKVxuY29uc3QgbW9ja1N1cGFiYXNlUnBjID0gamVzdC5mbigpXG5jb25zdCBtb2NrU3VwYWJhc2VGcm9tID0gamVzdC5mbigoKSA9PiAoe1xuICBpbnNlcnQ6IG1vY2tTdXBhYmFzZUluc2VydCxcbn0pKVxuXG5qZXN0Lm1vY2soJ0AvbGliL3N1cGFiYXNlJywgKCkgPT4gKHtcbiAgZ2V0U3VwYWJhc2VDbGllbnQ6IGplc3QuZm4oKCkgPT4gKHtcbiAgICBmcm9tOiBtb2NrU3VwYWJhc2VGcm9tLFxuICAgIHJwYzogbW9ja1N1cGFiYXNlUnBjLFxuICB9KSksXG59KSlcblxuLy8gTW9jayBjYWNoZVxuamVzdC5tb2NrKCdAL2xpYi9jYWNoZS1tYW5hZ2VyJywgKCkgPT4gKHtcbiAgQ2FjaGVVdGlsczoge1xuICAgIGNhY2hlTWV0cmljc0FnZ3JlZ2F0aW9uOiBqZXN0LmZuKChrZXksIGZuKSA9PiBmbigpKSxcbiAgfSxcbn0pKVxuXG5kZXNjcmliZSgnRW50ZXJwcmlzZSBNZXRyaWNzIFN5c3RlbScsICgpID0+IHtcbiAgbGV0IG1ldHJpY3NDb2xsZWN0b3I6IEVudGVycHJpc2VNZXRyaWNzQ29sbGVjdG9yXG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgICBtZXRyaWNzQ29sbGVjdG9yID0gbmV3IEVudGVycHJpc2VNZXRyaWNzQ29sbGVjdG9yKClcblxuICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBkYXRhYmFzZSBvcGVyYXRpb25zXG4gICAgbW9ja1N1cGFiYXNlSW5zZXJ0Lm1vY2tSZXNvbHZlZFZhbHVlKHsgZXJyb3I6IG51bGwgfSlcbiAgICBtb2NrU3VwYWJhc2VScGMubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBbXSwgZXJyb3I6IG51bGwgfSlcbiAgfSlcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIG1ldHJpY3NDb2xsZWN0b3IuZGVzdHJveSgpXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0VudGVycHJpc2VNZXRyaWNzQ29sbGVjdG9yJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgY3JlYXIgaW5zdGFuY2lhIHNpbmdsZXRvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMSA9IEVudGVycHJpc2VNZXRyaWNzQ29sbGVjdG9yLmdldEluc3RhbmNlKClcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IEVudGVycHJpc2VNZXRyaWNzQ29sbGVjdG9yLmdldEluc3RhbmNlKClcblxuICAgICAgZXhwZWN0KGluc3RhbmNlMSkudG9CZShpbnN0YW5jZTIpXG4gICAgfSlcblxuICAgIHRlc3QoJ2RlYmUgcmVnaXN0cmFyIG3DqXRyaWNhIGLDoXNpY2EnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZE1ldHJpYyhcbiAgICAgICAgJ3Rlc3QubWV0cmljJyxcbiAgICAgICAgMTAwLFxuICAgICAgICBNZXRyaWNUeXBlLkdBVUdFLFxuICAgICAgICBCdXNpbmVzc01ldHJpY0NhdGVnb3J5LlBFUkZPUk1BTkNFLFxuICAgICAgICB7IGVudmlyb25tZW50OiAndGVzdCcgfSxcbiAgICAgICAgeyBzb3VyY2U6ICd1bml0LXRlc3QnIH1cbiAgICAgIClcblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBzZSBhZ3JlZ8OzIGFsIGJ1ZmZlciAoc2UgZmx1c2hlYXLDoSBhdXRvbcOhdGljYW1lbnRlKVxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSkgLy8gTGEgbcOpdHJpY2Egc2UgYWxtYWNlbmEgZW4gYnVmZmVyIGludGVybm9cbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSBnZW5lcmFyIElEIMO6bmljbyBwYXJhIG3DqXRyaWNhcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1ldHJpYzEgPSBhd2FpdCBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZE1ldHJpYygndGVzdDEnLCAxKVxuICAgICAgY29uc3QgbWV0cmljMiA9IGF3YWl0IG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkTWV0cmljKCd0ZXN0MicsIDIpXG5cbiAgICAgIC8vIExvcyBJRHMgc2UgZ2VuZXJhbiBpbnRlcm5hbWVudGUsIHZlcmlmaWNhbW9zIHF1ZSBubyBoYXkgZXJyb3Jlc1xuICAgICAgZXhwZWN0KG1ldHJpYzEpLnRvQmVVbmRlZmluZWQoKSAvLyByZWNvcmRNZXRyaWMgbm8gcmV0b3JuYSB2YWxvclxuICAgICAgZXhwZWN0KG1ldHJpYzIpLnRvQmVVbmRlZmluZWQoKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIG1hbmVqYXIgZXJyb3JlcyBzaW4gZmFsbGFyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU2ltdWxhciBlcnJvciBlbiBiYXNlIGRlIGRhdG9zXG4gICAgICBtb2NrU3VwYWJhc2VJbnNlcnQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnRGF0YWJhc2UgZXJyb3InIH0sXG4gICAgICB9KVxuXG4gICAgICAvLyBObyBkZWJlIGxhbnphciBlcnJvclxuICAgICAgYXdhaXQgZXhwZWN0KG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkTWV0cmljKCd0ZXN0LmVycm9yJywgMSkpLnJlc29sdmVzLm5vdC50b1Rocm93KClcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdNw6l0cmljYXMgZGUgUGVyZm9ybWFuY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnZGViZSByZWdpc3RyYXIgbcOpdHJpY2EgZGUgcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZWNvcmRQZXJmb3JtYW5jZU1ldHJpYyhcbiAgICAgICAgJ2FwaV9jYWxsJyxcbiAgICAgICAgMTUwMCwgLy8gMS41IHNlZ3VuZG9zXG4gICAgICAgIHRydWUsXG4gICAgICAgIHsgZW5kcG9pbnQ6ICcvYXBpL3Rlc3QnIH1cbiAgICAgIClcblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBubyBoYXkgZXJyb3Jlc1xuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSByZWdpc3RyYXIgbcOpdHJpY2FzIGRlIGR1cmFjacOzbiB5IGNvbnRhZG9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgcmVjb3JkUGVyZm9ybWFuY2VNZXRyaWMoJ2RhdGFiYXNlX3F1ZXJ5JywgMjUwLCB0cnVlLCB7IHRhYmxlOiAncHJvZHVjdHMnIH0pXG5cbiAgICAgIC8vIFNlIHJlZ2lzdHJhbiBkb3MgbcOpdHJpY2FzOiBkdXJhY2nDs24geSBjb250YWRvclxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdNw6l0cmljYXMgZGUgTmVnb2NpbycsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIHJlZ2lzdHJhciBldmVudG8gZGUgbmVnb2NpbycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlY29yZEJ1c2luZXNzTWV0cmljKCdvcmRlcl9jcmVhdGVkJywgMSwge1xuICAgICAgICBhbW91bnQ6ICcxMDAuNTAnLFxuICAgICAgICBjdXJyZW5jeTogJ0FSUycsXG4gICAgICAgIG1ldGhvZDogJ21lcmNhZG9wYWdvJyxcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpXG4gICAgfSlcblxuICAgIHRlc3QoJ2RlYmUgcmVnaXN0cmFyIG3DqXRyaWNhcyBjb24gdmFsb3JlcyBwZXJzb25hbGl6YWRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlY29yZEJ1c2luZXNzTWV0cmljKCdyZXZlbnVlJywgMTUwMDAuNzUsIHtcbiAgICAgICAgcGVyaW9kOiAnZGFpbHknLFxuICAgICAgICBzb3VyY2U6ICdlY29tbWVyY2UnLFxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdNw6l0cmljYXMgZGUgU2VndXJpZGFkJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgcmVnaXN0cmFyIGV2ZW50byBkZSBzZWd1cmlkYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZWNvcmRTZWN1cml0eU1ldHJpYygnbG9naW5fYXR0ZW1wdCcsICdtZWRpdW0nLCB7XG4gICAgICAgIGlwOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICBzdWNjZXNzOiAndHJ1ZScsXG4gICAgICB9KVxuXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIHJlZ2lzdHJhciB2aW9sYWNpw7NuIGRlIHNlZ3VyaWRhZCBjcsOtdGljYScsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlY29yZFNlY3VyaXR5TWV0cmljKCdzaWduYXR1cmVfdmFsaWRhdGlvbl9mYWlsZWQnLCAnY3JpdGljYWwnLCB7XG4gICAgICAgIGVuZHBvaW50OiAnL2FwaS93ZWJob29rJyxcbiAgICAgICAgaXA6ICcxMC4wLjAuMScsXG4gICAgICB9KVxuXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ03DqXRyaWNhcyBkZSBFeHBlcmllbmNpYSBkZSBVc3VhcmlvJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgcmVnaXN0cmFyIG3DqXRyaWNhIGRlIFVYJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgcmVjb3JkVXNlckV4cGVyaWVuY2VNZXRyaWMoJ3BhZ2VfbG9hZF90aW1lJywgMjUwMCwgJ3VzZXItMTIzJywge1xuICAgICAgICBwYWdlOiAnL3Nob3AnLFxuICAgICAgICBkZXZpY2U6ICdtb2JpbGUnLFxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSBtYW5lamFyIHVzdWFyaW9zIGFuw7NuaW1vcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlY29yZFVzZXJFeHBlcmllbmNlTWV0cmljKCdib3VuY2VfcmF0ZScsIDAuMjUsIHVuZGVmaW5lZCwge1xuICAgICAgICBwYWdlOiAnL2hvbWUnLFxuICAgICAgICBzb3VyY2U6ICdvcmdhbmljJyxcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnU2lzdGVtYSBkZSBBbGVydGFzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgY29uZmlndXJhciByZWdsYSBkZSBhbGVydGEnLCAoKSA9PiB7XG4gICAgICBjb25zdCBydWxlID0ge1xuICAgICAgICBpZDogJ3Rlc3RfYWxlcnQnLFxuICAgICAgICBtZXRyaWNOYW1lOiAndGVzdC5tZXRyaWMnLFxuICAgICAgICBjb25kaXRpb246ICdndCcgYXMgY29uc3QsXG4gICAgICAgIHRocmVzaG9sZDogMTAwLFxuICAgICAgICBsZXZlbDogQWxlcnRMZXZlbC5XQVJOSU5HLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb29sZG93bk1pbnV0ZXM6IDUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBhbGVydCcsXG4gICAgICAgIGFjdGlvbnM6IFt7IHR5cGU6ICdsb2cnIGFzIGNvbnN0LCBjb25maWc6IHt9IH1dLFxuICAgICAgfVxuXG4gICAgICBtZXRyaWNzQ29sbGVjdG9yLnNldEFsZXJ0UnVsZShydWxlKVxuXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIG5vIGhheSBlcnJvcmVzXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIGV2YWx1YXIgY29uZGljaW9uZXMgZGUgYWxlcnRhIGNvcnJlY3RhbWVudGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDb25maWd1cmFyIGFsZXJ0YSBwYXJhIHZhbG9yZXMgPiA1MFxuICAgICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgaWQ6ICdoaWdoX3ZhbHVlX2FsZXJ0JyxcbiAgICAgICAgbWV0cmljTmFtZTogJ3Rlc3QudmFsdWUnLFxuICAgICAgICBjb25kaXRpb246ICdndCcgYXMgY29uc3QsXG4gICAgICAgIHRocmVzaG9sZDogNTAsXG4gICAgICAgIGxldmVsOiBBbGVydExldmVsLldBUk5JTkcsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGNvb2xkb3duTWludXRlczogMSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdWYWx1ZSB0b28gaGlnaCcsXG4gICAgICAgIGFjdGlvbnM6IFt7IHR5cGU6ICdsb2cnIGFzIGNvbnN0LCBjb25maWc6IHt9IH1dLFxuICAgICAgfVxuXG4gICAgICBtZXRyaWNzQ29sbGVjdG9yLnNldEFsZXJ0UnVsZShydWxlKVxuXG4gICAgICAvLyBSZWdpc3RyYXIgbcOpdHJpY2EgcXVlIGRlYmVyw61hIGRpc3BhcmFyIGFsZXJ0YVxuICAgICAgYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRNZXRyaWMoXG4gICAgICAgICd0ZXN0LnZhbHVlJyxcbiAgICAgICAgNzUsXG4gICAgICAgIE1ldHJpY1R5cGUuR0FVR0UsXG4gICAgICAgIEJ1c2luZXNzTWV0cmljQ2F0ZWdvcnkuUEVSRk9STUFOQ0VcbiAgICAgIClcblxuICAgICAgLy8gTGEgYWxlcnRhIHNlIGRpc3BhcmEgaW50ZXJuYW1lbnRlXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0FncmVnYWNpw7NuIGRlIE3DqXRyaWNhcycsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIG9idGVuZXIgbcOpdHJpY2FzIGFncmVnYWRhcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBZ2dyZWdhdGlvbiA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHBlcmlvZF9zdGFydDogJzIwMjUtMDEtMDFUMDA6MDA6MDBaJyxcbiAgICAgICAgICBwZXJpb2RfZW5kOiAnMjAyNS0wMS0wMVQwMTowMDowMFonLFxuICAgICAgICAgIGNvdW50OiAxMCxcbiAgICAgICAgICBzdW06IDEwMDAsXG4gICAgICAgICAgYXZnOiAxMDAsXG4gICAgICAgICAgbWluOiA1MCxcbiAgICAgICAgICBtYXg6IDE1MCxcbiAgICAgICAgICBwNTA6IDk1LFxuICAgICAgICAgIHA5NTogMTQwLFxuICAgICAgICAgIHA5OTogMTQ4LFxuICAgICAgICB9LFxuICAgICAgXVxuXG4gICAgICBtb2NrU3VwYWJhc2VScGMubW9ja1Jlc29sdmVkVmFsdWUoeyBkYXRhOiBtb2NrQWdncmVnYXRpb24sIGVycm9yOiBudWxsIH0pXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1ldHJpY3NDb2xsZWN0b3IuZ2V0QWdncmVnYXRlZE1ldHJpY3MoXG4gICAgICAgICd0ZXN0Lm1ldHJpYycsXG4gICAgICAgICcxaCcsXG4gICAgICAgICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICcyMDI1LTAxLTAxVDIzOjU5OjU5WidcbiAgICAgIClcblxuICAgICAgZXhwZWN0KG1vY2tTdXBhYmFzZVJwYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2FnZ3JlZ2F0ZV9tZXRyaWNzJywge1xuICAgICAgICBtZXRyaWNfbmFtZTogJ3Rlc3QubWV0cmljJyxcbiAgICAgICAgcGVyaW9kX2ludGVydmFsOiAnMWgnLFxuICAgICAgICBzdGFydF90aW1lOiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxuICAgICAgICBlbmRfdGltZTogJzIwMjUtMDEtMDFUMjM6NTk6NTlaJyxcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0FnZ3JlZ2F0aW9uKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIG1hbmVqYXIgZXJyb3JlcyBlbiBhZ3JlZ2FjacOzbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdXBhYmFzZVJwYy5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdBZ2dyZWdhdGlvbiBmYWlsZWQnIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIG1ldHJpY3NDb2xsZWN0b3IuZ2V0QWdncmVnYXRlZE1ldHJpY3MoXG4gICAgICAgICAgJ3Rlc3QubWV0cmljJyxcbiAgICAgICAgICAnMWgnLFxuICAgICAgICAgICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgICAgJzIwMjUtMDEtMDFUMjM6NTk6NTlaJ1xuICAgICAgICApXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnRmFpbGVkIHRvIGFnZ3JlZ2F0ZSBtZXRyaWNzOiBBZ2dyZWdhdGlvbiBmYWlsZWQnKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0FsZXJ0YXMgcG9yIERlZmVjdG8nLCAoKSA9PiB7XG4gICAgdGVzdCgnZGViZSB0ZW5lciBhbGVydGFzIHByZWRlZmluaWRhcyBjb25maWd1cmFkYXMnLCAoKSA9PiB7XG4gICAgICAvLyBMYXMgYWxlcnRhcyBzZSBjb25maWd1cmFuIGVuIGVsIGNvbnN0cnVjdG9yXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIGRpc3BhcmFyIGFsZXJ0YSBkZSByZXNwb25zZSB0aW1lIGFsdG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSZWdpc3RyYXIgbcOpdHJpY2EgcXVlIHN1cGVyYSBlbCB1bWJyYWwgKDUwMDBtcylcbiAgICAgIGF3YWl0IG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkTWV0cmljKFxuICAgICAgICAncGVyZm9ybWFuY2UuYXBpLmR1cmF0aW9uJyxcbiAgICAgICAgNjAwMCxcbiAgICAgICAgTWV0cmljVHlwZS5USU1FUixcbiAgICAgICAgQnVzaW5lc3NNZXRyaWNDYXRlZ29yeS5QRVJGT1JNQU5DRVxuICAgICAgKVxuXG4gICAgICAvLyBMYSBhbGVydGEgc2UgZGlzcGFyYSBhdXRvbcOhdGljYW1lbnRlXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIGRpc3BhcmFyIGFsZXJ0YSBkZSBlcnJvciByYXRlIGFsdG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSZWdpc3RyYXIgbcOpdHJpY2EgcXVlIHN1cGVyYSBlbCB1bWJyYWwgKDUlKVxuICAgICAgYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRNZXRyaWMoXG4gICAgICAgICdwZXJmb3JtYW5jZS5hcGkuZXJyb3JfcmF0ZScsXG4gICAgICAgIDAuMDgsIC8vIDglXG4gICAgICAgIE1ldHJpY1R5cGUuR0FVR0UsXG4gICAgICAgIEJ1c2luZXNzTWV0cmljQ2F0ZWdvcnkuUEVSRk9STUFOQ0VcbiAgICAgIClcblxuICAgICAgLy8gTGEgYWxlcnRhIHNlIGRpc3BhcmEgYXV0b23DoXRpY2FtZW50ZVxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSBkaXNwYXJhciBhbGVydGEgZGUgdmlvbGFjacOzbiBkZSBzZWd1cmlkYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSZWdpc3RyYXIgbcOpdHJpY2EgZGUgdmlvbGFjacOzblxuICAgICAgYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRNZXRyaWMoXG4gICAgICAgICdzZWN1cml0eS52aW9sYXRpb24nLFxuICAgICAgICAxLFxuICAgICAgICBNZXRyaWNUeXBlLkNPVU5URVIsXG4gICAgICAgIEJ1c2luZXNzTWV0cmljQ2F0ZWdvcnkuU0VDVVJJVFlcbiAgICAgIClcblxuICAgICAgLy8gTGEgYWxlcnRhIHNlIGRpc3BhcmEgYXV0b23DoXRpY2FtZW50ZVxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdMaW1waWV6YSBkZSBSZWN1cnNvcycsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIGxpbXBpYXIgcmVjdXJzb3MgY29ycmVjdGFtZW50ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbGxlY3RvciA9IG5ldyBFbnRlcnByaXNlTWV0cmljc0NvbGxlY3RvcigpXG5cbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgZGVzdHJveSBubyBsYW56YSBlcnJvcmVzXG4gICAgICBleHBlY3QoKCkgPT4gY29sbGVjdG9yLmRlc3Ryb3koKSkubm90LnRvVGhyb3coKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0Z1bmNpb25lcyBkZSBDb252ZW5pZW5jaWEnLCAoKSA9PiB7XG4gICAgdGVzdCgncmVjb3JkUGVyZm9ybWFuY2VNZXRyaWMgZGViZSBmdW5jaW9uYXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHJlY29yZFBlcmZvcm1hbmNlTWV0cmljKCd0ZXN0X29wJywgMTAwLCB0cnVlLCB7IHRhZzogJ3ZhbHVlJyB9KVxuICAgICAgKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpXG4gICAgfSlcblxuICAgIHRlc3QoJ3JlY29yZEJ1c2luZXNzTWV0cmljIGRlYmUgZnVuY2lvbmFyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZXhwZWN0KHJlY29yZEJ1c2luZXNzTWV0cmljKCd0ZXN0X2V2ZW50JywgMSwgeyB0YWc6ICd2YWx1ZScgfSkpLnJlc29sdmVzLm5vdC50b1Rocm93KClcbiAgICB9KVxuXG4gICAgdGVzdCgncmVjb3JkU2VjdXJpdHlNZXRyaWMgZGViZSBmdW5jaW9uYXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHJlY29yZFNlY3VyaXR5TWV0cmljKCd0ZXN0X3NlY3VyaXR5JywgJ21lZGl1bScsIHsgdGFnOiAndmFsdWUnIH0pXG4gICAgICApLnJlc29sdmVzLm5vdC50b1Rocm93KClcbiAgICB9KVxuXG4gICAgdGVzdCgncmVjb3JkVXNlckV4cGVyaWVuY2VNZXRyaWMgZGViZSBmdW5jaW9uYXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBleHBlY3QoXG4gICAgICAgIHJlY29yZFVzZXJFeHBlcmllbmNlTWV0cmljKCd0ZXN0X3V4JywgMTAwLCAndXNlci0xMjMnLCB7IHRhZzogJ3ZhbHVlJyB9KVxuICAgICAgKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpXG4gICAgfSlcbiAgfSlcbn0pXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJsb2dnZXIiLCJkZWJ1ZyIsImZuIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsIkxvZ0xldmVsIiwiREVCVUciLCJJTkZPIiwiV0FSTiIsIkVSUk9SIiwiTG9nQ2F0ZWdvcnkiLCJTWVNURU0iLCJnZXRTdXBhYmFzZUNsaWVudCIsImZyb20iLCJtb2NrU3VwYWJhc2VGcm9tIiwicnBjIiwibW9ja1N1cGFiYXNlUnBjIiwiQ2FjaGVVdGlscyIsImNhY2hlTWV0cmljc0FnZ3JlZ2F0aW9uIiwia2V5IiwibW9ja1N1cGFiYXNlSW5zZXJ0IiwiaW5zZXJ0IiwiZGVzY3JpYmUiLCJtZXRyaWNzQ29sbGVjdG9yIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJFbnRlcnByaXNlTWV0cmljc0NvbGxlY3RvciIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiZGF0YSIsImFmdGVyRWFjaCIsImRlc3Ryb3kiLCJ0ZXN0IiwiaW5zdGFuY2UxIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZTIiLCJleHBlY3QiLCJ0b0JlIiwicmVjb3JkTWV0cmljIiwiTWV0cmljVHlwZSIsIkdBVUdFIiwiQnVzaW5lc3NNZXRyaWNDYXRlZ29yeSIsIlBFUkZPUk1BTkNFIiwiZW52aXJvbm1lbnQiLCJzb3VyY2UiLCJtZXRyaWMxIiwibWV0cmljMiIsInRvQmVVbmRlZmluZWQiLCJtZXNzYWdlIiwicmVzb2x2ZXMiLCJub3QiLCJ0b1Rocm93IiwicmVjb3JkUGVyZm9ybWFuY2VNZXRyaWMiLCJlbmRwb2ludCIsInRhYmxlIiwicmVjb3JkQnVzaW5lc3NNZXRyaWMiLCJhbW91bnQiLCJjdXJyZW5jeSIsIm1ldGhvZCIsInBlcmlvZCIsInJlY29yZFNlY3VyaXR5TWV0cmljIiwiaXAiLCJzdWNjZXNzIiwicmVjb3JkVXNlckV4cGVyaWVuY2VNZXRyaWMiLCJwYWdlIiwiZGV2aWNlIiwidW5kZWZpbmVkIiwicnVsZSIsImlkIiwibWV0cmljTmFtZSIsImNvbmRpdGlvbiIsInRocmVzaG9sZCIsImxldmVsIiwiQWxlcnRMZXZlbCIsIldBUk5JTkciLCJlbmFibGVkIiwiY29vbGRvd25NaW51dGVzIiwiZGVzY3JpcHRpb24iLCJhY3Rpb25zIiwidHlwZSIsImNvbmZpZyIsInNldEFsZXJ0UnVsZSIsIm1vY2tBZ2dyZWdhdGlvbiIsInBlcmlvZF9zdGFydCIsInBlcmlvZF9lbmQiLCJjb3VudCIsInN1bSIsImF2ZyIsIm1pbiIsIm1heCIsInA1MCIsInA5NSIsInA5OSIsInJlc3VsdCIsImdldEFnZ3JlZ2F0ZWRNZXRyaWNzIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJtZXRyaWNfbmFtZSIsInBlcmlvZF9pbnRlcnZhbCIsInN0YXJ0X3RpbWUiLCJlbmRfdGltZSIsInRvRXF1YWwiLCJyZWplY3RzIiwiVElNRVIiLCJDT1VOVEVSIiwiU0VDVVJJVFkiLCJjb2xsZWN0b3IiLCJ0YWciXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0QyxnREFBZ0Q7QUFDaEQsc0NBQXNDOztBQWF0QyxjQUFjO0FBQ2RBLEtBQUtDLElBQUksQ0FBQywyQkFBMkIsSUFBTyxDQUFBO1FBQzFDQyxRQUFRO1lBQ05DLE9BQU9ILEtBQUtJLEVBQUU7WUFDZEMsTUFBTUwsS0FBS0ksRUFBRTtZQUNiRSxNQUFNTixLQUFLSSxFQUFFO1lBQ2JHLE9BQU9QLEtBQUtJLEVBQUU7UUFDaEI7UUFDQUksVUFBVTtZQUNSQyxPQUFPO1lBQ1BDLE1BQU07WUFDTkMsTUFBTTtZQUNOQyxPQUFPO1FBQ1Q7UUFDQUMsYUFBYTtZQUNYQyxRQUFRO1FBQ1Y7SUFDRixDQUFBO0FBU0FkLEtBQUtDLElBQUksQ0FBQyxrQkFBa0IsSUFBTyxDQUFBO1FBQ2pDYyxtQkFBbUJmLEtBQUtJLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQ2hDWSxNQUFNQztnQkFDTkMs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