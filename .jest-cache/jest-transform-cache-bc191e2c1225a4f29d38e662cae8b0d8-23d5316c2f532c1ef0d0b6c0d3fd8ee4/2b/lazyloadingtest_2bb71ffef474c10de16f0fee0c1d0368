2c769575f87cf6f01deb2903b6468e43
// ===================================
// PINTEYA E-COMMERCE - LAZY LOADING PERFORMANCE TEST
// Tests para verificar que el lazy loading funciona correctamente
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
const _globals = require("@jest/globals");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// ===================================
// MOCKS
// ===================================
// Mock de performance para medir tiempos de carga
const mockPerformanceNow = _globals.jest.fn();
Object.defineProperty(global, 'performance', {
    value: {
        now: mockPerformanceNow
    },
    writable: true
});
// Mock de console para capturar logs de lazy loading
const mockConsoleLog = _globals.jest.spyOn(console, 'log').mockImplementation(()=>{});
// Mock de dynamic imports
const mockDynamicImport = _globals.jest.fn();
_globals.jest.mock('next/dynamic', ()=>{
    return (importFn, options)=>{
        const LazyComponent = /*#__PURE__*/ _react.default.lazy(()=>{
            mockDynamicImport();
            return importFn();
        });
        return /*#__PURE__*/ _react.default.forwardRef((props, ref)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_react.default.Suspense, {
                fallback: options?.loading?.() || /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                    children: "Loading..."
                }),
                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyComponent, {
                    ...props,
                    ref: ref
                })
            }));
    };
});
// ===================================
// SETUP Y CLEANUP
// ===================================
(0, _globals.beforeEach)(()=>{
    _globals.jest.clearAllMocks();
    mockPerformanceNow.mockReturnValue(1000);
});
(0, _globals.afterEach)(()=>{
    _globals.jest.clearAllTimers();
});
// ===================================
// TESTS DE LAZY LOADING
// ===================================
(0, _globals.describe)('Lazy Loading Performance Tests', ()=>{
    (0, _globals.it)('debe cargar componentes admin bajo demanda', async ()=>{
        _globals.jest.useFakeTimers();
        // Simular tiempo de carga inicial
        mockPerformanceNow.mockReturnValueOnce(1000);
        // Importar componente lazy
        const { LazyAdminDashboard } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/LazyAdminDashboard")));
        // Renderizar componente
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyAdminDashboard, {}));
        // Verificar que muestra skeleton inicialmente
        (0, _globals.expect)(_react1.screen.getByText(/cargando/i) || _react1.screen.getAllByRole('generic').length > 0).toBeTruthy();
        // Simular tiempo después de la carga
        mockPerformanceNow.mockReturnValueOnce(1200);
        // Avanzar timers para que se complete la carga
        _globals.jest.advanceTimersByTime(1000);
        // Verificar que el componente se carga
        await (0, _react1.waitFor)(()=>{
            // El componente debería estar cargado o mostrar contenido
            (0, _globals.expect)(_react1.screen.queryByText(/cargando/i)).toBeFalsy();
        }, {
            timeout: 3000
        });
        _globals.jest.useRealTimers();
    });
    (0, _globals.it)('debe mostrar skeletons apropiados durante la carga', async ()=>{
        const { LazyProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/products/LazyProductComponents")));
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyProductList, {}));
        // Verificar que muestra skeleton de productos
        const skeletonElements = _react1.screen.getAllByRole('generic');
        (0, _globals.expect)(skeletonElements.length).toBeGreaterThan(0);
        // Verificar estructura del skeleton
        (0, _globals.expect)(_react1.screen.getByText(/filtros/i) || skeletonElements.length > 4).toBeTruthy();
    });
    (0, _globals.it)('debe manejar errores de carga gracefully', async ()=>{
        // Mock de error en import dinámico
        const originalImport = _globals.jest.requireActual('next/dynamic');
        _globals.jest.doMock('next/dynamic', ()=>{
            return ()=>{
                throw new Error('Failed to load component');
            };
        });
        try {
            const { LazyLogisticsMap } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")));
            (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyLogisticsMap, {}));
            // Verificar que muestra error boundary
            await (0, _react1.waitFor)(()=>{
                (0, _globals.expect)(_react1.screen.getByText(/error de carga/i) || _react1.screen.getByText(/error/i)).toBeInTheDocument();
            });
        } catch (error) {
            // Error esperado durante el test
            (0, _globals.expect)(error).toBeDefined();
        }
    });
    (0, _globals.it)('debe precargar componentes cuando se solicita', async ()=>{
        const { usePreloadAdminComponents } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/LazyAdminDashboard")));
        // Crear componente de prueba que usa el hook
        function TestComponent() {
            const { preloadAdmin, preloadMonitoring } = usePreloadAdminComponents();
            _react.default.useEffect(()=>{
                preloadAdmin();
                preloadMonitoring();
            }, [
                preloadAdmin,
                preloadMonitoring
            ]);
            return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                children: "Test Component"
            });
        }
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(TestComponent, {}));
        // Verificar que el componente se renderiza
        (0, _globals.expect)(_react1.screen.getByText('Test Component')).toBeInTheDocument();
        // Los imports dinámicos deberían haberse llamado
        await (0, _react1.waitFor)(()=>{
            // Verificar que se intentó precargar (esto es difícil de testear directamente)
            (0, _globals.expect)(true).toBe(true); // Placeholder - en un entorno real verificaríamos network requests
        });
    });
    (0, _globals.it)('debe tener performance aceptable en carga de componentes', async ()=>{
        const startTime = 1000;
        const endTime = 1200;
        mockPerformanceNow.mockReturnValueOnce(startTime).mockReturnValueOnce(endTime);
        const { LazyCarrierPerformanceTable } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")));
        const start = performance.now();
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyCarrierPerformanceTable, {}));
        const end = performance.now();
        // Verificar que el tiempo de render inicial es rápido (< 200ms)
        const renderTime = end - start;
        (0, _globals.expect)(renderTime).toBeLessThan(200);
    });
    (0, _globals.it)('debe limpiar recursos correctamente al desmontar', async ()=>{
        const { LazyRealTimeDashboard } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")));
        const { unmount } = (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(LazyRealTimeDashboard, {}));
        // Desmontar componente
        unmount();
        // Verificar que no hay memory leaks (esto es más conceptual en el test)
        (0, _globals.expect)(mockConsoleLog).not.toHaveBeenCalledWith(_globals.expect.stringContaining('memory leak'));
    });
    (0, _globals.it)('debe manejar múltiples componentes lazy simultáneamente', async ()=>{
        const components = await Promise.all([
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/LazyAdminDashboard"))),
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/products/LazyProductComponents"))),
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")))
        ]);
        const [{ LazyAdminDashboard }, { LazyProductList }, { LazyLogisticsMap }] = components;
        // Renderizar múltiples componentes lazy
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyAdminDashboard, {}),
                /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyProductList, {}),
                /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyLogisticsMap, {})
            ]
        }));
        // Verificar que todos muestran skeletons inicialmente
        const loadingElements = _react1.screen.getAllByText(/cargando/i);
        (0, _globals.expect)(loadingElements.length).toBeGreaterThanOrEqual(0); // Pueden ser skeletons sin texto "cargando"
        // Verificar que no hay conflictos entre componentes
        (0, _globals.expect)(_react1.screen.getByRole('main') || document.body).toBeInTheDocument();
    });
    (0, _globals.it)('debe optimizar bundle size con lazy loading', async ()=>{
        // Este test es más conceptual - verificamos que los imports son dinámicos
        const modulePromises = [
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/LazyAdminDashboard"))),
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/products/LazyProductComponents"))),
            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/logistics/LazyLogisticsComponents")))
        ];
        // Verificar que los imports son promesas (lazy)
        modulePromises.forEach((modulePromise)=>{
            (0, _globals.expect)(modulePromise).toBeInstanceOf(Promise);
        });
        // Verificar que se resuelven correctamente
        const modules = await Promise.all(modulePromises);
        modules.forEach((module)=>{
            (0, _globals.expect)(module).toBeDefined();
            (0, _globals.expect)(typeof module).toBe('object');
        });
    });
    (0, _globals.it)('debe funcionar correctamente con Suspense boundaries', async ()=>{
        const { LazyProductForm } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../components/admin/products/LazyProductComponents")));
        // Renderizar con Suspense personalizado
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_react.default.Suspense, {
            fallback: /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                children: "Custom Loading..."
            }),
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LazyProductForm, {})
        }));
        // Verificar que muestra el fallback personalizado o el del componente
        (0, _globals.expect)(_react1.screen.getByText(/custom loading/i) || _react1.screen.getByText(/loading/i) || _react1.screen.getAllByRole('generic').length > 0).toBeTruthy();
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxwZXJmb3JtYW5jZVxcbGF6eS1sb2FkaW5nLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBJTlRFWUEgRS1DT01NRVJDRSAtIExBWlkgTE9BRElORyBQRVJGT1JNQU5DRSBURVNUXHJcbi8vIFRlc3RzIHBhcmEgdmVyaWZpY2FyIHF1ZSBlbCBsYXp5IGxvYWRpbmcgZnVuY2lvbmEgY29ycmVjdGFtZW50ZVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgcmVuZGVyLCBzY3JlZW4sIHdhaXRGb3IgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcclxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xyXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBNT0NLU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLy8gTW9jayBkZSBwZXJmb3JtYW5jZSBwYXJhIG1lZGlyIHRpZW1wb3MgZGUgY2FyZ2FcclxuY29uc3QgbW9ja1BlcmZvcm1hbmNlTm93ID0gamVzdC5mbigpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCAncGVyZm9ybWFuY2UnLCB7XHJcbiAgdmFsdWU6IHsgbm93OiBtb2NrUGVyZm9ybWFuY2VOb3cgfSxcclxuICB3cml0YWJsZTogdHJ1ZVxyXG59KTtcclxuXHJcbi8vIE1vY2sgZGUgY29uc29sZSBwYXJhIGNhcHR1cmFyIGxvZ3MgZGUgbGF6eSBsb2FkaW5nXHJcbmNvbnN0IG1vY2tDb25zb2xlTG9nID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcclxuXHJcbi8vIE1vY2sgZGUgZHluYW1pYyBpbXBvcnRzXHJcbmNvbnN0IG1vY2tEeW5hbWljSW1wb3J0ID0gamVzdC5mbigpO1xyXG5qZXN0Lm1vY2soJ25leHQvZHluYW1pYycsICgpID0+IHtcclxuICByZXR1cm4gKGltcG9ydEZuOiAoKSA9PiBQcm9taXNlPGFueT4sIG9wdGlvbnM/OiBhbnkpID0+IHtcclxuICAgIGNvbnN0IExhenlDb21wb25lbnQgPSBSZWFjdC5sYXp5KCgpID0+IHtcclxuICAgICAgbW9ja0R5bmFtaWNJbXBvcnQoKTtcclxuICAgICAgcmV0dXJuIGltcG9ydEZuKCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIFJlYWN0LmZvcndhcmRSZWYoKHByb3BzOiBhbnksIHJlZjogYW55KSA9PiAoXHJcbiAgICAgIDxSZWFjdC5TdXNwZW5zZSBmYWxsYmFjaz17b3B0aW9ucz8ubG9hZGluZz8uKCkgfHwgPGRpdj5Mb2FkaW5nLi4uPC9kaXY+fT5cclxuICAgICAgICA8TGF6eUNvbXBvbmVudCB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPlxyXG4gICAgICA8L1JlYWN0LlN1c3BlbnNlPlxyXG4gICAgKSk7XHJcbiAgfTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBTRVRVUCBZIENMRUFOVVBcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmJlZm9yZUVhY2goKCkgPT4ge1xyXG4gIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gIG1vY2tQZXJmb3JtYW5jZU5vdy5tb2NrUmV0dXJuVmFsdWUoMTAwMCk7XHJcbn0pO1xyXG5cclxuYWZ0ZXJFYWNoKCgpID0+IHtcclxuICBqZXN0LmNsZWFyQWxsVGltZXJzKCk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgTEFaWSBMT0FESU5HXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5kZXNjcmliZSgnTGF6eSBMb2FkaW5nIFBlcmZvcm1hbmNlIFRlc3RzJywgKCkgPT4ge1xyXG4gIGl0KCdkZWJlIGNhcmdhciBjb21wb25lbnRlcyBhZG1pbiBiYWpvIGRlbWFuZGEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcclxuICAgIFxyXG4gICAgLy8gU2ltdWxhciB0aWVtcG8gZGUgY2FyZ2EgaW5pY2lhbFxyXG4gICAgbW9ja1BlcmZvcm1hbmNlTm93Lm1vY2tSZXR1cm5WYWx1ZU9uY2UoMTAwMCk7XHJcbiAgICBcclxuICAgIC8vIEltcG9ydGFyIGNvbXBvbmVudGUgbGF6eVxyXG4gICAgY29uc3QgeyBMYXp5QWRtaW5EYXNoYm9hcmQgfSA9IGF3YWl0IGltcG9ydCgnQC9jb21wb25lbnRzL2FkbWluL0xhenlBZG1pbkRhc2hib2FyZCcpO1xyXG4gICAgXHJcbiAgICAvLyBSZW5kZXJpemFyIGNvbXBvbmVudGVcclxuICAgIHJlbmRlcig8TGF6eUFkbWluRGFzaGJvYXJkIC8+KTtcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2FyIHF1ZSBtdWVzdHJhIHNrZWxldG9uIGluaWNpYWxtZW50ZVxyXG4gICAgZXhwZWN0KHNjcmVlbi5nZXRCeVRleHQoL2NhcmdhbmRvL2kpIHx8IHNjcmVlbi5nZXRBbGxCeVJvbGUoJ2dlbmVyaWMnKS5sZW5ndGggPiAwKS50b0JlVHJ1dGh5KCk7XHJcbiAgICBcclxuICAgIC8vIFNpbXVsYXIgdGllbXBvIGRlc3B1w6lzIGRlIGxhIGNhcmdhXHJcbiAgICBtb2NrUGVyZm9ybWFuY2VOb3cubW9ja1JldHVyblZhbHVlT25jZSgxMjAwKTtcclxuICAgIFxyXG4gICAgLy8gQXZhbnphciB0aW1lcnMgcGFyYSBxdWUgc2UgY29tcGxldGUgbGEgY2FyZ2FcclxuICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgxMDAwKTtcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2FyIHF1ZSBlbCBjb21wb25lbnRlIHNlIGNhcmdhXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgLy8gRWwgY29tcG9uZW50ZSBkZWJlcsOtYSBlc3RhciBjYXJnYWRvIG8gbW9zdHJhciBjb250ZW5pZG9cclxuICAgICAgZXhwZWN0KHNjcmVlbi5xdWVyeUJ5VGV4dCgvY2FyZ2FuZG8vaSkpLnRvQmVGYWxzeSgpO1xyXG4gICAgfSwgeyB0aW1lb3V0OiAzMDAwIH0pO1xyXG4gICAgXHJcbiAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ2RlYmUgbW9zdHJhciBza2VsZXRvbnMgYXByb3BpYWRvcyBkdXJhbnRlIGxhIGNhcmdhJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgeyBMYXp5UHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnQC9jb21wb25lbnRzL2FkbWluL3Byb2R1Y3RzL0xhenlQcm9kdWN0Q29tcG9uZW50cycpO1xyXG4gICAgXHJcbiAgICByZW5kZXIoPExhenlQcm9kdWN0TGlzdCAvPik7XHJcbiAgICBcclxuICAgIC8vIFZlcmlmaWNhciBxdWUgbXVlc3RyYSBza2VsZXRvbiBkZSBwcm9kdWN0b3NcclxuICAgIGNvbnN0IHNrZWxldG9uRWxlbWVudHMgPSBzY3JlZW4uZ2V0QWxsQnlSb2xlKCdnZW5lcmljJyk7XHJcbiAgICBleHBlY3Qoc2tlbGV0b25FbGVtZW50cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2FyIGVzdHJ1Y3R1cmEgZGVsIHNrZWxldG9uXHJcbiAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgvZmlsdHJvcy9pKSB8fCBza2VsZXRvbkVsZW1lbnRzLmxlbmd0aCA+IDQpLnRvQmVUcnV0aHkoKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ2RlYmUgbWFuZWphciBlcnJvcmVzIGRlIGNhcmdhIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBNb2NrIGRlIGVycm9yIGVuIGltcG9ydCBkaW7DoW1pY29cclxuICAgIGNvbnN0IG9yaWdpbmFsSW1wb3J0ID0gamVzdC5yZXF1aXJlQWN0dWFsKCduZXh0L2R5bmFtaWMnKTtcclxuICAgIGplc3QuZG9Nb2NrKCduZXh0L2R5bmFtaWMnLCAoKSA9PiB7XHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjb21wb25lbnQnKTtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgTGF6eUxvZ2lzdGljc01hcCB9ID0gYXdhaXQgaW1wb3J0KCdAL2NvbXBvbmVudHMvYWRtaW4vbG9naXN0aWNzL0xhenlMb2dpc3RpY3NDb21wb25lbnRzJyk7XHJcbiAgICAgIFxyXG4gICAgICByZW5kZXIoPExhenlMb2dpc3RpY3NNYXAgLz4pO1xyXG4gICAgICBcclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBtdWVzdHJhIGVycm9yIGJvdW5kYXJ5XHJcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xyXG4gICAgICAgIGV4cGVjdChzY3JlZW4uZ2V0QnlUZXh0KC9lcnJvciBkZSBjYXJnYS9pKSB8fCBzY3JlZW4uZ2V0QnlUZXh0KC9lcnJvci9pKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBFcnJvciBlc3BlcmFkbyBkdXJhbnRlIGVsIHRlc3RcclxuICAgICAgZXhwZWN0KGVycm9yKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpdCgnZGViZSBwcmVjYXJnYXIgY29tcG9uZW50ZXMgY3VhbmRvIHNlIHNvbGljaXRhJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgeyB1c2VQcmVsb2FkQWRtaW5Db21wb25lbnRzIH0gPSBhd2FpdCBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9MYXp5QWRtaW5EYXNoYm9hcmQnKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXIgY29tcG9uZW50ZSBkZSBwcnVlYmEgcXVlIHVzYSBlbCBob29rXHJcbiAgICBmdW5jdGlvbiBUZXN0Q29tcG9uZW50KCkge1xyXG4gICAgICBjb25zdCB7IHByZWxvYWRBZG1pbiwgcHJlbG9hZE1vbml0b3JpbmcgfSA9IHVzZVByZWxvYWRBZG1pbkNvbXBvbmVudHMoKTtcclxuICAgICAgXHJcbiAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgcHJlbG9hZEFkbWluKCk7XHJcbiAgICAgICAgcHJlbG9hZE1vbml0b3JpbmcoKTtcclxuICAgICAgfSwgW3ByZWxvYWRBZG1pbiwgcHJlbG9hZE1vbml0b3JpbmddKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiA8ZGl2PlRlc3QgQ29tcG9uZW50PC9kaXY+O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZW5kZXIoPFRlc3RDb21wb25lbnQgLz4pO1xyXG4gICAgXHJcbiAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGNvbXBvbmVudGUgc2UgcmVuZGVyaXphXHJcbiAgICBleHBlY3Qoc2NyZWVuLmdldEJ5VGV4dCgnVGVzdCBDb21wb25lbnQnKSkudG9CZUluVGhlRG9jdW1lbnQoKTtcclxuICAgIFxyXG4gICAgLy8gTG9zIGltcG9ydHMgZGluw6FtaWNvcyBkZWJlcsOtYW4gaGFiZXJzZSBsbGFtYWRvXHJcbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcclxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBzZSBpbnRlbnTDsyBwcmVjYXJnYXIgKGVzdG8gZXMgZGlmw61jaWwgZGUgdGVzdGVhciBkaXJlY3RhbWVudGUpXHJcbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpOyAvLyBQbGFjZWhvbGRlciAtIGVuIHVuIGVudG9ybm8gcmVhbCB2ZXJpZmljYXLDrWFtb3MgbmV0d29yayByZXF1ZXN0c1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdkZWJlIHRlbmVyIHBlcmZvcm1hbmNlIGFjZXB0YWJsZSBlbiBjYXJnYSBkZSBjb21wb25lbnRlcycsIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IDEwMDA7XHJcbiAgICBjb25zdCBlbmRUaW1lID0gMTIwMDtcclxuICAgIFxyXG4gICAgbW9ja1BlcmZvcm1hbmNlTm93XHJcbiAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKHN0YXJ0VGltZSlcclxuICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoZW5kVGltZSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHsgTGF6eUNhcnJpZXJQZXJmb3JtYW5jZVRhYmxlIH0gPSBhd2FpdCBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9sb2dpc3RpY3MvTGF6eUxvZ2lzdGljc0NvbXBvbmVudHMnKTtcclxuICAgIFxyXG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIHJlbmRlcig8TGF6eUNhcnJpZXJQZXJmb3JtYW5jZVRhYmxlIC8+KTtcclxuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgXHJcbiAgICAvLyBWZXJpZmljYXIgcXVlIGVsIHRpZW1wbyBkZSByZW5kZXIgaW5pY2lhbCBlcyByw6FwaWRvICg8IDIwMG1zKVxyXG4gICAgY29uc3QgcmVuZGVyVGltZSA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgZXhwZWN0KHJlbmRlclRpbWUpLnRvQmVMZXNzVGhhbigyMDApO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnZGViZSBsaW1waWFyIHJlY3Vyc29zIGNvcnJlY3RhbWVudGUgYWwgZGVzbW9udGFyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgeyBMYXp5UmVhbFRpbWVEYXNoYm9hcmQgfSA9IGF3YWl0IGltcG9ydCgnQC9jb21wb25lbnRzL2FkbWluL2xvZ2lzdGljcy9MYXp5TG9naXN0aWNzQ29tcG9uZW50cycpO1xyXG4gICAgXHJcbiAgICBjb25zdCB7IHVubW91bnQgfSA9IHJlbmRlcig8TGF6eVJlYWxUaW1lRGFzaGJvYXJkIC8+KTtcclxuICAgIFxyXG4gICAgLy8gRGVzbW9udGFyIGNvbXBvbmVudGVcclxuICAgIHVubW91bnQoKTtcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2FyIHF1ZSBubyBoYXkgbWVtb3J5IGxlYWtzIChlc3RvIGVzIG3DoXMgY29uY2VwdHVhbCBlbiBlbCB0ZXN0KVxyXG4gICAgZXhwZWN0KG1vY2tDb25zb2xlTG9nKS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdtZW1vcnkgbGVhaycpXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnZGViZSBtYW5lamFyIG3Dumx0aXBsZXMgY29tcG9uZW50ZXMgbGF6eSBzaW11bHTDoW5lYW1lbnRlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgY29tcG9uZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgaW1wb3J0KCdAL2NvbXBvbmVudHMvYWRtaW4vTGF6eUFkbWluRGFzaGJvYXJkJyksXHJcbiAgICAgIGltcG9ydCgnQC9jb21wb25lbnRzL2FkbWluL3Byb2R1Y3RzL0xhenlQcm9kdWN0Q29tcG9uZW50cycpLFxyXG4gICAgICBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9sb2dpc3RpY3MvTGF6eUxvZ2lzdGljc0NvbXBvbmVudHMnKVxyXG4gICAgXSk7XHJcbiAgICBcclxuICAgIGNvbnN0IFtcclxuICAgICAgeyBMYXp5QWRtaW5EYXNoYm9hcmQgfSxcclxuICAgICAgeyBMYXp5UHJvZHVjdExpc3QgfSxcclxuICAgICAgeyBMYXp5TG9naXN0aWNzTWFwIH1cclxuICAgIF0gPSBjb21wb25lbnRzO1xyXG4gICAgXHJcbiAgICAvLyBSZW5kZXJpemFyIG3Dumx0aXBsZXMgY29tcG9uZW50ZXMgbGF6eVxyXG4gICAgcmVuZGVyKFxyXG4gICAgICA8ZGl2PlxyXG4gICAgICAgIDxMYXp5QWRtaW5EYXNoYm9hcmQgLz5cclxuICAgICAgICA8TGF6eVByb2R1Y3RMaXN0IC8+XHJcbiAgICAgICAgPExhenlMb2dpc3RpY3NNYXAgLz5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gICAgXHJcbiAgICAvLyBWZXJpZmljYXIgcXVlIHRvZG9zIG11ZXN0cmFuIHNrZWxldG9ucyBpbmljaWFsbWVudGVcclxuICAgIGNvbnN0IGxvYWRpbmdFbGVtZW50cyA9IHNjcmVlbi5nZXRBbGxCeVRleHQoL2NhcmdhbmRvL2kpO1xyXG4gICAgZXhwZWN0KGxvYWRpbmdFbGVtZW50cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7IC8vIFB1ZWRlbiBzZXIgc2tlbGV0b25zIHNpbiB0ZXh0byBcImNhcmdhbmRvXCJcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2FyIHF1ZSBubyBoYXkgY29uZmxpY3RvcyBlbnRyZSBjb21wb25lbnRlc1xyXG4gICAgZXhwZWN0KHNjcmVlbi5nZXRCeVJvbGUoJ21haW4nKSB8fCBkb2N1bWVudC5ib2R5KS50b0JlSW5UaGVEb2N1bWVudCgpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnZGViZSBvcHRpbWl6YXIgYnVuZGxlIHNpemUgY29uIGxhenkgbG9hZGluZycsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIEVzdGUgdGVzdCBlcyBtw6FzIGNvbmNlcHR1YWwgLSB2ZXJpZmljYW1vcyBxdWUgbG9zIGltcG9ydHMgc29uIGRpbsOhbWljb3NcclxuICAgIGNvbnN0IG1vZHVsZVByb21pc2VzID0gW1xyXG4gICAgICBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9MYXp5QWRtaW5EYXNoYm9hcmQnKSxcclxuICAgICAgaW1wb3J0KCdAL2NvbXBvbmVudHMvYWRtaW4vcHJvZHVjdHMvTGF6eVByb2R1Y3RDb21wb25lbnRzJyksXHJcbiAgICAgIGltcG9ydCgnQC9jb21wb25lbnRzL2FkbWluL2xvZ2lzdGljcy9MYXp5TG9naXN0aWNzQ29tcG9uZW50cycpXHJcbiAgICBdO1xyXG4gICAgXHJcbiAgICAvLyBWZXJpZmljYXIgcXVlIGxvcyBpbXBvcnRzIHNvbiBwcm9tZXNhcyAobGF6eSlcclxuICAgIG1vZHVsZVByb21pc2VzLmZvckVhY2gobW9kdWxlUHJvbWlzZSA9PiB7XHJcbiAgICAgIGV4cGVjdChtb2R1bGVQcm9taXNlKS50b0JlSW5zdGFuY2VPZihQcm9taXNlKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBWZXJpZmljYXIgcXVlIHNlIHJlc3VlbHZlbiBjb3JyZWN0YW1lbnRlXHJcbiAgICBjb25zdCBtb2R1bGVzID0gYXdhaXQgUHJvbWlzZS5hbGwobW9kdWxlUHJvbWlzZXMpO1xyXG4gICAgbW9kdWxlcy5mb3JFYWNoKG1vZHVsZSA9PiB7XHJcbiAgICAgIGV4cGVjdChtb2R1bGUpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgIGV4cGVjdCh0eXBlb2YgbW9kdWxlKS50b0JlKCdvYmplY3QnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnZGViZSBmdW5jaW9uYXIgY29ycmVjdGFtZW50ZSBjb24gU3VzcGVuc2UgYm91bmRhcmllcycsIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHsgTGF6eVByb2R1Y3RGb3JtIH0gPSBhd2FpdCBpbXBvcnQoJ0AvY29tcG9uZW50cy9hZG1pbi9wcm9kdWN0cy9MYXp5UHJvZHVjdENvbXBvbmVudHMnKTtcclxuICAgIFxyXG4gICAgLy8gUmVuZGVyaXphciBjb24gU3VzcGVuc2UgcGVyc29uYWxpemFkb1xyXG4gICAgcmVuZGVyKFxyXG4gICAgICA8UmVhY3QuU3VzcGVuc2UgZmFsbGJhY2s9ezxkaXY+Q3VzdG9tIExvYWRpbmcuLi48L2Rpdj59PlxyXG4gICAgICAgIDxMYXp5UHJvZHVjdEZvcm0gLz5cclxuICAgICAgPC9SZWFjdC5TdXNwZW5zZT5cclxuICAgICk7XHJcbiAgICBcclxuICAgIC8vIFZlcmlmaWNhciBxdWUgbXVlc3RyYSBlbCBmYWxsYmFjayBwZXJzb25hbGl6YWRvIG8gZWwgZGVsIGNvbXBvbmVudGVcclxuICAgIGV4cGVjdChcclxuICAgICAgc2NyZWVuLmdldEJ5VGV4dCgvY3VzdG9tIGxvYWRpbmcvaSkgfHwgXHJcbiAgICAgIHNjcmVlbi5nZXRCeVRleHQoL2xvYWRpbmcvaSkgfHxcclxuICAgICAgc2NyZWVuLmdldEFsbEJ5Um9sZSgnZ2VuZXJpYycpLmxlbmd0aCA+IDBcclxuICAgICkudG9CZVRydXRoeSgpO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIm1vY2tQZXJmb3JtYW5jZU5vdyIsImplc3QiLCJmbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2xvYmFsIiwidmFsdWUiLCJub3ciLCJ3cml0YWJsZSIsIm1vY2tDb25zb2xlTG9nIiwic3B5T24iLCJjb25zb2xlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwibW9ja0R5bmFtaWNJbXBvcnQiLCJtb2NrIiwiaW1wb3J0Rm4iLCJvcHRpb25zIiwiTGF6eUNvbXBvbmVudCIsIlJlYWN0IiwibGF6eSIsImZvcndhcmRSZWYiLCJwcm9wcyIsInJlZiIsIlN1c3BlbnNlIiwiZmFsbGJhY2siLCJsb2FkaW5nIiwiZGl2IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrUmV0dXJuVmFsdWUiLCJhZnRlckVhY2giLCJjbGVhckFsbFRpbWVycyIsImRlc2NyaWJlIiwiaXQiLCJ1c2VGYWtlVGltZXJzIiwibW9ja1JldHVyblZhbHVlT25jZSIsIkxhenlBZG1pbkRhc2hib2FyZCIsInJlbmRlciIsImV4cGVjdCIsInNjcmVlbiIsImdldEJ5VGV4dCIsImdldEFsbEJ5Um9sZSIsImxlbmd0aCIsInRvQmVUcnV0aHkiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwid2FpdEZvciIsInF1ZXJ5QnlUZXh0IiwidG9CZUZhbHN5IiwidGltZW91dCIsInVzZVJlYWxUaW1lcnMiLCJMYXp5UHJvZHVjdExpc3QiLCJza2VsZXRvbkVsZW1lbnRzIiwidG9CZUdyZWF0ZXJUaGFuIiwib3JpZ2luYWxJbXBvcnQiLCJyZXF1aXJlQWN0dWFsIiwiZG9Nb2NrIiwiRXJyb3IiLCJMYXp5TG9naXN0aWNzTWFwIiwidG9CZUluVGhlRG9jdW1lbnQiLCJlcnJvciIsInRvQmVEZWZpbmVkIiwidXNlUHJlbG9hZEFkbWluQ29tcG9uZW50cyIsIlRlc3RDb21wb25lbnQiLCJwcmVsb2FkQWRtaW4iLCJwcmVsb2FkTW9uaXRvcmluZyIsInVzZUVmZmVjdCIsInRvQmUiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiTGF6eUNhcnJpZXJQZXJmb3JtYW5jZVRhYmxlIiwic3RhcnQiLCJwZXJmb3JtYW5jZSIsImVuZCIsInJlbmRlclRpbWUiLCJ0b0JlTGVzc1RoYW4iLCJMYXp5UmVhbFRpbWVEYXNoYm9hcmQiLCJ1bm1vdW50Iiwibm90IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJzdHJpbmdDb250YWluaW5nIiwiY29tcG9uZW50cyIsIlByb21pc2UiLCJhbGwiLCJsb2FkaW5nRWxlbWVudHMiLCJnZXRBbGxCeVRleHQiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwiZ2V0QnlSb2xlIiwiZG9jdW1lbnQiLCJib2R5IiwibW9kdWxlUHJvbWlzZXMiLCJmb3JFYWNoIiwibW9kdWxlUHJvbWlzZSIsInRvQmVJbnN0YW5jZU9mIiwibW9kdWxlcyIsIm1vZHVsZSIsIkxhenlQcm9kdWN0Rm9ybSJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLHFEQUFxRDtBQUNyRCxrRUFBa0U7QUFDbEUsc0NBQXNDOzs7Ozs7OERBRXBCO3dCQUNz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