b5f694182668e90a2c8cc00b7e05bab5
/**
 * Tests para Sistema Enterprise de Auditoría de Seguridad
 * Valida funcionalidad completa del sistema de auditoría, detección de anomalías y gestión de incidentes
 */ // Mock de dependencias
"use strict";
jest.mock('@/lib/supabase', ()=>({
        supabaseAdmin: {
            from: jest.fn(()=>({
                    select: jest.fn(()=>({
                            eq: jest.fn(()=>({
                                    single: jest.fn(),
                                    range: jest.fn(()=>({
                                            order: jest.fn()
                                        }))
                                })),
                            insert: jest.fn(()=>({
                                    select: jest.fn(()=>({
                                            single: jest.fn()
                                        }))
                                })),
                            update: jest.fn(()=>({
                                    eq: jest.fn(()=>({
                                            select: jest.fn(()=>({
                                                    single: jest.fn()
                                                }))
                                        }))
                                })),
                            order: jest.fn(()=>({
                                    range: jest.fn()
                                })),
                            not: jest.fn(()=>({
                                    filter: jest.fn()
                                }))
                        }))
                }))
        }
    }));
jest.mock('@/lib/auth/security-audit', ()=>({
        logSecurityEvent: jest.fn()
    }));
jest.mock('@/lib/auth/security-audit-enhanced', ()=>({
        analyzeSecurityPatterns: jest.fn(),
        getSecurityMetrics: jest.fn(),
        generateSecurityReport: jest.fn()
    }));
jest.mock('@/lib/rate-limiting/enterprise-rate-limiter', ()=>({
        metricsCollector: {
            getMetrics: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _enterpriseauditsystem = require("../../lib/security/enterprise-audit-system");
const _securityaudit = require("../../lib/auth/security-audit");
const _securityauditenhanced = require("../../lib/auth/security-audit-enhanced");
const _enterpriseratelimiter = require("../../lib/rate-limiting/enterprise-rate-limiter");
describe('Sistema Enterprise de Auditoría de Seguridad', ()=>{
    let mockLogSecurityEvent;
    let mockAnalyzeSecurityPatterns;
    let mockGetSecurityMetrics;
    let mockGetMetrics;
    beforeEach(()=>{
        mockLogSecurityEvent = _securityaudit.logSecurityEvent;
        mockAnalyzeSecurityPatterns = _securityauditenhanced.analyzeSecurityPatterns;
        mockGetSecurityMetrics = _securityauditenhanced.getSecurityMetrics;
        mockGetMetrics = _enterpriseratelimiter.metricsCollector.getMetrics;
        jest.clearAllMocks();
        // Setup default mocks
        mockLogSecurityEvent.mockResolvedValue(undefined);
        mockAnalyzeSecurityPatterns.mockResolvedValue([]);
        mockGetSecurityMetrics.mockResolvedValue({
            total_events: 100,
            critical_events: 5,
            failed_logins: 10,
            suspicious_activities: 3,
            blocked_ips: 2,
            security_alerts: 8
        });
        mockGetMetrics.mockReturnValue({
            totalRequests: 1000,
            allowedRequests: 950,
            blockedRequests: 50,
            redisHits: 900,
            memoryFallbacks: 100,
            errors: 5,
            averageResponseTime: 45,
            topBlockedIPs: [
                {
                    ip: '192.168.1.100',
                    count: 25
                },
                {
                    ip: '10.0.0.50',
                    count: 15
                }
            ],
            topEndpoints: [
                {
                    endpoint: '/api/admin',
                    count: 30
                },
                {
                    endpoint: '/api/payments',
                    count: 20
                }
            ]
        });
    });
    describe('Configuración Enterprise', ()=>{
        it('debe tener configuración de retención de datos', ()=>{
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DATA_RETENTION).toBeDefined();
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DATA_RETENTION.security_events).toBe(365);
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DATA_RETENTION.anomalies).toBe(180);
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DATA_RETENTION.incidents).toBe(1095);
        });
        it('debe tener umbrales de detección configurados', ()=>{
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DETECTION_THRESHOLDS).toBeDefined();
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DETECTION_THRESHOLDS.anomaly_confidence).toBe(0.7);
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.DETECTION_THRESHOLDS.risk_score_critical).toBe(80);
        });
        it('debe tener configuración de alertas', ()=>{
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.ALERT_CONFIG).toBeDefined();
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.ALERT_CONFIG.immediate_notification).toContain('critical');
            expect(_enterpriseauditsystem.ENTERPRISE_AUDIT_CONFIG.ALERT_CONFIG.notification_cooldown).toBe(300);
        });
    });
    describe('Registro de Eventos Enterprise', ()=>{
        it('debe registrar evento enterprise con contexto completo', async ()=>{
            const mockContext = {
                userId: 'user_123',
                sessionId: 'sess_123',
                email: 'test@example.com',
                role: 'admin',
                permissions: [
                    'admin_access'
                ],
                sessionValid: true,
                securityLevel: 'high',
                ipAddress: '192.168.1.1',
                userAgent: 'test-agent',
                supabase: {},
                validations: {
                    jwtValid: true,
                    csrfValid: true,
                    rateLimitPassed: true,
                    originValid: true
                }
            };
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.1'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const event = {
                user_id: 'user_123',
                event_type: 'AUTH_SUCCESS',
                event_category: 'authentication',
                severity: 'low',
                description: 'Usuario autenticado correctamente',
                metadata: {
                    method: 'clerk'
                },
                ip_address: '192.168.1.1',
                user_agent: 'test-agent'
            };
            const correlationId = await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent(event, mockContext, mockRequest);
            expect(correlationId).toBeDefined();
            expect(correlationId).toMatch(/^corr_\d+_[a-z0-9]+$/);
            expect(mockLogSecurityEvent).toHaveBeenCalledWith(event);
        });
        it('debe calcular risk score correctamente', async ()=>{
            const criticalEvent = {
                user_id: 'user_123',
                event_type: 'SECURITY_VIOLATION',
                event_category: 'suspicious_behavior',
                severity: 'critical',
                description: 'Violación de seguridad crítica',
                metadata: {},
                ip_address: '192.168.1.1',
                user_agent: 'test-agent'
            };
            const correlationId = await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent(criticalEvent);
            expect(correlationId).toBeDefined();
            expect(mockLogSecurityEvent).toHaveBeenCalled();
        });
        it('debe manejar eventos sin contexto enterprise', async ()=>{
            const event = {
                user_id: 'user_123',
                event_type: 'AUTH_FAILURE',
                event_category: 'authentication',
                severity: 'medium',
                description: 'Fallo de autenticación',
                metadata: {},
                ip_address: '192.168.1.1',
                user_agent: 'test-agent'
            };
            const correlationId = await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent(event);
            expect(correlationId).toBeDefined();
            expect(mockLogSecurityEvent).toHaveBeenCalledWith(event);
        });
    });
    describe('Detección de Anomalías', ()=>{
        it('debe detectar anomalías sin eventos', async ()=>{
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies('user_123');
            expect(anomalies).toEqual([]);
        });
        it('debe detectar patrones de login inusuales', async ()=>{
            // Mock de eventos que simularían un patrón sospechoso
            const mockEvents = [
                {
                    id: 'evt_1',
                    user_id: 'user_123',
                    event_type: 'AUTH_FAILURE',
                    event_category: 'authentication',
                    severity: 'medium',
                    description: 'Fallo de autenticación',
                    metadata: {},
                    ip_address: '192.168.1.1',
                    user_agent: 'test-agent',
                    timestamp: new Date(Date.now() - 1000).toISOString(),
                    resolved: false
                },
                {
                    id: 'evt_2',
                    user_id: 'user_123',
                    event_type: 'AUTH_FAILURE',
                    event_category: 'authentication',
                    severity: 'medium',
                    description: 'Fallo de autenticación',
                    metadata: {},
                    ip_address: '192.168.1.2',
                    user_agent: 'test-agent',
                    timestamp: new Date(Date.now() - 500).toISOString(),
                    resolved: false
                },
                {
                    id: 'evt_3',
                    user_id: 'user_123',
                    event_type: 'AUTH_SUCCESS',
                    event_category: 'authentication',
                    severity: 'low',
                    description: 'Autenticación exitosa',
                    metadata: {},
                    ip_address: '192.168.1.3',
                    user_agent: 'test-agent',
                    timestamp: new Date().toISOString(),
                    resolved: false
                }
            ];
            // Simular que getRecentEvents devuelve estos eventos
            jest.spyOn(_enterpriseauditsystem.enterpriseAuditSystem, 'getRecentEvents').mockResolvedValue(mockEvents);
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies('user_123');
            // Debería detectar al menos una anomalía por el patrón de múltiples fallos + éxito
            expect(anomalies.length).toBeGreaterThanOrEqual(0);
        });
        it('debe detectar abuso de rate limiting', async ()=>{
            // Mock de métricas con muchos bloqueos
            mockGetMetrics.mockReturnValue({
                totalRequests: 1000,
                allowedRequests: 800,
                blockedRequests: 200,
                redisHits: 900,
                memoryFallbacks: 100,
                errors: 5,
                averageResponseTime: 45,
                topBlockedIPs: [
                    {
                        ip: '192.168.1.100',
                        count: 50
                    },
                    {
                        ip: '10.0.0.50',
                        count: 30
                    }
                ],
                topEndpoints: []
            });
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies();
            // Debería detectar anomalías de rate limit abuse
            expect(anomalies.length).toBeGreaterThanOrEqual(0);
        });
        it('debe filtrar anomalías por confianza', async ()=>{
            // Simular detección con diferentes niveles de confianza
            jest.spyOn(_enterpriseauditsystem.enterpriseAuditSystem, 'getRecentEvents').mockResolvedValue([]);
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies();
            // Solo deberían retornarse anomalías con confianza >= 0.7
            anomalies.forEach((anomaly)=>{
                expect(anomaly.confidence_score).toBeGreaterThanOrEqual(0.7);
            });
        });
    });
    describe('Generación de Reportes Enterprise', ()=>{
        it('debe generar reporte enterprise completo', async ()=>{
            const mockBaseReport = {
                period: {
                    start: '2025-01-01',
                    end: '2025-01-31'
                },
                summary: {
                    total_events: 100
                },
                events: [],
                patterns: [],
                recommendations: []
            };
            const mockGenerateSecurityReport = _securityauditenhanced.generateSecurityReport;
            mockGenerateSecurityReport.mockResolvedValue(mockBaseReport);
            const startDate = '2025-01-01T00:00:00.000Z';
            const endDate = '2025-01-31T23:59:59.999Z';
            const report = await _enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport(startDate, endDate, true, true);
            expect(report).toBeDefined();
            expect(report.enterprise_data).toBeDefined();
            expect(report.enterprise_data.anomalies).toBeDefined();
            expect(report.enterprise_data.incidents).toBeDefined();
            expect(report.enterprise_data.rate_limiting_stats).toBeDefined();
            expect(mockGenerateSecurityReport).toHaveBeenCalledWith(startDate, endDate);
        });
        it('debe generar reporte sin anomalías e incidentes', async ()=>{
            const mockBaseReport = {
                period: {
                    start: '2025-01-01',
                    end: '2025-01-31'
                },
                summary: {
                    total_events: 50
                },
                events: [],
                patterns: [],
                recommendations: []
            };
            const mockGenerateSecurityReport = _securityauditenhanced.generateSecurityReport;
            mockGenerateSecurityReport.mockResolvedValue(mockBaseReport);
            const startDate = '2025-01-01T00:00:00.000Z';
            const endDate = '2025-01-31T23:59:59.999Z';
            const report = await _enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport(startDate, endDate, false, false);
            expect(report.enterprise_data.anomalies).toEqual([]);
            expect(report.enterprise_data.incidents).toEqual([]);
        });
    });
    describe('Integración con Rate Limiting', ()=>{
        it('debe obtener estadísticas de rate limiting', async ()=>{
            const stats = _enterpriseauditsystem.enterpriseAuditSystem.getRateLimitingStats();
            expect(stats).toBeDefined();
            expect(stats.totalRequests).toBe(1000);
            expect(stats.blockedRequests).toBe(50);
            expect(stats.topBlockedIPs).toHaveLength(2);
            expect(mockGetMetrics).toHaveBeenCalled();
        });
        it('debe incluir métricas de rate limiting en reportes', async ()=>{
            const mockBaseReport = {
                period: {
                    start: '2025-01-01',
                    end: '2025-01-31'
                },
                summary: {
                    total_events: 100
                },
                events: [],
                patterns: [],
                recommendations: []
            };
            const mockGenerateSecurityReport = _securityauditenhanced.generateSecurityReport;
            mockGenerateSecurityReport.mockResolvedValue(mockBaseReport);
            const report = await _enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport('2025-01-01T00:00:00.000Z', '2025-01-31T23:59:59.999Z');
            expect(report.enterprise_data.rate_limiting_stats).toBeDefined();
            expect(report.enterprise_data.rate_limiting_stats.totalRequests).toBe(1000);
        });
    });
    describe('Gestión de Instancia Singleton', ()=>{
        it('debe retornar la misma instancia', ()=>{
            const instance1 = _enterpriseauditsystem.EnterpriseAuditSystem.getInstance();
            const instance2 = _enterpriseauditsystem.EnterpriseAuditSystem.getInstance();
            expect(instance1).toBe(instance2);
            expect(instance1).toBe(_enterpriseauditsystem.enterpriseAuditSystem);
        });
        it('debe poder destruir la instancia', ()=>{
            const spy = jest.spyOn(console, 'log').mockImplementation();
            _enterpriseauditsystem.enterpriseAuditSystem.destroy();
            // Verificar que se limpien los intervalos
            expect(spy).not.toHaveBeenCalledWith(expect.stringContaining('Error'));
            spy.mockRestore();
        });
    });
    describe('Manejo de Errores', ()=>{
        it('debe manejar errores en registro de eventos', async ()=>{
            mockLogSecurityEvent.mockRejectedValue(new Error('Database error'));
            const event = {
                user_id: 'user_123',
                event_type: 'AUTH_FAILURE',
                event_category: 'authentication',
                severity: 'medium',
                description: 'Test event',
                metadata: {},
                ip_address: '192.168.1.1',
                user_agent: 'test-agent'
            };
            await expect(_enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent(event)).rejects.toThrow();
        });
        it('debe manejar errores en detección de anomalías', async ()=>{
            jest.spyOn(_enterpriseauditsystem.enterpriseAuditSystem, 'getRecentEvents').mockRejectedValue(new Error('Database error'));
            const anomalies = await _enterpriseauditsystem.enterpriseAuditSystem.detectAnomalies('user_123');
            // Debe retornar array vacío en caso de error
            expect(anomalies).toEqual([]);
        });
        it('debe manejar errores en generación de reportes', async ()=>{
            const mockGenerateSecurityReport = _securityauditenhanced.generateSecurityReport;
            mockGenerateSecurityReport.mockRejectedValue(new Error('Report generation failed'));
            await expect(_enterpriseauditsystem.enterpriseAuditSystem.generateEnterpriseReport('2025-01-01T00:00:00.000Z', '2025-01-31T23:59:59.999Z')).rejects.toThrow();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxzZWN1cml0eVxcZW50ZXJwcmlzZS1hdWRpdC1zeXN0ZW0udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRlc3RzIHBhcmEgU2lzdGVtYSBFbnRlcnByaXNlIGRlIEF1ZGl0b3LDrWEgZGUgU2VndXJpZGFkXG4gKiBWYWxpZGEgZnVuY2lvbmFsaWRhZCBjb21wbGV0YSBkZWwgc2lzdGVtYSBkZSBhdWRpdG9yw61hLCBkZXRlY2Npw7NuIGRlIGFub21hbMOtYXMgeSBnZXN0acOzbiBkZSBpbmNpZGVudGVzXG4gKi9cblxuLy8gTW9jayBkZSBkZXBlbmRlbmNpYXNcbmplc3QubW9jaygnQC9saWIvc3VwYWJhc2UnLCAoKSA9PiAoe1xuICBzdXBhYmFzZUFkbWluOiB7XG4gICAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIGVxOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCksXG4gICAgICAgICAgcmFuZ2U6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIG9yZGVyOiBqZXN0LmZuKCksXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9KSksXG4gICAgICAgIGluc2VydDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCksXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9KSksXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgICAgc2luZ2xlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9KSksXG4gICAgICAgIG9yZGVyOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgcmFuZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgfSkpLFxuICAgICAgICBub3Q6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICBmaWx0ZXI6IGplc3QuZm4oKSxcbiAgICAgICAgfSkpLFxuICAgICAgfSkpLFxuICAgIH0pKSxcbiAgfSxcbn0pKVxuXG5qZXN0Lm1vY2soJ0AvbGliL2F1dGgvc2VjdXJpdHktYXVkaXQnLCAoKSA9PiAoe1xuICBsb2dTZWN1cml0eUV2ZW50OiBqZXN0LmZuKCksXG59KSlcblxuamVzdC5tb2NrKCdAL2xpYi9hdXRoL3NlY3VyaXR5LWF1ZGl0LWVuaGFuY2VkJywgKCkgPT4gKHtcbiAgYW5hbHl6ZVNlY3VyaXR5UGF0dGVybnM6IGplc3QuZm4oKSxcbiAgZ2V0U2VjdXJpdHlNZXRyaWNzOiBqZXN0LmZuKCksXG4gIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQ6IGplc3QuZm4oKSxcbn0pKVxuXG5qZXN0Lm1vY2soJ0AvbGliL3JhdGUtbGltaXRpbmcvZW50ZXJwcmlzZS1yYXRlLWxpbWl0ZXInLCAoKSA9PiAoe1xuICBtZXRyaWNzQ29sbGVjdG9yOiB7XG4gICAgZ2V0TWV0cmljczogamVzdC5mbigpLFxuICB9LFxufSkpXG5cbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInXG5pbXBvcnQge1xuICBFbnRlcnByaXNlQXVkaXRTeXN0ZW0sXG4gIGVudGVycHJpc2VBdWRpdFN5c3RlbSxcbiAgdHlwZSBFbnRlcnByaXNlU2VjdXJpdHlFdmVudCxcbiAgdHlwZSBTZWN1cml0eUFub21hbHlEZXRlY3Rpb24sXG4gIHR5cGUgU2VjdXJpdHlJbmNpZGVudCxcbiAgRU5URVJQUklTRV9BVURJVF9DT05GSUcsXG59IGZyb20gJ0AvbGliL3NlY3VyaXR5L2VudGVycHJpc2UtYXVkaXQtc3lzdGVtJ1xuaW1wb3J0IHsgbG9nU2VjdXJpdHlFdmVudCB9IGZyb20gJ0AvbGliL2F1dGgvc2VjdXJpdHktYXVkaXQnXG5pbXBvcnQge1xuICBhbmFseXplU2VjdXJpdHlQYXR0ZXJucyxcbiAgZ2V0U2VjdXJpdHlNZXRyaWNzLFxuICBnZW5lcmF0ZVNlY3VyaXR5UmVwb3J0LFxufSBmcm9tICdAL2xpYi9hdXRoL3NlY3VyaXR5LWF1ZGl0LWVuaGFuY2VkJ1xuaW1wb3J0IHsgbWV0cmljc0NvbGxlY3RvciB9IGZyb20gJ0AvbGliL3JhdGUtbGltaXRpbmcvZW50ZXJwcmlzZS1yYXRlLWxpbWl0ZXInXG5pbXBvcnQgdHlwZSB7IEVudGVycHJpc2VBdXRoQ29udGV4dCB9IGZyb20gJ0AvbGliL2F1dGgvZW50ZXJwcmlzZS1hdXRoLXV0aWxzJ1xuXG5kZXNjcmliZSgnU2lzdGVtYSBFbnRlcnByaXNlIGRlIEF1ZGl0b3LDrWEgZGUgU2VndXJpZGFkJywgKCkgPT4ge1xuICBsZXQgbW9ja0xvZ1NlY3VyaXR5RXZlbnQ6IGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGxvZ1NlY3VyaXR5RXZlbnQ+XG4gIGxldCBtb2NrQW5hbHl6ZVNlY3VyaXR5UGF0dGVybnM6IGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGFuYWx5emVTZWN1cml0eVBhdHRlcm5zPlxuICBsZXQgbW9ja0dldFNlY3VyaXR5TWV0cmljczogamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZ2V0U2VjdXJpdHlNZXRyaWNzPlxuICBsZXQgbW9ja0dldE1ldHJpY3M6IGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIG1ldHJpY3NDb2xsZWN0b3IuZ2V0TWV0cmljcz5cblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrTG9nU2VjdXJpdHlFdmVudCA9IGxvZ1NlY3VyaXR5RXZlbnQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgbG9nU2VjdXJpdHlFdmVudD5cbiAgICBtb2NrQW5hbHl6ZVNlY3VyaXR5UGF0dGVybnMgPSBhbmFseXplU2VjdXJpdHlQYXR0ZXJucyBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPFxuICAgICAgdHlwZW9mIGFuYWx5emVTZWN1cml0eVBhdHRlcm5zXG4gICAgPlxuICAgIG1vY2tHZXRTZWN1cml0eU1ldHJpY3MgPSBnZXRTZWN1cml0eU1ldHJpY3MgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZ2V0U2VjdXJpdHlNZXRyaWNzPlxuICAgIG1vY2tHZXRNZXRyaWNzID0gbWV0cmljc0NvbGxlY3Rvci5nZXRNZXRyaWNzIGFzIGplc3QuTW9ja2VkRnVuY3Rpb248XG4gICAgICB0eXBlb2YgbWV0cmljc0NvbGxlY3Rvci5nZXRNZXRyaWNzXG4gICAgPlxuXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcblxuICAgIC8vIFNldHVwIGRlZmF1bHQgbW9ja3NcbiAgICBtb2NrTG9nU2VjdXJpdHlFdmVudC5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpXG4gICAgbW9ja0FuYWx5emVTZWN1cml0eVBhdHRlcm5zLm1vY2tSZXNvbHZlZFZhbHVlKFtdKVxuICAgIG1vY2tHZXRTZWN1cml0eU1ldHJpY3MubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgdG90YWxfZXZlbnRzOiAxMDAsXG4gICAgICBjcml0aWNhbF9ldmVudHM6IDUsXG4gICAgICBmYWlsZWRfbG9naW5zOiAxMCxcbiAgICAgIHN1c3BpY2lvdXNfYWN0aXZpdGllczogMyxcbiAgICAgIGJsb2NrZWRfaXBzOiAyLFxuICAgICAgc2VjdXJpdHlfYWxlcnRzOiA4LFxuICAgIH0pXG4gICAgbW9ja0dldE1ldHJpY3MubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHRvdGFsUmVxdWVzdHM6IDEwMDAsXG4gICAgICBhbGxvd2VkUmVxdWVzdHM6IDk1MCxcbiAgICAgIGJsb2NrZWRSZXF1ZXN0czogNTAsXG4gICAgICByZWRpc0hpdHM6IDkwMCxcbiAgICAgIG1lbW9yeUZhbGxiYWNrczogMTAwLFxuICAgICAgZXJyb3JzOiA1LFxuICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogNDUsXG4gICAgICB0b3BCbG9ja2VkSVBzOiBbXG4gICAgICAgIHsgaXA6ICcxOTIuMTY4LjEuMTAwJywgY291bnQ6IDI1IH0sXG4gICAgICAgIHsgaXA6ICcxMC4wLjAuNTAnLCBjb3VudDogMTUgfSxcbiAgICAgIF0sXG4gICAgICB0b3BFbmRwb2ludHM6IFtcbiAgICAgICAgeyBlbmRwb2ludDogJy9hcGkvYWRtaW4nLCBjb3VudDogMzAgfSxcbiAgICAgICAgeyBlbmRwb2ludDogJy9hcGkvcGF5bWVudHMnLCBjb3VudDogMjAgfSxcbiAgICAgIF0sXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnQ29uZmlndXJhY2nDs24gRW50ZXJwcmlzZScsICgpID0+IHtcbiAgICBpdCgnZGViZSB0ZW5lciBjb25maWd1cmFjacOzbiBkZSByZXRlbmNpw7NuIGRlIGRhdG9zJywgKCkgPT4ge1xuICAgICAgZXhwZWN0KEVOVEVSUFJJU0VfQVVESVRfQ09ORklHLkRBVEFfUkVURU5USU9OKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QoRU5URVJQUklTRV9BVURJVF9DT05GSUcuREFUQV9SRVRFTlRJT04uc2VjdXJpdHlfZXZlbnRzKS50b0JlKDM2NSlcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5EQVRBX1JFVEVOVElPTi5hbm9tYWxpZXMpLnRvQmUoMTgwKVxuICAgICAgZXhwZWN0KEVOVEVSUFJJU0VfQVVESVRfQ09ORklHLkRBVEFfUkVURU5USU9OLmluY2lkZW50cykudG9CZSgxMDk1KVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSB0ZW5lciB1bWJyYWxlcyBkZSBkZXRlY2Npw7NuIGNvbmZpZ3VyYWRvcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5ERVRFQ1RJT05fVEhSRVNIT0xEUykudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KEVOVEVSUFJJU0VfQVVESVRfQ09ORklHLkRFVEVDVElPTl9USFJFU0hPTERTLmFub21hbHlfY29uZmlkZW5jZSkudG9CZSgwLjcpXG4gICAgICBleHBlY3QoRU5URVJQUklTRV9BVURJVF9DT05GSUcuREVURUNUSU9OX1RIUkVTSE9MRFMucmlza19zY29yZV9jcml0aWNhbCkudG9CZSg4MClcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgdGVuZXIgY29uZmlndXJhY2nDs24gZGUgYWxlcnRhcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5BTEVSVF9DT05GSUcpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChFTlRFUlBSSVNFX0FVRElUX0NPTkZJRy5BTEVSVF9DT05GSUcuaW1tZWRpYXRlX25vdGlmaWNhdGlvbikudG9Db250YWluKCdjcml0aWNhbCcpXG4gICAgICBleHBlY3QoRU5URVJQUklTRV9BVURJVF9DT05GSUcuQUxFUlRfQ09ORklHLm5vdGlmaWNhdGlvbl9jb29sZG93bikudG9CZSgzMDApXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUmVnaXN0cm8gZGUgRXZlbnRvcyBFbnRlcnByaXNlJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIHJlZ2lzdHJhciBldmVudG8gZW50ZXJwcmlzZSBjb24gY29udGV4dG8gY29tcGxldG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQ29udGV4dDogRW50ZXJwcmlzZUF1dGhDb250ZXh0ID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyXzEyMycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3NfMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcm9sZTogJ2FkbWluJyxcbiAgICAgICAgcGVybWlzc2lvbnM6IFsnYWRtaW5fYWNjZXNzJ10sXG4gICAgICAgIHNlc3Npb25WYWxpZDogdHJ1ZSxcbiAgICAgICAgc2VjdXJpdHlMZXZlbDogJ2hpZ2gnLFxuICAgICAgICBpcEFkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIHVzZXJBZ2VudDogJ3Rlc3QtYWdlbnQnLFxuICAgICAgICBzdXBhYmFzZToge30gYXMgYW55LFxuICAgICAgICB2YWxpZGF0aW9uczoge1xuICAgICAgICAgIGp3dFZhbGlkOiB0cnVlLFxuICAgICAgICAgIGNzcmZWYWxpZDogdHJ1ZSxcbiAgICAgICAgICByYXRlTGltaXRQYXNzZWQ6IHRydWUsXG4gICAgICAgICAgb3JpZ2luVmFsaWQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ3gtZm9yd2FyZGVkLWZvcicsICcxOTIuMTY4LjEuMSddXSksXG4gICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Rlc3QnIH0sXG4gICAgICB9IGFzIGFueVxuXG4gICAgICBjb25zdCBldmVudDogT21pdDxFbnRlcnByaXNlU2VjdXJpdHlFdmVudCwgJ2lkJyB8ICd0aW1lc3RhbXAnIHwgJ3Jlc29sdmVkJz4gPSB7XG4gICAgICAgIHVzZXJfaWQ6ICd1c2VyXzEyMycsXG4gICAgICAgIGV2ZW50X3R5cGU6ICdBVVRIX1NVQ0NFU1MnLFxuICAgICAgICBldmVudF9jYXRlZ29yeTogJ2F1dGhlbnRpY2F0aW9uJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdsb3cnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1VzdWFyaW8gYXV0ZW50aWNhZG8gY29ycmVjdGFtZW50ZScsXG4gICAgICAgIG1ldGFkYXRhOiB7IG1ldGhvZDogJ2NsZXJrJyB9LFxuICAgICAgICBpcF9hZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICB1c2VyX2FnZW50OiAndGVzdC1hZ2VudCcsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSBhd2FpdCBlbnRlcnByaXNlQXVkaXRTeXN0ZW0ubG9nRW50ZXJwcmlzZUV2ZW50KFxuICAgICAgICBldmVudCxcbiAgICAgICAgbW9ja0NvbnRleHQsXG4gICAgICAgIG1vY2tSZXF1ZXN0XG4gICAgICApXG5cbiAgICAgIGV4cGVjdChjb3JyZWxhdGlvbklkKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QoY29ycmVsYXRpb25JZCkudG9NYXRjaCgvXmNvcnJfXFxkK19bYS16MC05XSskLylcbiAgICAgIGV4cGVjdChtb2NrTG9nU2VjdXJpdHlFdmVudCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXZlbnQpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIGNhbGN1bGFyIHJpc2sgc2NvcmUgY29ycmVjdGFtZW50ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNyaXRpY2FsRXZlbnQ6IE9taXQ8RW50ZXJwcmlzZVNlY3VyaXR5RXZlbnQsICdpZCcgfCAndGltZXN0YW1wJyB8ICdyZXNvbHZlZCc+ID0ge1xuICAgICAgICB1c2VyX2lkOiAndXNlcl8xMjMnLFxuICAgICAgICBldmVudF90eXBlOiAnU0VDVVJJVFlfVklPTEFUSU9OJyxcbiAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdzdXNwaWNpb3VzX2JlaGF2aW9yJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVmlvbGFjacOzbiBkZSBzZWd1cmlkYWQgY3LDrXRpY2EnLFxuICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIGlwX2FkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIHVzZXJfYWdlbnQ6ICd0ZXN0LWFnZW50JyxcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29ycmVsYXRpb25JZCA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5sb2dFbnRlcnByaXNlRXZlbnQoY3JpdGljYWxFdmVudClcblxuICAgICAgZXhwZWN0KGNvcnJlbGF0aW9uSWQpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChtb2NrTG9nU2VjdXJpdHlFdmVudCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIG1hbmVqYXIgZXZlbnRvcyBzaW4gY29udGV4dG8gZW50ZXJwcmlzZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50OiBPbWl0PEVudGVycHJpc2VTZWN1cml0eUV2ZW50LCAnaWQnIHwgJ3RpbWVzdGFtcCcgfCAncmVzb2x2ZWQnPiA9IHtcbiAgICAgICAgdXNlcl9pZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgZXZlbnRfdHlwZTogJ0FVVEhfRkFJTFVSRScsXG4gICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnYXV0aGVudGljYXRpb24nLFxuICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRmFsbG8gZGUgYXV0ZW50aWNhY2nDs24nLFxuICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIGlwX2FkZHJlc3M6ICcxOTIuMTY4LjEuMScsXG4gICAgICAgIHVzZXJfYWdlbnQ6ICd0ZXN0LWFnZW50JyxcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29ycmVsYXRpb25JZCA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5sb2dFbnRlcnByaXNlRXZlbnQoZXZlbnQpXG5cbiAgICAgIGV4cGVjdChjb3JyZWxhdGlvbklkKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QobW9ja0xvZ1NlY3VyaXR5RXZlbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV2ZW50KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0RldGVjY2nDs24gZGUgQW5vbWFsw61hcycsICgpID0+IHtcbiAgICBpdCgnZGViZSBkZXRlY3RhciBhbm9tYWzDrWFzIHNpbiBldmVudG9zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYW5vbWFsaWVzID0gYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmRldGVjdEFub21hbGllcygndXNlcl8xMjMnKVxuXG4gICAgICBleHBlY3QoYW5vbWFsaWVzKS50b0VxdWFsKFtdKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBkZXRlY3RhciBwYXRyb25lcyBkZSBsb2dpbiBpbnVzdWFsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGRlIGV2ZW50b3MgcXVlIHNpbXVsYXLDrWFuIHVuIHBhdHLDs24gc29zcGVjaG9zb1xuICAgICAgY29uc3QgbW9ja0V2ZW50czogRW50ZXJwcmlzZVNlY3VyaXR5RXZlbnRbXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnZXZ0XzEnLFxuICAgICAgICAgIHVzZXJfaWQ6ICd1c2VyXzEyMycsXG4gICAgICAgICAgZXZlbnRfdHlwZTogJ0FVVEhfRkFJTFVSRScsXG4gICAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdhdXRoZW50aWNhdGlvbicsXG4gICAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmFsbG8gZGUgYXV0ZW50aWNhY2nDs24nLFxuICAgICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgICBpcF9hZGRyZXNzOiAnMTkyLjE2OC4xLjEnLFxuICAgICAgICAgIHVzZXJfYWdlbnQ6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKERhdGUubm93KCkgLSAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHJlc29sdmVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiAnZXZ0XzInLFxuICAgICAgICAgIHVzZXJfaWQ6ICd1c2VyXzEyMycsXG4gICAgICAgICAgZXZlbnRfdHlwZTogJ0FVVEhfRkFJTFVSRScsXG4gICAgICAgICAgZXZlbnRfY2F0ZWdvcnk6ICdhdXRoZW50aWNhdGlvbicsXG4gICAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmFsbG8gZGUgYXV0ZW50aWNhY2nDs24nLFxuICAgICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgICBpcF9hZGRyZXNzOiAnMTkyLjE2OC4xLjInLFxuICAgICAgICAgIHVzZXJfYWdlbnQ6ICd0ZXN0LWFnZW50JyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKERhdGUubm93KCkgLSA1MDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6ICdldnRfMycsXG4gICAgICAgICAgdXNlcl9pZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgICBldmVudF90eXBlOiAnQVVUSF9TVUNDRVNTJyxcbiAgICAgICAgICBldmVudF9jYXRlZ29yeTogJ2F1dGhlbnRpY2F0aW9uJyxcbiAgICAgICAgICBzZXZlcml0eTogJ2xvdycsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBdXRlbnRpY2FjacOzbiBleGl0b3NhJyxcbiAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgICAgaXBfYWRkcmVzczogJzE5Mi4xNjguMS4zJyxcbiAgICAgICAgICB1c2VyX2FnZW50OiAndGVzdC1hZ2VudCcsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgXVxuXG4gICAgICAvLyBTaW11bGFyIHF1ZSBnZXRSZWNlbnRFdmVudHMgZGV2dWVsdmUgZXN0b3MgZXZlbnRvc1xuICAgICAgamVzdC5zcHlPbihlbnRlcnByaXNlQXVkaXRTeXN0ZW0gYXMgYW55LCAnZ2V0UmVjZW50RXZlbnRzJykubW9ja1Jlc29sdmVkVmFsdWUobW9ja0V2ZW50cylcblxuICAgICAgY29uc3QgYW5vbWFsaWVzID0gYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmRldGVjdEFub21hbGllcygndXNlcl8xMjMnKVxuXG4gICAgICAvLyBEZWJlcsOtYSBkZXRlY3RhciBhbCBtZW5vcyB1bmEgYW5vbWFsw61hIHBvciBlbCBwYXRyw7NuIGRlIG3Dumx0aXBsZXMgZmFsbG9zICsgw6l4aXRvXG4gICAgICBleHBlY3QoYW5vbWFsaWVzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBkZXRlY3RhciBhYnVzbyBkZSByYXRlIGxpbWl0aW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBkZSBtw6l0cmljYXMgY29uIG11Y2hvcyBibG9xdWVvc1xuICAgICAgbW9ja0dldE1ldHJpY3MubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgdG90YWxSZXF1ZXN0czogMTAwMCxcbiAgICAgICAgYWxsb3dlZFJlcXVlc3RzOiA4MDAsXG4gICAgICAgIGJsb2NrZWRSZXF1ZXN0czogMjAwLFxuICAgICAgICByZWRpc0hpdHM6IDkwMCxcbiAgICAgICAgbWVtb3J5RmFsbGJhY2tzOiAxMDAsXG4gICAgICAgIGVycm9yczogNSxcbiAgICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogNDUsXG4gICAgICAgIHRvcEJsb2NrZWRJUHM6IFtcbiAgICAgICAgICB7IGlwOiAnMTkyLjE2OC4xLjEwMCcsIGNvdW50OiA1MCB9LCAvLyBTdXBlcmEgZWwgdW1icmFsIGRlIDEwXG4gICAgICAgICAgeyBpcDogJzEwLjAuMC41MCcsIGNvdW50OiAzMCB9LFxuICAgICAgICBdLFxuICAgICAgICB0b3BFbmRwb2ludHM6IFtdLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgYW5vbWFsaWVzID0gYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmRldGVjdEFub21hbGllcygpXG5cbiAgICAgIC8vIERlYmVyw61hIGRldGVjdGFyIGFub21hbMOtYXMgZGUgcmF0ZSBsaW1pdCBhYnVzZVxuICAgICAgZXhwZWN0KGFub21hbGllcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMClcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgZmlsdHJhciBhbm9tYWzDrWFzIHBvciBjb25maWFuemEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBTaW11bGFyIGRldGVjY2nDs24gY29uIGRpZmVyZW50ZXMgbml2ZWxlcyBkZSBjb25maWFuemFcbiAgICAgIGplc3Quc3B5T24oZW50ZXJwcmlzZUF1ZGl0U3lzdGVtIGFzIGFueSwgJ2dldFJlY2VudEV2ZW50cycpLm1vY2tSZXNvbHZlZFZhbHVlKFtdKVxuXG4gICAgICBjb25zdCBhbm9tYWxpZXMgPSBhd2FpdCBlbnRlcnByaXNlQXVkaXRTeXN0ZW0uZGV0ZWN0QW5vbWFsaWVzKClcblxuICAgICAgLy8gU29sbyBkZWJlcsOtYW4gcmV0b3JuYXJzZSBhbm9tYWzDrWFzIGNvbiBjb25maWFuemEgPj0gMC43XG4gICAgICBhbm9tYWxpZXMuZm9yRWFjaChhbm9tYWx5ID0+IHtcbiAgICAgICAgZXhwZWN0KGFub21hbHkuY29uZmlkZW5jZV9zY29yZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwLjcpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0dlbmVyYWNpw7NuIGRlIFJlcG9ydGVzIEVudGVycHJpc2UnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgZ2VuZXJhciByZXBvcnRlIGVudGVycHJpc2UgY29tcGxldG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQmFzZVJlcG9ydCA9IHtcbiAgICAgICAgcGVyaW9kOiB7IHN0YXJ0OiAnMjAyNS0wMS0wMScsIGVuZDogJzIwMjUtMDEtMzEnIH0sXG4gICAgICAgIHN1bW1hcnk6IHsgdG90YWxfZXZlbnRzOiAxMDAgfSxcbiAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgcGF0dGVybnM6IFtdLFxuICAgICAgICByZWNvbW1lbmRhdGlvbnM6IFtdLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBtb2NrR2VuZXJhdGVTZWN1cml0eVJlcG9ydCA9IGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxcbiAgICAgICAgdHlwZW9mIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnRcbiAgICAgID5cbiAgICAgIG1vY2tHZW5lcmF0ZVNlY3VyaXR5UmVwb3J0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tCYXNlUmVwb3J0KVxuXG4gICAgICBjb25zdCBzdGFydERhdGUgPSAnMjAyNS0wMS0wMVQwMDowMDowMC4wMDBaJ1xuICAgICAgY29uc3QgZW5kRGF0ZSA9ICcyMDI1LTAxLTMxVDIzOjU5OjU5Ljk5OVonXG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5nZW5lcmF0ZUVudGVycHJpc2VSZXBvcnQoXG4gICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgZW5kRGF0ZSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuXG4gICAgICBleHBlY3QocmVwb3J0KS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVwb3J0LmVudGVycHJpc2VfZGF0YSkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlcG9ydC5lbnRlcnByaXNlX2RhdGEuYW5vbWFsaWVzKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QocmVwb3J0LmVudGVycHJpc2VfZGF0YS5pbmNpZGVudHMpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChyZXBvcnQuZW50ZXJwcmlzZV9kYXRhLnJhdGVfbGltaXRpbmdfc3RhdHMpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChtb2NrR2VuZXJhdGVTZWN1cml0eVJlcG9ydCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoc3RhcnREYXRlLCBlbmREYXRlKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBnZW5lcmFyIHJlcG9ydGUgc2luIGFub21hbMOtYXMgZSBpbmNpZGVudGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Jhc2VSZXBvcnQgPSB7XG4gICAgICAgIHBlcmlvZDogeyBzdGFydDogJzIwMjUtMDEtMDEnLCBlbmQ6ICcyMDI1LTAxLTMxJyB9LFxuICAgICAgICBzdW1tYXJ5OiB7IHRvdGFsX2V2ZW50czogNTAgfSxcbiAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgcGF0dGVybnM6IFtdLFxuICAgICAgICByZWNvbW1lbmRhdGlvbnM6IFtdLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBtb2NrR2VuZXJhdGVTZWN1cml0eVJlcG9ydCA9IGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxcbiAgICAgICAgdHlwZW9mIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnRcbiAgICAgID5cbiAgICAgIG1vY2tHZW5lcmF0ZVNlY3VyaXR5UmVwb3J0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tCYXNlUmVwb3J0KVxuXG4gICAgICBjb25zdCBzdGFydERhdGUgPSAnMjAyNS0wMS0wMVQwMDowMDowMC4wMDBaJ1xuICAgICAgY29uc3QgZW5kRGF0ZSA9ICcyMDI1LTAxLTMxVDIzOjU5OjU5Ljk5OVonXG5cbiAgICAgIGNvbnN0IHJlcG9ydCA9IGF3YWl0IGVudGVycHJpc2VBdWRpdFN5c3RlbS5nZW5lcmF0ZUVudGVycHJpc2VSZXBvcnQoXG4gICAgICAgIHN0YXJ0RGF0ZSxcbiAgICAgICAgZW5kRGF0ZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlXG4gICAgICApXG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZW50ZXJwcmlzZV9kYXRhLmFub21hbGllcykudG9FcXVhbChbXSlcbiAgICAgIGV4cGVjdChyZXBvcnQuZW50ZXJwcmlzZV9kYXRhLmluY2lkZW50cykudG9FcXVhbChbXSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdJbnRlZ3JhY2nDs24gY29uIFJhdGUgTGltaXRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgb2J0ZW5lciBlc3RhZMOtc3RpY2FzIGRlIHJhdGUgbGltaXRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0cyA9IChlbnRlcnByaXNlQXVkaXRTeXN0ZW0gYXMgYW55KS5nZXRSYXRlTGltaXRpbmdTdGF0cygpXG5cbiAgICAgIGV4cGVjdChzdGF0cykudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsUmVxdWVzdHMpLnRvQmUoMTAwMClcbiAgICAgIGV4cGVjdChzdGF0cy5ibG9ja2VkUmVxdWVzdHMpLnRvQmUoNTApXG4gICAgICBleHBlY3Qoc3RhdHMudG9wQmxvY2tlZElQcykudG9IYXZlTGVuZ3RoKDIpXG4gICAgICBleHBlY3QobW9ja0dldE1ldHJpY3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBpbmNsdWlyIG3DqXRyaWNhcyBkZSByYXRlIGxpbWl0aW5nIGVuIHJlcG9ydGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Jhc2VSZXBvcnQgPSB7XG4gICAgICAgIHBlcmlvZDogeyBzdGFydDogJzIwMjUtMDEtMDEnLCBlbmQ6ICcyMDI1LTAxLTMxJyB9LFxuICAgICAgICBzdW1tYXJ5OiB7IHRvdGFsX2V2ZW50czogMTAwIH0sXG4gICAgICAgIGV2ZW50czogW10sXG4gICAgICAgIHBhdHRlcm5zOiBbXSxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbXSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgbW9ja0dlbmVyYXRlU2VjdXJpdHlSZXBvcnQgPSBnZW5lcmF0ZVNlY3VyaXR5UmVwb3J0IGFzIGplc3QuTW9ja2VkRnVuY3Rpb248XG4gICAgICAgIHR5cGVvZiBnZW5lcmF0ZVNlY3VyaXR5UmVwb3J0XG4gICAgICA+XG4gICAgICBtb2NrR2VuZXJhdGVTZWN1cml0eVJlcG9ydC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQmFzZVJlcG9ydClcblxuICAgICAgY29uc3QgcmVwb3J0ID0gYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmdlbmVyYXRlRW50ZXJwcmlzZVJlcG9ydChcbiAgICAgICAgJzIwMjUtMDEtMDFUMDA6MDA6MDAuMDAwWicsXG4gICAgICAgICcyMDI1LTAxLTMxVDIzOjU5OjU5Ljk5OVonXG4gICAgICApXG5cbiAgICAgIGV4cGVjdChyZXBvcnQuZW50ZXJwcmlzZV9kYXRhLnJhdGVfbGltaXRpbmdfc3RhdHMpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChyZXBvcnQuZW50ZXJwcmlzZV9kYXRhLnJhdGVfbGltaXRpbmdfc3RhdHMudG90YWxSZXF1ZXN0cykudG9CZSgxMDAwKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0dlc3Rpw7NuIGRlIEluc3RhbmNpYSBTaW5nbGV0b24nLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgcmV0b3JuYXIgbGEgbWlzbWEgaW5zdGFuY2lhJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UxID0gRW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmdldEluc3RhbmNlKClcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IEVudGVycHJpc2VBdWRpdFN5c3RlbS5nZXRJbnN0YW5jZSgpXG5cbiAgICAgIGV4cGVjdChpbnN0YW5jZTEpLnRvQmUoaW5zdGFuY2UyKVxuICAgICAgZXhwZWN0KGluc3RhbmNlMSkudG9CZShlbnRlcnByaXNlQXVkaXRTeXN0ZW0pXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIHBvZGVyIGRlc3RydWlyIGxhIGluc3RhbmNpYScsICgpID0+IHtcbiAgICAgIGNvbnN0IHNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigpXG5cbiAgICAgIGVudGVycHJpc2VBdWRpdFN5c3RlbS5kZXN0cm95KClcblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBzZSBsaW1waWVuIGxvcyBpbnRlcnZhbG9zXG4gICAgICBleHBlY3Qoc3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0Vycm9yJykpXG5cbiAgICAgIHNweS5tb2NrUmVzdG9yZSgpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnTWFuZWpvIGRlIEVycm9yZXMnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgbWFuZWphciBlcnJvcmVzIGVuIHJlZ2lzdHJvIGRlIGV2ZW50b3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrTG9nU2VjdXJpdHlFdmVudC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RhdGFiYXNlIGVycm9yJykpXG5cbiAgICAgIGNvbnN0IGV2ZW50OiBPbWl0PEVudGVycHJpc2VTZWN1cml0eUV2ZW50LCAnaWQnIHwgJ3RpbWVzdGFtcCcgfCAncmVzb2x2ZWQnPiA9IHtcbiAgICAgICAgdXNlcl9pZDogJ3VzZXJfMTIzJyxcbiAgICAgICAgZXZlbnRfdHlwZTogJ0FVVEhfRkFJTFVSRScsXG4gICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnYXV0aGVudGljYXRpb24nLFxuICAgICAgICBzZXZlcml0eTogJ21lZGl1bScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBldmVudCcsXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgaXBfYWRkcmVzczogJzE5Mi4xNjguMS4xJyxcbiAgICAgICAgdXNlcl9hZ2VudDogJ3Rlc3QtYWdlbnQnLFxuICAgICAgfVxuXG4gICAgICBhd2FpdCBleHBlY3QoZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmxvZ0VudGVycHJpc2VFdmVudChldmVudCkpLnJlamVjdHMudG9UaHJvdygpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIG1hbmVqYXIgZXJyb3JlcyBlbiBkZXRlY2Npw7NuIGRlIGFub21hbMOtYXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0XG4gICAgICAgIC5zcHlPbihlbnRlcnByaXNlQXVkaXRTeXN0ZW0gYXMgYW55LCAnZ2V0UmVjZW50RXZlbnRzJylcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgZXJyb3InKSlcblxuICAgICAgY29uc3QgYW5vbWFsaWVzID0gYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmRldGVjdEFub21hbGllcygndXNlcl8xMjMnKVxuXG4gICAgICAvLyBEZWJlIHJldG9ybmFyIGFycmF5IHZhY8OtbyBlbiBjYXNvIGRlIGVycm9yXG4gICAgICBleHBlY3QoYW5vbWFsaWVzKS50b0VxdWFsKFtdKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBtYW5lamFyIGVycm9yZXMgZW4gZ2VuZXJhY2nDs24gZGUgcmVwb3J0ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrR2VuZXJhdGVTZWN1cml0eVJlcG9ydCA9IGdlbmVyYXRlU2VjdXJpdHlSZXBvcnQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjxcbiAgICAgICAgdHlwZW9mIGdlbmVyYXRlU2VjdXJpdHlSZXBvcnRcbiAgICAgID5cbiAgICAgIG1vY2tHZW5lcmF0ZVNlY3VyaXR5UmVwb3J0Lm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignUmVwb3J0IGdlbmVyYXRpb24gZmFpbGVkJykpXG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmdlbmVyYXRlRW50ZXJwcmlzZVJlcG9ydChcbiAgICAgICAgICAnMjAyNS0wMS0wMVQwMDowMDowMC4wMDBaJyxcbiAgICAgICAgICAnMjAyNS0wMS0zMVQyMzo1OTo1OS45OTlaJ1xuICAgICAgICApXG4gICAgICApLnJlamVjdHMudG9UaHJvdygpXG4gICAgfSlcbiAgfSlcbn0pXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJzdXBhYmFzZUFkbWluIiwiZnJvbSIsImZuIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJyYW5nZSIsIm9yZGVyIiwiaW5zZXJ0IiwidXBkYXRlIiwibm90IiwiZmlsdGVyIiwibG9nU2VjdXJpdHlFdmVudCIsImFuYWx5emVTZWN1cml0eVBhdHRlcm5zIiwiZ2V0U2VjdXJpdHlNZXRyaWNzIiwiZ2VuZXJhdGVTZWN1cml0eVJlcG9ydCIsIm1ldHJpY3NDb2xsZWN0b3IiLCJnZXRNZXRyaWNzIiwiZGVzY3JpYmUiLCJtb2NrTG9nU2VjdXJpdHlFdmVudCIsIm1vY2tBbmFseXplU2VjdXJpdHlQYXR0ZXJucyIsIm1vY2tHZXRTZWN1cml0eU1ldHJpY3MiLCJtb2NrR2V0TWV0cmljcyIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJ1bmRlZmluZWQiLCJ0b3RhbF9ldmVudHMiLCJjcml0aWNhbF9ldmVudHMiLCJmYWlsZWRfbG9naW5zIiwic3VzcGljaW91c19hY3Rpdml0aWVzIiwiYmxvY2tlZF9pcHMiLCJzZWN1cml0eV9hbGVydHMiLCJtb2NrUmV0dXJuVmFsdWUiLCJ0b3RhbFJlcXVlc3RzIiwiYWxsb3dlZFJlcXVlc3RzIiwiYmxvY2tlZFJlcXVlc3RzIiwicmVkaXNIaXRzIiwibWVtb3J5RmFsbGJhY2tzIiwiZXJyb3JzIiwiYXZlcmFnZVJlc3BvbnNlVGltZSIsInRvcEJsb2NrZWRJUHMiLCJpcCIsImNvdW50IiwidG9wRW5kcG9pbnRzIiwiZW5kcG9pbnQiLCJpdCIsImV4cGVjdCIsIkVOVEVSUFJJU0VfQVVESVRfQ09ORklHIiwiREFUQV9SRVRFTlRJT04iLCJ0b0JlRGVmaW5lZCIsInNlY3VyaXR5X2V2ZW50cyIsInRvQmUiLCJhbm9tYWxpZXMiLCJpbmNpZGVudHMiLCJERVRFQ1RJT05fVEhSRVNIT0xEUyIsImFub21hbHlfY29uZmlkZW5jZSIsInJpc2tfc2NvcmVfY3JpdGljYWwiLCJBTEVSVF9DT05GSUciLCJpbW1lZGlhdGVfbm90aWZpY2F0aW9uIiwidG9Db250YWluIiwibm90aWZpY2F0aW9uX2Nvb2xkb3duIiwibW9ja0NvbnRleHQiLCJ1c2VySWQiLCJzZXNzaW9uSWQiLCJlbWFpbCIsInJvbGUiLCJwZXJtaXNzaW9ucyIsInNlc3Npb25WYWxpZCIsInNlY3VyaXR5TGV2ZWwiLCJpcEFkZHJlc3MiLCJ1c2VyQWdlbnQiLCJzdXBhYmFzZSIsInZhbGlkYXRpb25zIiwiand0VmFsaWQiLCJjc3JmVmFsaWQiLCJyYXRlTGltaXRQYXNzZWQiLCJvcmlnaW5WYWxpZCIsIm1vY2tSZXF1ZXN0IiwiaGVhZGVycyIsIk1hcCIsIm5leHRVcmwiLCJwYXRobmFtZSIsImV2ZW50IiwidXNlcl9pZCIsImV2ZW50X3R5cGUiLCJldmVudF9jYXRlZ29yeSIsInNldmVyaXR5IiwiZGVzY3JpcHRpb24iLCJtZXRhZGF0YSIsIm1ldGhvZCIsImlwX2FkZHJlc3MiLCJ1c2VyX2FnZW50IiwiY29ycmVsYXRpb25JZCIsImVudGVycHJpc2VBdWRpdFN5c3RlbSIsImxvZ0VudGVycHJpc2VFdmVudCIsInRvTWF0Y2giLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImNyaXRpY2FsRXZlbnQiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiZGV0ZWN0QW5vbWFsaWVzIiwidG9FcXVhbCIsIm1vY2tFdmVudHMiLCJpZCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJ0b0lTT1N0cmluZyIsInJlc29sdmVkIiwic3B5T24iLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwiZm9yRWFjaCIsImFub21hbHkiLCJjb25maWRlbmNlX3Njb3JlIiwibW9ja0Jhc2VSZXBvcnQiLCJwZXJpb2QiLCJzdGFydCIsImVuZCIsInN1bW1hcnkiLCJldmVudHMiLCJwYXR0ZXJucyIsInJlY29tbWVuZGF0aW9ucyIsIm1vY2tHZW5lcmF0ZVNlY3VyaXR5UmVwb3J0Iiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInJlcG9ydCIsImdlbmVyYXRlRW50ZXJwcmlzZVJlcG9ydCIsImVudGVycHJpc2VfZGF0YSIsInJhdGVfbGltaXRpbmdfc3RhdHMiLCJzdGF0cyIsImdldFJhdGVMaW1pdGluZ1N0YXRzIiwidG9IYXZlTGVuZ3RoIiwiaW5zdGFuY2UxIiwiRW50ZXJwcmlzZUF1ZGl0U3lzdGVtIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZTIiLCJzcHkiLCJjb25zb2xlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZGVzdHJveSIsInN0cmluZ0NvbnRhaW5pbmciLCJtb2NrUmVzdG9yZSIsIm1vY2tSZWplY3RlZFZhbHVlIiwi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