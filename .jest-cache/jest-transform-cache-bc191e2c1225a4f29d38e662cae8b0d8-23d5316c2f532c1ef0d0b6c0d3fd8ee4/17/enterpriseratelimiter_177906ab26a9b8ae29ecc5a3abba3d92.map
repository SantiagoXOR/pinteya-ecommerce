{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\rate-limiting\\enterprise-rate-limiter.ts"],"sourcesContent":["/**\r\n * Sistema Enterprise de Rate Limiting\r\n * Unifica todas las implementaciones de rate limiting con Redis y fallback en memoria\r\n */\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport type { NextApiRequest } from 'next';\r\nimport { isRedisAvailable, enterpriseRateLimit } from '@/lib/integrations/redis';\r\n\r\n// =====================================================\r\n// TIPOS Y INTERFACES\r\n// =====================================================\r\n\r\nexport interface EnterpriseRateLimitConfig {\r\n  windowMs: number;\r\n  maxRequests: number;\r\n  message?: string;\r\n  keyGenerator?: (request: NextRequest | NextApiRequest) => string;\r\n  skipSuccessfulRequests?: boolean;\r\n  skipFailedRequests?: boolean;\r\n  enableRedis?: boolean;\r\n  enableMemoryFallback?: boolean;\r\n  enableMetrics?: boolean;\r\n  enableLogging?: boolean;\r\n  customHeaders?: Record<string, string>;\r\n  onLimitReached?: (key: string, request: NextRequest | NextApiRequest) => void;\r\n}\r\n\r\nexport interface EnterpriseRateLimitResult {\r\n  allowed: boolean;\r\n  limit: number;\r\n  remaining: number;\r\n  resetTime: number;\r\n  retryAfter?: number;\r\n  error?: string;\r\n  code?: string;\r\n  source: 'redis' | 'memory' | 'error';\r\n  metrics?: {\r\n    responseTime: number;\r\n    cacheHit: boolean;\r\n    keyGenerated: string;\r\n  };\r\n}\r\n\r\nexport interface RateLimitMetrics {\r\n  totalRequests: number;\r\n  allowedRequests: number;\r\n  blockedRequests: number;\r\n  redisHits: number;\r\n  memoryFallbacks: number;\r\n  errors: number;\r\n  averageResponseTime: number;\r\n  topBlockedIPs: Array<{ ip: string; count: number }>;\r\n  topEndpoints: Array<{ endpoint: string; count: number }>;\r\n}\r\n\r\n// =====================================================\r\n// CONFIGURACIONES PREDEFINIDAS ENTERPRISE\r\n// =====================================================\r\n\r\nexport const ENTERPRISE_RATE_LIMIT_CONFIGS: Record<string, EnterpriseRateLimitConfig> = {\r\n  // Autenticación crítica\r\n  CRITICAL_AUTH: {\r\n    windowMs: 15 * 60 * 1000, // 15 minutos\r\n    maxRequests: 3, // 3 intentos por 15 minutos\r\n    message: 'Demasiados intentos de autenticación crítica. Intenta en 15 minutos.',\r\n    enableRedis: true,\r\n    enableMetrics: true,\r\n    enableLogging: true\r\n  },\r\n\r\n  // Admin APIs\r\n  ADMIN_API: {\r\n    windowMs: 5 * 60 * 1000, // 5 minutos\r\n    maxRequests: 50, // 50 requests por 5 minutos\r\n    message: 'Límite de requests administrativas excedido. Intenta en 5 minutos.',\r\n    enableRedis: true,\r\n    enableMetrics: true,\r\n    enableLogging: true\r\n  },\r\n\r\n  // APIs de pagos\r\n  PAYMENT_API: {\r\n    windowMs: 10 * 60 * 1000, // 10 minutos\r\n    maxRequests: 15, // 15 requests por 10 minutos\r\n    message: 'Límite de requests de pagos excedido. Intenta en 10 minutos.',\r\n    enableRedis: true,\r\n    enableMetrics: true,\r\n    enableLogging: true,\r\n    onLimitReached: (key, request) => {\r\n      console.warn(`[PAYMENT_RATE_LIMIT] Límite excedido para ${key}`);\r\n    }\r\n  },\r\n\r\n  // APIs públicas de productos\r\n  PUBLIC_API: {\r\n    windowMs: 1 * 60 * 1000, // 1 minuto\r\n    maxRequests: 100, // 100 requests por minuto\r\n    message: 'Límite de requests públicas excedido. Intenta en 1 minuto.',\r\n    enableRedis: true,\r\n    enableMetrics: true,\r\n    enableLogging: false // No loggear APIs públicas\r\n  },\r\n\r\n  // Webhooks\r\n  WEBHOOK_API: {\r\n    windowMs: 1 * 60 * 1000, // 1 minuto\r\n    maxRequests: 200, // 200 webhooks por minuto\r\n    message: 'Límite de webhooks excedido.',\r\n    enableRedis: true,\r\n    enableMetrics: true,\r\n    enableLogging: true\r\n  },\r\n\r\n  // Búsquedas y consultas\r\n  SEARCH_API: {\r\n    windowMs: 1 * 60 * 1000, // 1 minuto\r\n    maxRequests: 60, // 60 búsquedas por minuto\r\n    message: 'Límite de búsquedas excedido. Intenta en 1 minuto.',\r\n    enableRedis: true,\r\n    enableMetrics: true,\r\n    enableLogging: false\r\n  },\r\n\r\n  // Upload de archivos\r\n  UPLOAD_API: {\r\n    windowMs: 5 * 60 * 1000, // 5 minutos\r\n    maxRequests: 10, // 10 uploads por 5 minutos\r\n    message: 'Límite de uploads excedido. Intenta en 5 minutos.',\r\n    enableRedis: true,\r\n    enableMetrics: true,\r\n    enableLogging: true\r\n  },\r\n\r\n  // APIs de desarrollo/debug\r\n  DEBUG_API: {\r\n    windowMs: 1 * 60 * 1000, // 1 minuto\r\n    maxRequests: 30, // 30 requests por minuto\r\n    message: 'Límite de debug APIs excedido.',\r\n    enableRedis: false, // Usar memoria para debug\r\n    enableMetrics: true,\r\n    enableLogging: true\r\n  }\r\n};\r\n\r\n// =====================================================\r\n// GENERADORES DE CLAVES\r\n// =====================================================\r\n\r\n/**\r\n * Generador de clave por IP\r\n */\r\nexport function ipKeyGenerator(request: NextRequest | NextApiRequest): string {\r\n  const ip = getClientIP(request);\r\n  return `ip:${ip}`;\r\n}\r\n\r\n/**\r\n * Generador de clave por usuario autenticado\r\n */\r\nexport function userKeyGenerator(request: NextRequest | NextApiRequest): string {\r\n  // Intentar obtener user ID de diferentes fuentes\r\n  const userId = getUserId(request);\r\n  const ip = getClientIP(request);\r\n  \r\n  return userId ? `user:${userId}` : `ip:${ip}`;\r\n}\r\n\r\n/**\r\n * Generador de clave por endpoint\r\n */\r\nexport function endpointKeyGenerator(request: NextRequest | NextApiRequest): string {\r\n  const ip = getClientIP(request);\r\n  const endpoint = getEndpoint(request);\r\n  \r\n  return `endpoint:${ip}:${endpoint}`;\r\n}\r\n\r\n/**\r\n * Generador de clave híbrido (usuario + endpoint)\r\n */\r\nexport function hybridKeyGenerator(request: NextRequest | NextApiRequest): string {\r\n  const userId = getUserId(request);\r\n  const ip = getClientIP(request);\r\n  const endpoint = getEndpoint(request);\r\n  \r\n  const userPart = userId ? `user:${userId}` : `ip:${ip}`;\r\n  return `${userPart}:${endpoint}`;\r\n}\r\n\r\n// =====================================================\r\n// UTILIDADES\r\n// =====================================================\r\n\r\n/**\r\n * Obtiene la IP del cliente\r\n */\r\nfunction getClientIP(request: NextRequest | NextApiRequest): string {\r\n  // Intentar diferentes headers de IP\r\n  const headers = [\r\n    'x-forwarded-for',\r\n    'x-real-ip',\r\n    'x-client-ip',\r\n    'cf-connecting-ip'\r\n  ];\r\n\r\n  for (const header of headers) {\r\n    let ip: string | null = null;\r\n    \r\n    if ('headers' in request && typeof request.headers.get === 'function') {\r\n      // NextRequest\r\n      ip = (request as NextRequest).headers.get(header);\r\n    } else if ('headers' in request) {\r\n      // NextApiRequest\r\n      const headerValue = (request as NextApiRequest).headers[header];\r\n      ip = Array.isArray(headerValue) ? headerValue[0] : headerValue || null;\r\n    }\r\n\r\n    if (ip) {\r\n      // Tomar la primera IP si hay múltiples\r\n      return ip.split(',')[0].trim();\r\n    }\r\n  }\r\n\r\n  return 'unknown';\r\n}\r\n\r\n/**\r\n * Obtiene el ID del usuario autenticado\r\n */\r\nfunction getUserId(request: NextRequest | NextApiRequest): string | null {\r\n  // Intentar obtener de diferentes fuentes\r\n  \r\n  // 1. Headers de Clerk\r\n  let userId: string | null = null;\r\n  \r\n  if ('headers' in request && typeof request.headers.get === 'function') {\r\n    // NextRequest\r\n    userId = (request as NextRequest).headers.get('x-clerk-user-id');\r\n  } else if ('headers' in request) {\r\n    // NextApiRequest\r\n    const headerValue = (request as NextApiRequest).headers['x-clerk-user-id'];\r\n    userId = Array.isArray(headerValue) ? headerValue[0] : headerValue || null;\r\n  }\r\n\r\n  // 2. Contexto enterprise si está disponible\r\n  if (!userId && (request as any).enterpriseAuth?.userId) {\r\n    userId = (request as any).enterpriseAuth.userId;\r\n  }\r\n\r\n  // 3. Contexto de autenticación si está disponible\r\n  if (!userId && (request as any).auth?.userId) {\r\n    userId = (request as any).auth.userId;\r\n  }\r\n\r\n  return userId;\r\n}\r\n\r\n/**\r\n * Obtiene el endpoint de la request\r\n */\r\nfunction getEndpoint(request: NextRequest | NextApiRequest): string {\r\n  if ('nextUrl' in request) {\r\n    // NextRequest\r\n    return (request as NextRequest).nextUrl.pathname;\r\n  } else if ('url' in request) {\r\n    // NextApiRequest\r\n    try {\r\n      const url = new URL((request as NextApiRequest).url || '', 'http://localhost');\r\n      return url.pathname;\r\n    } catch {\r\n      return '/unknown';\r\n    }\r\n  }\r\n  \r\n  return '/unknown';\r\n}\r\n\r\n// =====================================================\r\n// STORE EN MEMORIA (FALLBACK)\r\n// =====================================================\r\n\r\ninterface MemoryRateLimitEntry {\r\n  count: number;\r\n  resetTime: number;\r\n  firstRequest: number;\r\n}\r\n\r\nclass MemoryRateLimitStore {\r\n  private store = new Map<string, MemoryRateLimitEntry>();\r\n  private cleanupInterval: NodeJS.Timeout;\r\n\r\n  constructor() {\r\n    // Limpiar entradas expiradas cada 5 minutos\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanup();\r\n    }, 5 * 60 * 1000);\r\n  }\r\n\r\n  get(key: string): MemoryRateLimitEntry | null {\r\n    const entry = this.store.get(key);\r\n    \r\n    if (!entry) {\r\n      return null;\r\n    }\r\n\r\n    // Verificar si ha expirado\r\n    if (Date.now() > entry.resetTime) {\r\n      this.store.delete(key);\r\n      return null;\r\n    }\r\n\r\n    return entry;\r\n  }\r\n\r\n  set(key: string, entry: MemoryRateLimitEntry): void {\r\n    this.store.set(key, entry);\r\n  }\r\n\r\n  increment(key: string): number {\r\n    const entry = this.get(key);\r\n    if (entry) {\r\n      entry.count++;\r\n      this.set(key, entry);\r\n      return entry.count;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private cleanup(): void {\r\n    const now = Date.now();\r\n    let cleaned = 0;\r\n\r\n    for (const [key, entry] of this.store.entries()) {\r\n      if (now > entry.resetTime) {\r\n        this.store.delete(key);\r\n        cleaned++;\r\n      }\r\n    }\r\n\r\n    if (cleaned > 0) {\r\n      console.log(`[MEMORY_RATE_LIMIT] Limpiadas ${cleaned} entradas expiradas`);\r\n    }\r\n  }\r\n\r\n  getStats(): { entries: number; memoryUsage: number } {\r\n    const entries = this.store.size;\r\n    const memoryUsage = JSON.stringify([...this.store.entries()]).length;\r\n\r\n    return { entries, memoryUsage };\r\n  }\r\n\r\n  clear(): void {\r\n    this.store.clear();\r\n  }\r\n\r\n  destroy(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n    this.store.clear();\r\n  }\r\n}\r\n\r\n// Instancia global del store en memoria\r\nconst memoryStore = new MemoryRateLimitStore();\r\n\r\n// =====================================================\r\n// MÉTRICAS GLOBALES\r\n// =====================================================\r\n\r\nclass RateLimitMetricsCollector {\r\n  private metrics: RateLimitMetrics = {\r\n    totalRequests: 0,\r\n    allowedRequests: 0,\r\n    blockedRequests: 0,\r\n    redisHits: 0,\r\n    memoryFallbacks: 0,\r\n    errors: 0,\r\n    averageResponseTime: 0,\r\n    topBlockedIPs: [],\r\n    topEndpoints: []\r\n  };\r\n\r\n  private responseTimes: number[] = [];\r\n  private blockedIPs = new Map<string, number>();\r\n  private endpointCounts = new Map<string, number>();\r\n\r\n  recordRequest(result: EnterpriseRateLimitResult, ip: string, endpoint: string): void {\r\n    this.metrics.totalRequests++;\r\n\r\n    if (result.allowed) {\r\n      this.metrics.allowedRequests++;\r\n    } else {\r\n      this.metrics.blockedRequests++;\r\n      \r\n      // Registrar IP bloqueada\r\n      const currentCount = this.blockedIPs.get(ip) || 0;\r\n      this.blockedIPs.set(ip, currentCount + 1);\r\n    }\r\n\r\n    // Registrar fuente\r\n    if (result.source === 'redis') {\r\n      this.metrics.redisHits++;\r\n    } else if (result.source === 'memory') {\r\n      this.metrics.memoryFallbacks++;\r\n    } else if (result.source === 'error') {\r\n      this.metrics.errors++;\r\n    }\r\n\r\n    // Registrar tiempo de respuesta\r\n    if (result.metrics?.responseTime) {\r\n      this.responseTimes.push(result.metrics.responseTime);\r\n      \r\n      // Mantener solo los últimos 1000 tiempos\r\n      if (this.responseTimes.length > 1000) {\r\n        this.responseTimes = this.responseTimes.slice(-1000);\r\n      }\r\n\r\n      // Calcular promedio\r\n      this.metrics.averageResponseTime = \r\n        this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length;\r\n    }\r\n\r\n    // Registrar endpoint\r\n    const endpointCount = this.endpointCounts.get(endpoint) || 0;\r\n    this.endpointCounts.set(endpoint, endpointCount + 1);\r\n\r\n    // Actualizar tops\r\n    this.updateTopLists();\r\n  }\r\n\r\n  private updateTopLists(): void {\r\n    // Top IPs bloqueadas\r\n    this.metrics.topBlockedIPs = Array.from(this.blockedIPs.entries())\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 10)\r\n      .map(([ip, count]) => ({ ip, count }));\r\n\r\n    // Top endpoints\r\n    this.metrics.topEndpoints = Array.from(this.endpointCounts.entries())\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, 10)\r\n      .map(([endpoint, count]) => ({ endpoint, count }));\r\n  }\r\n\r\n  getMetrics(): RateLimitMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  reset(): void {\r\n    this.metrics = {\r\n      totalRequests: 0,\r\n      allowedRequests: 0,\r\n      blockedRequests: 0,\r\n      redisHits: 0,\r\n      memoryFallbacks: 0,\r\n      errors: 0,\r\n      averageResponseTime: 0,\r\n      topBlockedIPs: [],\r\n      topEndpoints: []\r\n    };\r\n    this.responseTimes = [];\r\n    this.blockedIPs.clear();\r\n    this.endpointCounts.clear();\r\n  }\r\n}\r\n\r\n// Instancia global del collector de métricas\r\nconst metricsCollector = new RateLimitMetricsCollector();\r\n\r\n// Exportar para uso externo\r\nexport { memoryStore, metricsCollector };\r\n\r\n// =====================================================\r\n// IMPLEMENTACIÓN REDIS\r\n// =====================================================\r\n\r\n// Función isRedisAvailable ahora se importa desde @/lib/redis\r\n\r\n/**\r\n * Rate limiting con Redis\r\n */\r\nasync function rateLimitWithRedis(\r\n  key: string,\r\n  config: EnterpriseRateLimitConfig\r\n): Promise<EnterpriseRateLimitResult> {\r\n  const startTime = Date.now();\r\n\r\n  try {\r\n    // Usar la función importada de Redis\r\n    const result = await enterpriseRateLimit(key, config);\r\n\r\n    if (result) {\r\n      return {\r\n        allowed: result.allowed,\r\n        limit: result.limit || config.maxRequests,\r\n        remaining: result.remaining || 0,\r\n        resetTime: result.resetTime || Date.now() + config.windowMs,\r\n        retryAfter: result.allowed ? undefined : Math.ceil(config.windowMs / 1000),\r\n        source: 'redis',\r\n        metrics: {\r\n          responseTime: Date.now() - startTime,\r\n          cacheHit: true,\r\n          keyGenerated: key\r\n        }\r\n      };\r\n    }\r\n\r\n    // Si no hay resultado, usar implementación manual\r\n    const { redis } = await import('@/lib/redis');\r\n    const now = Date.now();\r\n    const window = Math.floor(now / config.windowMs);\r\n    const redisKey = `rate_limit:${key}:${window}`;\r\n\r\n    // Usar pipeline para operaciones atómicas\r\n    const pipeline = redis.pipeline();\r\n    pipeline.incr(redisKey);\r\n    pipeline.expire(redisKey, Math.ceil(config.windowMs / 1000));\r\n\r\n    const results = await pipeline.exec();\r\n    const count = results?.[0]?.[1] as number || 1;\r\n\r\n    const remaining = Math.max(0, config.maxRequests - count);\r\n    const resetTime = (window + 1) * config.windowMs;\r\n    const allowed = count <= config.maxRequests;\r\n\r\n    return {\r\n      allowed,\r\n      limit: config.maxRequests,\r\n      remaining,\r\n      resetTime,\r\n      retryAfter: allowed ? undefined : Math.ceil((resetTime - now) / 1000),\r\n      source: 'redis',\r\n      metrics: {\r\n        responseTime: Date.now() - startTime,\r\n        cacheHit: true,\r\n        keyGenerated: redisKey\r\n      }\r\n    };\r\n  } catch (error) {\r\n    console.error('[RATE_LIMIT] Error en Redis:', error);\r\n\r\n    // Fallback a memoria en caso de error\r\n    return rateLimitWithMemory(key, config);\r\n  }\r\n}\r\n\r\n/**\r\n * Rate limiting con memoria (fallback)\r\n */\r\nfunction rateLimitWithMemory(\r\n  key: string,\r\n  config: EnterpriseRateLimitConfig\r\n): EnterpriseRateLimitResult {\r\n  const startTime = Date.now();\r\n  const now = Date.now();\r\n\r\n  let entry = memoryStore.get(key);\r\n\r\n  if (!entry) {\r\n    // Primera request en esta ventana\r\n    entry = {\r\n      count: 1,\r\n      resetTime: now + config.windowMs,\r\n      firstRequest: now\r\n    };\r\n    memoryStore.set(key, entry);\r\n\r\n    return {\r\n      allowed: true,\r\n      limit: config.maxRequests,\r\n      remaining: config.maxRequests - 1,\r\n      resetTime: entry.resetTime,\r\n      source: 'memory',\r\n      metrics: {\r\n        responseTime: Date.now() - startTime,\r\n        cacheHit: false,\r\n        keyGenerated: key\r\n      }\r\n    };\r\n  }\r\n\r\n  // Incrementar contador\r\n  entry.count++;\r\n  memoryStore.set(key, entry);\r\n\r\n  const allowed = entry.count <= config.maxRequests;\r\n  const remaining = Math.max(0, config.maxRequests - entry.count);\r\n\r\n  return {\r\n    allowed,\r\n    limit: config.maxRequests,\r\n    remaining,\r\n    resetTime: entry.resetTime,\r\n    retryAfter: allowed ? undefined : Math.ceil((entry.resetTime - now) / 1000),\r\n    source: 'memory',\r\n    metrics: {\r\n      responseTime: Date.now() - startTime,\r\n      cacheHit: true,\r\n      keyGenerated: key\r\n    }\r\n  };\r\n}\r\n\r\n// =====================================================\r\n// FUNCIÓN PRINCIPAL DE RATE LIMITING\r\n// =====================================================\r\n\r\n/**\r\n * Función principal de rate limiting enterprise\r\n */\r\nexport async function checkEnterpriseRateLimit(\r\n  request: NextRequest | NextApiRequest,\r\n  configName: keyof typeof ENTERPRISE_RATE_LIMIT_CONFIGS,\r\n  customConfig?: Partial<EnterpriseRateLimitConfig>\r\n): Promise<EnterpriseRateLimitResult> {\r\n  const baseConfig = ENTERPRISE_RATE_LIMIT_CONFIGS[configName];\r\n\r\n  if (!baseConfig) {\r\n    return {\r\n      allowed: true,\r\n      limit: 1000,\r\n      remaining: 999,\r\n      resetTime: Date.now() + 60000,\r\n      error: `Configuración '${configName}' no encontrada`,\r\n      code: 'CONFIG_NOT_FOUND',\r\n      source: 'error'\r\n    };\r\n  }\r\n\r\n  const config = { ...baseConfig, ...customConfig };\r\n  const keyGenerator = config.keyGenerator || hybridKeyGenerator;\r\n  const key = keyGenerator(request);\r\n\r\n  let result: EnterpriseRateLimitResult;\r\n\r\n  try {\r\n    // Intentar Redis primero si está habilitado\r\n    if (config.enableRedis !== false && await isRedisAvailable()) {\r\n      result = await rateLimitWithRedis(key, config);\r\n    } else {\r\n      result = rateLimitWithMemory(key, config);\r\n    }\r\n\r\n    // Registrar métricas si está habilitado\r\n    if (config.enableMetrics) {\r\n      const ip = getClientIP(request);\r\n      const endpoint = getEndpoint(request);\r\n      metricsCollector.recordRequest(result, ip, endpoint);\r\n    }\r\n\r\n    // Logging si está habilitado\r\n    if (config.enableLogging) {\r\n      if (!result.allowed) {\r\n        console.warn(`[RATE_LIMIT] Límite excedido para ${key}: ${result.remaining}/${result.limit}`);\r\n\r\n        // Callback personalizado si está definido\r\n        if (config.onLimitReached) {\r\n          config.onLimitReached(key, request);\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    console.error('[RATE_LIMIT] Error en checkEnterpriseRateLimit:', error);\r\n\r\n    return {\r\n      allowed: true, // Permitir en caso de error\r\n      limit: config.maxRequests,\r\n      remaining: config.maxRequests,\r\n      resetTime: Date.now() + config.windowMs,\r\n      error: 'Error interno en rate limiting',\r\n      code: 'INTERNAL_ERROR',\r\n      source: 'error'\r\n    };\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":["ENTERPRISE_RATE_LIMIT_CONFIGS","checkEnterpriseRateLimit","endpointKeyGenerator","hybridKeyGenerator","ipKeyGenerator","memoryStore","metricsCollector","userKeyGenerator","CRITICAL_AUTH","windowMs","maxRequests","message","enableRedis","enableMetrics","enableLogging","ADMIN_API","PAYMENT_API","onLimitReached","key","request","console","warn","PUBLIC_API","WEBHOOK_API","SEARCH_API","UPLOAD_API","DEBUG_API","ip","getClientIP","userId","getUserId","endpoint","getEndpoint","userPart","headers","header","get","headerValue","Array","isArray","split","trim","enterpriseAuth","auth","nextUrl","pathname","url","URL","MemoryRateLimitStore","store","Map","cleanupInterval","setInterval","cleanup","entry","Date","now","resetTime","delete","set","increment","count","cleaned","entries","log","getStats","size","memoryUsage","JSON","stringify","length","clear","destroy","clearInterval","RateLimitMetricsCollector","recordRequest","result","metrics","totalRequests","allowed","allowedRequests","blockedRequests","currentCount","blockedIPs","source","redisHits","memoryFallbacks","errors","responseTime","responseTimes","push","slice","averageResponseTime","reduce","a","b","endpointCount","endpointCounts","updateTopLists","topBlockedIPs","from","sort","map","topEndpoints","getMetrics","reset","rateLimitWithRedis","config","startTime","enterpriseRateLimit","limit","remaining","retryAfter","undefined","Math","ceil","cacheHit","keyGenerated","redis","window","floor","redisKey","pipeline","incr","expire","results","exec","max","error","rateLimitWithMemory","firstRequest","configName","customConfig","baseConfig","code","keyGenerator","isRedisAvailable"],"mappings":"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"}