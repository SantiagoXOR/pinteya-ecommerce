{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\retry-logic.ts"],"sourcesContent":["// ===================================\r\n// PINTEYA E-COMMERCE - RETRY LOGIC WITH EXPONENTIAL BACKOFF\r\n// ===================================\r\n\r\nimport { logger, LogLevel, LogCategory } from './enterprise/logger';\r\nimport { metricsCollector } from './enterprise/metrics';\r\n\r\n// Configuración de retry\r\nexport interface RetryConfig {\r\n  maxRetries: number;           // Máximo número de reintentos\r\n  baseDelayMs: number;          // Delay base en milisegundos\r\n  maxDelayMs: number;           // Delay máximo en milisegundos\r\n  backoffMultiplier: number;    // Multiplicador para backoff exponencial\r\n  jitterMs: number;             // Jitter máximo en milisegundos\r\n  retryableErrors: string[];    // Códigos de error que permiten retry\r\n  nonRetryableErrors: string[]; // Códigos de error que NO permiten retry\r\n}\r\n\r\n// Configuraciones predefinidas\r\nexport const RETRY_CONFIGS: Record<string, RetryConfig> = {\r\n  // Para llamadas críticas a MercadoPago\r\n  MERCADOPAGO_CRITICAL: {\r\n    maxRetries: 3,\r\n    baseDelayMs: 1000,        // 1 segundo\r\n    maxDelayMs: 30000,        // 30 segundos\r\n    backoffMultiplier: 2,\r\n    jitterMs: 500,\r\n    retryableErrors: [\r\n      'ECONNRESET',\r\n      'ENOTFOUND',\r\n      'ECONNREFUSED',\r\n      'ETIMEDOUT',\r\n      'NETWORK_ERROR',\r\n      'TIMEOUT',\r\n      '500',\r\n      '502',\r\n      '503',\r\n      '504',\r\n      '429'  // Rate limit - retry después de delay\r\n    ],\r\n    nonRetryableErrors: [\r\n      '400',  // Bad Request\r\n      '401',  // Unauthorized\r\n      '403',  // Forbidden\r\n      '404',  // Not Found\r\n      '422',  // Unprocessable Entity\r\n      'INVALID_CREDENTIALS',\r\n      'INVALID_REQUEST',\r\n      'PAYMENT_REJECTED'\r\n    ]\r\n  },\r\n\r\n  // Para operaciones de consulta menos críticas\r\n  MERCADOPAGO_QUERY: {\r\n    maxRetries: 2,\r\n    baseDelayMs: 500,         // 0.5 segundos\r\n    maxDelayMs: 10000,        // 10 segundos\r\n    backoffMultiplier: 2,\r\n    jitterMs: 250,\r\n    retryableErrors: [\r\n      'ECONNRESET',\r\n      'ENOTFOUND',\r\n      'ETIMEDOUT',\r\n      '500',\r\n      '502',\r\n      '503',\r\n      '504'\r\n    ],\r\n    nonRetryableErrors: [\r\n      '400',\r\n      '401',\r\n      '403',\r\n      '404',\r\n      '422'\r\n    ]\r\n  },\r\n\r\n  // Para webhooks (menos agresivo)\r\n  WEBHOOK_PROCESSING: {\r\n    maxRetries: 1,\r\n    baseDelayMs: 2000,        // 2 segundos\r\n    maxDelayMs: 5000,         // 5 segundos\r\n    backoffMultiplier: 1.5,\r\n    jitterMs: 1000,\r\n    retryableErrors: [\r\n      'ECONNRESET',\r\n      'ETIMEDOUT',\r\n      '500',\r\n      '503'\r\n    ],\r\n    nonRetryableErrors: [\r\n      '400',\r\n      '401',\r\n      '403',\r\n      '404',\r\n      '422',\r\n      'DUPLICATE_WEBHOOK'\r\n    ]\r\n  }\r\n} as const;\r\n\r\n// Resultado del retry\r\nexport interface RetryResult<T> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: Error;\r\n  attempts: number;\r\n  totalDuration: number;\r\n  lastAttemptDuration: number;\r\n}\r\n\r\n// Información del intento\r\nexport interface AttemptInfo {\r\n  attempt: number;\r\n  maxRetries: number;\r\n  delay: number;\r\n  error?: Error;\r\n  duration: number;\r\n}\r\n\r\n/**\r\n * Calcula el delay para el siguiente intento usando backoff exponencial con jitter\r\n */\r\nfunction calculateDelay(\r\n  attempt: number, \r\n  config: RetryConfig\r\n): number {\r\n  // Backoff exponencial: baseDelay * (multiplier ^ attempt)\r\n  const exponentialDelay = config.baseDelayMs * Math.pow(config.backoffMultiplier, attempt);\r\n  \r\n  // Aplicar límite máximo\r\n  const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs);\r\n  \r\n  // Agregar jitter aleatorio para evitar thundering herd\r\n  const jitter = Math.random() * config.jitterMs;\r\n  \r\n  return Math.floor(cappedDelay + jitter);\r\n}\r\n\r\n/**\r\n * Determina si un error es reintentable\r\n */\r\nfunction isRetryableError(error: Error, config: RetryConfig): boolean {\r\n  const errorMessage = (error.message || '').toLowerCase();\r\n  const errorName = (error.name || '').toLowerCase();\r\n  \r\n  // Verificar errores no reintenables primero (tienen prioridad)\r\n  for (const nonRetryableError of config.nonRetryableErrors) {\r\n    if (errorMessage.includes(nonRetryableError.toLowerCase()) ||\r\n        errorName.includes(nonRetryableError.toLowerCase())) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Verificar errores reintenables\r\n  for (const retryableError of config.retryableErrors) {\r\n    if (errorMessage.includes(retryableError.toLowerCase()) ||\r\n        errorName.includes(retryableError.toLowerCase())) {\r\n      return true;\r\n    }\r\n  }\r\n  \r\n  // Por defecto, no reintentar errores desconocidos\r\n  return false;\r\n}\r\n\r\n/**\r\n * Extrae información del error para logging\r\n */\r\nfunction extractErrorInfo(error: Error): {\r\n  type: string;\r\n  code?: string;\r\n  statusCode?: number;\r\n  isNetwork: boolean;\r\n} {\r\n  const message = (error.message || '').toLowerCase();\r\n  const name = (error.name || '').toLowerCase();\r\n  \r\n  // Detectar errores de red\r\n  const networkErrors = ['econnreset', 'enotfound', 'econnrefused', 'etimedout'];\r\n  const isNetwork = networkErrors.some(netError => \r\n    message.includes(netError) || name.includes(netError)\r\n  );\r\n  \r\n  // Extraer código de estado HTTP si existe\r\n  const statusMatch = message.match(/(\\d{3})/);\r\n  const statusCode = statusMatch ? parseInt(statusMatch[1]) : undefined;\r\n  \r\n  return {\r\n    type: name || 'unknown',\r\n    code: statusCode?.toString(),\r\n    statusCode,\r\n    isNetwork\r\n  };\r\n}\r\n\r\n/**\r\n * Función principal de retry con backoff exponencial\r\n */\r\nexport async function retryWithBackoff<T>(\r\n  operation: () => Promise<T>,\r\n  config: RetryConfig,\r\n  operationName: string = 'unknown'\r\n): Promise<RetryResult<T>> {\r\n  const startTime = Date.now();\r\n  let lastError: Error | undefined;\r\n  let attempts = 0;\r\n\r\n  logger.info(LogCategory.API, `Starting retry operation: ${operationName}`);\r\n\r\n  for (let attempt = 0; attempt <= config.maxRetries; attempt++) {\r\n    attempts = attempt + 1;\r\n    const attemptStart = Date.now();\r\n\r\n    try {\r\n      logger.info(LogCategory.API, `Retry attempt ${attempts}/${config.maxRetries + 1} for ${operationName}`);\r\n      \r\n      const result = await operation();\r\n      const attemptDuration = Date.now() - attemptStart;\r\n      const totalDuration = Date.now() - startTime;\r\n\r\n      logger.info(LogCategory.API, `Retry operation succeeded: ${operationName}`);\r\n\r\n      // ✅ NUEVO: Registrar métricas de retry exitoso\r\n      await metricsCollector.recordRetry(operationName, attempts, true, totalDuration);\r\n\r\n      return {\r\n        success: true,\r\n        data: result,\r\n        attempts,\r\n        totalDuration,\r\n        lastAttemptDuration: attemptDuration,\r\n      };\r\n\r\n    } catch (error) {\r\n      lastError = error as Error;\r\n      const attemptDuration = Date.now() - attemptStart;\r\n      const errorInfo = extractErrorInfo(lastError);\r\n\r\n      const attemptInfo: AttemptInfo = {\r\n        attempt: attempts,\r\n        maxRetries: config.maxRetries + 1,\r\n        delay: 0,\r\n        error: lastError,\r\n        duration: attemptDuration,\r\n      };\r\n\r\n      // Log del intento fallido\r\n      logger.warn(LogCategory.API, `Retry attempt ${attempts} failed for ${operationName}`);\r\n\r\n      // Si es el último intento, no calcular delay\r\n      if (attempt === config.maxRetries) {\r\n        break;\r\n      }\r\n\r\n      // Verificar si el error es reintentable\r\n      if (!isRetryableError(lastError, config)) {\r\n        logger.error(LogCategory.API, `Non-retryable error for ${operationName}`, lastError);\r\n        break;\r\n      }\r\n\r\n      // Calcular delay para el siguiente intento\r\n      const delay = calculateDelay(attempt, config);\r\n      attemptInfo.delay = delay;\r\n\r\n      logger.info(LogCategory.API, `Retrying ${operationName} in ${delay}ms`);\r\n\r\n      // Esperar antes del siguiente intento\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n  }\r\n\r\n  // Todos los intentos fallaron\r\n  const totalDuration = Date.now() - startTime;\r\n  \r\n  logger.error(LogCategory.API, `All retry attempts failed for ${operationName}`, lastError!);\r\n\r\n  // ✅ NUEVO: Registrar métricas de retry fallido\r\n  await metricsCollector.recordRetry(operationName, attempts, false, totalDuration);\r\n\r\n  return {\r\n    success: false,\r\n    error: lastError,\r\n    attempts,\r\n    totalDuration,\r\n    lastAttemptDuration: 0,\r\n  };\r\n}\r\n\r\n/**\r\n * Wrapper específico para operaciones de MercadoPago\r\n */\r\nexport async function retryMercadoPagoOperation<T>(\r\n  operation: () => Promise<T>,\r\n  operationName: string,\r\n  isCritical: boolean = true\r\n): Promise<RetryResult<T>> {\r\n  const config = isCritical ? RETRY_CONFIGS.MERCADOPAGO_CRITICAL : RETRY_CONFIGS.MERCADOPAGO_QUERY;\r\n  \r\n  return retryWithBackoff(operation, config, `MercadoPago:${operationName}`);\r\n}\r\n\r\n/**\r\n * Wrapper para operaciones de webhook\r\n */\r\nexport async function retryWebhookOperation<T>(\r\n  operation: () => Promise<T>,\r\n  operationName: string\r\n): Promise<RetryResult<T>> {\r\n  return retryWithBackoff(operation, RETRY_CONFIGS.WEBHOOK_PROCESSING, `Webhook:${operationName}`);\r\n}\r\n\r\n/**\r\n * Función de utilidad para crear un retry personalizado\r\n */\r\nexport function createRetryFunction<T>(\r\n  config: RetryConfig,\r\n  operationName: string\r\n) {\r\n  return (operation: () => Promise<T>): Promise<RetryResult<T>> => {\r\n    return retryWithBackoff(operation, config, operationName);\r\n  };\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":["RETRY_CONFIGS","createRetryFunction","retryMercadoPagoOperation","retryWebhookOperation","retryWithBackoff","MERCADOPAGO_CRITICAL","maxRetries","baseDelayMs","maxDelayMs","backoffMultiplier","jitterMs","retryableErrors","nonRetryableErrors","MERCADOPAGO_QUERY","WEBHOOK_PROCESSING","calculateDelay","attempt","config","exponentialDelay","Math","pow","cappedDelay","min","jitter","random","floor","isRetryableError","error","errorMessage","message","toLowerCase","errorName","name","nonRetryableError","includes","retryableError","extractErrorInfo","networkErrors","isNetwork","some","netError","statusMatch","match","statusCode","parseInt","undefined","type","code","toString","operation","operationName","startTime","Date","now","lastError","attempts","logger","info","LogCategory","API","attemptStart","result","attemptDuration","totalDuration","metricsCollector","recordRetry","success","data","lastAttemptDuration","errorInfo","attemptInfo","delay","duration","warn","Promise","resolve","setTimeout","isCritical"],"mappings":"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"}