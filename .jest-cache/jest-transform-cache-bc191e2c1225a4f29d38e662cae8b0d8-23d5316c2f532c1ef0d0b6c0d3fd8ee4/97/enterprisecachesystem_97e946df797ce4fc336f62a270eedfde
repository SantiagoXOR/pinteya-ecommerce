134b90cb182e20f62083e06333712c20
/**
 * Sistema Enterprise de Caché Inteligente
 * Extiende el cache manager existente con funcionalidades enterprise avanzadas
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get ENTERPRISE_CACHE_CONFIGS () {
        return ENTERPRISE_CACHE_CONFIGS;
    },
    get EnterpriseCacheSystem () {
        return EnterpriseCacheSystem;
    },
    get EnterpriseCacheUtils () {
        return EnterpriseCacheUtils;
    },
    get enterpriseCacheSystem () {
        return enterpriseCacheSystem;
    }
});
const _cachemanager = require("../cache-manager");
const _redis = require("../integrations/redis");
const _enterpriseauditsystem = require("../security/enterprise-audit-system");
const ENTERPRISE_CACHE_CONFIGS = {
    // Cache crítico para datos de autenticación
    AUTH_CRITICAL: {
        ..._cachemanager.CACHE_CONFIGS.SYSTEM_CONFIG,
        ttl: 300,
        prefix: 'auth_critical',
        enableAuditLogging: true,
        enableMetrics: true,
        enableInvalidation: true,
        securityLevel: 'critical',
        encryptData: true,
        compressionLevel: 9,
        evictionPolicy: 'ttl'
    },
    // Cache para datos de productos con invalidación inteligente
    PRODUCTS_SMART: {
        ..._cachemanager.CACHE_CONFIGS.PRODUCT_DATA,
        ttl: 1800,
        prefix: 'products_smart',
        enableAuditLogging: false,
        enableMetrics: true,
        enableInvalidation: true,
        enableWarmup: true,
        invalidationPatterns: [
            'product:*',
            'category:*',
            'inventory:*'
        ],
        dependentKeys: [
            'categories',
            'brands',
            'pricing'
        ],
        warmupStrategy: 'scheduled',
        warmupInterval: 3600,
        securityLevel: 'standard',
        compressionLevel: 6,
        evictionPolicy: 'lru'
    },
    // Cache para APIs públicas con alta performance
    PUBLIC_PERFORMANCE: {
        ttl: 600,
        prefix: 'public_perf',
        compress: true,
        serialize: true,
        enableAuditLogging: false,
        enableMetrics: true,
        enableInvalidation: true,
        enableWarmup: true,
        warmupStrategy: 'eager',
        securityLevel: 'basic',
        compressionLevel: 3,
        maxMemoryUsage: 100 * 1024 * 1024,
        evictionPolicy: 'lfu'
    },
    // Cache para sesiones de usuario
    USER_SESSIONS: {
        ttl: 7200,
        prefix: 'user_sessions',
        compress: false,
        serialize: true,
        enableAuditLogging: true,
        enableMetrics: true,
        enableInvalidation: true,
        securityLevel: 'high',
        encryptData: true,
        evictionPolicy: 'ttl'
    },
    // Cache para métricas y analytics
    ANALYTICS_DATA: {
        ttl: 900,
        prefix: 'analytics',
        compress: true,
        serialize: true,
        enableAuditLogging: false,
        enableMetrics: true,
        enableInvalidation: true,
        enableWarmup: true,
        warmupStrategy: 'lazy',
        securityLevel: 'standard',
        compressionLevel: 8,
        evictionPolicy: 'lru'
    }
};
class EnterpriseCacheSystem {
    constructor(){
        this.metrics = new Map();
        this.invalidationJobs = new Map();
        this.warmupJobs = new Map();
        this.isInitialized = false;
    }
    static getInstance() {
        if (!EnterpriseCacheSystem.instance) {
            EnterpriseCacheSystem.instance = new EnterpriseCacheSystem();
        }
        return EnterpriseCacheSystem.instance;
    }
    /**
   * Inicializa el sistema enterprise de caché
   */ async initialize() {
        if (this.isInitialized) {
            return;
        }
        try {
            // Inicializar jobs de warmup programados
            await this.initializeWarmupJobs();
            // Inicializar limpieza automática
            this.startCleanupScheduler();
            // Inicializar monitoreo de memoria
            this.startMemoryMonitoring();
            this.isInitialized = true;
            console.log('[ENTERPRISE_CACHE] Sistema inicializado correctamente');
        } catch (error) {
            console.error('[ENTERPRISE_CACHE] Error inicializando sistema:', error);
            throw error;
        }
    }
    /**
   * Obtiene datos del caché con funcionalidades enterprise
   */ async get(key, config, context) {
        const startTime = Date.now();
        const fullKey = this.generateKey(config, key);
        try {
            // Verificar permisos de acceso si es necesario
            if (config.securityLevel === 'critical' && context) {
                await this.verifyAccess(fullKey, context);
            }
            // Intentar obtener del caché
            const result = await _cachemanager.cacheManager.get(key, config);
            const responseTime = Date.now() - startTime;
            // Actualizar métricas
            if (config.enableMetrics) {
                this.updateMetrics(fullKey, result !== null, responseTime);
            }
            // Registrar acceso si está habilitado
            if (config.enableAuditLogging && context) {
                await this.logCacheAccess('GET', fullKey, result !== null, context);
            }
            return result;
        } catch (error) {
            const responseTime = Date.now() - startTime;
            // Actualizar métricas de error
            if (config.enableMetrics) {
                this.updateErrorMetrics(fullKey, responseTime);
            }
            console.error('[ENTERPRISE_CACHE] Error en get:', error);
            return null;
        }
    }
    /**
   * Establece datos en el caché con funcionalidades enterprise
   */ async set(key, value, config, context) {
        const startTime = Date.now();
        const fullKey = this.generateKey(config, key);
        try {
            // Verificar permisos de escritura si es necesario
            if (config.securityLevel === 'critical' && context) {
                await this.verifyWriteAccess(fullKey, context);
            }
            // Encriptar datos si está configurado
            let processedValue = value;
            if (config.encryptData) {
                processedValue = await this.encryptData(value);
            }
            // Establecer en caché
            const success = await _cachemanager.cacheManager.set(key, processedValue, config);
            const responseTime = Date.now() - startTime;
            // Actualizar métricas
            if (config.enableMetrics) {
                this.updateSetMetrics(fullKey, success, responseTime);
            }
            // Registrar escritura si está habilitado
            if (config.enableAuditLogging && context) {
                await this.logCacheAccess('SET', fullKey, success, context);
            }
            // Programar invalidación de dependencias si es necesario
            if (config.enableInvalidation && config.dependentKeys) {
                await this.scheduleDependencyInvalidation(fullKey, config.dependentKeys);
            }
            return success;
        } catch (error) {
            const responseTime = Date.now() - startTime;
            // Actualizar métricas de error
            if (config.enableMetrics) {
                this.updateErrorMetrics(fullKey, responseTime);
            }
            console.error('[ENTERPRISE_CACHE] Error en set:', error);
            return false;
        }
    }
    /**
   * Invalidación inteligente de caché
   */ async invalidate(pattern, reason = 'manual', context) {
        try {
            const affectedKeys = await this.findKeysByPattern(pattern);
            // Eliminar claves del caché
            const deletionPromises = affectedKeys.map((key)=>_redis.redisCache.del(key));
            await Promise.all(deletionPromises);
            // Registrar evento de invalidación
            const invalidationEvent = {
                pattern,
                reason,
                affectedKeys,
                timestamp: new Date().toISOString(),
                triggeredBy: context?.userId
            };
            this.invalidationJobs.set(`inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, invalidationEvent);
            // Registrar en auditoría si hay contexto
            if (context) {
                await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent({
                    user_id: context.userId,
                    event_type: 'CACHE_INVALIDATION',
                    event_category: 'system_operation',
                    severity: 'medium',
                    description: `Cache invalidation: ${pattern}`,
                    metadata: {
                        pattern,
                        reason,
                        affected_keys_count: affectedKeys.length,
                        affected_keys: affectedKeys.slice(0, 10)
                    },
                    ip_address: context.ipAddress,
                    user_agent: context.userAgent
                }, context);
            }
            console.log(`[ENTERPRISE_CACHE] Invalidated ${affectedKeys.length} keys for pattern: ${pattern}`);
            return affectedKeys;
        } catch (error) {
            console.error('[ENTERPRISE_CACHE] Error en invalidación:', error);
            return [];
        }
    }
    /**
   * Warmup inteligente de caché
   */ async warmup(keys, config, dataFetcher) {
        const jobId = `warmup_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const warmupJob = {
            id: jobId,
            pattern: keys.join(','),
            strategy: config.warmupStrategy || 'lazy',
            interval: config.warmupInterval,
            lastRun: new Date().toISOString(),
            status: 'running'
        };
        this.warmupJobs.set(jobId, warmupJob);
        try {
            const warmupPromises = keys.map(async (key)=>{
                try {
                    // Verificar si ya existe en caché
                    const existing = await this.get(key, config);
                    if (existing !== null) {
                        return; // Ya está en caché
                    }
                    // Obtener datos y cachear
                    const data = await dataFetcher(key);
                    await this.set(key, data, config);
                } catch (error) {
                    console.warn(`[ENTERPRISE_CACHE] Error warming up key ${key}:`, error);
                }
            });
            await Promise.all(warmupPromises);
            // Actualizar estado del job
            warmupJob.status = 'completed';
            warmupJob.nextRun = config.warmupInterval ? new Date(Date.now() + config.warmupInterval * 1000).toISOString() : undefined;
            console.log(`[ENTERPRISE_CACHE] Warmup completed for ${keys.length} keys`);
        } catch (error) {
            warmupJob.status = 'failed';
            console.error('[ENTERPRISE_CACHE] Error en warmup:', error);
        }
    }
    /**
   * Obtiene métricas del sistema de caché
   */ getMetrics() {
        return Object.fromEntries(this.metrics);
    }
    /**
   * Obtiene estadísticas de invalidación
   */ getInvalidationStats() {
        return Array.from(this.invalidationJobs.values());
    }
    /**
   * Obtiene estadísticas de warmup
   */ getWarmupStats() {
        return Array.from(this.warmupJobs.values());
    }
    // =====================================================
    // MÉTODOS PRIVADOS
    // =====================================================
    generateKey(config, key) {
        return `${config.prefix}:${key}`;
    }
    async verifyAccess(key, context) {
        // Verificar permisos de acceso para datos críticos
        if (!context.permissions.includes('cache_access') && !context.permissions.includes('admin_access')) {
            throw new Error('Insufficient permissions for cache access');
        }
    }
    async verifyWriteAccess(key, context) {
        // Verificar permisos de escritura para datos críticos
        if (!context.permissions.includes('cache_write') && !context.permissions.includes('admin_access')) {
            throw new Error('Insufficient permissions for cache write');
        }
    }
    async encryptData(data) {
        // Implementación básica de encriptación
        // En producción, usar una librería de encriptación robusta
        try {
            const jsonString = JSON.stringify(data);
            const encoded = Buffer.from(jsonString).toString('base64');
            return {
                encrypted: true,
                data: encoded
            };
        } catch (error) {
            console.warn('[ENTERPRISE_CACHE] Error encriptando datos:', error);
            return data;
        }
    }
    updateMetrics(key, hit, responseTime) {
        const existing = this.metrics.get(key) || {
            hits: 0,
            misses: 0,
            hitRate: 0,
            avgResponseTime: 0,
            memoryUsage: 0,
            evictions: 0,
            errors: 0,
            lastAccess: new Date().toISOString()
        };
        if (hit) {
            existing.hits++;
        } else {
            existing.misses++;
        }
        const totalRequests = existing.hits + existing.misses;
        existing.hitRate = totalRequests > 0 ? existing.hits / totalRequests : 0;
        existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;
        existing.lastAccess = new Date().toISOString();
        this.metrics.set(key, existing);
    }
    updateSetMetrics(key, success, responseTime) {
        const existing = this.metrics.get(key) || {
            hits: 0,
            misses: 0,
            hitRate: 0,
            avgResponseTime: 0,
            memoryUsage: 0,
            evictions: 0,
            errors: 0,
            lastAccess: new Date().toISOString()
        };
        existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;
        existing.lastAccess = new Date().toISOString();
        if (!success) {
            existing.errors++;
        }
        this.metrics.set(key, existing);
    }
    updateErrorMetrics(key, responseTime) {
        const existing = this.metrics.get(key) || {
            hits: 0,
            misses: 0,
            hitRate: 0,
            avgResponseTime: 0,
            memoryUsage: 0,
            evictions: 0,
            errors: 0,
            lastAccess: new Date().toISOString()
        };
        existing.errors++;
        existing.avgResponseTime = (existing.avgResponseTime + responseTime) / 2;
        existing.lastAccess = new Date().toISOString();
        this.metrics.set(key, existing);
    }
    async logCacheAccess(operation, key, success, context) {
        try {
            await _enterpriseauditsystem.enterpriseAuditSystem.logEnterpriseEvent({
                user_id: context.userId,
                event_type: 'CACHE_ACCESS',
                event_category: 'system_operation',
                severity: 'low',
                description: `Cache ${operation}: ${key}`,
                metadata: {
                    operation,
                    key,
                    success,
                    cache_system: 'enterprise'
                },
                ip_address: context.ipAddress,
                user_agent: context.userAgent
            }, context);
        } catch (error) {
            console.warn('[ENTERPRISE_CACHE] Error logging cache access:', error);
        }
    }
    async findKeysByPattern(pattern) {
        try {
            // Usar Redis SCAN para encontrar claves por patrón
            const keys = [];
            const client = _redis.redisCache['client'] // Acceder al cliente Redis interno
            ;
            if (client && typeof client.scanStream === 'function') {
                const stream = client.scanStream({
                    match: pattern,
                    count: 100
                });
                return new Promise((resolve, reject)=>{
                    stream.on('data', (resultKeys)=>{
                        keys.push(...resultKeys);
                    });
                    stream.on('end', ()=>{
                        resolve(keys);
                    });
                    stream.on('error', (error)=>{
                        reject(error);
                    });
                });
            }
            return keys;
        } catch (error) {
            console.error('[ENTERPRISE_CACHE] Error finding keys by pattern:', error);
            return [];
        }
    }
    async scheduleDependencyInvalidation(key, dependentKeys) {
        // Programar invalidación de claves dependientes
        // Esto se podría implementar con un job queue como Bull o Agenda
        setTimeout(async ()=>{
            for (const depKey of dependentKeys){
                await this.invalidate(depKey, 'dependency_changed');
            }
        }, 1000); // 1 segundo de delay
    }
    async initializeWarmupJobs() {
        // Inicializar jobs de warmup programados
        // En una implementación real, esto se cargaría desde una base de datos
        console.log('[ENTERPRISE_CACHE] Warmup jobs initialized');
    }
    startCleanupScheduler() {
        // Limpiar métricas antiguas cada hora
        setInterval(()=>{
            const oneHourAgo = Date.now() - 60 * 60 * 1000;
            for (const [key, metrics] of this.metrics.entries()){
                const lastAccessTime = new Date(metrics.lastAccess).getTime();
                if (lastAccessTime < oneHourAgo) {
                    this.metrics.delete(key);
                }
            }
        }, 60 * 60 * 1000); // 1 hora
    }
    startMemoryMonitoring() {
        // Monitorear uso de memoria cada 5 minutos
        setInterval(()=>{
            const memoryUsage = process.memoryUsage();
            if (memoryUsage.heapUsed > 500 * 1024 * 1024) {
                // 500MB
                console.warn('[ENTERPRISE_CACHE] High memory usage detected:', memoryUsage);
            // Aquí se podría implementar limpieza automática
            }
        }, 5 * 60 * 1000); // 5 minutos
    }
}
const enterpriseCacheSystem = EnterpriseCacheSystem.getInstance();
const EnterpriseCacheUtils = {
    /**
   * Cache para datos de autenticación críticos
   */ async cacheAuthData (key, fetcher, context) {
        const cached = await enterpriseCacheSystem.get(key, ENTERPRISE_CACHE_CONFIGS.AUTH_CRITICAL, context);
        if (cached !== null) {
            return cached;
        }
        const data = await fetcher();
        await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.AUTH_CRITICAL, context);
        return data;
    },
    /**
   * Cache inteligente para productos
   */ async cacheProductData (key, fetcher) {
        const cached = await enterpriseCacheSystem.get(key, ENTERPRISE_CACHE_CONFIGS.PRODUCTS_SMART);
        if (cached !== null) {
            return cached;
        }
        const data = await fetcher();
        await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.PRODUCTS_SMART);
        return data;
    },
    /**
   * Cache de alta performance para APIs públicas
   */ async cachePublicData (key, fetcher) {
        const cached = await enterpriseCacheSystem.get(key, ENTERPRISE_CACHE_CONFIGS.PUBLIC_PERFORMANCE);
        if (cached !== null) {
            return cached;
        }
        const data = await fetcher();
        await enterpriseCacheSystem.set(key, data, ENTERPRISE_CACHE_CONFIGS.PUBLIC_PERFORMANCE);
        return data;
    },
    /**
   * Invalidación masiva por patrones
   */ async invalidateByPatterns (patterns, context) {
        const invalidationPromises = patterns.map((pattern)=>enterpriseCacheSystem.invalidate(pattern, 'manual', context));
        await Promise.all(invalidationPromises);
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcbGliXFxvcHRpbWl6YXRpb25cXGVudGVycHJpc2UtY2FjaGUtc3lzdGVtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2lzdGVtYSBFbnRlcnByaXNlIGRlIENhY2jDqSBJbnRlbGlnZW50ZVxuICogRXh0aWVuZGUgZWwgY2FjaGUgbWFuYWdlciBleGlzdGVudGUgY29uIGZ1bmNpb25hbGlkYWRlcyBlbnRlcnByaXNlIGF2YW56YWRhc1xuICovXG5cbmltcG9ydCB7IGNhY2hlTWFuYWdlciwgQ0FDSEVfQ09ORklHUywgdHlwZSBDYWNoZUNvbmZpZyB9IGZyb20gJ0AvbGliL2NhY2hlLW1hbmFnZXInXG5pbXBvcnQgeyByZWRpc0NhY2hlIH0gZnJvbSAnQC9saWIvaW50ZWdyYXRpb25zL3JlZGlzJ1xuaW1wb3J0IHsgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtIH0gZnJvbSAnQC9saWIvc2VjdXJpdHkvZW50ZXJwcmlzZS1hdWRpdC1zeXN0ZW0nXG5pbXBvcnQgeyBtZXRyaWNzQ29sbGVjdG9yIH0gZnJvbSAnQC9saWIvcmF0ZS1saW1pdGluZy9lbnRlcnByaXNlLXJhdGUtbGltaXRlcidcbmltcG9ydCB0eXBlIHsgRW50ZXJwcmlzZUF1dGhDb250ZXh0IH0gZnJvbSAnQC9saWIvYXV0aC9lbnRlcnByaXNlLWF1dGgtdXRpbHMnXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUSVBPUyBZIElOVEVSRkFDRVMgRU5URVJQUklTRVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBFbnRlcnByaXNlQ2FjaGVDb25maWcgZXh0ZW5kcyBDYWNoZUNvbmZpZyB7XG4gIC8vIENvbmZpZ3VyYWNpb25lcyBlbnRlcnByaXNlXG4gIGVuYWJsZUF1ZGl0TG9nZ2luZz86IGJvb2xlYW5cbiAgZW5hYmxlTWV0cmljcz86IGJvb2xlYW5cbiAgZW5hYmxlSW52YWxpZGF0aW9uPzogYm9vbGVhblxuICBlbmFibGVXYXJtdXA/OiBib29sZWFuXG5cbiAgLy8gQ29uZmlndXJhY2lvbmVzIGRlIGludmFsaWRhY2nDs25cbiAgaW52YWxpZGF0aW9uUGF0dGVybnM/OiBzdHJpbmdbXVxuICBkZXBlbmRlbnRLZXlzPzogc3RyaW5nW11cblxuICAvLyBDb25maWd1cmFjaW9uZXMgZGUgd2FybXVwXG4gIHdhcm11cFN0cmF0ZWd5PzogJ2VhZ2VyJyB8ICdsYXp5JyB8ICdzY2hlZHVsZWQnXG4gIHdhcm11cEludGVydmFsPzogbnVtYmVyXG5cbiAgLy8gQ29uZmlndXJhY2lvbmVzIGRlIHNlZ3VyaWRhZFxuICBzZWN1cml0eUxldmVsPzogJ2Jhc2ljJyB8ICdzdGFuZGFyZCcgfCAnaGlnaCcgfCAnY3JpdGljYWwnXG4gIGVuY3J5cHREYXRhPzogYm9vbGVhblxuXG4gIC8vIENvbmZpZ3VyYWNpb25lcyBkZSBwZXJmb3JtYW5jZVxuICBjb21wcmVzc2lvbkxldmVsPzogbnVtYmVyXG4gIG1heE1lbW9yeVVzYWdlPzogbnVtYmVyXG4gIGV2aWN0aW9uUG9saWN5PzogJ2xydScgfCAnbGZ1JyB8ICd0dGwnIHwgJ3JhbmRvbSdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZU1ldHJpY3Mge1xuICBoaXRzOiBudW1iZXJcbiAgbWlzc2VzOiBudW1iZXJcbiAgaGl0UmF0ZTogbnVtYmVyXG4gIGF2Z1Jlc3BvbnNlVGltZTogbnVtYmVyXG4gIG1lbW9yeVVzYWdlOiBudW1iZXJcbiAgZXZpY3Rpb25zOiBudW1iZXJcbiAgZXJyb3JzOiBudW1iZXJcbiAgbGFzdEFjY2Vzczogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVJbnZhbGlkYXRpb25FdmVudCB7XG4gIHBhdHRlcm46IHN0cmluZ1xuICByZWFzb246ICdtYW51YWwnIHwgJ3R0bF9leHBpcmVkJyB8ICdkZXBlbmRlbmN5X2NoYW5nZWQnIHwgJ21lbW9yeV9wcmVzc3VyZSdcbiAgYWZmZWN0ZWRLZXlzOiBzdHJpbmdbXVxuICB0aW1lc3RhbXA6IHN0cmluZ1xuICB0cmlnZ2VyZWRCeT86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlV2FybXVwSm9iIHtcbiAgaWQ6IHN0cmluZ1xuICBwYXR0ZXJuOiBzdHJpbmdcbiAgc3RyYXRlZ3k6ICdlYWdlcicgfCAnbGF6eScgfCAnc2NoZWR1bGVkJ1xuICBpbnRlcnZhbD86IG51bWJlclxuICBsYXN0UnVuPzogc3RyaW5nXG4gIG5leHRSdW4/OiBzdHJpbmdcbiAgc3RhdHVzOiAncGVuZGluZycgfCAncnVubmluZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDT05GSUdVUkFDSU9ORVMgRU5URVJQUklTRSBQUkVERUZJTklEQVNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBFTlRFUlBSSVNFX0NBQ0hFX0NPTkZJR1M6IFJlY29yZDxzdHJpbmcsIEVudGVycHJpc2VDYWNoZUNvbmZpZz4gPSB7XG4gIC8vIENhY2hlIGNyw610aWNvIHBhcmEgZGF0b3MgZGUgYXV0ZW50aWNhY2nDs25cbiAgQVVUSF9DUklUSUNBTDoge1xuICAgIC4uLkNBQ0hFX0NPTkZJR1MuU1lTVEVNX0NPTkZJRyxcbiAgICB0dGw6IDMwMCwgLy8gNSBtaW51dG9zXG4gICAgcHJlZml4OiAnYXV0aF9jcml0aWNhbCcsXG4gICAgZW5hYmxlQXVkaXRMb2dnaW5nOiB0cnVlLFxuICAgIGVuYWJsZU1ldHJpY3M6IHRydWUsXG4gICAgZW5hYmxlSW52YWxpZGF0aW9uOiB0cnVlLFxuICAgIHNlY3VyaXR5TGV2ZWw6ICdjcml0aWNhbCcsXG4gICAgZW5jcnlwdERhdGE6IHRydWUsXG4gICAgY29tcHJlc3Npb25MZXZlbDogOSxcbiAgICBldmljdGlvblBvbGljeTogJ3R0bCcsXG4gIH0sXG5cbiAgLy8gQ2FjaGUgcGFyYSBkYXRvcyBkZSBwcm9kdWN0b3MgY29uIGludmFsaWRhY2nDs24gaW50ZWxpZ2VudGVcbiAgUFJPRFVDVFNfU01BUlQ6IHtcbiAgICAuLi5DQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSxcbiAgICB0dGw6IDE4MDAsIC8vIDMwIG1pbnV0b3NcbiAgICBwcmVmaXg6ICdwcm9kdWN0c19zbWFydCcsXG4gICAgZW5hYmxlQXVkaXRMb2dnaW5nOiBmYWxzZSxcbiAgICBlbmFibGVNZXRyaWNzOiB0cnVlLFxuICAgIGVuYWJsZUludmFsaWRhdGlvbjogdHJ1ZSxcbiAgICBlbmFibGVXYXJtdXA6IHRydWUsXG4gICAgaW52YWxpZGF0aW9uUGF0dGVybnM6IFsncHJvZHVjdDoqJywgJ2NhdGVnb3J5OionLCAnaW52ZW50b3J5OionXSxcbiAgICBkZXBlbmRlbnRLZXlzOiBbJ2NhdGVnb3JpZXMnLCAnYnJhbmRzJywgJ3ByaWNpbmcnXSxcbiAgICB3YXJtdXBTdHJhdGVneTogJ3NjaGVkdWxlZCcsXG4gICAgd2FybXVwSW50ZXJ2YWw6IDM2MDAsIC8vIDEgaG9yYVxuICAgIHNlY3VyaXR5TGV2ZWw6ICdzdGFuZGFyZCcsXG4gICAgY29tcHJlc3Npb25MZXZlbDogNixcbiAgICBldmljdGlvblBvbGljeTogJ2xydScsXG4gIH0sXG5cbiAgLy8gQ2FjaGUgcGFyYSBBUElzIHDDumJsaWNhcyBjb24gYWx0YSBwZXJmb3JtYW5jZVxuICBQVUJMSUNfUEVSRk9STUFOQ0U6IHtcbiAgICB0dGw6IDYwMCwgLy8gMTAgbWludXRvc1xuICAgIHByZWZpeDogJ3B1YmxpY19wZXJmJyxcbiAgICBjb21wcmVzczogdHJ1ZSxcbiAgICBzZXJpYWxpemU6IHRydWUsXG4gICAgZW5hYmxlQXVkaXRMb2dnaW5nOiBmYWxzZSxcbiAgICBlbmFibGVNZXRyaWNzOiB0cnVlLFxuICAgIGVuYWJsZUludmFsaWRhdGlvbjogdHJ1ZSxcbiAgICBlbmFibGVXYXJtdXA6IHRydWUsXG4gICAgd2FybXVwU3RyYXRlZ3k6ICdlYWdlcicsXG4gICAgc2VjdXJpdHlMZXZlbDogJ2Jhc2ljJyxcbiAgICBjb21wcmVzc2lvbkxldmVsOiAzLFxuICAgIG1heE1lbW9yeVVzYWdlOiAxMDAgKiAxMDI0ICogMTAyNCwgLy8gMTAwTUJcbiAgICBldmljdGlvblBvbGljeTogJ2xmdScsXG4gIH0sXG5cbiAgLy8gQ2FjaGUgcGFyYSBzZXNpb25lcyBkZSB1c3VhcmlvXG4gIFVTRVJfU0VTU0lPTlM6IHtcbiAgICB0dGw6IDcyMDAsIC8vIDIgaG9yYXNcbiAgICBwcmVmaXg6ICd1c2VyX3Nlc3Npb25zJyxcbiAgICBjb21wcmVzczogZmFsc2UsXG4gICAgc2VyaWFsaXplOiB0cnVlLFxuICAgIGVuYWJsZUF1ZGl0TG9nZ2luZzogdHJ1ZSxcbiAgICBlbmFibGVNZXRyaWNzOiB0cnVlLFxuICAgIGVuYWJsZUludmFsaWRhdGlvbjogdHJ1ZSxcbiAgICBzZWN1cml0eUxldmVsOiAnaGlnaCcsXG4gICAgZW5jcnlwdERhdGE6IHRydWUsXG4gICAgZXZpY3Rpb25Qb2xpY3k6ICd0dGwnLFxuICB9LFxuXG4gIC8vIENhY2hlIHBhcmEgbcOpdHJpY2FzIHkgYW5hbHl0aWNzXG4gIEFOQUxZVElDU19EQVRBOiB7XG4gICAgdHRsOiA5MDAsIC8vIDE1IG1pbnV0b3NcbiAgICBwcmVmaXg6ICdhbmFseXRpY3MnLFxuICAgIGNvbXByZXNzOiB0cnVlLFxuICAgIHNlcmlhbGl6ZTogdHJ1ZSxcbiAgICBlbmFibGVBdWRpdExvZ2dpbmc6IGZhbHNlLFxuICAgIGVuYWJsZU1ldHJpY3M6IHRydWUsXG4gICAgZW5hYmxlSW52YWxpZGF0aW9uOiB0cnVlLFxuICAgIGVuYWJsZVdhcm11cDogdHJ1ZSxcbiAgICB3YXJtdXBTdHJhdGVneTogJ2xhenknLFxuICAgIHNlY3VyaXR5TGV2ZWw6ICdzdGFuZGFyZCcsXG4gICAgY29tcHJlc3Npb25MZXZlbDogOCxcbiAgICBldmljdGlvblBvbGljeTogJ2xydScsXG4gIH0sXG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTSVNURU1BIEVOVEVSUFJJU0UgREUgQ0FDSMOJXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY2xhc3MgRW50ZXJwcmlzZUNhY2hlU3lzdGVtIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEVudGVycHJpc2VDYWNoZVN5c3RlbVxuICBwcml2YXRlIG1ldHJpY3M6IE1hcDxzdHJpbmcsIENhY2hlTWV0cmljcz4gPSBuZXcgTWFwKClcbiAgcHJpdmF0ZSBpbnZhbGlkYXRpb25Kb2JzOiBNYXA8c3RyaW5nLCBDYWNoZUludmFsaWRhdGlvbkV2ZW50PiA9IG5ldyBNYXAoKVxuICBwcml2YXRlIHdhcm11cEpvYnM6IE1hcDxzdHJpbmcsIENhY2hlV2FybXVwSm9iPiA9IG5ldyBNYXAoKVxuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRW50ZXJwcmlzZUNhY2hlU3lzdGVtIHtcbiAgICBpZiAoIUVudGVycHJpc2VDYWNoZVN5c3RlbS5pbnN0YW5jZSkge1xuICAgICAgRW50ZXJwcmlzZUNhY2hlU3lzdGVtLmluc3RhbmNlID0gbmV3IEVudGVycHJpc2VDYWNoZVN5c3RlbSgpXG4gICAgfVxuICAgIHJldHVybiBFbnRlcnByaXNlQ2FjaGVTeXN0ZW0uaW5zdGFuY2VcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmljaWFsaXphIGVsIHNpc3RlbWEgZW50ZXJwcmlzZSBkZSBjYWNow6lcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEluaWNpYWxpemFyIGpvYnMgZGUgd2FybXVwIHByb2dyYW1hZG9zXG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVXYXJtdXBKb2JzKClcblxuICAgICAgLy8gSW5pY2lhbGl6YXIgbGltcGllemEgYXV0b23DoXRpY2FcbiAgICAgIHRoaXMuc3RhcnRDbGVhbnVwU2NoZWR1bGVyKClcblxuICAgICAgLy8gSW5pY2lhbGl6YXIgbW9uaXRvcmVvIGRlIG1lbW9yaWFcbiAgICAgIHRoaXMuc3RhcnRNZW1vcnlNb25pdG9yaW5nKClcblxuICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZVxuICAgICAgY29uc29sZS5sb2coJ1tFTlRFUlBSSVNFX0NBQ0hFXSBTaXN0ZW1hIGluaWNpYWxpemFkbyBjb3JyZWN0YW1lbnRlJylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGluaWNpYWxpemFuZG8gc2lzdGVtYTonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9idGllbmUgZGF0b3MgZGVsIGNhY2jDqSBjb24gZnVuY2lvbmFsaWRhZGVzIGVudGVycHJpc2VcbiAgICovXG4gIGFzeW5jIGdldDxUPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICBjb25maWc6IEVudGVycHJpc2VDYWNoZUNvbmZpZyxcbiAgICBjb250ZXh0PzogRW50ZXJwcmlzZUF1dGhDb250ZXh0XG4gICk6IFByb21pc2U8VCB8IG51bGw+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgZnVsbEtleSA9IHRoaXMuZ2VuZXJhdGVLZXkoY29uZmlnLCBrZXkpXG5cbiAgICB0cnkge1xuICAgICAgLy8gVmVyaWZpY2FyIHBlcm1pc29zIGRlIGFjY2VzbyBzaSBlcyBuZWNlc2FyaW9cbiAgICAgIGlmIChjb25maWcuc2VjdXJpdHlMZXZlbCA9PT0gJ2NyaXRpY2FsJyAmJiBjb250ZXh0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudmVyaWZ5QWNjZXNzKGZ1bGxLZXksIGNvbnRleHQpXG4gICAgICB9XG5cbiAgICAgIC8vIEludGVudGFyIG9idGVuZXIgZGVsIGNhY2jDqVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVNYW5hZ2VyLmdldDxUPihrZXksIGNvbmZpZylcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcblxuICAgICAgLy8gQWN0dWFsaXphciBtw6l0cmljYXNcbiAgICAgIGlmIChjb25maWcuZW5hYmxlTWV0cmljcykge1xuICAgICAgICB0aGlzLnVwZGF0ZU1ldHJpY3MoZnVsbEtleSwgcmVzdWx0ICE9PSBudWxsLCByZXNwb25zZVRpbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ2lzdHJhciBhY2Nlc28gc2kgZXN0w6EgaGFiaWxpdGFkb1xuICAgICAgaWYgKGNvbmZpZy5lbmFibGVBdWRpdExvZ2dpbmcgJiYgY29udGV4dCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvZ0NhY2hlQWNjZXNzKCdHRVQnLCBmdWxsS2V5LCByZXN1bHQgIT09IG51bGwsIGNvbnRleHQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuXG4gICAgICAvLyBBY3R1YWxpemFyIG3DqXRyaWNhcyBkZSBlcnJvclxuICAgICAgaWYgKGNvbmZpZy5lbmFibGVNZXRyaWNzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXJyb3JNZXRyaWNzKGZ1bGxLZXksIHJlc3BvbnNlVGltZSlcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGVuIGdldDonLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVzdGFibGVjZSBkYXRvcyBlbiBlbCBjYWNow6kgY29uIGZ1bmNpb25hbGlkYWRlcyBlbnRlcnByaXNlXG4gICAqL1xuICBhc3luYyBzZXQ8VD4oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IFQsXG4gICAgY29uZmlnOiBFbnRlcnByaXNlQ2FjaGVDb25maWcsXG4gICAgY29udGV4dD86IEVudGVycHJpc2VBdXRoQ29udGV4dFxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgZnVsbEtleSA9IHRoaXMuZ2VuZXJhdGVLZXkoY29uZmlnLCBrZXkpXG5cbiAgICB0cnkge1xuICAgICAgLy8gVmVyaWZpY2FyIHBlcm1pc29zIGRlIGVzY3JpdHVyYSBzaSBlcyBuZWNlc2FyaW9cbiAgICAgIGlmIChjb25maWcuc2VjdXJpdHlMZXZlbCA9PT0gJ2NyaXRpY2FsJyAmJiBjb250ZXh0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudmVyaWZ5V3JpdGVBY2Nlc3MoZnVsbEtleSwgY29udGV4dClcbiAgICAgIH1cblxuICAgICAgLy8gRW5jcmlwdGFyIGRhdG9zIHNpIGVzdMOhIGNvbmZpZ3VyYWRvXG4gICAgICBsZXQgcHJvY2Vzc2VkVmFsdWUgPSB2YWx1ZVxuICAgICAgaWYgKGNvbmZpZy5lbmNyeXB0RGF0YSkge1xuICAgICAgICBwcm9jZXNzZWRWYWx1ZSA9IChhd2FpdCB0aGlzLmVuY3J5cHREYXRhKHZhbHVlKSkgYXMgVFxuICAgICAgfVxuXG4gICAgICAvLyBFc3RhYmxlY2VyIGVuIGNhY2jDqVxuICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IGNhY2hlTWFuYWdlci5zZXQoa2V5LCBwcm9jZXNzZWRWYWx1ZSwgY29uZmlnKVxuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuXG4gICAgICAvLyBBY3R1YWxpemFyIG3DqXRyaWNhc1xuICAgICAgaWYgKGNvbmZpZy5lbmFibGVNZXRyaWNzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2V0TWV0cmljcyhmdWxsS2V5LCBzdWNjZXNzLCByZXNwb25zZVRpbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIFJlZ2lzdHJhciBlc2NyaXR1cmEgc2kgZXN0w6EgaGFiaWxpdGFkb1xuICAgICAgaWYgKGNvbmZpZy5lbmFibGVBdWRpdExvZ2dpbmcgJiYgY29udGV4dCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvZ0NhY2hlQWNjZXNzKCdTRVQnLCBmdWxsS2V5LCBzdWNjZXNzLCBjb250ZXh0KVxuICAgICAgfVxuXG4gICAgICAvLyBQcm9ncmFtYXIgaW52YWxpZGFjacOzbiBkZSBkZXBlbmRlbmNpYXMgc2kgZXMgbmVjZXNhcmlvXG4gICAgICBpZiAoY29uZmlnLmVuYWJsZUludmFsaWRhdGlvbiAmJiBjb25maWcuZGVwZW5kZW50S2V5cykge1xuICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlRGVwZW5kZW5jeUludmFsaWRhdGlvbihmdWxsS2V5LCBjb25maWcuZGVwZW5kZW50S2V5cylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1Y2Nlc3NcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuXG4gICAgICAvLyBBY3R1YWxpemFyIG3DqXRyaWNhcyBkZSBlcnJvclxuICAgICAgaWYgKGNvbmZpZy5lbmFibGVNZXRyaWNzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRXJyb3JNZXRyaWNzKGZ1bGxLZXksIHJlc3BvbnNlVGltZSlcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGVuIHNldDonLCBlcnJvcilcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZhbGlkYWNpw7NuIGludGVsaWdlbnRlIGRlIGNhY2jDqVxuICAgKi9cbiAgYXN5bmMgaW52YWxpZGF0ZShcbiAgICBwYXR0ZXJuOiBzdHJpbmcsXG4gICAgcmVhc29uOiBDYWNoZUludmFsaWRhdGlvbkV2ZW50WydyZWFzb24nXSA9ICdtYW51YWwnLFxuICAgIGNvbnRleHQ/OiBFbnRlcnByaXNlQXV0aENvbnRleHRcbiAgKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZmZlY3RlZEtleXMgPSBhd2FpdCB0aGlzLmZpbmRLZXlzQnlQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgICAgIC8vIEVsaW1pbmFyIGNsYXZlcyBkZWwgY2FjaMOpXG4gICAgICBjb25zdCBkZWxldGlvblByb21pc2VzID0gYWZmZWN0ZWRLZXlzLm1hcChrZXkgPT4gcmVkaXNDYWNoZS5kZWwoa2V5KSlcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGRlbGV0aW9uUHJvbWlzZXMpXG5cbiAgICAgIC8vIFJlZ2lzdHJhciBldmVudG8gZGUgaW52YWxpZGFjacOzblxuICAgICAgY29uc3QgaW52YWxpZGF0aW9uRXZlbnQ6IENhY2hlSW52YWxpZGF0aW9uRXZlbnQgPSB7XG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIHJlYXNvbixcbiAgICAgICAgYWZmZWN0ZWRLZXlzLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdHJpZ2dlcmVkQnk6IGNvbnRleHQ/LnVzZXJJZCxcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnZhbGlkYXRpb25Kb2JzLnNldChcbiAgICAgICAgYGludl8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgICAgIGludmFsaWRhdGlvbkV2ZW50XG4gICAgICApXG5cbiAgICAgIC8vIFJlZ2lzdHJhciBlbiBhdWRpdG9yw61hIHNpIGhheSBjb250ZXh0b1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmxvZ0VudGVycHJpc2VFdmVudChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB1c2VyX2lkOiBjb250ZXh0LnVzZXJJZCxcbiAgICAgICAgICAgIGV2ZW50X3R5cGU6ICdDQUNIRV9JTlZBTElEQVRJT04nIGFzIGFueSxcbiAgICAgICAgICAgIGV2ZW50X2NhdGVnb3J5OiAnc3lzdGVtX29wZXJhdGlvbicsXG4gICAgICAgICAgICBzZXZlcml0eTogJ21lZGl1bScgYXMgYW55LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDYWNoZSBpbnZhbGlkYXRpb246ICR7cGF0dGVybn1gLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgICBhZmZlY3RlZF9rZXlzX2NvdW50OiBhZmZlY3RlZEtleXMubGVuZ3RoLFxuICAgICAgICAgICAgICBhZmZlY3RlZF9rZXlzOiBhZmZlY3RlZEtleXMuc2xpY2UoMCwgMTApLCAvLyBQcmltZXJhcyAxMCBwYXJhIG5vIHNhdHVyYXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpcF9hZGRyZXNzOiBjb250ZXh0LmlwQWRkcmVzcyxcbiAgICAgICAgICAgIHVzZXJfYWdlbnQ6IGNvbnRleHQudXNlckFnZW50LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgW0VOVEVSUFJJU0VfQ0FDSEVdIEludmFsaWRhdGVkICR7YWZmZWN0ZWRLZXlzLmxlbmd0aH0ga2V5cyBmb3IgcGF0dGVybjogJHtwYXR0ZXJufWBcbiAgICAgIClcbiAgICAgIHJldHVybiBhZmZlY3RlZEtleXNcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGVuIGludmFsaWRhY2nDs246JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FybXVwIGludGVsaWdlbnRlIGRlIGNhY2jDqVxuICAgKi9cbiAgYXN5bmMgd2FybXVwKFxuICAgIGtleXM6IHN0cmluZ1tdLFxuICAgIGNvbmZpZzogRW50ZXJwcmlzZUNhY2hlQ29uZmlnLFxuICAgIGRhdGFGZXRjaGVyOiAoa2V5OiBzdHJpbmcpID0+IFByb21pc2U8YW55PlxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBqb2JJZCA9IGB3YXJtdXBfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXG5cbiAgICBjb25zdCB3YXJtdXBKb2I6IENhY2hlV2FybXVwSm9iID0ge1xuICAgICAgaWQ6IGpvYklkLFxuICAgICAgcGF0dGVybjoga2V5cy5qb2luKCcsJyksXG4gICAgICBzdHJhdGVneTogY29uZmlnLndhcm11cFN0cmF0ZWd5IHx8ICdsYXp5JyxcbiAgICAgIGludGVydmFsOiBjb25maWcud2FybXVwSW50ZXJ2YWwsXG4gICAgICBsYXN0UnVuOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBzdGF0dXM6ICdydW5uaW5nJyxcbiAgICB9XG5cbiAgICB0aGlzLndhcm11cEpvYnMuc2V0KGpvYklkLCB3YXJtdXBKb2IpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgd2FybXVwUHJvbWlzZXMgPSBrZXlzLm1hcChhc3luYyBrZXkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFZlcmlmaWNhciBzaSB5YSBleGlzdGUgZW4gY2FjaMOpXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBhd2FpdCB0aGlzLmdldChrZXksIGNvbmZpZylcbiAgICAgICAgICBpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAvLyBZYSBlc3TDoSBlbiBjYWNow6lcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPYnRlbmVyIGRhdG9zIHkgY2FjaGVhclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBkYXRhRmV0Y2hlcihrZXkpXG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXQoa2V5LCBkYXRhLCBjb25maWcpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBbRU5URVJQUklTRV9DQUNIRV0gRXJyb3Igd2FybWluZyB1cCBrZXkgJHtrZXl9OmAsIGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh3YXJtdXBQcm9taXNlcylcblxuICAgICAgLy8gQWN0dWFsaXphciBlc3RhZG8gZGVsIGpvYlxuICAgICAgd2FybXVwSm9iLnN0YXR1cyA9ICdjb21wbGV0ZWQnXG4gICAgICB3YXJtdXBKb2IubmV4dFJ1biA9IGNvbmZpZy53YXJtdXBJbnRlcnZhbFxuICAgICAgICA/IG5ldyBEYXRlKERhdGUubm93KCkgKyBjb25maWcud2FybXVwSW50ZXJ2YWwgKiAxMDAwKS50b0lTT1N0cmluZygpXG4gICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgIGNvbnNvbGUubG9nKGBbRU5URVJQUklTRV9DQUNIRV0gV2FybXVwIGNvbXBsZXRlZCBmb3IgJHtrZXlzLmxlbmd0aH0ga2V5c2ApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdhcm11cEpvYi5zdGF0dXMgPSAnZmFpbGVkJ1xuICAgICAgY29uc29sZS5lcnJvcignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGVuIHdhcm11cDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2J0aWVuZSBtw6l0cmljYXMgZGVsIHNpc3RlbWEgZGUgY2FjaMOpXG4gICAqL1xuICBnZXRNZXRyaWNzKCk6IFJlY29yZDxzdHJpbmcsIENhY2hlTWV0cmljcz4ge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5tZXRyaWNzKVxuICB9XG5cbiAgLyoqXG4gICAqIE9idGllbmUgZXN0YWTDrXN0aWNhcyBkZSBpbnZhbGlkYWNpw7NuXG4gICAqL1xuICBnZXRJbnZhbGlkYXRpb25TdGF0cygpOiBDYWNoZUludmFsaWRhdGlvbkV2ZW50W10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaW52YWxpZGF0aW9uSm9icy52YWx1ZXMoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnRpZW5lIGVzdGFkw61zdGljYXMgZGUgd2FybXVwXG4gICAqL1xuICBnZXRXYXJtdXBTdGF0cygpOiBDYWNoZVdhcm11cEpvYltdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLndhcm11cEpvYnMudmFsdWVzKCkpXG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBNw4lUT0RPUyBQUklWQURPU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVLZXkoY29uZmlnOiBFbnRlcnByaXNlQ2FjaGVDb25maWcsIGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7Y29uZmlnLnByZWZpeH06JHtrZXl9YFxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB2ZXJpZnlBY2Nlc3Moa2V5OiBzdHJpbmcsIGNvbnRleHQ6IEVudGVycHJpc2VBdXRoQ29udGV4dCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFZlcmlmaWNhciBwZXJtaXNvcyBkZSBhY2Nlc28gcGFyYSBkYXRvcyBjcsOtdGljb3NcbiAgICBpZiAoXG4gICAgICAhY29udGV4dC5wZXJtaXNzaW9ucy5pbmNsdWRlcygnY2FjaGVfYWNjZXNzJykgJiZcbiAgICAgICFjb250ZXh0LnBlcm1pc3Npb25zLmluY2x1ZGVzKCdhZG1pbl9hY2Nlc3MnKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMgZm9yIGNhY2hlIGFjY2VzcycpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB2ZXJpZnlXcml0ZUFjY2VzcyhrZXk6IHN0cmluZywgY29udGV4dDogRW50ZXJwcmlzZUF1dGhDb250ZXh0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVmVyaWZpY2FyIHBlcm1pc29zIGRlIGVzY3JpdHVyYSBwYXJhIGRhdG9zIGNyw610aWNvc1xuICAgIGlmIChcbiAgICAgICFjb250ZXh0LnBlcm1pc3Npb25zLmluY2x1ZGVzKCdjYWNoZV93cml0ZScpICYmXG4gICAgICAhY29udGV4dC5wZXJtaXNzaW9ucy5pbmNsdWRlcygnYWRtaW5fYWNjZXNzJylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdWZmaWNpZW50IHBlcm1pc3Npb25zIGZvciBjYWNoZSB3cml0ZScpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBlbmNyeXB0RGF0YShkYXRhOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIEltcGxlbWVudGFjacOzbiBiw6FzaWNhIGRlIGVuY3JpcHRhY2nDs25cbiAgICAvLyBFbiBwcm9kdWNjacOzbiwgdXNhciB1bmEgbGlicmVyw61hIGRlIGVuY3JpcHRhY2nDs24gcm9idXN0YVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBCdWZmZXIuZnJvbShqc29uU3RyaW5nKS50b1N0cmluZygnYmFzZTY0JylcbiAgICAgIHJldHVybiB7IGVuY3J5cHRlZDogdHJ1ZSwgZGF0YTogZW5jb2RlZCB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGVuY3JpcHRhbmRvIGRhdG9zOicsIGVycm9yKVxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZU1ldHJpY3Moa2V5OiBzdHJpbmcsIGhpdDogYm9vbGVhbiwgcmVzcG9uc2VUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMubWV0cmljcy5nZXQoa2V5KSB8fCB7XG4gICAgICBoaXRzOiAwLFxuICAgICAgbWlzc2VzOiAwLFxuICAgICAgaGl0UmF0ZTogMCxcbiAgICAgIGF2Z1Jlc3BvbnNlVGltZTogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAwLFxuICAgICAgZXZpY3Rpb25zOiAwLFxuICAgICAgZXJyb3JzOiAwLFxuICAgICAgbGFzdEFjY2VzczogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH1cblxuICAgIGlmIChoaXQpIHtcbiAgICAgIGV4aXN0aW5nLmhpdHMrK1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5taXNzZXMrK1xuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsUmVxdWVzdHMgPSBleGlzdGluZy5oaXRzICsgZXhpc3RpbmcubWlzc2VzXG4gICAgZXhpc3RpbmcuaGl0UmF0ZSA9IHRvdGFsUmVxdWVzdHMgPiAwID8gZXhpc3RpbmcuaGl0cyAvIHRvdGFsUmVxdWVzdHMgOiAwXG4gICAgZXhpc3RpbmcuYXZnUmVzcG9uc2VUaW1lID0gKGV4aXN0aW5nLmF2Z1Jlc3BvbnNlVGltZSArIHJlc3BvbnNlVGltZSkgLyAyXG4gICAgZXhpc3RpbmcubGFzdEFjY2VzcyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuXG4gICAgdGhpcy5tZXRyaWNzLnNldChrZXksIGV4aXN0aW5nKVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVTZXRNZXRyaWNzKGtleTogc3RyaW5nLCBzdWNjZXNzOiBib29sZWFuLCByZXNwb25zZVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5tZXRyaWNzLmdldChrZXkpIHx8IHtcbiAgICAgIGhpdHM6IDAsXG4gICAgICBtaXNzZXM6IDAsXG4gICAgICBoaXRSYXRlOiAwLFxuICAgICAgYXZnUmVzcG9uc2VUaW1lOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDAsXG4gICAgICBldmljdGlvbnM6IDAsXG4gICAgICBlcnJvcnM6IDAsXG4gICAgICBsYXN0QWNjZXNzOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfVxuXG4gICAgZXhpc3RpbmcuYXZnUmVzcG9uc2VUaW1lID0gKGV4aXN0aW5nLmF2Z1Jlc3BvbnNlVGltZSArIHJlc3BvbnNlVGltZSkgLyAyXG4gICAgZXhpc3RpbmcubGFzdEFjY2VzcyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuXG4gICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICBleGlzdGluZy5lcnJvcnMrK1xuICAgIH1cblxuICAgIHRoaXMubWV0cmljcy5zZXQoa2V5LCBleGlzdGluZylcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRXJyb3JNZXRyaWNzKGtleTogc3RyaW5nLCByZXNwb25zZVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5tZXRyaWNzLmdldChrZXkpIHx8IHtcbiAgICAgIGhpdHM6IDAsXG4gICAgICBtaXNzZXM6IDAsXG4gICAgICBoaXRSYXRlOiAwLFxuICAgICAgYXZnUmVzcG9uc2VUaW1lOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDAsXG4gICAgICBldmljdGlvbnM6IDAsXG4gICAgICBlcnJvcnM6IDAsXG4gICAgICBsYXN0QWNjZXNzOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfVxuXG4gICAgZXhpc3RpbmcuZXJyb3JzKytcbiAgICBleGlzdGluZy5hdmdSZXNwb25zZVRpbWUgPSAoZXhpc3RpbmcuYXZnUmVzcG9uc2VUaW1lICsgcmVzcG9uc2VUaW1lKSAvIDJcbiAgICBleGlzdGluZy5sYXN0QWNjZXNzID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG5cbiAgICB0aGlzLm1ldHJpY3Muc2V0KGtleSwgZXhpc3RpbmcpXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvZ0NhY2hlQWNjZXNzKFxuICAgIG9wZXJhdGlvbjogJ0dFVCcgfCAnU0VUJyxcbiAgICBrZXk6IHN0cmluZyxcbiAgICBzdWNjZXNzOiBib29sZWFuLFxuICAgIGNvbnRleHQ6IEVudGVycHJpc2VBdXRoQ29udGV4dFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZW50ZXJwcmlzZUF1ZGl0U3lzdGVtLmxvZ0VudGVycHJpc2VFdmVudChcbiAgICAgICAge1xuICAgICAgICAgIHVzZXJfaWQ6IGNvbnRleHQudXNlcklkLFxuICAgICAgICAgIGV2ZW50X3R5cGU6ICdDQUNIRV9BQ0NFU1MnIGFzIGFueSxcbiAgICAgICAgICBldmVudF9jYXRlZ29yeTogJ3N5c3RlbV9vcGVyYXRpb24nLFxuICAgICAgICAgIHNldmVyaXR5OiAnbG93JyBhcyBhbnksXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDYWNoZSAke29wZXJhdGlvbn06ICR7a2V5fWAsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICBjYWNoZV9zeXN0ZW06ICdlbnRlcnByaXNlJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlwX2FkZHJlc3M6IGNvbnRleHQuaXBBZGRyZXNzLFxuICAgICAgICAgIHVzZXJfYWdlbnQ6IGNvbnRleHQudXNlckFnZW50LFxuICAgICAgICB9LFxuICAgICAgICBjb250ZXh0XG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignW0VOVEVSUFJJU0VfQ0FDSEVdIEVycm9yIGxvZ2dpbmcgY2FjaGUgYWNjZXNzOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmluZEtleXNCeVBhdHRlcm4ocGF0dGVybjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2FyIFJlZGlzIFNDQU4gcGFyYSBlbmNvbnRyYXIgY2xhdmVzIHBvciBwYXRyw7NuXG4gICAgICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdXG4gICAgICBjb25zdCBjbGllbnQgPSByZWRpc0NhY2hlWydjbGllbnQnXSAvLyBBY2NlZGVyIGFsIGNsaWVudGUgUmVkaXMgaW50ZXJub1xuXG4gICAgICBpZiAoY2xpZW50ICYmIHR5cGVvZiBjbGllbnQuc2NhblN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjbGllbnQuc2NhblN0cmVhbSh7XG4gICAgICAgICAgbWF0Y2g6IHBhdHRlcm4sXG4gICAgICAgICAgY291bnQ6IDEwMCxcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHN0cmVhbS5vbignZGF0YScsIChyZXN1bHRLZXlzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICAgICAga2V5cy5wdXNoKC4uLnJlc3VsdEtleXMpXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShrZXlzKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXlzXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tFTlRFUlBSSVNFX0NBQ0hFXSBFcnJvciBmaW5kaW5nIGtleXMgYnkgcGF0dGVybjonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2NoZWR1bGVEZXBlbmRlbmN5SW52YWxpZGF0aW9uKFxuICAgIGtleTogc3RyaW5nLFxuICAgIGRlcGVuZGVudEtleXM6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFByb2dyYW1hciBpbnZhbGlkYWNpw7NuIGRlIGNsYXZlcyBkZXBlbmRpZW50ZXNcbiAgICAvLyBFc3RvIHNlIHBvZHLDrWEgaW1wbGVtZW50YXIgY29uIHVuIGpvYiBxdWV1ZSBjb21vIEJ1bGwgbyBBZ2VuZGFcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZGVwS2V5IG9mIGRlcGVuZGVudEtleXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnZhbGlkYXRlKGRlcEtleSwgJ2RlcGVuZGVuY3lfY2hhbmdlZCcpXG4gICAgICB9XG4gICAgfSwgMTAwMCkgLy8gMSBzZWd1bmRvIGRlIGRlbGF5XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVXYXJtdXBKb2JzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEluaWNpYWxpemFyIGpvYnMgZGUgd2FybXVwIHByb2dyYW1hZG9zXG4gICAgLy8gRW4gdW5hIGltcGxlbWVudGFjacOzbiByZWFsLCBlc3RvIHNlIGNhcmdhcsOtYSBkZXNkZSB1bmEgYmFzZSBkZSBkYXRvc1xuICAgIGNvbnNvbGUubG9nKCdbRU5URVJQUklTRV9DQUNIRV0gV2FybXVwIGpvYnMgaW5pdGlhbGl6ZWQnKVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydENsZWFudXBTY2hlZHVsZXIoKTogdm9pZCB7XG4gICAgLy8gTGltcGlhciBtw6l0cmljYXMgYW50aWd1YXMgY2FkYSBob3JhXG4gICAgc2V0SW50ZXJ2YWwoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9uZUhvdXJBZ28gPSBEYXRlLm5vdygpIC0gNjAgKiA2MCAqIDEwMDBcblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIG1ldHJpY3NdIG9mIHRoaXMubWV0cmljcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBjb25zdCBsYXN0QWNjZXNzVGltZSA9IG5ldyBEYXRlKG1ldHJpY3MubGFzdEFjY2VzcykuZ2V0VGltZSgpXG4gICAgICAgICAgaWYgKGxhc3RBY2Nlc3NUaW1lIDwgb25lSG91ckFnbykge1xuICAgICAgICAgICAgdGhpcy5tZXRyaWNzLmRlbGV0ZShrZXkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgNjAgKiA2MCAqIDEwMDBcbiAgICApIC8vIDEgaG9yYVxuICB9XG5cbiAgcHJpdmF0ZSBzdGFydE1lbW9yeU1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgLy8gTW9uaXRvcmVhciB1c28gZGUgbWVtb3JpYSBjYWRhIDUgbWludXRvc1xuICAgIHNldEludGVydmFsKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCBtZW1vcnlVc2FnZSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKVxuXG4gICAgICAgIGlmIChtZW1vcnlVc2FnZS5oZWFwVXNlZCA+IDUwMCAqIDEwMjQgKiAxMDI0KSB7XG4gICAgICAgICAgLy8gNTAwTUJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1tFTlRFUlBSSVNFX0NBQ0hFXSBIaWdoIG1lbW9yeSB1c2FnZSBkZXRlY3RlZDonLCBtZW1vcnlVc2FnZSlcbiAgICAgICAgICAvLyBBcXXDrSBzZSBwb2Ryw61hIGltcGxlbWVudGFyIGxpbXBpZXphIGF1dG9tw6F0aWNhXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICA1ICogNjAgKiAxMDAwXG4gICAgKSAvLyA1IG1pbnV0b3NcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSU5TVEFOQ0lBIFNJTkdMRVRPTiBZIFVUSUxJREFERVNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBlbnRlcnByaXNlQ2FjaGVTeXN0ZW0gPSBFbnRlcnByaXNlQ2FjaGVTeXN0ZW0uZ2V0SW5zdGFuY2UoKVxuXG4vKipcbiAqIEZ1bmNpb25lcyBkZSB1dGlsaWRhZCBwYXJhIGNhc29zIGNvbXVuZXNcbiAqL1xuZXhwb3J0IGNvbnN0IEVudGVycHJpc2VDYWNoZVV0aWxzID0ge1xuICAvKipcbiAgICogQ2FjaGUgcGFyYSBkYXRvcyBkZSBhdXRlbnRpY2FjacOzbiBjcsOtdGljb3NcbiAgICovXG4gIGFzeW5jIGNhY2hlQXV0aERhdGE8VD4oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgZmV0Y2hlcjogKCkgPT4gUHJvbWlzZTxUPixcbiAgICBjb250ZXh0OiBFbnRlcnByaXNlQXV0aENvbnRleHRcbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgZW50ZXJwcmlzZUNhY2hlU3lzdGVtLmdldDxUPihcbiAgICAgIGtleSxcbiAgICAgIEVOVEVSUFJJU0VfQ0FDSEVfQ09ORklHUy5BVVRIX0NSSVRJQ0FMLFxuICAgICAgY29udGV4dFxuICAgIClcbiAgICBpZiAoY2FjaGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkXG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoZXIoKVxuICAgIGF3YWl0IGVudGVycHJpc2VDYWNoZVN5c3RlbS5zZXQoa2V5LCBkYXRhLCBFTlRFUlBSSVNFX0NBQ0hFX0NPTkZJR1MuQVVUSF9DUklUSUNBTCwgY29udGV4dClcbiAgICByZXR1cm4gZGF0YVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWNoZSBpbnRlbGlnZW50ZSBwYXJhIHByb2R1Y3Rvc1xuICAgKi9cbiAgYXN5bmMgY2FjaGVQcm9kdWN0RGF0YTxUPihrZXk6IHN0cmluZywgZmV0Y2hlcjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IGVudGVycHJpc2VDYWNoZVN5c3RlbS5nZXQ8VD4oa2V5LCBFTlRFUlBSSVNFX0NBQ0hFX0NPTkZJR1MuUFJPRFVDVFNfU01BUlQpXG4gICAgaWYgKGNhY2hlZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaGVyKClcbiAgICBhd2FpdCBlbnRlcnByaXNlQ2FjaGVTeXN0ZW0uc2V0KGtleSwgZGF0YSwgRU5URVJQUklTRV9DQUNIRV9DT05GSUdTLlBST0RVQ1RTX1NNQVJUKVxuICAgIHJldHVybiBkYXRhXG4gIH0sXG5cbiAgLyoqXG4gICAqIENhY2hlIGRlIGFsdGEgcGVyZm9ybWFuY2UgcGFyYSBBUElzIHDDumJsaWNhc1xuICAgKi9cbiAgYXN5bmMgY2FjaGVQdWJsaWNEYXRhPFQ+KGtleTogc3RyaW5nLCBmZXRjaGVyOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgZW50ZXJwcmlzZUNhY2hlU3lzdGVtLmdldDxUPihcbiAgICAgIGtleSxcbiAgICAgIEVOVEVSUFJJU0VfQ0FDSEVfQ09ORklHUy5QVUJMSUNfUEVSRk9STUFOQ0VcbiAgICApXG4gICAgaWYgKGNhY2hlZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaGVyKClcbiAgICBhd2FpdCBlbnRlcnByaXNlQ2FjaGVTeXN0ZW0uc2V0KGtleSwgZGF0YSwgRU5URVJQUklTRV9DQUNIRV9DT05GSUdTLlBVQkxJQ19QRVJGT1JNQU5DRSlcbiAgICByZXR1cm4gZGF0YVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZhbGlkYWNpw7NuIG1hc2l2YSBwb3IgcGF0cm9uZXNcbiAgICovXG4gIGFzeW5jIGludmFsaWRhdGVCeVBhdHRlcm5zKHBhdHRlcm5zOiBzdHJpbmdbXSwgY29udGV4dD86IEVudGVycHJpc2VBdXRoQ29udGV4dCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGludmFsaWRhdGlvblByb21pc2VzID0gcGF0dGVybnMubWFwKHBhdHRlcm4gPT5cbiAgICAgIGVudGVycHJpc2VDYWNoZVN5c3RlbS5pbnZhbGlkYXRlKHBhdHRlcm4sICdtYW51YWwnLCBjb250ZXh0KVxuICAgIClcbiAgICBhd2FpdCBQcm9taXNlLmFsbChpbnZhbGlkYXRpb25Qcm9taXNlcylcbiAgfSxcbn1cbiJdLCJuYW1lcyI6WyJFTlRFUlBSSVNFX0NBQ0hFX0NPTkZJR1MiLCJFbnRlcnByaXNlQ2FjaGVTeXN0ZW0iLCJFbnRlcnByaXNlQ2FjaGVVdGlscyIsImVudGVycHJpc2VDYWNoZVN5c3RlbSIsIkFVVEhfQ1JJVElDQUwiLCJDQUNIRV9DT05GSUdTIiwiU1lTVEVNX0NPTkZJRyIsInR0bCIsInByZWZpeCIsImVuYWJsZUF1ZGl0TG9nZ2luZyIsImVuYWJsZU1ldHJpY3MiLCJlbmFibGVJbnZhbGlkYXRpb24iLCJzZWN1cml0eUxldmVsIiwiZW5jcnlwdERhdGEiLCJjb21wcmVzc2lvbkxldmVsIiwiZXZpY3Rpb25Qb2xpY3kiLCJQUk9EVUNUU19TTUFSVCIsIlBST0RVQ1RfREFUQSIsImVuYWJsZVdhcm11cCIsImludmFsaWRhdGlvblBhdHRlcm5zIiwiZGVwZW5kZW50S2V5cyIsIndhcm11cFN0cmF0ZWd5Iiwid2FybXVwSW50ZXJ2YWwiLCJQVUJMSUNfUEVSRk9STUFOQ0UiLCJjb21wcmVzcyIsInNlcmlhbGl6ZSIsIm1heE1lbW9yeVVzYWdlIiwiVVNFUl9TRVNTSU9OUyIsIkFOQUxZVElDU19EQVRBIiwibWV0cmljcyIsIk1hcCIsImludmFsaWRhdGlvbkpvYnMiLCJ3YXJtdXBKb2JzIiwiaXNJbml0aWFsaXplZCIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJpbml0aWFsaXplIiwiaW5pdGlhbGl6ZVdhcm11cEpvYnMiLCJzdGFydENsZWFudXBTY2hlZHVsZXIiLCJzdGFydE1lbW9yeU1vbml0b3JpbmciLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJnZXQiLCJrZXkiLCJjb25maWciLCJjb250ZXh0Iiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImZ1bGxLZXkiLCJnZW5lcmF0ZUtleSIsInZlcmlmeUFjY2VzcyIsInJlc3VsdCIsImNhY2hlTWFuYWdlciIsInJlc3BvbnNlVGltZSIsInVwZGF0ZU1ldHJpY3MiLCJsb2dDYWNoZUFjY2VzcyIsInVwZGF0ZUVycm9yTWV0cmljcyIsInNldCIsInZhbHVlIiwidmVyaWZ5V3JpdGVBY2Nlc3MiLCJwcm9jZXNzZWRWYWx1ZSIsInN1Y2Nlc3MiLCJ1cGRhdGVTZXRNZXRyaWNzIiwic2NoZWR1bGVEZXBlbmRlbmN5SW52YWxpZGF0aW9uIiwiaW52YWxpZGF0ZSIsInBhdHRlcm4iLCJyZWFzb24iLCJhZmZlY3RlZEtleXMiLCJmaW5kS2V5c0J5UGF0dGVybiIsImRlbGV0aW9uUHJvbWlzZXMiLCJtYXAiLCJyZWRpc0NhY2hlIiwiZGVsIiwiUHJvbWlzZSIsImFsbCIsImludmFsaWRhdGlvbkV2ZW50IiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJ0cmlnZ2VyZWRCeSIsInVzZXJJZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImVudGVycHJpc2VBdWRpdFN5c3RlbSIsImxvZ0VudGVycHJpc2VFdmVudCIsInVzZXJfaWQiLCJldmVudF90eXBlIiwiZXZlbnRfY2F0ZWdvcnkiLCJzZXZlcml0eSIsImRlc2NyaXB0aW9uIiwibWV0YWRhdGEiLCJhZmZlY3RlZF9rZXlzX2NvdW50IiwibGVuZ3RoIiwiYWZmZWN0ZWRfa2V5cyIsInNsaWNlIiwiaXBfYWRkcmVzcyIsImlwQWRkcmVzcyIsInVzZXJfYWdlbnQiLCJ1c2VyQWdlbnQiLCJ3YXJtdXAiLCJrZXlzIiwiZGF0YUZldGNoZXIiLCJqb2JJZCIsIndhcm11cEpvYiIsImlkIiwiam9pbiIsInN0cmF0ZWd5IiwiaW50ZXJ2YWwiLCJsYXN0UnVuIiwic3RhdHVzIiwid2FybXVwUHJvbWlzZXMiLCJleGlzdGluZyIsImRhdGEiLCJ3YXJuIiwibmV4dFJ1biIsInVuZGVmaW5lZCIsImdldE1ldHJpY3MiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImdldEludmFsaWRhdGlvblN0YXRzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZ2V0V2FybXVwU3RhdHMiLCJwZXJtaXNzaW9ucyIsImluY2x1ZGVzIiwiRXJyb3IiLCJqc29uU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImVuY29kZWQiLCJCdWZmZXIiLCJlbmNyeXB0ZWQiLCJoaXQiLCJoaXRzIiwibWlzc2VzIiwiaGl0UmF0ZSIsImF2Z1Jlc3BvbnNlVGltZSIsIm1lbW9yeVVzYWdlIiwiZXZpY3Rpb25zIiwiZXJyb3JzIiwibGFzdEFjY2VzcyIsInRvdGFsUmVxdWVzdHMiLCJvcGVyYXRpb24iLCJjYWNoZV9zeXN0ZW0iLCJjbGllbnQiLCJzY2FuU3RyZWFtIiwic3RyZWFtIiwibWF0Y2giLCJjb3VudCIsInJlc29sdmUiLCJyZWplY3QiLCJvbiIsInJlc3VsdEtleXMiLCJwdXNoIiwic2V0VGltZW91dCIsImRlcEtleSIsInNldEludGVydmFsIiwib25lSG91ckFnbyIsImVudHJpZXMiLCJsYXN0QWNjZXNzVGltZSIsImdldFRpbWUiLCJkZWxldGUiLCJwcm9jZXNzIiwiaGVhcFVzZWQiLCJjYWNoZUF1dGhEYXRhIiwiZmV0Y2hlciIsImNhY2hlZCIsImNhY2hlUHJvZHVjdERhdGEiLCJjYWNoZVB1YmxpY0RhdGEiLCJpbnZhbGlkYXRlQnlQYXR0ZXJucyIsInBhdHRlcm5zIiwiaW52YWxpZGF0aW9uUHJvbWlzZXMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7Ozs7Ozs7Ozs7UUFzRVlBO2VBQUFBOztRQXFGQUM7ZUFBQUE7O1FBaWdCQUM7ZUFBQUE7O1FBTEFDO2VBQUFBOzs7OEJBcnBCaUQ7dUJBQ25DO3VDQUNXO0FBa0UvQixNQUFNSCwyQkFBa0U7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