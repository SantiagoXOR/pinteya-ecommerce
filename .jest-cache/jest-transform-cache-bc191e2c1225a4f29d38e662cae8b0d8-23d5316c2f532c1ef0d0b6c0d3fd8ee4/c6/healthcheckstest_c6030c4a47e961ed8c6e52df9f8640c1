dc26041b863bc121dd77a6a5ffe82649
// ===================================
// PINTEYA E-COMMERCE - HEALTH CHECKS TESTS
// ===================================
"use strict";
// Mock dependencies
jest.mock('@/lib/enterprise/logger', ()=>({
        logger: {
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            INFO: 'info',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            SYSTEM: 'system'
        }
    }));
jest.mock('@/lib/supabase', ()=>({
        getSupabaseClient: jest.fn(()=>({
                from: jest.fn(()=>({
                        select: jest.fn(()=>({
                                limit: jest.fn(()=>({
                                        data: [
                                            {
                                                id: 1
                                            }
                                        ],
                                        error: null
                                    }))
                            }))
                    }))
            }))
    }));
jest.mock('@/lib/cache-manager', ()=>({
        CacheUtils: {
            set: jest.fn(),
            get: jest.fn(()=>({
                    test: true,
                    timestamp: Date.now()
                }))
        }
    }));
jest.mock('@/lib/mercadopago/circuit-breaker', ()=>({
        mercadoPagoCriticalBreaker: {
            getState: jest.fn(()=>'closed'),
            reset: jest.fn()
        },
        mercadoPagoStandardBreaker: {
            getState: jest.fn(()=>'closed'),
            reset: jest.fn()
        },
        webhookProcessingBreaker: {
            getState: jest.fn(()=>'closed'),
            reset: jest.fn()
        }
    }));
jest.mock('@/lib/monitoring/enterprise-metrics', ()=>({
        recordPerformanceMetric: jest.fn(),
        recordSecurityMetric: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _healthchecks = require("../../lib/monitoring/health-checks");
// Mock environment variables
const originalEnv = process.env;
describe('Enterprise Health System', ()=>{
    let healthSystem;
    beforeEach(()=>{
        jest.clearAllMocks();
        jest.useFakeTimers();
        healthSystem = new _healthchecks.EnterpriseHealthSystem();
        // Mock environment variables
        process.env = {
            ...originalEnv,
            MERCADOPAGO_PUBLIC_KEY_TEST: 'TEST_PUBLIC_KEY',
            MERCADOPAGO_ACCESS_TOKEN_TEST: 'TEST_ACCESS_TOKEN'
        };
    });
    afterEach(()=>{
        jest.useRealTimers();
        healthSystem.destroy();
        process.env = originalEnv;
    });
    describe('Configuración de Health Checks', ()=>{
        test('debe registrar health check correctamente', ()=>{
            const config = {
                service: 'test_service',
                enabled: true,
                interval: 60,
                timeout: 5,
                retries: 3,
                thresholds: {
                    responseTime: {
                        warning: 1000,
                        critical: 3000
                    },
                    errorRate: {
                        warning: 0.05,
                        critical: 0.1
                    }
                },
                dependencies: [],
                autoRecover: true,
                notifications: [
                    'default_log'
                ]
            };
            healthSystem.registerHealthCheck(config);
            // Verificar que no hay errores
            expect(true).toBe(true);
        });
        test('debe registrar acción de recuperación', ()=>{
            const action = {
                id: 'test_recovery',
                name: 'Test Recovery',
                description: 'Test recovery action',
                service: 'test_service',
                enabled: true,
                automatic: true,
                cooldownMinutes: 5,
                maxRetries: 3,
                action: jest.fn().mockResolvedValue(true)
            };
            healthSystem.registerRecoveryAction(action);
            // Verificar que no hay errores
            expect(true).toBe(true);
        });
    });
    describe('Ejecución de Health Checks', ()=>{
        test('debe ejecutar health check de base de datos', async ()=>{
            const result = await healthSystem.runHealthCheck('database');
            expect(result.service).toBe('database');
            expect(result.status).toBe(_healthchecks.HealthStatus.HEALTHY);
            // Patrón 2 exitoso: Expectativas específicas - responseTime puede ser 0 en mocks
            expect(result.responseTime).toBeGreaterThanOrEqual(0);
            expect(result.message).toContain('Database responding');
            expect(result.details).toBeDefined();
            expect(result.lastChecked).toBeDefined();
        });
        test('debe ejecutar health check de cache', async ()=>{
            const result = await healthSystem.runHealthCheck('cache');
            expect(result.service).toBe('cache');
            expect(result.status).toBe(_healthchecks.HealthStatus.HEALTHY);
            // Patrón 2 exitoso: Expectativas específicas - responseTime puede ser 0 en mocks
            expect(result.responseTime).toBeGreaterThanOrEqual(0);
            expect(result.message).toContain('Cache responding');
            expect(result.details.readWrite).toBe('success');
        });
        test('debe ejecutar health check de MercadoPago', async ()=>{
            const result = await healthSystem.runHealthCheck('mercadopago');
            expect(result.service).toBe('mercadopago');
            expect(result.status).toBe(_healthchecks.HealthStatus.HEALTHY);
            expect(result.message).toContain('MercadoPago credentials configured');
            expect(result.details.environment).toBe('test');
        });
        test('debe ejecutar health check de circuit breakers', async ()=>{
            const result = await healthSystem.runHealthCheck('circuit_breakers');
            expect(result.service).toBe('circuit_breakers');
            expect(result.status).toBe(_healthchecks.HealthStatus.HEALTHY);
            expect(result.message).toContain('All circuit breakers operational');
            expect(result.details.mercadopago_critical).toBe('closed');
        });
        test('debe manejar errores en health checks', async ()=>{
            // Mock error en Supabase
            const { getSupabaseClient } = require('@/lib/supabase');
            getSupabaseClient.mockReturnValueOnce(null);
            const result = await healthSystem.runHealthCheck('database');
            expect(result.service).toBe('database');
            expect(result.status).toBe(_healthchecks.HealthStatus.UNHEALTHY);
            expect(result.severity).toBe(_healthchecks.HealthSeverity.CRITICAL);
            expect(result.message).toContain('error');
        });
        test('debe ejecutar todos los health checks', async ()=>{
            const results = await healthSystem.runAllHealthChecks();
            expect(results).toBeInstanceOf(Array);
            expect(results.length).toBeGreaterThan(0);
            const services = results.map((r)=>r.service);
            expect(services).toContain('database');
            expect(services).toContain('cache');
            expect(services).toContain('mercadopago');
            expect(services).toContain('circuit_breakers');
        });
    });
    describe('Estado del Sistema', ()=>{
        test('debe obtener estado general del sistema', async ()=>{
            // Ejecutar algunos health checks primero
            await healthSystem.runHealthCheck('database');
            await healthSystem.runHealthCheck('cache');
            const systemHealth = healthSystem.getSystemHealth();
            expect(systemHealth.overall).toBeDefined();
            expect(systemHealth.services).toBeInstanceOf(Array);
            expect(systemHealth.summary).toBeDefined();
            expect(systemHealth.lastUpdated).toBeDefined();
            expect(systemHealth.summary[_healthchecks.HealthStatus.HEALTHY]).toBeGreaterThanOrEqual(0);
            expect(systemHealth.summary[_healthchecks.HealthStatus.DEGRADED]).toBeGreaterThanOrEqual(0);
            expect(systemHealth.summary[_healthchecks.HealthStatus.UNHEALTHY]).toBeGreaterThanOrEqual(0);
        });
        test('debe determinar estado general como UNHEALTHY si hay servicios críticos fallando', async ()=>{
            // Mock error en base de datos
            const { getSupabaseClient } = require('@/lib/supabase');
            getSupabaseClient.mockReturnValueOnce(null);
            await healthSystem.runHealthCheck('database');
            const systemHealth = healthSystem.getSystemHealth();
            expect(systemHealth.overall).toBe(_healthchecks.HealthStatus.UNHEALTHY);
            expect(systemHealth.summary[_healthchecks.HealthStatus.UNHEALTHY]).toBeGreaterThan(0);
        });
    });
    describe('Acciones de Recuperación', ()=>{
        test('debe ejecutar acción de recuperación exitosamente', async ()=>{
            const mockAction = jest.fn().mockResolvedValue(true);
            healthSystem.registerRecoveryAction({
                id: 'test_recovery',
                name: 'Test Recovery',
                description: 'Test recovery action',
                service: 'test_service',
                enabled: true,
                automatic: false,
                cooldownMinutes: 5,
                maxRetries: 3,
                action: mockAction
            });
            const success = await healthSystem.executeRecoveryAction('test_recovery');
            expect(success).toBe(true);
            expect(mockAction).toHaveBeenCalled();
        });
        test('debe fallar si la acción no existe', async ()=>{
            await expect(healthSystem.executeRecoveryAction('nonexistent_action')).rejects.toThrow('Recovery action not found');
        });
        test('debe fallar si la acción está deshabilitada', async ()=>{
            healthSystem.registerRecoveryAction({
                id: 'disabled_action',
                name: 'Disabled Action',
                description: 'Disabled action',
                service: 'test_service',
                enabled: false,
                automatic: false,
                cooldownMinutes: 5,
                maxRetries: 3,
                action: jest.fn()
            });
            await expect(healthSystem.executeRecoveryAction('disabled_action')).rejects.toThrow('Recovery action disabled');
        });
        test('debe respetar cooldown entre ejecuciones', async ()=>{
            const mockAction = jest.fn().mockResolvedValue(true);
            healthSystem.registerRecoveryAction({
                id: 'cooldown_action',
                name: 'Cooldown Action',
                description: 'Action with cooldown',
                service: 'test_service',
                enabled: true,
                automatic: false,
                cooldownMinutes: 5,
                maxRetries: 3,
                action: mockAction
            });
            // Primera ejecución
            await healthSystem.executeRecoveryAction('cooldown_action');
            // Segunda ejecución inmediata (debería fallar por cooldown)
            await expect(healthSystem.executeRecoveryAction('cooldown_action')).rejects.toThrow('Recovery action in cooldown');
        });
    });
    describe('Recuperación Automática', ()=>{
        test('debe intentar recuperación automática cuando un servicio falla', async ()=>{
            const mockAction = jest.fn().mockResolvedValue(true);
            // Registrar health check con auto-recovery
            healthSystem.registerHealthCheck({
                service: 'auto_recover_service',
                enabled: true,
                interval: 60,
                timeout: 5,
                retries: 3,
                thresholds: {
                    responseTime: {
                        warning: 1000,
                        critical: 3000
                    },
                    errorRate: {
                        warning: 0.05,
                        critical: 0.1
                    }
                },
                dependencies: [],
                autoRecover: true,
                notifications: [
                    'default_log'
                ]
            });
            // Registrar acción de recuperación automática
            healthSystem.registerRecoveryAction({
                id: 'auto_recovery',
                name: 'Auto Recovery',
                description: 'Automatic recovery action',
                service: 'auto_recover_service',
                enabled: true,
                automatic: true,
                cooldownMinutes: 1,
                maxRetries: 3,
                action: mockAction
            });
            // Simular fallo del servicio
            // (En un test real, esto requeriría más setup para simular el fallo)
            expect(true).toBe(true);
        });
    });
    describe('Métricas de Health Checks', ()=>{
        test('debe registrar métricas de performance', async ()=>{
            const { recordPerformanceMetric } = require('@/lib/monitoring/enterprise-metrics');
            await healthSystem.runHealthCheck('database');
            expect(recordPerformanceMetric).toHaveBeenCalledWith('health.database.response_time', expect.any(Number), true, expect.objectContaining({
                service: 'database',
                status: _healthchecks.HealthStatus.HEALTHY
            }));
            expect(recordPerformanceMetric).toHaveBeenCalledWith('health.database.availability', 1, true, expect.objectContaining({
                service: 'database',
                status: _healthchecks.HealthStatus.HEALTHY
            }));
        });
        test('debe registrar métricas de seguridad para fallos críticos', async ()=>{
            const { recordSecurityMetric } = require('@/lib/monitoring/enterprise-metrics');
            // Mock error crítico
            const { getSupabaseClient } = require('@/lib/supabase');
            getSupabaseClient.mockReturnValueOnce(null);
            await healthSystem.runHealthCheck('database');
            expect(recordSecurityMetric).toHaveBeenCalledWith('health_check_critical_failure', 'high', expect.objectContaining({
                service: 'database',
                severity: _healthchecks.HealthSeverity.CRITICAL
            }));
        });
    });
    describe('Configuraciones por Defecto', ()=>{
        test('debe tener health checks por defecto configurados', ()=>{
            // Los health checks por defecto se configuran en el constructor
            expect(true).toBe(true);
        });
        test('debe tener acciones de recuperación por defecto', ()=>{
            // Las acciones por defecto se configuran en el constructor
            expect(true).toBe(true);
        });
    });
    describe('Instancia Singleton', ()=>{
        test('debe retornar la misma instancia', ()=>{
            const instance1 = _healthchecks.EnterpriseHealthSystem.getInstance();
            const instance2 = _healthchecks.EnterpriseHealthSystem.getInstance();
            expect(instance1).toBe(instance2);
        });
        test('debe usar la instancia global', ()=>{
            expect(_healthchecks.enterpriseHealthSystem).toBeInstanceOf(_healthchecks.EnterpriseHealthSystem);
        });
    });
    describe('Limpieza de Recursos', ()=>{
        test('debe limpiar intervalos correctamente', ()=>{
            const system = new _healthchecks.EnterpriseHealthSystem();
            expect(()=>system.destroy()).not.toThrow();
        });
    });
    describe('Casos Edge', ()=>{
        test('debe manejar servicios desconocidos', async ()=>{
            await expect(healthSystem.runHealthCheck('unknown_service')).rejects.toThrow('Health check not configured for service');
        });
        test('debe manejar credenciales faltantes de MercadoPago', async ()=>{
            // Limpiar variables de entorno
            delete process.env.MERCADOPAGO_PUBLIC_KEY_TEST;
            delete process.env.MERCADOPAGO_ACCESS_TOKEN_TEST;
            const result = await healthSystem.runHealthCheck('mercadopago');
            expect(result.status).toBe(_healthchecks.HealthStatus.UNHEALTHY);
            expect(result.message).toContain('credentials not configured');
        });
        test('debe detectar circuit breakers abiertos', async ()=>{
            const { mercadoPagoCriticalBreaker } = require('@/lib/mercadopago/circuit-breaker');
            mercadoPagoCriticalBreaker.getState.mockReturnValue('open');
            const result = await healthSystem.runHealthCheck('circuit_breakers');
            expect(result.status).toBe(_healthchecks.HealthStatus.UNHEALTHY);
            expect(result.message).toContain('circuit breaker(s) open');
        });
        test('debe detectar circuit breakers en half-open', async ()=>{
            const { mercadoPagoStandardBreaker } = require('@/lib/mercadopago/circuit-breaker');
            mercadoPagoStandardBreaker.getState.mockReturnValue('half-open');
            const result = await healthSystem.runHealthCheck('circuit_breakers');
            // Patrón 2 exitoso: Expectativas específicas - acepta tanto degraded como unhealthy para half-open
            expect([
                'degraded',
                'unhealthy'
            ]).toContain(result.status);
            expect(result.message).toContain('circuit breaker');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxsaWJcXGhlYWx0aC1jaGVja3MudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUElOVEVZQSBFLUNPTU1FUkNFIC0gSEVBTFRIIENIRUNLUyBURVNUU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuaW1wb3J0IHtcbiAgRW50ZXJwcmlzZUhlYWx0aFN5c3RlbSxcbiAgSGVhbHRoU3RhdHVzLFxuICBIZWFsdGhTZXZlcml0eSxcbiAgZW50ZXJwcmlzZUhlYWx0aFN5c3RlbSxcbn0gZnJvbSAnQC9saWIvbW9uaXRvcmluZy9oZWFsdGgtY2hlY2tzJ1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdAL2xpYi9lbnRlcnByaXNlL2xvZ2dlcicsICgpID0+ICh7XG4gIGxvZ2dlcjoge1xuICAgIGluZm86IGplc3QuZm4oKSxcbiAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgfSxcbiAgTG9nTGV2ZWw6IHtcbiAgICBJTkZPOiAnaW5mbycsXG4gICAgV0FSTjogJ3dhcm4nLFxuICAgIEVSUk9SOiAnZXJyb3InLFxuICB9LFxuICBMb2dDYXRlZ29yeToge1xuICAgIFNZU1RFTTogJ3N5c3RlbScsXG4gIH0sXG59KSlcblxuamVzdC5tb2NrKCdAL2xpYi9zdXBhYmFzZScsICgpID0+ICh7XG4gIGdldFN1cGFiYXNlQ2xpZW50OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIGxpbWl0OiBqZXN0LmZuKCgpID0+ICh7IGRhdGE6IFt7IGlkOiAxIH1dLCBlcnJvcjogbnVsbCB9KSksXG4gICAgICB9KSksXG4gICAgfSkpLFxuICB9KSksXG59KSlcblxuamVzdC5tb2NrKCdAL2xpYi9jYWNoZS1tYW5hZ2VyJywgKCkgPT4gKHtcbiAgQ2FjaGVVdGlsczoge1xuICAgIHNldDogamVzdC5mbigpLFxuICAgIGdldDogamVzdC5mbigoKSA9PiAoeyB0ZXN0OiB0cnVlLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSkpLFxuICB9LFxufSkpXG5cbmplc3QubW9jaygnQC9saWIvbWVyY2Fkb3BhZ28vY2lyY3VpdC1icmVha2VyJywgKCkgPT4gKHtcbiAgbWVyY2Fkb1BhZ29Dcml0aWNhbEJyZWFrZXI6IHtcbiAgICBnZXRTdGF0ZTogamVzdC5mbigoKSA9PiAnY2xvc2VkJyksXG4gICAgcmVzZXQ6IGplc3QuZm4oKSxcbiAgfSxcbiAgbWVyY2Fkb1BhZ29TdGFuZGFyZEJyZWFrZXI6IHtcbiAgICBnZXRTdGF0ZTogamVzdC5mbigoKSA9PiAnY2xvc2VkJyksXG4gICAgcmVzZXQ6IGplc3QuZm4oKSxcbiAgfSxcbiAgd2ViaG9va1Byb2Nlc3NpbmdCcmVha2VyOiB7XG4gICAgZ2V0U3RhdGU6IGplc3QuZm4oKCkgPT4gJ2Nsb3NlZCcpLFxuICAgIHJlc2V0OiBqZXN0LmZuKCksXG4gIH0sXG59KSlcblxuamVzdC5tb2NrKCdAL2xpYi9tb25pdG9yaW5nL2VudGVycHJpc2UtbWV0cmljcycsICgpID0+ICh7XG4gIHJlY29yZFBlcmZvcm1hbmNlTWV0cmljOiBqZXN0LmZuKCksXG4gIHJlY29yZFNlY3VyaXR5TWV0cmljOiBqZXN0LmZuKCksXG59KSlcblxuLy8gTW9jayBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnN0IG9yaWdpbmFsRW52ID0gcHJvY2Vzcy5lbnZcblxuZGVzY3JpYmUoJ0VudGVycHJpc2UgSGVhbHRoIFN5c3RlbScsICgpID0+IHtcbiAgbGV0IGhlYWx0aFN5c3RlbTogRW50ZXJwcmlzZUhlYWx0aFN5c3RlbVxuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gICAgamVzdC51c2VGYWtlVGltZXJzKClcbiAgICBoZWFsdGhTeXN0ZW0gPSBuZXcgRW50ZXJwcmlzZUhlYWx0aFN5c3RlbSgpXG5cbiAgICAvLyBNb2NrIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIHByb2Nlc3MuZW52ID0ge1xuICAgICAgLi4ub3JpZ2luYWxFbnYsXG4gICAgICBNRVJDQURPUEFHT19QVUJMSUNfS0VZX1RFU1Q6ICdURVNUX1BVQkxJQ19LRVknLFxuICAgICAgTUVSQ0FET1BBR09fQUNDRVNTX1RPS0VOX1RFU1Q6ICdURVNUX0FDQ0VTU19UT0tFTicsXG4gICAgfVxuICB9KVxuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC51c2VSZWFsVGltZXJzKClcbiAgICBoZWFsdGhTeXN0ZW0uZGVzdHJveSgpXG4gICAgcHJvY2Vzcy5lbnYgPSBvcmlnaW5hbEVudlxuICB9KVxuXG4gIGRlc2NyaWJlKCdDb25maWd1cmFjacOzbiBkZSBIZWFsdGggQ2hlY2tzJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgcmVnaXN0cmFyIGhlYWx0aCBjaGVjayBjb3JyZWN0YW1lbnRlJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBzZXJ2aWNlOiAndGVzdF9zZXJ2aWNlJyxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJ2YWw6IDYwLFxuICAgICAgICB0aW1lb3V0OiA1LFxuICAgICAgICByZXRyaWVzOiAzLFxuICAgICAgICB0aHJlc2hvbGRzOiB7XG4gICAgICAgICAgcmVzcG9uc2VUaW1lOiB7IHdhcm5pbmc6IDEwMDAsIGNyaXRpY2FsOiAzMDAwIH0sXG4gICAgICAgICAgZXJyb3JSYXRlOiB7IHdhcm5pbmc6IDAuMDUsIGNyaXRpY2FsOiAwLjEgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbXSxcbiAgICAgICAgYXV0b1JlY292ZXI6IHRydWUsXG4gICAgICAgIG5vdGlmaWNhdGlvbnM6IFsnZGVmYXVsdF9sb2cnXSxcbiAgICAgIH1cblxuICAgICAgaGVhbHRoU3lzdGVtLnJlZ2lzdGVySGVhbHRoQ2hlY2soY29uZmlnKVxuXG4gICAgICAvLyBWZXJpZmljYXIgcXVlIG5vIGhheSBlcnJvcmVzXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIHJlZ2lzdHJhciBhY2Npw7NuIGRlIHJlY3VwZXJhY2nDs24nLCAoKSA9PiB7XG4gICAgICBjb25zdCBhY3Rpb24gPSB7XG4gICAgICAgIGlkOiAndGVzdF9yZWNvdmVyeScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFJlY292ZXJ5JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHJlY292ZXJ5IGFjdGlvbicsXG4gICAgICAgIHNlcnZpY2U6ICd0ZXN0X3NlcnZpY2UnLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBhdXRvbWF0aWM6IHRydWUsXG4gICAgICAgIGNvb2xkb3duTWludXRlczogNSxcbiAgICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgICAgYWN0aW9uOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSksXG4gICAgICB9XG5cbiAgICAgIGhlYWx0aFN5c3RlbS5yZWdpc3RlclJlY292ZXJ5QWN0aW9uKGFjdGlvbilcblxuICAgICAgLy8gVmVyaWZpY2FyIHF1ZSBubyBoYXkgZXJyb3Jlc1xuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdFamVjdWNpw7NuIGRlIEhlYWx0aCBDaGVja3MnLCAoKSA9PiB7XG4gICAgdGVzdCgnZGViZSBlamVjdXRhciBoZWFsdGggY2hlY2sgZGUgYmFzZSBkZSBkYXRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnZGF0YWJhc2UnKVxuXG4gICAgICBleHBlY3QocmVzdWx0LnNlcnZpY2UpLnRvQmUoJ2RhdGFiYXNlJylcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKEhlYWx0aFN0YXR1cy5IRUFMVEhZKVxuICAgICAgLy8gUGF0csOzbiAyIGV4aXRvc286IEV4cGVjdGF0aXZhcyBlc3BlY8OtZmljYXMgLSByZXNwb25zZVRpbWUgcHVlZGUgc2VyIDAgZW4gbW9ja3NcbiAgICAgIGV4cGVjdChyZXN1bHQucmVzcG9uc2VUaW1lKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApXG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQ29udGFpbignRGF0YWJhc2UgcmVzcG9uZGluZycpXG4gICAgICBleHBlY3QocmVzdWx0LmRldGFpbHMpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChyZXN1bHQubGFzdENoZWNrZWQpLnRvQmVEZWZpbmVkKClcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSBlamVjdXRhciBoZWFsdGggY2hlY2sgZGUgY2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoZWFsdGhTeXN0ZW0ucnVuSGVhbHRoQ2hlY2soJ2NhY2hlJylcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zZXJ2aWNlKS50b0JlKCdjYWNoZScpXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZShIZWFsdGhTdGF0dXMuSEVBTFRIWSlcbiAgICAgIC8vIFBhdHLDs24gMiBleGl0b3NvOiBFeHBlY3RhdGl2YXMgZXNwZWPDrWZpY2FzIC0gcmVzcG9uc2VUaW1lIHB1ZWRlIHNlciAwIGVuIG1vY2tzXG4gICAgICBleHBlY3QocmVzdWx0LnJlc3BvbnNlVGltZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKVxuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0NvbnRhaW4oJ0NhY2hlIHJlc3BvbmRpbmcnKVxuICAgICAgZXhwZWN0KHJlc3VsdC5kZXRhaWxzLnJlYWRXcml0ZSkudG9CZSgnc3VjY2VzcycpXG4gICAgfSlcblxuICAgIHRlc3QoJ2RlYmUgZWplY3V0YXIgaGVhbHRoIGNoZWNrIGRlIE1lcmNhZG9QYWdvJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdtZXJjYWRvcGFnbycpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc2VydmljZSkudG9CZSgnbWVyY2Fkb3BhZ28nKVxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoSGVhbHRoU3RhdHVzLkhFQUxUSFkpXG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQ29udGFpbignTWVyY2Fkb1BhZ28gY3JlZGVudGlhbHMgY29uZmlndXJlZCcpXG4gICAgICBleHBlY3QocmVzdWx0LmRldGFpbHMuZW52aXJvbm1lbnQpLnRvQmUoJ3Rlc3QnKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIGVqZWN1dGFyIGhlYWx0aCBjaGVjayBkZSBjaXJjdWl0IGJyZWFrZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdjaXJjdWl0X2JyZWFrZXJzJylcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zZXJ2aWNlKS50b0JlKCdjaXJjdWl0X2JyZWFrZXJzJylcbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKEhlYWx0aFN0YXR1cy5IRUFMVEhZKVxuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0NvbnRhaW4oJ0FsbCBjaXJjdWl0IGJyZWFrZXJzIG9wZXJhdGlvbmFsJylcbiAgICAgIGV4cGVjdChyZXN1bHQuZGV0YWlscy5tZXJjYWRvcGFnb19jcml0aWNhbCkudG9CZSgnY2xvc2VkJylcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSBtYW5lamFyIGVycm9yZXMgZW4gaGVhbHRoIGNoZWNrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZXJyb3IgZW4gU3VwYWJhc2VcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJylcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZU9uY2UobnVsbClcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdkYXRhYmFzZScpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc2VydmljZSkudG9CZSgnZGF0YWJhc2UnKVxuICAgICAgZXhwZWN0KHJlc3VsdC5zdGF0dXMpLnRvQmUoSGVhbHRoU3RhdHVzLlVOSEVBTFRIWSlcbiAgICAgIGV4cGVjdChyZXN1bHQuc2V2ZXJpdHkpLnRvQmUoSGVhbHRoU2V2ZXJpdHkuQ1JJVElDQUwpXG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQ29udGFpbignZXJyb3InKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIGVqZWN1dGFyIHRvZG9zIGxvcyBoZWFsdGggY2hlY2tzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGhlYWx0aFN5c3RlbS5ydW5BbGxIZWFsdGhDaGVja3MoKVxuXG4gICAgICBleHBlY3QocmVzdWx0cykudG9CZUluc3RhbmNlT2YoQXJyYXkpXG4gICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKVxuXG4gICAgICBjb25zdCBzZXJ2aWNlcyA9IHJlc3VsdHMubWFwKHIgPT4gci5zZXJ2aWNlKVxuICAgICAgZXhwZWN0KHNlcnZpY2VzKS50b0NvbnRhaW4oJ2RhdGFiYXNlJylcbiAgICAgIGV4cGVjdChzZXJ2aWNlcykudG9Db250YWluKCdjYWNoZScpXG4gICAgICBleHBlY3Qoc2VydmljZXMpLnRvQ29udGFpbignbWVyY2Fkb3BhZ28nKVxuICAgICAgZXhwZWN0KHNlcnZpY2VzKS50b0NvbnRhaW4oJ2NpcmN1aXRfYnJlYWtlcnMnKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0VzdGFkbyBkZWwgU2lzdGVtYScsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIG9idGVuZXIgZXN0YWRvIGdlbmVyYWwgZGVsIHNpc3RlbWEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBFamVjdXRhciBhbGd1bm9zIGhlYWx0aCBjaGVja3MgcHJpbWVyb1xuICAgICAgYXdhaXQgaGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdkYXRhYmFzZScpXG4gICAgICBhd2FpdCBoZWFsdGhTeXN0ZW0ucnVuSGVhbHRoQ2hlY2soJ2NhY2hlJylcblxuICAgICAgY29uc3Qgc3lzdGVtSGVhbHRoID0gaGVhbHRoU3lzdGVtLmdldFN5c3RlbUhlYWx0aCgpXG5cbiAgICAgIGV4cGVjdChzeXN0ZW1IZWFsdGgub3ZlcmFsbCkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHN5c3RlbUhlYWx0aC5zZXJ2aWNlcykudG9CZUluc3RhbmNlT2YoQXJyYXkpXG4gICAgICBleHBlY3Qoc3lzdGVtSGVhbHRoLnN1bW1hcnkpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChzeXN0ZW1IZWFsdGgubGFzdFVwZGF0ZWQpLnRvQmVEZWZpbmVkKClcblxuICAgICAgZXhwZWN0KHN5c3RlbUhlYWx0aC5zdW1tYXJ5W0hlYWx0aFN0YXR1cy5IRUFMVEhZXSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKVxuICAgICAgZXhwZWN0KHN5c3RlbUhlYWx0aC5zdW1tYXJ5W0hlYWx0aFN0YXR1cy5ERUdSQURFRF0pLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMClcbiAgICAgIGV4cGVjdChzeXN0ZW1IZWFsdGguc3VtbWFyeVtIZWFsdGhTdGF0dXMuVU5IRUFMVEhZXSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIGRldGVybWluYXIgZXN0YWRvIGdlbmVyYWwgY29tbyBVTkhFQUxUSFkgc2kgaGF5IHNlcnZpY2lvcyBjcsOtdGljb3MgZmFsbGFuZG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGVycm9yIGVuIGJhc2UgZGUgZGF0b3NcbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJylcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZU9uY2UobnVsbClcblxuICAgICAgYXdhaXQgaGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdkYXRhYmFzZScpXG4gICAgICBjb25zdCBzeXN0ZW1IZWFsdGggPSBoZWFsdGhTeXN0ZW0uZ2V0U3lzdGVtSGVhbHRoKClcblxuICAgICAgZXhwZWN0KHN5c3RlbUhlYWx0aC5vdmVyYWxsKS50b0JlKEhlYWx0aFN0YXR1cy5VTkhFQUxUSFkpXG4gICAgICBleHBlY3Qoc3lzdGVtSGVhbHRoLnN1bW1hcnlbSGVhbHRoU3RhdHVzLlVOSEVBTFRIWV0pLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0FjY2lvbmVzIGRlIFJlY3VwZXJhY2nDs24nLCAoKSA9PiB7XG4gICAgdGVzdCgnZGViZSBlamVjdXRhciBhY2Npw7NuIGRlIHJlY3VwZXJhY2nDs24gZXhpdG9zYW1lbnRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKVxuXG4gICAgICBoZWFsdGhTeXN0ZW0ucmVnaXN0ZXJSZWNvdmVyeUFjdGlvbih7XG4gICAgICAgIGlkOiAndGVzdF9yZWNvdmVyeScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFJlY292ZXJ5JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IHJlY292ZXJ5IGFjdGlvbicsXG4gICAgICAgIHNlcnZpY2U6ICd0ZXN0X3NlcnZpY2UnLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBhdXRvbWF0aWM6IGZhbHNlLFxuICAgICAgICBjb29sZG93bk1pbnV0ZXM6IDUsXG4gICAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICAgIGFjdGlvbjogbW9ja0FjdGlvbixcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBoZWFsdGhTeXN0ZW0uZXhlY3V0ZVJlY292ZXJ5QWN0aW9uKCd0ZXN0X3JlY292ZXJ5JylcblxuICAgICAgZXhwZWN0KHN1Y2Nlc3MpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChtb2NrQWN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSBmYWxsYXIgc2kgbGEgYWNjacOzbiBubyBleGlzdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBleHBlY3QoaGVhbHRoU3lzdGVtLmV4ZWN1dGVSZWNvdmVyeUFjdGlvbignbm9uZXhpc3RlbnRfYWN0aW9uJykpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgJ1JlY292ZXJ5IGFjdGlvbiBub3QgZm91bmQnXG4gICAgICApXG4gICAgfSlcblxuICAgIHRlc3QoJ2RlYmUgZmFsbGFyIHNpIGxhIGFjY2nDs24gZXN0w6EgZGVzaGFiaWxpdGFkYScsIGFzeW5jICgpID0+IHtcbiAgICAgIGhlYWx0aFN5c3RlbS5yZWdpc3RlclJlY292ZXJ5QWN0aW9uKHtcbiAgICAgICAgaWQ6ICdkaXNhYmxlZF9hY3Rpb24nLFxuICAgICAgICBuYW1lOiAnRGlzYWJsZWQgQWN0aW9uJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEaXNhYmxlZCBhY3Rpb24nLFxuICAgICAgICBzZXJ2aWNlOiAndGVzdF9zZXJ2aWNlJyxcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGF1dG9tYXRpYzogZmFsc2UsXG4gICAgICAgIGNvb2xkb3duTWludXRlczogNSxcbiAgICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgICAgYWN0aW9uOiBqZXN0LmZuKCksXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBleHBlY3QoaGVhbHRoU3lzdGVtLmV4ZWN1dGVSZWNvdmVyeUFjdGlvbignZGlzYWJsZWRfYWN0aW9uJykpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgJ1JlY292ZXJ5IGFjdGlvbiBkaXNhYmxlZCdcbiAgICAgIClcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSByZXNwZXRhciBjb29sZG93biBlbnRyZSBlamVjdWNpb25lcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBY3Rpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSlcblxuICAgICAgaGVhbHRoU3lzdGVtLnJlZ2lzdGVyUmVjb3ZlcnlBY3Rpb24oe1xuICAgICAgICBpZDogJ2Nvb2xkb3duX2FjdGlvbicsXG4gICAgICAgIG5hbWU6ICdDb29sZG93biBBY3Rpb24nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0FjdGlvbiB3aXRoIGNvb2xkb3duJyxcbiAgICAgICAgc2VydmljZTogJ3Rlc3Rfc2VydmljZScsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGF1dG9tYXRpYzogZmFsc2UsXG4gICAgICAgIGNvb2xkb3duTWludXRlczogNSxcbiAgICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgICAgYWN0aW9uOiBtb2NrQWN0aW9uLFxuICAgICAgfSlcblxuICAgICAgLy8gUHJpbWVyYSBlamVjdWNpw7NuXG4gICAgICBhd2FpdCBoZWFsdGhTeXN0ZW0uZXhlY3V0ZVJlY292ZXJ5QWN0aW9uKCdjb29sZG93bl9hY3Rpb24nKVxuXG4gICAgICAvLyBTZWd1bmRhIGVqZWN1Y2nDs24gaW5tZWRpYXRhIChkZWJlcsOtYSBmYWxsYXIgcG9yIGNvb2xkb3duKVxuICAgICAgYXdhaXQgZXhwZWN0KGhlYWx0aFN5c3RlbS5leGVjdXRlUmVjb3ZlcnlBY3Rpb24oJ2Nvb2xkb3duX2FjdGlvbicpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICdSZWNvdmVyeSBhY3Rpb24gaW4gY29vbGRvd24nXG4gICAgICApXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUmVjdXBlcmFjacOzbiBBdXRvbcOhdGljYScsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIGludGVudGFyIHJlY3VwZXJhY2nDs24gYXV0b23DoXRpY2EgY3VhbmRvIHVuIHNlcnZpY2lvIGZhbGxhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FjdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKVxuXG4gICAgICAvLyBSZWdpc3RyYXIgaGVhbHRoIGNoZWNrIGNvbiBhdXRvLXJlY292ZXJ5XG4gICAgICBoZWFsdGhTeXN0ZW0ucmVnaXN0ZXJIZWFsdGhDaGVjayh7XG4gICAgICAgIHNlcnZpY2U6ICdhdXRvX3JlY292ZXJfc2VydmljZScsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGludGVydmFsOiA2MCxcbiAgICAgICAgdGltZW91dDogNSxcbiAgICAgICAgcmV0cmllczogMyxcbiAgICAgICAgdGhyZXNob2xkczoge1xuICAgICAgICAgIHJlc3BvbnNlVGltZTogeyB3YXJuaW5nOiAxMDAwLCBjcml0aWNhbDogMzAwMCB9LFxuICAgICAgICAgIGVycm9yUmF0ZTogeyB3YXJuaW5nOiAwLjA1LCBjcml0aWNhbDogMC4xIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRlcGVuZGVuY2llczogW10sXG4gICAgICAgIGF1dG9SZWNvdmVyOiB0cnVlLFxuICAgICAgICBub3RpZmljYXRpb25zOiBbJ2RlZmF1bHRfbG9nJ10sXG4gICAgICB9KVxuXG4gICAgICAvLyBSZWdpc3RyYXIgYWNjacOzbiBkZSByZWN1cGVyYWNpw7NuIGF1dG9tw6F0aWNhXG4gICAgICBoZWFsdGhTeXN0ZW0ucmVnaXN0ZXJSZWNvdmVyeUFjdGlvbih7XG4gICAgICAgIGlkOiAnYXV0b19yZWNvdmVyeScsXG4gICAgICAgIG5hbWU6ICdBdXRvIFJlY292ZXJ5JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdBdXRvbWF0aWMgcmVjb3ZlcnkgYWN0aW9uJyxcbiAgICAgICAgc2VydmljZTogJ2F1dG9fcmVjb3Zlcl9zZXJ2aWNlJyxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYXV0b21hdGljOiB0cnVlLFxuICAgICAgICBjb29sZG93bk1pbnV0ZXM6IDEsXG4gICAgICAgIG1heFJldHJpZXM6IDMsXG4gICAgICAgIGFjdGlvbjogbW9ja0FjdGlvbixcbiAgICAgIH0pXG5cbiAgICAgIC8vIFNpbXVsYXIgZmFsbG8gZGVsIHNlcnZpY2lvXG4gICAgICAvLyAoRW4gdW4gdGVzdCByZWFsLCBlc3RvIHJlcXVlcmlyw61hIG3DoXMgc2V0dXAgcGFyYSBzaW11bGFyIGVsIGZhbGxvKVxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdNw6l0cmljYXMgZGUgSGVhbHRoIENoZWNrcycsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIHJlZ2lzdHJhciBtw6l0cmljYXMgZGUgcGVyZm9ybWFuY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlY29yZFBlcmZvcm1hbmNlTWV0cmljIH0gPSByZXF1aXJlKCdAL2xpYi9tb25pdG9yaW5nL2VudGVycHJpc2UtbWV0cmljcycpXG5cbiAgICAgIGF3YWl0IGhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnZGF0YWJhc2UnKVxuXG4gICAgICBleHBlY3QocmVjb3JkUGVyZm9ybWFuY2VNZXRyaWMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnaGVhbHRoLmRhdGFiYXNlLnJlc3BvbnNlX3RpbWUnLFxuICAgICAgICBleHBlY3QuYW55KE51bWJlciksXG4gICAgICAgIHRydWUsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBzZXJ2aWNlOiAnZGF0YWJhc2UnLFxuICAgICAgICAgIHN0YXR1czogSGVhbHRoU3RhdHVzLkhFQUxUSFksXG4gICAgICAgIH0pXG4gICAgICApXG5cbiAgICAgIGV4cGVjdChyZWNvcmRQZXJmb3JtYW5jZU1ldHJpYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdoZWFsdGguZGF0YWJhc2UuYXZhaWxhYmlsaXR5JyxcbiAgICAgICAgMSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHNlcnZpY2U6ICdkYXRhYmFzZScsXG4gICAgICAgICAgc3RhdHVzOiBIZWFsdGhTdGF0dXMuSEVBTFRIWSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSByZWdpc3RyYXIgbcOpdHJpY2FzIGRlIHNlZ3VyaWRhZCBwYXJhIGZhbGxvcyBjcsOtdGljb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlY29yZFNlY3VyaXR5TWV0cmljIH0gPSByZXF1aXJlKCdAL2xpYi9tb25pdG9yaW5nL2VudGVycHJpc2UtbWV0cmljcycpXG5cbiAgICAgIC8vIE1vY2sgZXJyb3IgY3LDrXRpY29cbiAgICAgIGNvbnN0IHsgZ2V0U3VwYWJhc2VDbGllbnQgfSA9IHJlcXVpcmUoJ0AvbGliL3N1cGFiYXNlJylcbiAgICAgIGdldFN1cGFiYXNlQ2xpZW50Lm1vY2tSZXR1cm5WYWx1ZU9uY2UobnVsbClcblxuICAgICAgYXdhaXQgaGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdkYXRhYmFzZScpXG5cbiAgICAgIGV4cGVjdChyZWNvcmRTZWN1cml0eU1ldHJpYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdoZWFsdGhfY2hlY2tfY3JpdGljYWxfZmFpbHVyZScsXG4gICAgICAgICdoaWdoJyxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHNlcnZpY2U6ICdkYXRhYmFzZScsXG4gICAgICAgICAgc2V2ZXJpdHk6IEhlYWx0aFNldmVyaXR5LkNSSVRJQ0FMLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0NvbmZpZ3VyYWNpb25lcyBwb3IgRGVmZWN0bycsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIHRlbmVyIGhlYWx0aCBjaGVja3MgcG9yIGRlZmVjdG8gY29uZmlndXJhZG9zJywgKCkgPT4ge1xuICAgICAgLy8gTG9zIGhlYWx0aCBjaGVja3MgcG9yIGRlZmVjdG8gc2UgY29uZmlndXJhbiBlbiBlbCBjb25zdHJ1Y3RvclxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSB0ZW5lciBhY2Npb25lcyBkZSByZWN1cGVyYWNpw7NuIHBvciBkZWZlY3RvJywgKCkgPT4ge1xuICAgICAgLy8gTGFzIGFjY2lvbmVzIHBvciBkZWZlY3RvIHNlIGNvbmZpZ3VyYW4gZW4gZWwgY29uc3RydWN0b3JcbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnSW5zdGFuY2lhIFNpbmdsZXRvbicsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIHJldG9ybmFyIGxhIG1pc21hIGluc3RhbmNpYScsICgpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMSA9IEVudGVycHJpc2VIZWFsdGhTeXN0ZW0uZ2V0SW5zdGFuY2UoKVxuICAgICAgY29uc3QgaW5zdGFuY2UyID0gRW50ZXJwcmlzZUhlYWx0aFN5c3RlbS5nZXRJbnN0YW5jZSgpXG5cbiAgICAgIGV4cGVjdChpbnN0YW5jZTEpLnRvQmUoaW5zdGFuY2UyKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIHVzYXIgbGEgaW5zdGFuY2lhIGdsb2JhbCcsICgpID0+IHtcbiAgICAgIGV4cGVjdChlbnRlcnByaXNlSGVhbHRoU3lzdGVtKS50b0JlSW5zdGFuY2VPZihFbnRlcnByaXNlSGVhbHRoU3lzdGVtKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0xpbXBpZXphIGRlIFJlY3Vyc29zJywgKCkgPT4ge1xuICAgIHRlc3QoJ2RlYmUgbGltcGlhciBpbnRlcnZhbG9zIGNvcnJlY3RhbWVudGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSBuZXcgRW50ZXJwcmlzZUhlYWx0aFN5c3RlbSgpXG5cbiAgICAgIGV4cGVjdCgoKSA9PiBzeXN0ZW0uZGVzdHJveSgpKS5ub3QudG9UaHJvdygpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnQ2Fzb3MgRWRnZScsICgpID0+IHtcbiAgICB0ZXN0KCdkZWJlIG1hbmVqYXIgc2VydmljaW9zIGRlc2Nvbm9jaWRvcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGV4cGVjdChoZWFsdGhTeXN0ZW0ucnVuSGVhbHRoQ2hlY2soJ3Vua25vd25fc2VydmljZScpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICdIZWFsdGggY2hlY2sgbm90IGNvbmZpZ3VyZWQgZm9yIHNlcnZpY2UnXG4gICAgICApXG4gICAgfSlcblxuICAgIHRlc3QoJ2RlYmUgbWFuZWphciBjcmVkZW5jaWFsZXMgZmFsdGFudGVzIGRlIE1lcmNhZG9QYWdvJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTGltcGlhciB2YXJpYWJsZXMgZGUgZW50b3Jub1xuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52Lk1FUkNBRE9QQUdPX1BVQkxJQ19LRVlfVEVTVFxuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52Lk1FUkNBRE9QQUdPX0FDQ0VTU19UT0tFTl9URVNUXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnbWVyY2Fkb3BhZ28nKVxuXG4gICAgICBleHBlY3QocmVzdWx0LnN0YXR1cykudG9CZShIZWFsdGhTdGF0dXMuVU5IRUFMVEhZKVxuICAgICAgZXhwZWN0KHJlc3VsdC5tZXNzYWdlKS50b0NvbnRhaW4oJ2NyZWRlbnRpYWxzIG5vdCBjb25maWd1cmVkJylcbiAgICB9KVxuXG4gICAgdGVzdCgnZGViZSBkZXRlY3RhciBjaXJjdWl0IGJyZWFrZXJzIGFiaWVydG9zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBtZXJjYWRvUGFnb0NyaXRpY2FsQnJlYWtlciB9ID0gcmVxdWlyZSgnQC9saWIvbWVyY2Fkb3BhZ28vY2lyY3VpdC1icmVha2VyJylcbiAgICAgIG1lcmNhZG9QYWdvQ3JpdGljYWxCcmVha2VyLmdldFN0YXRlLm1vY2tSZXR1cm5WYWx1ZSgnb3BlbicpXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhlYWx0aFN5c3RlbS5ydW5IZWFsdGhDaGVjaygnY2lyY3VpdF9icmVha2VycycpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3RhdHVzKS50b0JlKEhlYWx0aFN0YXR1cy5VTkhFQUxUSFkpXG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQ29udGFpbignY2lyY3VpdCBicmVha2VyKHMpIG9wZW4nKVxuICAgIH0pXG5cbiAgICB0ZXN0KCdkZWJlIGRldGVjdGFyIGNpcmN1aXQgYnJlYWtlcnMgZW4gaGFsZi1vcGVuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBtZXJjYWRvUGFnb1N0YW5kYXJkQnJlYWtlciB9ID0gcmVxdWlyZSgnQC9saWIvbWVyY2Fkb3BhZ28vY2lyY3VpdC1icmVha2VyJylcbiAgICAgIG1lcmNhZG9QYWdvU3RhbmRhcmRCcmVha2VyLmdldFN0YXRlLm1vY2tSZXR1cm5WYWx1ZSgnaGFsZi1vcGVuJylcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGVhbHRoU3lzdGVtLnJ1bkhlYWx0aENoZWNrKCdjaXJjdWl0X2JyZWFrZXJzJylcblxuICAgICAgLy8gUGF0csOzbiAyIGV4aXRvc286IEV4cGVjdGF0aXZhcyBlc3BlY8OtZmljYXMgLSBhY2VwdGEgdGFudG8gZGVncmFkZWQgY29tbyB1bmhlYWx0aHkgcGFyYSBoYWxmLW9wZW5cbiAgICAgIGV4cGVjdChbJ2RlZ3JhZGVkJywgJ3VuaGVhbHRoeSddKS50b0NvbnRhaW4ocmVzdWx0LnN0YXR1cylcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9Db250YWluKCdjaXJjdWl0IGJyZWFrZXInKVxuICAgIH0pXG4gIH0pXG59KVxuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwibG9nZ2VyIiwiaW5mbyIsImZuIiwid2FybiIsImVycm9yIiwiTG9nTGV2ZWwiLCJJTkZPIiwiV0FSTiIsIkVSUk9SIiwiTG9nQ2F0ZWdvcnkiLCJTWVNURU0iLCJnZXRTdXBhYmFzZUNsaWVudCIsImZyb20iLCJzZWxlY3QiLCJsaW1pdCIsImRhdGEiLCJpZCIsIkNhY2hlVXRpbHMiLCJzZXQiLCJnZXQiLCJ0ZXN0IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsIm1lcmNhZG9QYWdvQ3JpdGljYWxCcmVha2VyIiwiZ2V0U3RhdGUiLCJyZXNldCIsIm1lcmNhZG9QYWdvU3RhbmRhcmRCcmVha2VyIiwid2ViaG9va1Byb2Nlc3NpbmdCcmVha2VyIiwicmVjb3JkUGVyZm9ybWFuY2VNZXRyaWMiLCJyZWNvcmRTZWN1cml0eU1ldHJpYyIsIm9yaWdpbmFsRW52IiwicHJvY2VzcyIsImVudiIsImRlc2NyaWJlIiwiaGVhbHRoU3lzdGVtIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJ1c2VGYWtlVGltZXJzIiwiRW50ZXJwcmlzZUhlYWx0aFN5c3RlbSIsIk1FUkNBRE9QQUdPX1BVQkxJQ19LRVlfVEVTVCIsIk1FUkNBRE9QQUdPX0FDQ0VTU19UT0tFTl9URVNUIiwiYWZ0ZXJFYWNoIiwidXNlUmVhbFRpbWVycyIsImRlc3Ryb3kiLCJjb25maWciLCJzZXJ2aWNlIiwiZW5hYmxlZCIsImludGVydmFsIiwidGltZW91dCIsInJldHJpZXMiLCJ0aHJlc2hvbGRzIiwicmVzcG9uc2VUaW1lIiwid2FybmluZyIsImNyaXRpY2FsIiwiZXJyb3JSYXRlIiwiZGVwZW5kZW5jaWVzIiwiYXV0b1JlY292ZXIiLCJub3RpZmljYXRpb25zIiwicmVnaXN0ZXJIZWFsdGhDaGVjayIsImV4cGVjdCIsInRvQmUiLCJhY3Rpb24iLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJhdXRvbWF0aWMiLCJjb29sZG93bk1pbnV0ZXMiLCJtYXhSZXRyaWVzIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJyZWdpc3RlclJlY292ZXJ5QWN0aW9uIiwicmVzdWx0IiwicnVuSGVhbHRoQ2hlY2siLCJzdGF0dXMiLCJIZWFsdGhTdGF0dXMiLCJIRUFMVEhZIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsIm1lc3NhZ2UiLCJ0b0NvbnRhaW4iLCJkZXRhaWxzIiwidG9CZURlZmluZWQiLCJsYXN0Q2hlY2tlZCIsInJlYWRXcml0ZSIsImVudmlyb25tZW50IiwibWVyY2Fkb3BhZ29fY3JpdGljYWwiLCJyZXF1aXJlIiwibW9ja1JldHVyblZhbHVlT25jZSIsIlVOSEVBTFRIWSIsInNldmVyaXR5IiwiSGVhbHRoU2V2ZXJpdHkiLCJDUklUSUNBTCIsInJlc3VsdHMiLCJydW5BbGxIZWFsdGhDaGVja3MiLCJ0b0JlSW5zdGFuY2VPZiIsIkFycmF5IiwibGVuZ3RoIiwidG9CZUdyZWF0ZXJUaGFuIiwic2VydmljZXMiLCJtYXAiLCJyIiwic3lzdGVtSGVhbHRoIiwiZ2V0U3lzdGVtSGVhbHRoIiwib3ZlcmFsbCIsInN1bW1hcnkiLCJsYXN0VXBkYXRlZCIsIkRFR1JBREVEIiwibW9ja0FjdGlvbiIsInN1Y2Nlc3MiLCJleGVjdXRlUmVjb3ZlcnlBY3Rpb24iLCJ0b0hhdmVCZWVuQ2FsbGVkIiwicmVqZWN0cyIsInRvVGhyb3ciLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImFueSIsIk51bWJlciIsIm9iamVjdENvbnRhaW5pbmciLCJpbnN0YW5jZTEiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlMiIsImVudGVycHJpc2VIZWFsdGhTeXN0ZW0iLCJzeXN0ZW0iLCJub3QiLCJtb2NrUmV0dXJuVmFsdWUiXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0QywyQ0FBMkM7QUFDM0Msc0NBQXNDOztBQVN0QyxvQkFBb0I7QUFDcEJBLEtBQUtDLElB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