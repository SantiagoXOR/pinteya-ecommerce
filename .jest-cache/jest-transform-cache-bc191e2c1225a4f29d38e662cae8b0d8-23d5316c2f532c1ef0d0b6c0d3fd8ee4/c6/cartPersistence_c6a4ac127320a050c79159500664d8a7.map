{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\redux\\middleware\\cartPersistence.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - CART PERSISTENCE MIDDLEWARE\n// ===================================\n\nimport { Middleware, AnyAction } from '@reduxjs/toolkit'\nimport { RootState } from '../store'\n\n// Clave para localStorage\nconst CART_STORAGE_KEY = 'pinteya-cart'\n\n// Definición de CartItem (importada desde cart-slice)\nexport interface CartItem {\n  id: number\n  title: string\n  price: number\n  discountedPrice: number\n  quantity: number\n  imgs?: {\n    thumbnails: string[]\n    previews: string[]\n  }\n}\n\n// Tipos para el estado persistido\ninterface PersistedCartState {\n  items: CartItem[]\n  timestamp: number\n  version: string\n}\n\n// Función para cargar el carrito desde localStorage\nexport const loadCartFromStorage = (): CartItem[] => {\n  // Solo ejecutar en el cliente\n  if (typeof window === 'undefined') {\n    return []\n  }\n\n  try {\n    const stored = localStorage.getItem(CART_STORAGE_KEY)\n    if (!stored || stored.trim() === '' || stored === '\"\"' || stored === \"''\") {\n      return []\n    }\n\n    // Validar que el string no esté corrupto\n    if (stored.includes('\"\"') && stored.length < 5) {\n      console.warn('Detected corrupted cart localStorage data, cleaning up')\n      localStorage.removeItem(CART_STORAGE_KEY)\n      return []\n    }\n\n    const parsed: PersistedCartState = JSON.parse(stored)\n\n    // Verificar estructura válida\n    if (!parsed || typeof parsed !== 'object') {\n      console.warn('Invalid cart data structure, cleaning up')\n      localStorage.removeItem(CART_STORAGE_KEY)\n      return []\n    }\n\n    // Verificar que no sea muy antiguo (7 días)\n    const maxAge = 7 * 24 * 60 * 60 * 1000 // 7 días en ms\n    const isExpired = parsed.timestamp && Date.now() - parsed.timestamp > maxAge\n\n    if (isExpired) {\n      localStorage.removeItem(CART_STORAGE_KEY)\n      return []\n    }\n\n    return parsed.items || []\n  } catch (error) {\n    console.warn('Error loading cart from localStorage:', error)\n    // Limpiar localStorage corrupto\n    localStorage.removeItem(CART_STORAGE_KEY)\n    return []\n  }\n}\n\n// Función para guardar el carrito en localStorage\nconst saveCartToStorage = (cartItems: CartItem[]): void => {\n  // Solo ejecutar en el cliente\n  if (typeof window === 'undefined') {\n    return\n  }\n\n  try {\n    // Si el carrito está vacío, limpiar localStorage\n    if (cartItems.length === 0) {\n      localStorage.removeItem(CART_STORAGE_KEY)\n      return\n    }\n\n    const dataToStore: PersistedCartState = {\n      items: cartItems,\n      timestamp: Date.now(),\n      version: '1.0.0',\n    }\n\n    localStorage.setItem(CART_STORAGE_KEY, JSON.stringify(dataToStore))\n  } catch (error) {\n    console.warn('Error saving cart to localStorage:', error)\n  }\n}\n\n// Función para limpiar el carrito del localStorage\nexport const clearCartFromStorage = (): void => {\n  if (typeof window === 'undefined') {\n    return\n  }\n\n  try {\n    localStorage.removeItem(CART_STORAGE_KEY)\n  } catch (error) {\n    console.warn('Error clearing cart from localStorage:', error)\n  }\n}\n\n// Variable para manejar debounce\nlet saveTimeout: NodeJS.Timeout | null = null\n\n// Middleware para persistir el carrito automáticamente\nexport const cartPersistenceMiddleware: Middleware = store => next => (action: AnyAction) => {\n  // Ejecutar la acción primero\n  const result = next(action)\n\n  // Solo persistir acciones relacionadas con el carrito\n  if (action.type?.startsWith('cart/')) {\n    const state = store.getState() as RootState\n    const cartItems = state.cartReducer.items\n\n    // Limpiar timeout anterior si existe\n    if (saveTimeout) {\n      clearTimeout(saveTimeout)\n    }\n\n    // Guardar en localStorage con debounce más largo para evitar escrituras excesivas\n    saveTimeout = setTimeout(() => {\n      // Solo guardar si hay items o si se está vaciando el carrito\n      if (cartItems.length > 0 || action.type === 'cart/removeAllItemsFromCart') {\n        saveCartToStorage(cartItems)\n      }\n      saveTimeout = null\n    }, 500) // Aumentado de 100ms a 500ms\n  }\n\n  return result\n}\n\n// Hook personalizado para manejar la persistencia del carrito\nexport const useCartPersistence = () => {\n  const loadCart = () => loadCartFromStorage()\n  const clearCart = () => clearCartFromStorage()\n\n  return {\n    loadCart,\n    clearCart,\n  }\n}\n\n// Función para migrar carrito temporal a usuario autenticado\nexport const migrateTemporaryCart = async (\n  temporaryCartItems: CartItem[],\n  userId: string\n): Promise<boolean> => {\n  try {\n    // Aquí se podría implementar la lógica para guardar el carrito\n    // en la base de datos asociado al usuario\n    // Por ahora, simplemente limpiamos el localStorage\n    // ya que el carrito se mantendrá en Redux\n\n    // En una implementación completa, aquí haríamos:\n    // 1. Enviar los items al backend para asociarlos al usuario\n    // 2. Limpiar el localStorage\n    // 3. Cargar el carrito del usuario desde el backend\n\n    return true\n  } catch (error) {\n    console.error('Error migrating temporary cart:', error)\n    return false\n  }\n}\n\n// Función para cargar carrito de usuario autenticado\nexport const loadUserCart = async (userId: string): Promise<CartItem[]> => {\n  try {\n    // Aquí se implementaría la lógica para cargar el carrito\n    // del usuario desde la base de datos\n\n    // En una implementación completa, aquí haríamos:\n    // 1. Hacer una petición al backend para obtener el carrito del usuario\n    // 2. Retornar los items del carrito\n\n    // Por ahora, retornamos un array vacío\n    return []\n  } catch (error) {\n    console.error('Error loading user cart:', error)\n    return []\n  }\n}\n\n// Función para guardar carrito de usuario autenticado\nexport const saveUserCart = async (userId: string, cartItems: CartItem[]): Promise<boolean> => {\n  try {\n    // Aquí se implementaría la lógica para guardar el carrito\n    // del usuario en la base de datos\n\n    // En una implementación completa, aquí haríamos:\n    // 1. Enviar los items al backend para guardarlos asociados al usuario\n    // 2. Manejar la respuesta del backend\n\n    return true\n  } catch (error) {\n    console.error('Error saving user cart:', error)\n    return false\n  }\n}\n"],"names":["cartPersistenceMiddleware","clearCartFromStorage","loadCartFromStorage","loadUserCart","migrateTemporaryCart","saveUserCart","useCartPersistence","CART_STORAGE_KEY","window","stored","localStorage","getItem","trim","includes","length","console","warn","removeItem","parsed","JSON","parse","maxAge","isExpired","timestamp","Date","now","items","error","saveCartToStorage","cartItems","dataToStore","version","setItem","stringify","saveTimeout","store","next","action","result","type","startsWith","state","getState","cartReducer","clearTimeout","setTimeout","loadCart","clearCart","temporaryCartItems","userId"],"mappings":"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"}