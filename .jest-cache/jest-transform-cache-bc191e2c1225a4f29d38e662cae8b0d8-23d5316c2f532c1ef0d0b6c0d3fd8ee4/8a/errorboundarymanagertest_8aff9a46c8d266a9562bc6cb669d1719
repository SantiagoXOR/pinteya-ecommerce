7086ee33f60bf68ea28024abafe47c7f
/**
 * @jest-environment jsdom
 */ // ===================================
// ERROR BOUNDARY MANAGER TESTS
// ===================================
// Tests para el sistema centralizado de gestión de Error Boundaries
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _errorboundarymanager = require("../../src/lib/error-boundary/error-boundary-manager");
// ===================================
// MOCKS
// ===================================
// Mock de fetch
global.fetch = jest.fn();
// Mock de console
const originalConsoleError = console.error;
const originalConsoleLog = console.log;
const originalConsoleWarn = console.warn;
beforeEach(()=>{
    console.error = jest.fn();
    console.log = jest.fn();
    console.warn = jest.fn();
    jest.clearAllMocks();
    fetch.mockClear();
    // Limpiar errores anteriores y forzar limpieza completa
    _errorboundarymanager.errorBoundaryManager.clearOldErrors(0);
    // Forzar limpieza adicional accediendo a la instancia privada
    const manager = _errorboundarymanager.errorBoundaryManager;
    manager.errors.clear();
    manager.patterns.clear();
});
afterEach(()=>{
    console.error = originalConsoleError;
    console.log = originalConsoleLog;
    console.warn = originalConsoleWarn;
});
// ===================================
// TESTS DE CONFIGURACIÓN
// ===================================
describe('ErrorBoundaryManager - Configuración', ()=>{
    test('devuelve configuración por defecto para niveles conocidos', ()=>{
        const pageConfig = _errorboundarymanager.errorBoundaryManager.getConfig('page');
        expect(pageConfig).toEqual({
            level: 'page',
            enableRetry: true,
            maxRetries: 2,
            retryDelay: 2000,
            enableAutoRecovery: true,
            recoveryTimeout: 5000,
            enableReporting: true
        });
        const sectionConfig = _errorboundarymanager.errorBoundaryManager.getConfig('section');
        expect(sectionConfig).toEqual({
            level: 'section',
            enableRetry: true,
            maxRetries: 3,
            retryDelay: 1000,
            enableAutoRecovery: true,
            recoveryTimeout: 3000,
            enableReporting: true
        });
        const componentConfig = _errorboundarymanager.errorBoundaryManager.getConfig('component');
        expect(componentConfig).toEqual({
            level: 'component',
            enableRetry: true,
            maxRetries: 5,
            retryDelay: 500,
            enableAutoRecovery: true,
            recoveryTimeout: 2000,
            enableReporting: false
        });
    });
    test('devuelve configuración de componente para niveles desconocidos', ()=>{
        const unknownConfig = _errorboundarymanager.errorBoundaryManager.getConfig('unknown');
        expect(unknownConfig.level).toBe('component');
    });
    test('permite actualizar configuración', ()=>{
        _errorboundarymanager.errorBoundaryManager.updateConfig('page', {
            maxRetries: 5,
            retryDelay: 3000
        });
        const updatedConfig = _errorboundarymanager.errorBoundaryManager.getConfig('page');
        expect(updatedConfig.maxRetries).toBe(5);
        expect(updatedConfig.retryDelay).toBe(3000);
        expect(updatedConfig.level).toBe('page'); // Otros valores se mantienen
    });
});
// ===================================
// TESTS DE REPORTE DE ERRORES
// ===================================
describe('ErrorBoundaryManager - Reporte de Errores', ()=>{
    test('reporta y almacena errores correctamente', ()=>{
        const error = new Error('Test error');
        const errorInfo = {
            componentStack: 'at TestComponent'
        };
        const context = {
            errorId: 'test-error-1',
            level: 'component',
            component: 'TestComponent',
            retryCount: 0
        };
        _errorboundarymanager.errorBoundaryManager.reportError(error, errorInfo, context);
        const metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(metrics.totalErrors).toBe(1);
        expect(metrics.errorsByComponent['TestComponent']).toBe(1);
        expect(metrics.errorsByType['UnknownError']).toBe(1);
    });
    test('clasifica errores correctamente', ()=>{
        const chunkError = new Error('Loading chunk 123 failed');
        const networkError = new Error('Network request failed');
        const typeError = new TypeError('Cannot read property');
        const reactError = new Error('Render error');
        reactError.stack = 'at React.Component.render';
        // Reportar diferentes tipos de errores
        _errorboundarymanager.errorBoundaryManager.reportError(chunkError, {
            componentStack: ''
        }, {
            errorId: 'chunk-1',
            level: 'page',
            component: 'App',
            retryCount: 0
        });
        _errorboundarymanager.errorBoundaryManager.reportError(networkError, {
            componentStack: ''
        }, {
            errorId: 'network-1',
            level: 'section',
            component: 'DataLoader',
            retryCount: 0
        });
        _errorboundarymanager.errorBoundaryManager.reportError(typeError, {
            componentStack: ''
        }, {
            errorId: 'type-1',
            level: 'component',
            component: 'UserProfile',
            retryCount: 0
        });
        _errorboundarymanager.errorBoundaryManager.reportError(reactError, {
            componentStack: ''
        }, {
            errorId: 'react-1',
            level: 'component',
            component: 'ProductCard',
            retryCount: 0
        });
        const metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(metrics.errorsByType['ChunkLoadError']).toBe(1);
        expect(metrics.errorsByType['NetworkError']).toBe(1);
        expect(metrics.errorsByType['TypeError']).toBe(1);
        expect(metrics.errorsByType['ReactError']).toBe(1);
    });
    test('evalúa impacto del usuario correctamente', ()=>{
        const pageError = new Error('Page error');
        const sectionError = new Error('Section error');
        const componentError = new Error('Component error');
        const chunkError = new Error('Loading chunk failed');
        _errorboundarymanager.errorBoundaryManager.reportError(pageError, {
            componentStack: ''
        }, {
            errorId: 'page-1',
            level: 'page',
            component: 'HomePage',
            retryCount: 0
        });
        _errorboundarymanager.errorBoundaryManager.reportError(sectionError, {
            componentStack: ''
        }, {
            errorId: 'section-1',
            level: 'section',
            component: 'ProductList',
            retryCount: 0
        });
        _errorboundarymanager.errorBoundaryManager.reportError(componentError, {
            componentStack: ''
        }, {
            errorId: 'component-1',
            level: 'component',
            component: 'Button',
            retryCount: 0
        });
        _errorboundarymanager.errorBoundaryManager.reportError(chunkError, {
            componentStack: ''
        }, {
            errorId: 'chunk-1',
            level: 'component',
            component: 'LazyComponent',
            retryCount: 0
        });
        const metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(metrics.errorsByImpact['critical']).toBe(1); // page error
        expect(metrics.errorsByImpact['high']).toBe(2); // section error + chunk error (high priority)
        expect(metrics.errorsByImpact['medium']).toBeUndefined(); // no medium errors
        expect(metrics.errorsByImpact['low']).toBe(1); // component error
    });
});
// ===================================
// TESTS DE DETECCIÓN DE PATRONES
// ===================================
describe('ErrorBoundaryManager - Detección de Patrones', ()=>{
    test('detecta patrones de errores frecuentes', ()=>{
        const error = new Error('Repeated error');
        // Reportar el mismo error múltiples veces
        for(let i = 0; i < 5; i++){
            _errorboundarymanager.errorBoundaryManager.reportError(error, {
                componentStack: ''
            }, {
                errorId: `repeat-${i}`,
                level: 'component',
                component: 'ProblematicComponent',
                retryCount: 0
            });
        }
        const metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(metrics.patterns.length).toBeGreaterThan(0);
        const pattern = metrics.patterns.find((p)=>p.pattern.includes('Error:ProblematicComponent'));
        expect(pattern).toBeDefined();
        expect(pattern?.frequency).toBe(5);
        expect(pattern?.affectedComponents).toContain('ProblematicComponent');
    });
    test('proporciona sugerencias de corrección para patrones conocidos', ()=>{
        const chunkError = new Error('Loading chunk failed');
        const networkError = new Error('Network timeout');
        const typeError = new TypeError('Cannot read property');
        _errorboundarymanager.errorBoundaryManager.reportError(chunkError, {
            componentStack: ''
        }, {
            errorId: 'chunk-1',
            level: 'component',
            component: 'LazyComponent',
            retryCount: 0
        });
        _errorboundarymanager.errorBoundaryManager.reportError(networkError, {
            componentStack: ''
        }, {
            errorId: 'network-1',
            level: 'component',
            component: 'ApiClient',
            retryCount: 0
        });
        _errorboundarymanager.errorBoundaryManager.reportError(typeError, {
            componentStack: ''
        }, {
            errorId: 'type-1',
            level: 'component',
            component: 'DataProcessor',
            retryCount: 0
        });
        const metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        const chunkPattern = metrics.patterns.find((p)=>p.pattern.includes('ChunkLoadError'));
        expect(chunkPattern?.suggestedFix).toBeDefined();
        expect(chunkPattern?.suggestedFix).toContain('chunk retry logic');
        const networkPattern = metrics.patterns.find((p)=>p.pattern.includes('NetworkError'));
        expect(networkPattern?.suggestedFix).toBeDefined();
        expect(networkPattern?.suggestedFix).toContain('network retry');
        const typePattern = metrics.patterns.find((p)=>p.pattern.includes('TypeError'));
        expect(typePattern?.suggestedFix).toBeDefined();
        expect(typePattern?.suggestedFix).toContain('null/undefined checks');
    });
});
// ===================================
// TESTS DE LISTENERS
// ===================================
describe('ErrorBoundaryManager - Listeners', ()=>{
    test('notifica a listeners cuando se reportan errores', ()=>{
        const listener = jest.fn();
        _errorboundarymanager.errorBoundaryManager.addErrorListener(listener);
        const error = new Error('Test error');
        _errorboundarymanager.errorBoundaryManager.reportError(error, {
            componentStack: ''
        }, {
            errorId: 'test-1',
            level: 'component',
            component: 'TestComponent',
            retryCount: 0
        });
        expect(listener).toHaveBeenCalledWith(expect.objectContaining({
            errorId: 'test-1',
            component: 'TestComponent',
            level: 'component'
        }));
        _errorboundarymanager.errorBoundaryManager.removeErrorListener(listener);
    });
    test('permite remover listeners', ()=>{
        const listener = jest.fn();
        _errorboundarymanager.errorBoundaryManager.addErrorListener(listener);
        _errorboundarymanager.errorBoundaryManager.removeErrorListener(listener);
        const error = new Error('Test error');
        _errorboundarymanager.errorBoundaryManager.reportError(error, {
            componentStack: ''
        }, {
            errorId: 'test-1',
            level: 'component',
            component: 'TestComponent',
            retryCount: 0
        });
        expect(listener).not.toHaveBeenCalled();
    });
    test('maneja errores en listeners sin afectar el flujo principal', ()=>{
        const faultyListener = jest.fn(()=>{
            throw new Error('Listener error');
        });
        const goodListener = jest.fn();
        _errorboundarymanager.errorBoundaryManager.addErrorListener(faultyListener);
        _errorboundarymanager.errorBoundaryManager.addErrorListener(goodListener);
        const error = new Error('Test error');
        _errorboundarymanager.errorBoundaryManager.reportError(error, {
            componentStack: ''
        }, {
            errorId: 'test-1',
            level: 'component',
            component: 'TestComponent',
            retryCount: 0
        });
        expect(faultyListener).toHaveBeenCalled();
        expect(goodListener).toHaveBeenCalled();
        expect(console.error).toHaveBeenCalledWith('❌ Error in error listener:', expect.any(Error));
        _errorboundarymanager.errorBoundaryManager.removeErrorListener(faultyListener);
        _errorboundarymanager.errorBoundaryManager.removeErrorListener(goodListener);
    });
});
// ===================================
// TESTS DE MÉTRICAS Y REPORTES
// ===================================
describe('ErrorBoundaryManager - Métricas y Reportes', ()=>{
    test('calcula métricas correctamente', ()=>{
        // Reportar varios errores
        const errors = [
            {
                type: 'TypeError',
                component: 'ComponentA',
                level: 'component',
                impact: 'low'
            },
            {
                type: 'NetworkError',
                component: 'ComponentB',
                level: 'section',
                impact: 'medium'
            },
            {
                type: 'TypeError',
                component: 'ComponentA',
                level: 'component',
                impact: 'low'
            },
            {
                type: 'ChunkLoadError',
                component: 'ComponentC',
                level: 'page',
                impact: 'critical'
            }
        ];
        errors.forEach((errorData, index)=>{
            const error = new Error(`${errorData.type} message`);
            if (errorData.type === 'TypeError') error.name = 'TypeError';
            if (errorData.type === 'NetworkError') error.message = 'Network failed';
            if (errorData.type === 'ChunkLoadError') error.message = 'Loading chunk failed';
            _errorboundarymanager.errorBoundaryManager.reportError(error, {
                componentStack: ''
            }, {
                errorId: `error-${index}`,
                level: errorData.level,
                component: errorData.component,
                retryCount: 0
            });
        });
        const metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(metrics.totalErrors).toBe(4);
        expect(metrics.errorsByType['TypeError']).toBe(2);
        expect(metrics.errorsByType['NetworkError']).toBe(1);
        expect(metrics.errorsByType['ChunkLoadError']).toBe(1);
        expect(metrics.errorsByComponent['ComponentA']).toBe(2);
        expect(metrics.errorsByComponent['ComponentB']).toBe(1);
        expect(metrics.errorsByComponent['ComponentC']).toBe(1);
    });
    test('proporciona errores recientes ordenados por timestamp', ()=>{
        const now = Date.now();
        // Reportar errores con diferentes timestamps
        for(let i = 0; i < 15; i++){
            const error = new Error(`Error ${i}`);
            _errorboundarymanager.errorBoundaryManager.reportError(error, {
                componentStack: ''
            }, {
                errorId: `error-${i}`,
                level: 'component',
                component: `Component${i}`,
                retryCount: 0
            });
        }
        const metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        // Debería devolver solo los 10 más recientes
        expect(metrics.recentErrors.length).toBe(10);
        // Deberían estar ordenados por timestamp descendente
        for(let i = 0; i < metrics.recentErrors.length - 1; i++){
            expect(metrics.recentErrors[i].timestamp).toBeGreaterThanOrEqual(metrics.recentErrors[i + 1].timestamp);
        }
    });
});
// ===================================
// TESTS DE ESTADO DE SALUD
// ===================================
describe('ErrorBoundaryManager - Estado de Salud', ()=>{
    test('reporta estado saludable cuando no hay errores', ()=>{
        const healthStatus = _errorboundarymanager.errorBoundaryManager.getHealthStatus();
        expect(healthStatus.status).toBe('healthy');
        expect(healthStatus.errorRate).toBe(0);
        expect(healthStatus.criticalErrors).toBe(0);
        expect(healthStatus.recommendations).toEqual([]);
    });
    test('reporta estado crítico cuando hay errores críticos', ()=>{
        const criticalError = new Error('Critical page error');
        _errorboundarymanager.errorBoundaryManager.reportError(criticalError, {
            componentStack: ''
        }, {
            errorId: 'critical-1',
            level: 'page',
            component: 'HomePage',
            retryCount: 0
        });
        const healthStatus = _errorboundarymanager.errorBoundaryManager.getHealthStatus();
        expect(healthStatus.status).toBe('critical');
        expect(healthStatus.criticalErrors).toBe(1);
        expect(healthStatus.recommendations).toContain('Resolver errores críticos inmediatamente');
    });
    test('reporta estado degradado con alta tasa de errores', ()=>{
        // Simular muchos errores recientes
        for(let i = 0; i < 10; i++){
            const error = new Error(`Error ${i}`);
            _errorboundarymanager.errorBoundaryManager.reportError(error, {
                componentStack: ''
            }, {
                errorId: `error-${i}`,
                level: 'component',
                component: `Component${i}`,
                retryCount: 0
            });
        }
        const healthStatus = _errorboundarymanager.errorBoundaryManager.getHealthStatus();
        expect(healthStatus.status).toBe('degraded');
        expect(healthStatus.recommendations).toContain('Alta tasa de errores detectada');
    });
    test('detecta patrones frecuentes en recomendaciones', ()=>{
        const error = new Error('Frequent error');
        // Reportar el mismo error múltiples veces
        for(let i = 0; i < 5; i++){
            _errorboundarymanager.errorBoundaryManager.reportError(error, {
                componentStack: ''
            }, {
                errorId: `frequent-${i}`,
                level: 'component',
                component: 'ProblematicComponent',
                retryCount: 0
            });
        }
        const healthStatus = _errorboundarymanager.errorBoundaryManager.getHealthStatus();
        expect(healthStatus.recommendations).toContain('Revisar patrones de errores frecuentes');
    });
});
// ===================================
// TESTS DE LIMPIEZA
// ===================================
describe('ErrorBoundaryManager - Limpieza', ()=>{
    test('limpia errores antiguos correctamente', ()=>{
        // Limpiar errores existentes primero
        _errorboundarymanager.errorBoundaryManager.clearOldErrors(0);
        // Mock Date.now para simular errores antiguos
        const originalDateNow = Date.now;
        const oldTimestamp = Date.now() - 25 * 60 * 60 * 1000; // 25 horas atrás
        // Simular error antiguo
        Date.now = jest.fn(()=>oldTimestamp);
        const oldError = new Error('Old error');
        _errorboundarymanager.errorBoundaryManager.reportError(oldError, {
            componentStack: ''
        }, {
            errorId: 'old-1',
            level: 'component',
            component: 'OldComponent',
            retryCount: 0
        });
        // Restaurar Date.now y reportar error reciente
        Date.now = originalDateNow;
        const recentError = new Error('Recent error');
        _errorboundarymanager.errorBoundaryManager.reportError(recentError, {
            componentStack: ''
        }, {
            errorId: 'recent-1',
            level: 'component',
            component: 'RecentComponent',
            retryCount: 0
        });
        // Verificar que ambos errores están presentes
        let metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(metrics.totalErrors).toBeGreaterThanOrEqual(2);
        // Limpiar errores antiguos (24 horas)
        _errorboundarymanager.errorBoundaryManager.clearOldErrors(24 * 60 * 60 * 1000);
        metrics = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        // Solo el error reciente debería permanecer
        expect(metrics.totalErrors).toBeGreaterThanOrEqual(1);
        // Verificar que el error reciente sigue presente
        const recentErrorExists = metrics.recentErrors.some((e)=>e.errorId === 'recent-1');
        expect(recentErrorExists).toBe(true);
    });
    test('marca errores como resueltos', ()=>{
        const error = new Error('Test error');
        _errorboundarymanager.errorBoundaryManager.reportError(error, {
            componentStack: ''
        }, {
            errorId: 'resolvable-1',
            level: 'component',
            component: 'TestComponent',
            retryCount: 0
        });
        const beforeResolve = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(beforeResolve.recentErrors[0].resolved).toBe(false);
        _errorboundarymanager.errorBoundaryManager.markErrorResolved('resolvable-1', 5000);
        const afterResolve = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(afterResolve.recentErrors[0].resolved).toBe(true);
        expect(afterResolve.recentErrors[0].resolutionTime).toBe(5000);
    });
});
// ===================================
// TESTS DE SINGLETON
// ===================================
describe('ErrorBoundaryManager - Singleton', ()=>{
    test('mantiene una sola instancia', ()=>{
        const instance1 = _errorboundarymanager.errorBoundaryManager;
        const instance2 = _errorboundarymanager.errorBoundaryManager;
        expect(instance1).toBe(instance2);
    });
    test('mantiene estado entre accesos', ()=>{
        const error = new Error('Persistent error');
        _errorboundarymanager.errorBoundaryManager.reportError(error, {
            componentStack: ''
        }, {
            errorId: 'persistent-1',
            level: 'component',
            component: 'PersistentComponent',
            retryCount: 0
        });
        const metrics1 = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        const metrics2 = _errorboundarymanager.errorBoundaryManager.getErrorMetrics();
        expect(metrics1.totalErrors).toBe(metrics2.totalErrors);
        expect(metrics1.totalErrors).toBe(1);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXF9fdGVzdHNfX1xcZXJyb3ItYm91bmRhcnlcXGVycm9yLWJvdW5kYXJ5LW1hbmFnZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGplc3QtZW52aXJvbm1lbnQganNkb21cclxuICovXHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBFUlJPUiBCT1VOREFSWSBNQU5BR0VSIFRFU1RTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFRlc3RzIHBhcmEgZWwgc2lzdGVtYSBjZW50cmFsaXphZG8gZGUgZ2VzdGnDs24gZGUgRXJyb3IgQm91bmRhcmllc1xyXG5cclxuaW1wb3J0IHsgZXJyb3JCb3VuZGFyeU1hbmFnZXIgfSBmcm9tICdAL2xpYi9lcnJvci1ib3VuZGFyeS9lcnJvci1ib3VuZGFyeS1tYW5hZ2VyJztcclxuaW1wb3J0IHR5cGUgeyBFcnJvck1ldHJpY3MgfSBmcm9tICdAL2xpYi9lcnJvci1ib3VuZGFyeS9lcnJvci1ib3VuZGFyeS1tYW5hZ2VyJztcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIE1PQ0tTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4vLyBNb2NrIGRlIGZldGNoXHJcbmdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKTtcclxuXHJcbi8vIE1vY2sgZGUgY29uc29sZVxyXG5jb25zdCBvcmlnaW5hbENvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3I7XHJcbmNvbnN0IG9yaWdpbmFsQ29uc29sZUxvZyA9IGNvbnNvbGUubG9nO1xyXG5jb25zdCBvcmlnaW5hbENvbnNvbGVXYXJuID0gY29uc29sZS53YXJuO1xyXG5cclxuYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgY29uc29sZS5lcnJvciA9IGplc3QuZm4oKTtcclxuICBjb25zb2xlLmxvZyA9IGplc3QuZm4oKTtcclxuICBjb25zb2xlLndhcm4gPSBqZXN0LmZuKCk7XHJcbiAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgKGZldGNoIGFzIGplc3QuTW9jaykubW9ja0NsZWFyKCk7XHJcbiAgXHJcbiAgLy8gTGltcGlhciBlcnJvcmVzIGFudGVyaW9yZXMgeSBmb3J6YXIgbGltcGllemEgY29tcGxldGFcclxuICBlcnJvckJvdW5kYXJ5TWFuYWdlci5jbGVhck9sZEVycm9ycygwKTtcclxuICBcclxuICAvLyBGb3J6YXIgbGltcGllemEgYWRpY2lvbmFsIGFjY2VkaWVuZG8gYSBsYSBpbnN0YW5jaWEgcHJpdmFkYVxyXG4gIGNvbnN0IG1hbmFnZXIgPSBlcnJvckJvdW5kYXJ5TWFuYWdlciBhcyBhbnk7XHJcbiAgbWFuYWdlci5lcnJvcnMuY2xlYXIoKTtcclxuICBtYW5hZ2VyLnBhdHRlcm5zLmNsZWFyKCk7XHJcbn0pO1xyXG5cclxuYWZ0ZXJFYWNoKCgpID0+IHtcclxuICBjb25zb2xlLmVycm9yID0gb3JpZ2luYWxDb25zb2xlRXJyb3I7XHJcbiAgY29uc29sZS5sb2cgPSBvcmlnaW5hbENvbnNvbGVMb2c7XHJcbiAgY29uc29sZS53YXJuID0gb3JpZ2luYWxDb25zb2xlV2FybjtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBDT05GSUdVUkFDScOTTlxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ0Vycm9yQm91bmRhcnlNYW5hZ2VyIC0gQ29uZmlndXJhY2nDs24nLCAoKSA9PiB7XHJcbiAgdGVzdCgnZGV2dWVsdmUgY29uZmlndXJhY2nDs24gcG9yIGRlZmVjdG8gcGFyYSBuaXZlbGVzIGNvbm9jaWRvcycsICgpID0+IHtcclxuICAgIGNvbnN0IHBhZ2VDb25maWcgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRDb25maWcoJ3BhZ2UnKTtcclxuICAgIGV4cGVjdChwYWdlQ29uZmlnKS50b0VxdWFsKHtcclxuICAgICAgbGV2ZWw6ICdwYWdlJyxcclxuICAgICAgZW5hYmxlUmV0cnk6IHRydWUsXHJcbiAgICAgIG1heFJldHJpZXM6IDIsXHJcbiAgICAgIHJldHJ5RGVsYXk6IDIwMDAsXHJcbiAgICAgIGVuYWJsZUF1dG9SZWNvdmVyeTogdHJ1ZSxcclxuICAgICAgcmVjb3ZlcnlUaW1lb3V0OiA1MDAwLFxyXG4gICAgICBlbmFibGVSZXBvcnRpbmc6IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHNlY3Rpb25Db25maWcgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRDb25maWcoJ3NlY3Rpb24nKTtcclxuICAgIGV4cGVjdChzZWN0aW9uQ29uZmlnKS50b0VxdWFsKHtcclxuICAgICAgbGV2ZWw6ICdzZWN0aW9uJyxcclxuICAgICAgZW5hYmxlUmV0cnk6IHRydWUsXHJcbiAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgIHJldHJ5RGVsYXk6IDEwMDAsXHJcbiAgICAgIGVuYWJsZUF1dG9SZWNvdmVyeTogdHJ1ZSxcclxuICAgICAgcmVjb3ZlcnlUaW1lb3V0OiAzMDAwLFxyXG4gICAgICBlbmFibGVSZXBvcnRpbmc6IHRydWVcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNvbXBvbmVudENvbmZpZyA9IGVycm9yQm91bmRhcnlNYW5hZ2VyLmdldENvbmZpZygnY29tcG9uZW50Jyk7XHJcbiAgICBleHBlY3QoY29tcG9uZW50Q29uZmlnKS50b0VxdWFsKHtcclxuICAgICAgbGV2ZWw6ICdjb21wb25lbnQnLFxyXG4gICAgICBlbmFibGVSZXRyeTogdHJ1ZSxcclxuICAgICAgbWF4UmV0cmllczogNSxcclxuICAgICAgcmV0cnlEZWxheTogNTAwLFxyXG4gICAgICBlbmFibGVBdXRvUmVjb3Zlcnk6IHRydWUsXHJcbiAgICAgIHJlY292ZXJ5VGltZW91dDogMjAwMCxcclxuICAgICAgZW5hYmxlUmVwb3J0aW5nOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ2RldnVlbHZlIGNvbmZpZ3VyYWNpw7NuIGRlIGNvbXBvbmVudGUgcGFyYSBuaXZlbGVzIGRlc2Nvbm9jaWRvcycsICgpID0+IHtcclxuICAgIGNvbnN0IHVua25vd25Db25maWcgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRDb25maWcoJ3Vua25vd24nKTtcclxuICAgIGV4cGVjdCh1bmtub3duQ29uZmlnLmxldmVsKS50b0JlKCdjb21wb25lbnQnKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgncGVybWl0ZSBhY3R1YWxpemFyIGNvbmZpZ3VyYWNpw7NuJywgKCkgPT4ge1xyXG4gICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIudXBkYXRlQ29uZmlnKCdwYWdlJywge1xyXG4gICAgICBtYXhSZXRyaWVzOiA1LFxyXG4gICAgICByZXRyeURlbGF5OiAzMDAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGVkQ29uZmlnID0gZXJyb3JCb3VuZGFyeU1hbmFnZXIuZ2V0Q29uZmlnKCdwYWdlJyk7XHJcbiAgICBleHBlY3QodXBkYXRlZENvbmZpZy5tYXhSZXRyaWVzKS50b0JlKDUpO1xyXG4gICAgZXhwZWN0KHVwZGF0ZWRDb25maWcucmV0cnlEZWxheSkudG9CZSgzMDAwKTtcclxuICAgIGV4cGVjdCh1cGRhdGVkQ29uZmlnLmxldmVsKS50b0JlKCdwYWdlJyk7IC8vIE90cm9zIHZhbG9yZXMgc2UgbWFudGllbmVuXHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgUkVQT1JURSBERSBFUlJPUkVTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5kZXNjcmliZSgnRXJyb3JCb3VuZGFyeU1hbmFnZXIgLSBSZXBvcnRlIGRlIEVycm9yZXMnLCAoKSA9PiB7XHJcbiAgdGVzdCgncmVwb3J0YSB5IGFsbWFjZW5hIGVycm9yZXMgY29ycmVjdGFtZW50ZScsICgpID0+IHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUZXN0IGVycm9yJyk7XHJcbiAgICBjb25zdCBlcnJvckluZm8gPSB7IGNvbXBvbmVudFN0YWNrOiAnYXQgVGVzdENvbXBvbmVudCcgfTtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgIGVycm9ySWQ6ICd0ZXN0LWVycm9yLTEnLFxyXG4gICAgICBsZXZlbDogJ2NvbXBvbmVudCcsXHJcbiAgICAgIGNvbXBvbmVudDogJ1Rlc3RDb21wb25lbnQnLFxyXG4gICAgICByZXRyeUNvdW50OiAwXHJcbiAgICB9O1xyXG5cclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKGVycm9yLCBlcnJvckluZm8sIGNvbnRleHQpO1xyXG5cclxuICAgIGNvbnN0IG1ldHJpY3MgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRFcnJvck1ldHJpY3MoKTtcclxuICAgIGV4cGVjdChtZXRyaWNzLnRvdGFsRXJyb3JzKS50b0JlKDEpO1xyXG4gICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JzQnlDb21wb25lbnRbJ1Rlc3RDb21wb25lbnQnXSkudG9CZSgxKTtcclxuICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5VHlwZVsnVW5rbm93bkVycm9yJ10pLnRvQmUoMSk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ2NsYXNpZmljYSBlcnJvcmVzIGNvcnJlY3RhbWVudGUnLCAoKSA9PiB7XHJcbiAgICBjb25zdCBjaHVua0Vycm9yID0gbmV3IEVycm9yKCdMb2FkaW5nIGNodW5rIDEyMyBmYWlsZWQnKTtcclxuICAgIGNvbnN0IG5ldHdvcmtFcnJvciA9IG5ldyBFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpO1xyXG4gICAgY29uc3QgdHlwZUVycm9yID0gbmV3IFR5cGVFcnJvcignQ2Fubm90IHJlYWQgcHJvcGVydHknKTtcclxuICAgIGNvbnN0IHJlYWN0RXJyb3IgPSBuZXcgRXJyb3IoJ1JlbmRlciBlcnJvcicpO1xyXG4gICAgcmVhY3RFcnJvci5zdGFjayA9ICdhdCBSZWFjdC5Db21wb25lbnQucmVuZGVyJztcclxuXHJcbiAgICAvLyBSZXBvcnRhciBkaWZlcmVudGVzIHRpcG9zIGRlIGVycm9yZXNcclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKGNodW5rRXJyb3IsIHsgY29tcG9uZW50U3RhY2s6ICcnIH0sIHtcclxuICAgICAgZXJyb3JJZDogJ2NodW5rLTEnLCBsZXZlbDogJ3BhZ2UnLCBjb21wb25lbnQ6ICdBcHAnLCByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcihuZXR3b3JrRXJyb3IsIHsgY29tcG9uZW50U3RhY2s6ICcnIH0sIHtcclxuICAgICAgZXJyb3JJZDogJ25ldHdvcmstMScsIGxldmVsOiAnc2VjdGlvbicsIGNvbXBvbmVudDogJ0RhdGFMb2FkZXInLCByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcih0eXBlRXJyb3IsIHsgY29tcG9uZW50U3RhY2s6ICcnIH0sIHtcclxuICAgICAgZXJyb3JJZDogJ3R5cGUtMScsIGxldmVsOiAnY29tcG9uZW50JywgY29tcG9uZW50OiAnVXNlclByb2ZpbGUnLCByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcihyZWFjdEVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiAnJyB9LCB7XHJcbiAgICAgIGVycm9ySWQ6ICdyZWFjdC0xJywgbGV2ZWw6ICdjb21wb25lbnQnLCBjb21wb25lbnQ6ICdQcm9kdWN0Q2FyZCcsIHJldHJ5Q291bnQ6IDBcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1ldHJpY3MgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRFcnJvck1ldHJpY3MoKTtcclxuICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5VHlwZVsnQ2h1bmtMb2FkRXJyb3InXSkudG9CZSgxKTtcclxuICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5VHlwZVsnTmV0d29ya0Vycm9yJ10pLnRvQmUoMSk7XHJcbiAgICBleHBlY3QobWV0cmljcy5lcnJvcnNCeVR5cGVbJ1R5cGVFcnJvciddKS50b0JlKDEpO1xyXG4gICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JzQnlUeXBlWydSZWFjdEVycm9yJ10pLnRvQmUoMSk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ2V2YWzDumEgaW1wYWN0byBkZWwgdXN1YXJpbyBjb3JyZWN0YW1lbnRlJywgKCkgPT4ge1xyXG4gICAgY29uc3QgcGFnZUVycm9yID0gbmV3IEVycm9yKCdQYWdlIGVycm9yJyk7XHJcbiAgICBjb25zdCBzZWN0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ1NlY3Rpb24gZXJyb3InKTtcclxuICAgIGNvbnN0IGNvbXBvbmVudEVycm9yID0gbmV3IEVycm9yKCdDb21wb25lbnQgZXJyb3InKTtcclxuICAgIGNvbnN0IGNodW5rRXJyb3IgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgY2h1bmsgZmFpbGVkJyk7XHJcblxyXG4gICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIucmVwb3J0RXJyb3IocGFnZUVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiAnJyB9LCB7XHJcbiAgICAgIGVycm9ySWQ6ICdwYWdlLTEnLCBsZXZlbDogJ3BhZ2UnLCBjb21wb25lbnQ6ICdIb21lUGFnZScsIHJldHJ5Q291bnQ6IDBcclxuICAgIH0pO1xyXG5cclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKHNlY3Rpb25FcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICBlcnJvcklkOiAnc2VjdGlvbi0xJywgbGV2ZWw6ICdzZWN0aW9uJywgY29tcG9uZW50OiAnUHJvZHVjdExpc3QnLCByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcihjb21wb25lbnRFcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICBlcnJvcklkOiAnY29tcG9uZW50LTEnLCBsZXZlbDogJ2NvbXBvbmVudCcsIGNvbXBvbmVudDogJ0J1dHRvbicsIHJldHJ5Q291bnQ6IDBcclxuICAgIH0pO1xyXG5cclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKGNodW5rRXJyb3IsIHsgY29tcG9uZW50U3RhY2s6ICcnIH0sIHtcclxuICAgICAgZXJyb3JJZDogJ2NodW5rLTEnLCBsZXZlbDogJ2NvbXBvbmVudCcsIGNvbXBvbmVudDogJ0xhenlDb21wb25lbnQnLCByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBtZXRyaWNzID0gZXJyb3JCb3VuZGFyeU1hbmFnZXIuZ2V0RXJyb3JNZXRyaWNzKCk7XHJcbiAgICBleHBlY3QobWV0cmljcy5lcnJvcnNCeUltcGFjdFsnY3JpdGljYWwnXSkudG9CZSgxKTsgLy8gcGFnZSBlcnJvclxyXG4gICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JzQnlJbXBhY3RbJ2hpZ2gnXSkudG9CZSgyKTsgLy8gc2VjdGlvbiBlcnJvciArIGNodW5rIGVycm9yIChoaWdoIHByaW9yaXR5KVxyXG4gICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JzQnlJbXBhY3RbJ21lZGl1bSddKS50b0JlVW5kZWZpbmVkKCk7IC8vIG5vIG1lZGl1bSBlcnJvcnNcclxuICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5SW1wYWN0Wydsb3cnXSkudG9CZSgxKTsgLy8gY29tcG9uZW50IGVycm9yXHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgREVURUNDScOTTiBERSBQQVRST05FU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ0Vycm9yQm91bmRhcnlNYW5hZ2VyIC0gRGV0ZWNjacOzbiBkZSBQYXRyb25lcycsICgpID0+IHtcclxuICB0ZXN0KCdkZXRlY3RhIHBhdHJvbmVzIGRlIGVycm9yZXMgZnJlY3VlbnRlcycsICgpID0+IHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdSZXBlYXRlZCBlcnJvcicpO1xyXG4gICAgXHJcbiAgICAvLyBSZXBvcnRhciBlbCBtaXNtbyBlcnJvciBtw7psdGlwbGVzIHZlY2VzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcihlcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICAgIGVycm9ySWQ6IGByZXBlYXQtJHtpfWAsXHJcbiAgICAgICAgbGV2ZWw6ICdjb21wb25lbnQnLFxyXG4gICAgICAgIGNvbXBvbmVudDogJ1Byb2JsZW1hdGljQ29tcG9uZW50JyxcclxuICAgICAgICByZXRyeUNvdW50OiAwXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ldHJpY3MgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRFcnJvck1ldHJpY3MoKTtcclxuICAgIGV4cGVjdChtZXRyaWNzLnBhdHRlcm5zLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgXHJcbiAgICBjb25zdCBwYXR0ZXJuID0gbWV0cmljcy5wYXR0ZXJucy5maW5kKHAgPT4gXHJcbiAgICAgIHAucGF0dGVybi5pbmNsdWRlcygnRXJyb3I6UHJvYmxlbWF0aWNDb21wb25lbnQnKVxyXG4gICAgKTtcclxuICAgIGV4cGVjdChwYXR0ZXJuKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgZXhwZWN0KHBhdHRlcm4/LmZyZXF1ZW5jeSkudG9CZSg1KTtcclxuICAgIGV4cGVjdChwYXR0ZXJuPy5hZmZlY3RlZENvbXBvbmVudHMpLnRvQ29udGFpbignUHJvYmxlbWF0aWNDb21wb25lbnQnKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdCgncHJvcG9yY2lvbmEgc3VnZXJlbmNpYXMgZGUgY29ycmVjY2nDs24gcGFyYSBwYXRyb25lcyBjb25vY2lkb3MnLCAoKSA9PiB7XHJcbiAgICBjb25zdCBjaHVua0Vycm9yID0gbmV3IEVycm9yKCdMb2FkaW5nIGNodW5rIGZhaWxlZCcpO1xyXG4gICAgY29uc3QgbmV0d29ya0Vycm9yID0gbmV3IEVycm9yKCdOZXR3b3JrIHRpbWVvdXQnKTtcclxuICAgIGNvbnN0IHR5cGVFcnJvciA9IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCByZWFkIHByb3BlcnR5Jyk7XHJcblxyXG4gICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIucmVwb3J0RXJyb3IoY2h1bmtFcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICBlcnJvcklkOiAnY2h1bmstMScsIGxldmVsOiAnY29tcG9uZW50JywgY29tcG9uZW50OiAnTGF6eUNvbXBvbmVudCcsIHJldHJ5Q291bnQ6IDBcclxuICAgIH0pO1xyXG5cclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKG5ldHdvcmtFcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICBlcnJvcklkOiAnbmV0d29yay0xJywgbGV2ZWw6ICdjb21wb25lbnQnLCBjb21wb25lbnQ6ICdBcGlDbGllbnQnLCByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcih0eXBlRXJyb3IsIHsgY29tcG9uZW50U3RhY2s6ICcnIH0sIHtcclxuICAgICAgZXJyb3JJZDogJ3R5cGUtMScsIGxldmVsOiAnY29tcG9uZW50JywgY29tcG9uZW50OiAnRGF0YVByb2Nlc3NvcicsIHJldHJ5Q291bnQ6IDBcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1ldHJpY3MgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRFcnJvck1ldHJpY3MoKTtcclxuICAgIFxyXG4gICAgY29uc3QgY2h1bmtQYXR0ZXJuID0gbWV0cmljcy5wYXR0ZXJucy5maW5kKHAgPT4gcC5wYXR0ZXJuLmluY2x1ZGVzKCdDaHVua0xvYWRFcnJvcicpKTtcclxuICAgIGV4cGVjdChjaHVua1BhdHRlcm4/LnN1Z2dlc3RlZEZpeCkudG9CZURlZmluZWQoKTtcclxuICAgIGV4cGVjdChjaHVua1BhdHRlcm4/LnN1Z2dlc3RlZEZpeCkudG9Db250YWluKCdjaHVuayByZXRyeSBsb2dpYycpO1xyXG5cclxuICAgIGNvbnN0IG5ldHdvcmtQYXR0ZXJuID0gbWV0cmljcy5wYXR0ZXJucy5maW5kKHAgPT4gcC5wYXR0ZXJuLmluY2x1ZGVzKCdOZXR3b3JrRXJyb3InKSk7XHJcbiAgICBleHBlY3QobmV0d29ya1BhdHRlcm4/LnN1Z2dlc3RlZEZpeCkudG9CZURlZmluZWQoKTtcclxuICAgIGV4cGVjdChuZXR3b3JrUGF0dGVybj8uc3VnZ2VzdGVkRml4KS50b0NvbnRhaW4oJ25ldHdvcmsgcmV0cnknKTtcclxuXHJcbiAgICBjb25zdCB0eXBlUGF0dGVybiA9IG1ldHJpY3MucGF0dGVybnMuZmluZChwID0+IHAucGF0dGVybi5pbmNsdWRlcygnVHlwZUVycm9yJykpO1xyXG4gICAgZXhwZWN0KHR5cGVQYXR0ZXJuPy5zdWdnZXN0ZWRGaXgpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICBleHBlY3QodHlwZVBhdHRlcm4/LnN1Z2dlc3RlZEZpeCkudG9Db250YWluKCdudWxsL3VuZGVmaW5lZCBjaGVja3MnKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBMSVNURU5FUlNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmRlc2NyaWJlKCdFcnJvckJvdW5kYXJ5TWFuYWdlciAtIExpc3RlbmVycycsICgpID0+IHtcclxuICB0ZXN0KCdub3RpZmljYSBhIGxpc3RlbmVycyBjdWFuZG8gc2UgcmVwb3J0YW4gZXJyb3JlcycsICgpID0+IHtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gamVzdC5mbigpO1xyXG4gICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIuYWRkRXJyb3JMaXN0ZW5lcihsaXN0ZW5lcik7XHJcblxyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKGVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiAnJyB9LCB7XHJcbiAgICAgIGVycm9ySWQ6ICd0ZXN0LTEnLFxyXG4gICAgICBsZXZlbDogJ2NvbXBvbmVudCcsXHJcbiAgICAgIGNvbXBvbmVudDogJ1Rlc3RDb21wb25lbnQnLFxyXG4gICAgICByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBlY3QobGlzdGVuZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XHJcbiAgICAgICAgZXJyb3JJZDogJ3Rlc3QtMScsXHJcbiAgICAgICAgY29tcG9uZW50OiAnVGVzdENvbXBvbmVudCcsXHJcbiAgICAgICAgbGV2ZWw6ICdjb21wb25lbnQnXHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlbW92ZUVycm9yTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdwZXJtaXRlIHJlbW92ZXIgbGlzdGVuZXJzJywgKCkgPT4ge1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBqZXN0LmZuKCk7XHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5hZGRFcnJvckxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlbW92ZUVycm9yTGlzdGVuZXIobGlzdGVuZXIpO1xyXG5cclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUZXN0IGVycm9yJyk7XHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcihlcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICBlcnJvcklkOiAndGVzdC0xJyxcclxuICAgICAgbGV2ZWw6ICdjb21wb25lbnQnLFxyXG4gICAgICBjb21wb25lbnQ6ICdUZXN0Q29tcG9uZW50JyxcclxuICAgICAgcmV0cnlDb3VudDogMFxyXG4gICAgfSk7XHJcblxyXG4gICAgZXhwZWN0KGxpc3RlbmVyKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdtYW5lamEgZXJyb3JlcyBlbiBsaXN0ZW5lcnMgc2luIGFmZWN0YXIgZWwgZmx1am8gcHJpbmNpcGFsJywgKCkgPT4ge1xyXG4gICAgY29uc3QgZmF1bHR5TGlzdGVuZXIgPSBqZXN0LmZuKCgpID0+IHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaXN0ZW5lciBlcnJvcicpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBnb29kTGlzdGVuZXIgPSBqZXN0LmZuKCk7XHJcblxyXG4gICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIuYWRkRXJyb3JMaXN0ZW5lcihmYXVsdHlMaXN0ZW5lcik7XHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5hZGRFcnJvckxpc3RlbmVyKGdvb2RMaXN0ZW5lcik7XHJcblxyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKGVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiAnJyB9LCB7XHJcbiAgICAgIGVycm9ySWQ6ICd0ZXN0LTEnLFxyXG4gICAgICBsZXZlbDogJ2NvbXBvbmVudCcsXHJcbiAgICAgIGNvbXBvbmVudDogJ1Rlc3RDb21wb25lbnQnLFxyXG4gICAgICByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBlY3QoZmF1bHR5TGlzdGVuZXIpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgIGV4cGVjdChnb29kTGlzdGVuZXIpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgIGV4cGVjdChjb25zb2xlLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgJ+KdjCBFcnJvciBpbiBlcnJvciBsaXN0ZW5lcjonLFxyXG4gICAgICBleHBlY3QuYW55KEVycm9yKVxyXG4gICAgKTtcclxuXHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZW1vdmVFcnJvckxpc3RlbmVyKGZhdWx0eUxpc3RlbmVyKTtcclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlbW92ZUVycm9yTGlzdGVuZXIoZ29vZExpc3RlbmVyKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBNw4lUUklDQVMgWSBSRVBPUlRFU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ0Vycm9yQm91bmRhcnlNYW5hZ2VyIC0gTcOpdHJpY2FzIHkgUmVwb3J0ZXMnLCAoKSA9PiB7XHJcbiAgdGVzdCgnY2FsY3VsYSBtw6l0cmljYXMgY29ycmVjdGFtZW50ZScsICgpID0+IHtcclxuICAgIC8vIFJlcG9ydGFyIHZhcmlvcyBlcnJvcmVzXHJcbiAgICBjb25zdCBlcnJvcnMgPSBbXHJcbiAgICAgIHsgdHlwZTogJ1R5cGVFcnJvcicsIGNvbXBvbmVudDogJ0NvbXBvbmVudEEnLCBsZXZlbDogJ2NvbXBvbmVudCcsIGltcGFjdDogJ2xvdycgfSxcclxuICAgICAgeyB0eXBlOiAnTmV0d29ya0Vycm9yJywgY29tcG9uZW50OiAnQ29tcG9uZW50QicsIGxldmVsOiAnc2VjdGlvbicsIGltcGFjdDogJ21lZGl1bScgfSxcclxuICAgICAgeyB0eXBlOiAnVHlwZUVycm9yJywgY29tcG9uZW50OiAnQ29tcG9uZW50QScsIGxldmVsOiAnY29tcG9uZW50JywgaW1wYWN0OiAnbG93JyB9LFxyXG4gICAgICB7IHR5cGU6ICdDaHVua0xvYWRFcnJvcicsIGNvbXBvbmVudDogJ0NvbXBvbmVudEMnLCBsZXZlbDogJ3BhZ2UnLCBpbXBhY3Q6ICdjcml0aWNhbCcgfVxyXG4gICAgXTtcclxuXHJcbiAgICBlcnJvcnMuZm9yRWFjaCgoZXJyb3JEYXRhLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHtlcnJvckRhdGEudHlwZX0gbWVzc2FnZWApO1xyXG4gICAgICBpZiAoZXJyb3JEYXRhLnR5cGUgPT09ICdUeXBlRXJyb3InKSBlcnJvci5uYW1lID0gJ1R5cGVFcnJvcic7XHJcbiAgICAgIGlmIChlcnJvckRhdGEudHlwZSA9PT0gJ05ldHdvcmtFcnJvcicpIGVycm9yLm1lc3NhZ2UgPSAnTmV0d29yayBmYWlsZWQnO1xyXG4gICAgICBpZiAoZXJyb3JEYXRhLnR5cGUgPT09ICdDaHVua0xvYWRFcnJvcicpIGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBjaHVuayBmYWlsZWQnO1xyXG5cclxuICAgICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIucmVwb3J0RXJyb3IoZXJyb3IsIHsgY29tcG9uZW50U3RhY2s6ICcnIH0sIHtcclxuICAgICAgICBlcnJvcklkOiBgZXJyb3ItJHtpbmRleH1gLFxyXG4gICAgICAgIGxldmVsOiBlcnJvckRhdGEubGV2ZWwgYXMgJ3BhZ2UnIHwgJ3NlY3Rpb24nIHwgJ2NvbXBvbmVudCcsXHJcbiAgICAgICAgY29tcG9uZW50OiBlcnJvckRhdGEuY29tcG9uZW50LFxyXG4gICAgICAgIHJldHJ5Q291bnQ6IDBcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBtZXRyaWNzID0gZXJyb3JCb3VuZGFyeU1hbmFnZXIuZ2V0RXJyb3JNZXRyaWNzKCk7XHJcbiAgICBcclxuICAgIGV4cGVjdChtZXRyaWNzLnRvdGFsRXJyb3JzKS50b0JlKDQpO1xyXG4gICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JzQnlUeXBlWydUeXBlRXJyb3InXSkudG9CZSgyKTtcclxuICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5VHlwZVsnTmV0d29ya0Vycm9yJ10pLnRvQmUoMSk7XHJcbiAgICBleHBlY3QobWV0cmljcy5lcnJvcnNCeVR5cGVbJ0NodW5rTG9hZEVycm9yJ10pLnRvQmUoMSk7XHJcbiAgICBleHBlY3QobWV0cmljcy5lcnJvcnNCeUNvbXBvbmVudFsnQ29tcG9uZW50QSddKS50b0JlKDIpO1xyXG4gICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JzQnlDb21wb25lbnRbJ0NvbXBvbmVudEInXSkudG9CZSgxKTtcclxuICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5Q29tcG9uZW50WydDb21wb25lbnRDJ10pLnRvQmUoMSk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3Byb3BvcmNpb25hIGVycm9yZXMgcmVjaWVudGVzIG9yZGVuYWRvcyBwb3IgdGltZXN0YW1wJywgKCkgPT4ge1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIFxyXG4gICAgLy8gUmVwb3J0YXIgZXJyb3JlcyBjb24gZGlmZXJlbnRlcyB0aW1lc3RhbXBzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE1OyBpKyspIHtcclxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEVycm9yICR7aX1gKTtcclxuICAgICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIucmVwb3J0RXJyb3IoZXJyb3IsIHsgY29tcG9uZW50U3RhY2s6ICcnIH0sIHtcclxuICAgICAgICBlcnJvcklkOiBgZXJyb3ItJHtpfWAsXHJcbiAgICAgICAgbGV2ZWw6ICdjb21wb25lbnQnLFxyXG4gICAgICAgIGNvbXBvbmVudDogYENvbXBvbmVudCR7aX1gLFxyXG4gICAgICAgIHJldHJ5Q291bnQ6IDBcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWV0cmljcyA9IGVycm9yQm91bmRhcnlNYW5hZ2VyLmdldEVycm9yTWV0cmljcygpO1xyXG4gICAgXHJcbiAgICAvLyBEZWJlcsOtYSBkZXZvbHZlciBzb2xvIGxvcyAxMCBtw6FzIHJlY2llbnRlc1xyXG4gICAgZXhwZWN0KG1ldHJpY3MucmVjZW50RXJyb3JzLmxlbmd0aCkudG9CZSgxMCk7XHJcbiAgICBcclxuICAgIC8vIERlYmVyw61hbiBlc3RhciBvcmRlbmFkb3MgcG9yIHRpbWVzdGFtcCBkZXNjZW5kZW50ZVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRyaWNzLnJlY2VudEVycm9ycy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgZXhwZWN0KG1ldHJpY3MucmVjZW50RXJyb3JzW2ldLnRpbWVzdGFtcCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChcclxuICAgICAgICBtZXRyaWNzLnJlY2VudEVycm9yc1tpICsgMV0udGltZXN0YW1wXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgRVNUQURPIERFIFNBTFVEXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5kZXNjcmliZSgnRXJyb3JCb3VuZGFyeU1hbmFnZXIgLSBFc3RhZG8gZGUgU2FsdWQnLCAoKSA9PiB7XHJcbiAgdGVzdCgncmVwb3J0YSBlc3RhZG8gc2FsdWRhYmxlIGN1YW5kbyBubyBoYXkgZXJyb3JlcycsICgpID0+IHtcclxuICAgIGNvbnN0IGhlYWx0aFN0YXR1cyA9IGVycm9yQm91bmRhcnlNYW5hZ2VyLmdldEhlYWx0aFN0YXR1cygpO1xyXG4gICAgXHJcbiAgICBleHBlY3QoaGVhbHRoU3RhdHVzLnN0YXR1cykudG9CZSgnaGVhbHRoeScpO1xyXG4gICAgZXhwZWN0KGhlYWx0aFN0YXR1cy5lcnJvclJhdGUpLnRvQmUoMCk7XHJcbiAgICBleHBlY3QoaGVhbHRoU3RhdHVzLmNyaXRpY2FsRXJyb3JzKS50b0JlKDApO1xyXG4gICAgZXhwZWN0KGhlYWx0aFN0YXR1cy5yZWNvbW1lbmRhdGlvbnMpLnRvRXF1YWwoW10pO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdyZXBvcnRhIGVzdGFkbyBjcsOtdGljbyBjdWFuZG8gaGF5IGVycm9yZXMgY3LDrXRpY29zJywgKCkgPT4ge1xyXG4gICAgY29uc3QgY3JpdGljYWxFcnJvciA9IG5ldyBFcnJvcignQ3JpdGljYWwgcGFnZSBlcnJvcicpO1xyXG4gICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIucmVwb3J0RXJyb3IoY3JpdGljYWxFcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICBlcnJvcklkOiAnY3JpdGljYWwtMScsXHJcbiAgICAgIGxldmVsOiAncGFnZScsXHJcbiAgICAgIGNvbXBvbmVudDogJ0hvbWVQYWdlJyxcclxuICAgICAgcmV0cnlDb3VudDogMFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaGVhbHRoU3RhdHVzID0gZXJyb3JCb3VuZGFyeU1hbmFnZXIuZ2V0SGVhbHRoU3RhdHVzKCk7XHJcbiAgICBcclxuICAgIGV4cGVjdChoZWFsdGhTdGF0dXMuc3RhdHVzKS50b0JlKCdjcml0aWNhbCcpO1xyXG4gICAgZXhwZWN0KGhlYWx0aFN0YXR1cy5jcml0aWNhbEVycm9ycykudG9CZSgxKTtcclxuICAgIGV4cGVjdChoZWFsdGhTdGF0dXMucmVjb21tZW5kYXRpb25zKS50b0NvbnRhaW4oJ1Jlc29sdmVyIGVycm9yZXMgY3LDrXRpY29zIGlubWVkaWF0YW1lbnRlJyk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoJ3JlcG9ydGEgZXN0YWRvIGRlZ3JhZGFkbyBjb24gYWx0YSB0YXNhIGRlIGVycm9yZXMnLCAoKSA9PiB7XHJcbiAgICAvLyBTaW11bGFyIG11Y2hvcyBlcnJvcmVzIHJlY2llbnRlc1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBFcnJvciAke2l9YCk7XHJcbiAgICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKGVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiAnJyB9LCB7XHJcbiAgICAgICAgZXJyb3JJZDogYGVycm9yLSR7aX1gLFxyXG4gICAgICAgIGxldmVsOiAnY29tcG9uZW50JyxcclxuICAgICAgICBjb21wb25lbnQ6IGBDb21wb25lbnQke2l9YCxcclxuICAgICAgICByZXRyeUNvdW50OiAwXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhlYWx0aFN0YXR1cyA9IGVycm9yQm91bmRhcnlNYW5hZ2VyLmdldEhlYWx0aFN0YXR1cygpO1xyXG4gICAgXHJcbiAgICBleHBlY3QoaGVhbHRoU3RhdHVzLnN0YXR1cykudG9CZSgnZGVncmFkZWQnKTtcclxuICAgIGV4cGVjdChoZWFsdGhTdGF0dXMucmVjb21tZW5kYXRpb25zKS50b0NvbnRhaW4oJ0FsdGEgdGFzYSBkZSBlcnJvcmVzIGRldGVjdGFkYScpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdkZXRlY3RhIHBhdHJvbmVzIGZyZWN1ZW50ZXMgZW4gcmVjb21lbmRhY2lvbmVzJywgKCkgPT4ge1xyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZyZXF1ZW50IGVycm9yJyk7XHJcbiAgICBcclxuICAgIC8vIFJlcG9ydGFyIGVsIG1pc21vIGVycm9yIG3Dumx0aXBsZXMgdmVjZXNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKGVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiAnJyB9LCB7XHJcbiAgICAgICAgZXJyb3JJZDogYGZyZXF1ZW50LSR7aX1gLFxyXG4gICAgICAgIGxldmVsOiAnY29tcG9uZW50JyxcclxuICAgICAgICBjb21wb25lbnQ6ICdQcm9ibGVtYXRpY0NvbXBvbmVudCcsXHJcbiAgICAgICAgcmV0cnlDb3VudDogMFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoZWFsdGhTdGF0dXMgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRIZWFsdGhTdGF0dXMoKTtcclxuICAgIFxyXG4gICAgZXhwZWN0KGhlYWx0aFN0YXR1cy5yZWNvbW1lbmRhdGlvbnMpLnRvQ29udGFpbignUmV2aXNhciBwYXRyb25lcyBkZSBlcnJvcmVzIGZyZWN1ZW50ZXMnKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBMSU1QSUVaQVxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ0Vycm9yQm91bmRhcnlNYW5hZ2VyIC0gTGltcGllemEnLCAoKSA9PiB7XHJcbiAgdGVzdCgnbGltcGlhIGVycm9yZXMgYW50aWd1b3MgY29ycmVjdGFtZW50ZScsICgpID0+IHtcclxuICAgIC8vIExpbXBpYXIgZXJyb3JlcyBleGlzdGVudGVzIHByaW1lcm9cclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLmNsZWFyT2xkRXJyb3JzKDApO1xyXG5cclxuICAgIC8vIE1vY2sgRGF0ZS5ub3cgcGFyYSBzaW11bGFyIGVycm9yZXMgYW50aWd1b3NcclxuICAgIGNvbnN0IG9yaWdpbmFsRGF0ZU5vdyA9IERhdGUubm93O1xyXG4gICAgY29uc3Qgb2xkVGltZXN0YW1wID0gRGF0ZS5ub3coKSAtICgyNSAqIDYwICogNjAgKiAxMDAwKTsgLy8gMjUgaG9yYXMgYXRyw6FzXHJcbiAgICBcclxuICAgIC8vIFNpbXVsYXIgZXJyb3IgYW50aWd1b1xyXG4gICAgRGF0ZS5ub3cgPSBqZXN0LmZuKCgpID0+IG9sZFRpbWVzdGFtcCk7XHJcbiAgICBjb25zdCBvbGRFcnJvciA9IG5ldyBFcnJvcignT2xkIGVycm9yJyk7XHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcihvbGRFcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICBlcnJvcklkOiAnb2xkLTEnLFxyXG4gICAgICBsZXZlbDogJ2NvbXBvbmVudCcsXHJcbiAgICAgIGNvbXBvbmVudDogJ09sZENvbXBvbmVudCcsXHJcbiAgICAgIHJldHJ5Q291bnQ6IDBcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlc3RhdXJhciBEYXRlLm5vdyB5IHJlcG9ydGFyIGVycm9yIHJlY2llbnRlXHJcbiAgICBEYXRlLm5vdyA9IG9yaWdpbmFsRGF0ZU5vdztcclxuICAgIGNvbnN0IHJlY2VudEVycm9yID0gbmV3IEVycm9yKCdSZWNlbnQgZXJyb3InKTtcclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKHJlY2VudEVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiAnJyB9LCB7XHJcbiAgICAgIGVycm9ySWQ6ICdyZWNlbnQtMScsXHJcbiAgICAgIGxldmVsOiAnY29tcG9uZW50JyxcclxuICAgICAgY29tcG9uZW50OiAnUmVjZW50Q29tcG9uZW50JyxcclxuICAgICAgcmV0cnlDb3VudDogMFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVmVyaWZpY2FyIHF1ZSBhbWJvcyBlcnJvcmVzIGVzdMOhbiBwcmVzZW50ZXNcclxuICAgIGxldCBtZXRyaWNzID0gZXJyb3JCb3VuZGFyeU1hbmFnZXIuZ2V0RXJyb3JNZXRyaWNzKCk7XHJcbiAgICBleHBlY3QobWV0cmljcy50b3RhbEVycm9ycykudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgyKTtcclxuXHJcbiAgICAvLyBMaW1waWFyIGVycm9yZXMgYW50aWd1b3MgKDI0IGhvcmFzKVxyXG4gICAgZXJyb3JCb3VuZGFyeU1hbmFnZXIuY2xlYXJPbGRFcnJvcnMoMjQgKiA2MCAqIDYwICogMTAwMCk7XHJcblxyXG4gICAgbWV0cmljcyA9IGVycm9yQm91bmRhcnlNYW5hZ2VyLmdldEVycm9yTWV0cmljcygpO1xyXG5cclxuICAgIC8vIFNvbG8gZWwgZXJyb3IgcmVjaWVudGUgZGViZXLDrWEgcGVybWFuZWNlclxyXG4gICAgZXhwZWN0KG1ldHJpY3MudG90YWxFcnJvcnMpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMSk7XHJcbiAgICAvLyBWZXJpZmljYXIgcXVlIGVsIGVycm9yIHJlY2llbnRlIHNpZ3VlIHByZXNlbnRlXHJcbiAgICBjb25zdCByZWNlbnRFcnJvckV4aXN0cyA9IG1ldHJpY3MucmVjZW50RXJyb3JzLnNvbWUoZSA9PiBlLmVycm9ySWQgPT09ICdyZWNlbnQtMScpO1xyXG4gICAgZXhwZWN0KHJlY2VudEVycm9yRXhpc3RzKS50b0JlKHRydWUpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdtYXJjYSBlcnJvcmVzIGNvbW8gcmVzdWVsdG9zJywgKCkgPT4ge1xyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLnJlcG9ydEVycm9yKGVycm9yLCB7IGNvbXBvbmVudFN0YWNrOiAnJyB9LCB7XHJcbiAgICAgIGVycm9ySWQ6ICdyZXNvbHZhYmxlLTEnLFxyXG4gICAgICBsZXZlbDogJ2NvbXBvbmVudCcsXHJcbiAgICAgIGNvbXBvbmVudDogJ1Rlc3RDb21wb25lbnQnLFxyXG4gICAgICByZXRyeUNvdW50OiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBiZWZvcmVSZXNvbHZlID0gZXJyb3JCb3VuZGFyeU1hbmFnZXIuZ2V0RXJyb3JNZXRyaWNzKCk7XHJcbiAgICBleHBlY3QoYmVmb3JlUmVzb2x2ZS5yZWNlbnRFcnJvcnNbMF0ucmVzb2x2ZWQpLnRvQmUoZmFsc2UpO1xyXG5cclxuICAgIGVycm9yQm91bmRhcnlNYW5hZ2VyLm1hcmtFcnJvclJlc29sdmVkKCdyZXNvbHZhYmxlLTEnLCA1MDAwKTtcclxuXHJcbiAgICBjb25zdCBhZnRlclJlc29sdmUgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRFcnJvck1ldHJpY3MoKTtcclxuICAgIGV4cGVjdChhZnRlclJlc29sdmUucmVjZW50RXJyb3JzWzBdLnJlc29sdmVkKS50b0JlKHRydWUpO1xyXG4gICAgZXhwZWN0KGFmdGVyUmVzb2x2ZS5yZWNlbnRFcnJvcnNbMF0ucmVzb2x1dGlvblRpbWUpLnRvQmUoNTAwMCk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgU0lOR0xFVE9OXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5kZXNjcmliZSgnRXJyb3JCb3VuZGFyeU1hbmFnZXIgLSBTaW5nbGV0b24nLCAoKSA9PiB7XHJcbiAgdGVzdCgnbWFudGllbmUgdW5hIHNvbGEgaW5zdGFuY2lhJywgKCkgPT4ge1xyXG4gICAgY29uc3QgaW5zdGFuY2UxID0gZXJyb3JCb3VuZGFyeU1hbmFnZXI7XHJcbiAgICBjb25zdCBpbnN0YW5jZTIgPSBlcnJvckJvdW5kYXJ5TWFuYWdlcjtcclxuICAgIFxyXG4gICAgZXhwZWN0KGluc3RhbmNlMSkudG9CZShpbnN0YW5jZTIpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KCdtYW50aWVuZSBlc3RhZG8gZW50cmUgYWNjZXNvcycsICgpID0+IHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdQZXJzaXN0ZW50IGVycm9yJyk7XHJcbiAgICBlcnJvckJvdW5kYXJ5TWFuYWdlci5yZXBvcnRFcnJvcihlcnJvciwgeyBjb21wb25lbnRTdGFjazogJycgfSwge1xyXG4gICAgICBlcnJvcklkOiAncGVyc2lzdGVudC0xJyxcclxuICAgICAgbGV2ZWw6ICdjb21wb25lbnQnLFxyXG4gICAgICBjb21wb25lbnQ6ICdQZXJzaXN0ZW50Q29tcG9uZW50JyxcclxuICAgICAgcmV0cnlDb3VudDogMFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbWV0cmljczEgPSBlcnJvckJvdW5kYXJ5TWFuYWdlci5nZXRFcnJvck1ldHJpY3MoKTtcclxuICAgIGNvbnN0IG1ldHJpY3MyID0gZXJyb3JCb3VuZGFyeU1hbmFnZXIuZ2V0RXJyb3JNZXRyaWNzKCk7XHJcbiAgICBcclxuICAgIGV4cGVjdChtZXRyaWNzMS50b3RhbEVycm9ycykudG9CZShtZXRyaWNzMi50b3RhbEVycm9ycyk7XHJcbiAgICBleHBlY3QobWV0cmljczEudG90YWxFcnJvcnMpLnRvQmUoMSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmV0Y2giLCJqZXN0IiwiZm4iLCJvcmlnaW5hbENvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsIm9yaWdpbmFsQ29uc29sZUxvZyIsImxvZyIsIm9yaWdpbmFsQ29uc29sZVdhcm4iLCJ3YXJuIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJlcnJvckJvdW5kYXJ5TWFuYWdlciIsImNsZWFyT2xkRXJyb3JzIiwibWFuYWdlciIsImVycm9ycyIsImNsZWFyIiwicGF0dGVybnMiLCJhZnRlckVhY2giLCJkZXNjcmliZSIsInRlc3QiLCJwYWdlQ29uZmlnIiwiZ2V0Q29uZmlnIiwiZXhwZWN0IiwidG9FcXVhbCIsImxldmVsIiwiZW5hYmxlUmV0cnkiLCJtYXhSZXRyaWVzIiwicmV0cnlEZWxheSIsImVuYWJsZUF1dG9SZWNvdmVyeSIsInJlY292ZXJ5VGltZW91dCIsImVuYWJsZVJlcG9ydGluZyIsInNlY3Rpb25Db25maWciLCJjb21wb25lbnRDb25maWciLCJ1bmtub3duQ29uZmlnIiwidG9CZSIsInVwZGF0ZUNvbmZpZyIsInVwZGF0ZWRDb25maWciLCJFcnJvciIsImVycm9ySW5mbyIsImNvbXBvbmVudFN0YWNrIiwiY29udGV4dCIsImVycm9ySWQiLCJjb21wb25lbnQiLCJyZXRyeUNvdW50IiwicmVwb3J0RXJyb3IiLCJtZXRyaWNzIiwiZ2V0RXJyb3JNZXRyaWNzIiwidG90YWxFcnJvcnMiLCJlcnJvcnNCeUNvbXBvbmVudCIsImVycm9yc0J5VHlwZSIsImNodW5rRXJyb3IiLCJuZXR3b3JrRXJyb3IiLCJ0eXBlRXJyb3IiLCJUeXBlRXJyb3IiLCJyZWFjdEVycm9yIiwic3RhY2siLCJwYWdlRXJyb3IiLCJzZWN0aW9uRXJyb3IiLCJjb21wb25lbnRFcnJvciIsImVycm9yc0J5SW1wYWN0IiwidG9CZVVuZGVmaW5lZCIsImkiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJwYXR0ZXJuIiwiZmluZCIsInAiLCJpbmNsdWRlcyIsInRvQmVEZWZpbmVkIiwiZnJlcXVlbmN5IiwiYWZmZWN0ZWRDb21wb25lbnRzIiwidG9Db250YWluIiwiY2h1bmtQYXR0ZXJuIiwic3VnZ2VzdGVkRml4IiwibmV0d29ya1BhdHRlcm4iLCJ0eXBlUGF0dGVybiIsImxpc3RlbmVyIiwiYWRkRXJyb3JMaXN0ZW5lciIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib2JqZWN0Q29udGFpbmluZyIsInJlbW92ZUVycm9yTGlzdGVuZXIiLCJub3QiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiZmF1bHR5TGlzdGVuZXIiLCJnb29kTGlzdGVuZXIiLCJhbnkiLCJ0eXBlIiwiaW1wYWN0IiwiZm9yRWFjaCIsImVycm9yRGF0YSIsImluZGV4IiwibmFtZSIsIm1lc3NhZ2UiLCJub3ciLCJEYXRlIiwicmVjZW50RXJyb3JzIiwidGltZXN0YW1wIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsImhlYWx0aFN0YXR1cyIsImdldEhlYWx0aFN0YXR1cyIsInN0YXR1cyIsImVycm9yUmF0ZSIsImNyaXRpY2FsRXJyb3JzIiwicmVjb21tZW5kYXRpb25zIiwiY3JpdGljYWxFcnJvciIsIm9yaWdpbmFsRGF0ZU5vdyIsIm9sZFRpbWVzdGFtcCIsIm9sZEVycm9yIiwicmVjZW50RXJyb3IiLCJyZWNlbnRFcnJvckV4aXN0cyIsInNvbWUiLCJlIiwiYmVmb3JlUmVzb2x2ZSIsInJlc29sdmVkIiwibWFya0Vycm9yUmVzb2x2ZWQiLCJhZnRlclJlc29sdmUiLCJyZXNvbHV0aW9uVGltZSIsImluc3RhbmNlMSIsImluc3RhbmNlMiIsIm1ldHJpY3MxIiwibWV0cmljczIiXSwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQsc0NBQXNDO0FBQ3RDLCtCQUErQjtBQUMvQixzQ0FBc0M7QUFDdEMsb0VBQW9FOzs7OztzQ0FFL0I7QUFHckMsc0NBQXNDO0FBQ3RDLFFBQVE7QUFDUixzQ0FBc0M7QUFFdEMsZ0JBQWdCO0FBQ2hCQSxPQUFPQyxLQUFLLEdBQUdDLEtBQUtDLEVBQUU7QUFFdEIsa0JBQWtCO0FBQ2xCLE1BQU1DLHVCQUF1QkMsUUFBUUMsS0FBSztBQUMxQyxNQUFNQyxxQkFBcUJGLFFBQVFHLEdBQUc7QUFDdEMsTUFBTUMsc0JBQXNCSixRQUFRSyxJQUFJO0FBRXhDQyxXQUFXO0lBQ1ROLFFBQVFDLEtBQUssR0FBR0osS0FBS0MsRUFBRTtJQUN2QkUsUUFBUUcsR0FBRyxHQUFHTixLQUFLQyxFQUFFO0lBQ3JCRSxRQUFRSyxJQUFJLEdBQUdSLEtBQUtDLEVBQUU7SUFDdEJELEtBQUtVLGFBQWE7SUFDakJYLE1BQW9CWSxTQUFTO0lBRTlCLHdEQUF3RDtJQUN4REMsMENBQW9CLENBQUNDLGNBQWMsQ0FBQztJQUVwQyw4REFBOEQ7SUFDOUQsTUFBTUMsVUFBVUYsMENBQW9CO0lBQ3BDRSxRQUFRQyxNQUFNLENBQUNDLEtBQUs7SUFDcEJGLFFBQVFHLFFBQVEsQ0FBQ0QsS0FBSztBQUN4QjtBQUVBRSxVQUFVO0lBQ1JmLFFBQVFDLEtBQUssR0FBR0Y7SUFDaEJDLFFBQVFHLEdBQUcsR0FBR0Q7SUFDZEYsUUFBUUssSUFBSSxHQUFHRDtBQUNqQjtBQUVBLHNDQUFzQztBQUN0Qyx5QkFBeUI7QUFDekIsc0NBQXNDO0FBRXRDWSxTQUFTLHdDQUF3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