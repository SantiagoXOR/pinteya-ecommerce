{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\retry-logic.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - RETRY LOGIC WITH EXPONENTIAL BACKOFF\n// ===================================\n\nimport { logger, LogLevel, LogCategory } from './enterprise/logger'\nimport { metricsCollector } from './enterprise/metrics'\n\n// Configuración de retry\nexport interface RetryConfig {\n  maxRetries: number // Máximo número de reintentos\n  baseDelayMs: number // Delay base en milisegundos\n  maxDelayMs: number // Delay máximo en milisegundos\n  backoffMultiplier: number // Multiplicador para backoff exponencial\n  jitterMs: number // Jitter máximo en milisegundos\n  retryableErrors: string[] // Códigos de error que permiten retry\n  nonRetryableErrors: string[] // Códigos de error que NO permiten retry\n}\n\n// Configuraciones predefinidas\nexport const RETRY_CONFIGS: Record<string, RetryConfig> = {\n  // Para llamadas críticas a MercadoPago\n  MERCADOPAGO_CRITICAL: {\n    maxRetries: 3,\n    baseDelayMs: 1000, // 1 segundo\n    maxDelayMs: 30000, // 30 segundos\n    backoffMultiplier: 2,\n    jitterMs: 500,\n    retryableErrors: [\n      'ECONNRESET',\n      'ENOTFOUND',\n      'ECONNREFUSED',\n      'ETIMEDOUT',\n      'NETWORK_ERROR',\n      'TIMEOUT',\n      '500',\n      '502',\n      '503',\n      '504',\n      '429', // Rate limit - retry después de delay\n    ],\n    nonRetryableErrors: [\n      '400', // Bad Request\n      '401', // Unauthorized\n      '403', // Forbidden\n      '404', // Not Found\n      '422', // Unprocessable Entity\n      'INVALID_CREDENTIALS',\n      'INVALID_REQUEST',\n      'PAYMENT_REJECTED',\n    ],\n  },\n\n  // Para operaciones de consulta menos críticas\n  MERCADOPAGO_QUERY: {\n    maxRetries: 2,\n    baseDelayMs: 500, // 0.5 segundos\n    maxDelayMs: 10000, // 10 segundos\n    backoffMultiplier: 2,\n    jitterMs: 250,\n    retryableErrors: ['ECONNRESET', 'ENOTFOUND', 'ETIMEDOUT', '500', '502', '503', '504'],\n    nonRetryableErrors: ['400', '401', '403', '404', '422'],\n  },\n\n  // Para webhooks (menos agresivo)\n  WEBHOOK_PROCESSING: {\n    maxRetries: 1,\n    baseDelayMs: 2000, // 2 segundos\n    maxDelayMs: 5000, // 5 segundos\n    backoffMultiplier: 1.5,\n    jitterMs: 1000,\n    retryableErrors: ['ECONNRESET', 'ETIMEDOUT', '500', '503'],\n    nonRetryableErrors: ['400', '401', '403', '404', '422', 'DUPLICATE_WEBHOOK'],\n  },\n} as const\n\n// Resultado del retry\nexport interface RetryResult<T> {\n  success: boolean\n  data?: T\n  error?: Error\n  attempts: number\n  totalDuration: number\n  lastAttemptDuration: number\n}\n\n// Información del intento\nexport interface AttemptInfo {\n  attempt: number\n  maxRetries: number\n  delay: number\n  error?: Error\n  duration: number\n}\n\n/**\n * Calcula el delay para el siguiente intento usando backoff exponencial con jitter\n */\nfunction calculateDelay(attempt: number, config: RetryConfig): number {\n  // Backoff exponencial: baseDelay * (multiplier ^ attempt)\n  const exponentialDelay = config.baseDelayMs * Math.pow(config.backoffMultiplier, attempt)\n\n  // Aplicar límite máximo\n  const cappedDelay = Math.min(exponentialDelay, config.maxDelayMs)\n\n  // Agregar jitter aleatorio para evitar thundering herd\n  const jitter = Math.random() * config.jitterMs\n\n  return Math.floor(cappedDelay + jitter)\n}\n\n/**\n * Determina si un error es reintentable\n */\nfunction isRetryableError(error: Error, config: RetryConfig): boolean {\n  const errorMessage = (error.message || '').toLowerCase()\n  const errorName = (error.name || '').toLowerCase()\n\n  // Verificar errores no reintenables primero (tienen prioridad)\n  for (const nonRetryableError of config.nonRetryableErrors) {\n    if (\n      errorMessage.includes(nonRetryableError.toLowerCase()) ||\n      errorName.includes(nonRetryableError.toLowerCase())\n    ) {\n      return false\n    }\n  }\n\n  // Verificar errores reintenables\n  for (const retryableError of config.retryableErrors) {\n    if (\n      errorMessage.includes(retryableError.toLowerCase()) ||\n      errorName.includes(retryableError.toLowerCase())\n    ) {\n      return true\n    }\n  }\n\n  // Por defecto, no reintentar errores desconocidos\n  return false\n}\n\n/**\n * Extrae información del error para logging\n */\nfunction extractErrorInfo(error: Error): {\n  type: string\n  code?: string\n  statusCode?: number\n  isNetwork: boolean\n} {\n  const message = (error.message || '').toLowerCase()\n  const name = (error.name || '').toLowerCase()\n\n  // Detectar errores de red\n  const networkErrors = ['econnreset', 'enotfound', 'econnrefused', 'etimedout']\n  const isNetwork = networkErrors.some(\n    netError => message.includes(netError) || name.includes(netError)\n  )\n\n  // Extraer código de estado HTTP si existe\n  const statusMatch = message.match(/(\\d{3})/)\n  const statusCode = statusMatch ? parseInt(statusMatch[1]) : undefined\n\n  return {\n    type: name || 'unknown',\n    code: statusCode?.toString(),\n    statusCode,\n    isNetwork,\n  }\n}\n\n/**\n * Función principal de retry con backoff exponencial\n */\nexport async function retryWithBackoff<T>(\n  operation: () => Promise<T>,\n  config: RetryConfig,\n  operationName: string = 'unknown'\n): Promise<RetryResult<T>> {\n  const startTime = Date.now()\n  let lastError: Error | undefined\n  let attempts = 0\n\n  logger.info(LogCategory.API, `Starting retry operation: ${operationName}`)\n\n  for (let attempt = 0; attempt <= config.maxRetries; attempt++) {\n    attempts = attempt + 1\n    const attemptStart = Date.now()\n\n    try {\n      logger.info(\n        LogCategory.API,\n        `Retry attempt ${attempts}/${config.maxRetries + 1} for ${operationName}`\n      )\n\n      const result = await operation()\n      const attemptDuration = Date.now() - attemptStart\n      const totalDuration = Date.now() - startTime\n\n      logger.info(LogCategory.API, `Retry operation succeeded: ${operationName}`)\n\n      // ✅ NUEVO: Registrar métricas de retry exitoso\n      await metricsCollector.recordRetry(operationName, attempts, true, totalDuration)\n\n      return {\n        success: true,\n        data: result,\n        attempts,\n        totalDuration,\n        lastAttemptDuration: attemptDuration,\n      }\n    } catch (error) {\n      lastError = error as Error\n      const attemptDuration = Date.now() - attemptStart\n      const errorInfo = extractErrorInfo(lastError)\n\n      const attemptInfo: AttemptInfo = {\n        attempt: attempts,\n        maxRetries: config.maxRetries + 1,\n        delay: 0,\n        error: lastError,\n        duration: attemptDuration,\n      }\n\n      // Log del intento fallido\n      logger.warn(LogCategory.API, `Retry attempt ${attempts} failed for ${operationName}`)\n\n      // Si es el último intento, no calcular delay\n      if (attempt === config.maxRetries) {\n        break\n      }\n\n      // Verificar si el error es reintentable\n      if (!isRetryableError(lastError, config)) {\n        logger.error(LogCategory.API, `Non-retryable error for ${operationName}`, lastError)\n        break\n      }\n\n      // Calcular delay para el siguiente intento\n      const delay = calculateDelay(attempt, config)\n      attemptInfo.delay = delay\n\n      logger.info(LogCategory.API, `Retrying ${operationName} in ${delay}ms`)\n\n      // Esperar antes del siguiente intento\n      await new Promise(resolve => setTimeout(resolve, delay))\n    }\n  }\n\n  // Todos los intentos fallaron\n  const totalDuration = Date.now() - startTime\n\n  logger.error(LogCategory.API, `All retry attempts failed for ${operationName}`, lastError!)\n\n  // ✅ NUEVO: Registrar métricas de retry fallido\n  await metricsCollector.recordRetry(operationName, attempts, false, totalDuration)\n\n  return {\n    success: false,\n    error: lastError,\n    attempts,\n    totalDuration,\n    lastAttemptDuration: 0,\n  }\n}\n\n/**\n * Wrapper específico para operaciones de MercadoPago\n */\nexport async function retryMercadoPagoOperation<T>(\n  operation: () => Promise<T>,\n  operationName: string,\n  isCritical: boolean = true\n): Promise<RetryResult<T>> {\n  const config = isCritical ? RETRY_CONFIGS.MERCADOPAGO_CRITICAL : RETRY_CONFIGS.MERCADOPAGO_QUERY\n\n  return retryWithBackoff(operation, config, `MercadoPago:${operationName}`)\n}\n\n/**\n * Wrapper para operaciones de webhook\n */\nexport async function retryWebhookOperation<T>(\n  operation: () => Promise<T>,\n  operationName: string\n): Promise<RetryResult<T>> {\n  return retryWithBackoff(operation, RETRY_CONFIGS.WEBHOOK_PROCESSING, `Webhook:${operationName}`)\n}\n\n/**\n * Función de utilidad para crear un retry personalizado\n */\nexport function createRetryFunction<T>(config: RetryConfig, operationName: string) {\n  return (operation: () => Promise<T>): Promise<RetryResult<T>> => {\n    return retryWithBackoff(operation, config, operationName)\n  }\n}\n"],"names":["RETRY_CONFIGS","createRetryFunction","retryMercadoPagoOperation","retryWebhookOperation","retryWithBackoff","MERCADOPAGO_CRITICAL","maxRetries","baseDelayMs","maxDelayMs","backoffMultiplier","jitterMs","retryableErrors","nonRetryableErrors","MERCADOPAGO_QUERY","WEBHOOK_PROCESSING","calculateDelay","attempt","config","exponentialDelay","Math","pow","cappedDelay","min","jitter","random","floor","isRetryableError","error","errorMessage","message","toLowerCase","errorName","name","nonRetryableError","includes","retryableError","extractErrorInfo","networkErrors","isNetwork","some","netError","statusMatch","match","statusCode","parseInt","undefined","type","code","toString","operation","operationName","startTime","Date","now","lastError","attempts","logger","info","LogCategory","API","attemptStart","result","attemptDuration","totalDuration","metricsCollector","recordRetry","success","data","lastAttemptDuration","errorInfo","attemptInfo","delay","duration","warn","Promise","resolve","setTimeout","isCritical"],"mappings":"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"}