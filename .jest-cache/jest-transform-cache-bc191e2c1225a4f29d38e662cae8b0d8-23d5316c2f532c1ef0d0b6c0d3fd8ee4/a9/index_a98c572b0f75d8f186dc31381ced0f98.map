{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\integrations\\redis\\index.ts"],"sourcesContent":["// ===================================\r\n// PINTEYA E-COMMERCE - REDIS CONFIGURATION\r\n// ===================================\r\n\r\nimport Redis from 'ioredis';\r\nimport { logger, LogLevel, LogCategory } from '../../enterprise/logger';\r\n\r\n// Configuración de Redis\r\nconst REDIS_CONFIG = {\r\n  host: process.env.REDIS_HOST || 'localhost',\r\n  port: parseInt(process.env.REDIS_PORT || '6379'),\r\n  password: process.env.REDIS_PASSWORD,\r\n  db: parseInt(process.env.REDIS_DB || '0'),\r\n  retryDelayOnFailover: 100,\r\n  maxRetriesPerRequest: 3,\r\n  lazyConnect: true,\r\n  keepAlive: 30000,\r\n  connectTimeout: 10000,\r\n  commandTimeout: 5000,\r\n};\r\n\r\n// Mock Redis para desarrollo cuando Redis no está disponible\r\nclass MockRedis {\r\n  private storage = new Map<string, any>();\r\n\r\n  async get(key: string): Promise<string | null> {\r\n    return this.storage.get(key) || null;\r\n  }\r\n\r\n  async set(key: string, value: any, ...args: any[]): Promise<'OK'> {\r\n    this.storage.set(key, value);\r\n    return 'OK';\r\n  }\r\n\r\n  async del(key: string): Promise<number> {\r\n    const existed = this.storage.has(key);\r\n    this.storage.delete(key);\r\n    return existed ? 1 : 0;\r\n  }\r\n\r\n  async exists(key: string): Promise<number> {\r\n    return this.storage.has(key) ? 1 : 0;\r\n  }\r\n\r\n  async incr(key: string): Promise<number> {\r\n    const current = parseInt(this.storage.get(key) || '0');\r\n    const newValue = current + 1;\r\n    this.storage.set(key, newValue.toString());\r\n    return newValue;\r\n  }\r\n\r\n  async expire(key: string, seconds: number): Promise<number> {\r\n    // Mock: no implementamos expiración real\r\n    return 1;\r\n  }\r\n\r\n  async keys(pattern: string): Promise<string[]> {\r\n    const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\r\n    return Array.from(this.storage.keys()).filter(key => regex.test(key));\r\n  }\r\n\r\n  async flushall(): Promise<'OK'> {\r\n    this.storage.clear();\r\n    return 'OK';\r\n  }\r\n\r\n  // Métodos de listas para métricas\r\n  async lpush(key: string, ...values: string[]): Promise<number> {\r\n    const list = this.storage.get(key) || [];\r\n    list.unshift(...values);\r\n    this.storage.set(key, list);\r\n    return list.length;\r\n  }\r\n\r\n  async ltrim(key: string, start: number, stop: number): Promise<'OK'> {\r\n    const list = this.storage.get(key) || [];\r\n    const trimmed = list.slice(start, stop + 1);\r\n    this.storage.set(key, trimmed);\r\n    return 'OK';\r\n  }\r\n\r\n  async lrange(key: string, start: number, stop: number): Promise<string[]> {\r\n    const list = this.storage.get(key) || [];\r\n    if (stop === -1) {\r\n      return list.slice(start);\r\n    }\r\n    return list.slice(start, stop + 1);\r\n  }\r\n\r\n  async ttl(key: string): Promise<number> {\r\n    // Mock: retornar -1 (sin expiración) o un valor fijo\r\n    return this.storage.has(key) ? 3600 : -2;\r\n  }\r\n\r\n  // Pipeline mock para operaciones batch\r\n  pipeline(): MockPipeline {\r\n    return new MockPipeline(this);\r\n  }\r\n\r\n  // Métodos de conexión mock\r\n  async connect(): Promise<void> {\r\n    console.log('[REDIS MOCK] Conectado (simulado)');\r\n  }\r\n\r\n  disconnect(): void {\r\n    console.log('[REDIS MOCK] Desconectado (simulado)');\r\n  }\r\n\r\n  on(event: string, callback: Function): this {\r\n    return this;\r\n  }\r\n\r\n  async quit(): Promise<'OK'> {\r\n    console.log('[REDIS MOCK] Desconectado (quit simulado)');\r\n    return 'OK';\r\n  }\r\n}\r\n\r\n// Mock Pipeline para operaciones batch\r\nclass MockPipeline {\r\n  private commands: Array<{ method: string; args: any[] }> = [];\r\n  private redis: MockRedis;\r\n\r\n  constructor(redis: MockRedis) {\r\n    this.redis = redis;\r\n  }\r\n\r\n  get(key: string): this {\r\n    this.commands.push({ method: 'get', args: [key] });\r\n    return this;\r\n  }\r\n\r\n  ttl(key: string): this {\r\n    this.commands.push({ method: 'ttl', args: [key] });\r\n    return this;\r\n  }\r\n\r\n  incr(key: string): this {\r\n    this.commands.push({ method: 'incr', args: [key] });\r\n    return this;\r\n  }\r\n\r\n  expire(key: string, seconds: number): this {\r\n    this.commands.push({ method: 'expire', args: [key, seconds] });\r\n    return this;\r\n  }\r\n\r\n  async exec(): Promise<Array<[Error | null, any]>> {\r\n    const results: Array<[Error | null, any]> = [];\r\n\r\n    for (const command of this.commands) {\r\n      try {\r\n        const result = await (this.redis as any)[command.method](...command.args);\r\n        results.push([null, result]);\r\n      } catch (error) {\r\n        results.push([error as Error, null]);\r\n      }\r\n    }\r\n\r\n    this.commands = []; // Limpiar comandos después de ejecutar\r\n    return results;\r\n  }\r\n}\r\n\r\n// Cliente Redis singleton\r\nlet redisClient: Redis | MockRedis | null = null;\r\nlet isUsingMock = false;\r\n\r\n/**\r\n * Obtiene o crea la instancia de Redis\r\n */\r\nexport function getRedisClient(): Redis | MockRedis {\r\n  if (!redisClient) {\r\n    // Verificar si Redis está deshabilitado\r\n    if (process.env.DISABLE_REDIS === 'true') {\r\n      console.log('[REDIS] Redis deshabilitado por configuración, usando mock');\r\n      redisClient = new MockRedis();\r\n      isUsingMock = true;\r\n      return redisClient;\r\n    }\r\n\r\n    try {\r\n      redisClient = new Redis(REDIS_CONFIG);\r\n\r\n      // Event listeners para logging\r\n      redisClient.on('connect', () => {\r\n        logger.info(LogCategory.API, 'Redis connected successfully');\r\n        isUsingMock = false;\r\n      });\r\n\r\n      redisClient.on('error', (error) => {\r\n        logger.error(LogCategory.API, 'Redis connection error', error);\r\n        // Si hay error de conexión, usar mock\r\n        if (!isUsingMock) {\r\n          console.log('[REDIS] Cambiando a modo mock debido a error de conexión');\r\n          redisClient = new MockRedis();\r\n          isUsingMock = true;\r\n        }\r\n      });\r\n\r\n      redisClient.on('close', () => {\r\n        logger.warn(LogCategory.API, 'Redis connection closed');\r\n      });\r\n\r\n      redisClient.on('reconnecting', () => {\r\n        logger.info(LogCategory.API, 'Redis reconnecting...');\r\n      });\r\n\r\n    } catch (error) {\r\n      console.log('[REDIS] Error inicializando Redis, usando mock:', error.message);\r\n      redisClient = new MockRedis();\r\n      isUsingMock = true;\r\n    }\r\n  }\r\n\r\n  return redisClient;\r\n}\r\n\r\n/**\r\n * Verifica si Redis está disponible\r\n */\r\nexport async function isRedisAvailable(): Promise<boolean> {\r\n  try {\r\n    if (isUsingMock) {\r\n      return false; // Mock no es Redis real\r\n    }\r\n    const client = getRedisClient();\r\n    if (client instanceof MockRedis) {\r\n      return false;\r\n    }\r\n    await (client as Redis).ping();\r\n    return true;\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Redis health check failed', error as Error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Cierra la conexión de Redis\r\n */\r\nexport async function closeRedisConnection(): Promise<void> {\r\n  if (redisClient) {\r\n    await redisClient.quit();\r\n    redisClient = null;\r\n    logger.info(LogCategory.API, 'Redis connection closed gracefully');\r\n  }\r\n}\r\n\r\n/**\r\n * Operaciones de cache con manejo de errores\r\n */\r\nexport class RedisCache {\r\n  private client: Redis;\r\n\r\n  constructor() {\r\n    this.client = getRedisClient();\r\n  }\r\n\r\n  /**\r\n   * Obtiene un valor del cache\r\n   */\r\n  async get(key: string): Promise<string | null> {\r\n    try {\r\n      const value = await this.client.get(key);\r\n      logger.info(LogCategory.API, 'Cache get operation');\r\n      return value;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache get operation failed', error as Error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Establece un valor en el cache\r\n   */\r\n  async set(key: string, value: string, ttlSeconds?: number): Promise<boolean> {\r\n    try {\r\n      if (ttlSeconds) {\r\n        await this.client.setex(key, ttlSeconds, value);\r\n      } else {\r\n        await this.client.set(key, value);\r\n      }\r\n      \r\n      logger.info(LogCategory.API, 'Cache set operation');\r\n      return true;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache set operation failed', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Elimina un valor del cache\r\n   */\r\n  async del(key: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.client.del(key);\r\n      logger.info(LogCategory.API, 'Cache delete operation');\r\n      return result > 0;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache delete operation failed', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Incrementa un contador atómicamente\r\n   */\r\n  async incr(key: string): Promise<number | null> {\r\n    try {\r\n      const result = await this.client.incr(key);\r\n      logger.info(LogCategory.API, 'Cache increment operation');\r\n      return result;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache increment operation failed', error as Error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Establece TTL para una clave existente\r\n   */\r\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\r\n    try {\r\n      const result = await this.client.expire(key, ttlSeconds);\r\n      logger.info(LogCategory.API, 'Cache expire operation');\r\n      return result === 1;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache expire operation failed', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obtiene TTL restante de una clave\r\n   */\r\n  async ttl(key: string): Promise<number | null> {\r\n    try {\r\n      const result = await this.client.ttl(key);\r\n      logger.info(LogCategory.API, 'Cache TTL check');\r\n      return result;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache TTL check failed', error as Error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n// Instancia singleton del cache\r\nexport const redisCache = new RedisCache();\r\n\r\n// Funciones de utilidad para rate limiting\r\nexport async function getRateLimitInfo(key: string): Promise<{\r\n  count: number;\r\n  ttl: number;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const pipeline = client.pipeline();\r\n    pipeline.get(key);\r\n    pipeline.ttl(key);\r\n    \r\n    const results = await pipeline.exec();\r\n    \r\n    if (!results || results.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    const [countResult, ttlResult] = results;\r\n    const count = parseInt(countResult[1] as string) || 0;\r\n    const ttl = ttlResult[1] as number;\r\n\r\n    return { count, ttl };\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Rate limit info retrieval failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function incrementRateLimit(key: string, windowSeconds: number): Promise<{\r\n  count: number;\r\n  ttl: number;\r\n  isNewWindow: boolean;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const pipeline = client.pipeline();\r\n\r\n    // Incrementar contador\r\n    pipeline.incr(key);\r\n    // Establecer TTL solo si es la primera vez\r\n    pipeline.expire(key, windowSeconds);\r\n    // Obtener TTL actual\r\n    pipeline.ttl(key);\r\n\r\n    const results = await pipeline.exec();\r\n\r\n    if (!results || results.length !== 3) {\r\n      return null;\r\n    }\r\n\r\n    const count = results[0][1] as number;\r\n    const ttl = results[2][1] as number;\r\n    const isNewWindow = count === 1;\r\n\r\n    return { count, ttl, isNewWindow };\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Rate limit increment failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// =====================================================\r\n// FUNCIONES ENTERPRISE PARA RATE LIMITING\r\n// =====================================================\r\n\r\n/**\r\n * Rate limiting enterprise con sliding window\r\n */\r\nexport async function enterpriseRateLimit(\r\n  key: string,\r\n  windowMs: number,\r\n  maxRequests: number\r\n): Promise<{\r\n  allowed: boolean;\r\n  count: number;\r\n  remaining: number;\r\n  resetTime: number;\r\n  retryAfter?: number;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const now = Date.now();\r\n    const window = Math.floor(now / windowMs);\r\n    const redisKey = `rate_limit:${key}:${window}`;\r\n\r\n    // Usar pipeline para operaciones atómicas\r\n    const pipeline = client.pipeline();\r\n    pipeline.incr(redisKey);\r\n    pipeline.expire(redisKey, Math.ceil(windowMs / 1000));\r\n\r\n    const results = await pipeline.exec();\r\n\r\n    if (!results || results.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    const count = results[0][1] as number;\r\n    const remaining = Math.max(0, maxRequests - count);\r\n    const resetTime = (window + 1) * windowMs;\r\n    const allowed = count <= maxRequests;\r\n\r\n    const result = {\r\n      allowed,\r\n      count,\r\n      remaining,\r\n      resetTime,\r\n      retryAfter: allowed ? undefined : Math.ceil((resetTime - now) / 1000)\r\n    };\r\n\r\n    logger.debug(LogCategory.API, 'Enterprise rate limit check', {\r\n      key: redisKey,\r\n      count,\r\n      maxRequests,\r\n      allowed,\r\n      remaining\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Enterprise rate limit failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Rate limiting con múltiples ventanas (más preciso)\r\n */\r\nexport async function slidingWindowRateLimit(\r\n  key: string,\r\n  windowMs: number,\r\n  maxRequests: number,\r\n  precision: number = 10\r\n): Promise<{\r\n  allowed: boolean;\r\n  count: number;\r\n  remaining: number;\r\n  resetTime: number;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const now = Date.now();\r\n    const windowSize = Math.floor(windowMs / precision);\r\n    const currentWindow = Math.floor(now / windowSize);\r\n\r\n    // Limpiar ventanas antiguas y contar requests en ventana actual\r\n    const pipeline = client.pipeline();\r\n\r\n    // Eliminar ventanas más antiguas que el período de rate limiting\r\n    for (let i = 1; i <= precision; i++) {\r\n      const oldWindow = currentWindow - precision - i;\r\n      pipeline.del(`${key}:${oldWindow}`);\r\n    }\r\n\r\n    // Incrementar contador para ventana actual\r\n    const currentKey = `${key}:${currentWindow}`;\r\n    pipeline.incr(currentKey);\r\n    pipeline.expire(currentKey, Math.ceil(windowMs / 1000));\r\n\r\n    // Obtener contadores de todas las ventanas en el período\r\n    for (let i = 0; i < precision; i++) {\r\n      const windowKey = `${key}:${currentWindow - i}`;\r\n      pipeline.get(windowKey);\r\n    }\r\n\r\n    const results = await pipeline.exec();\r\n\r\n    if (!results) {\r\n      return null;\r\n    }\r\n\r\n    // Calcular total de requests en la ventana deslizante\r\n    let totalCount = 0;\r\n    const countResults = results.slice(precision + 2); // Saltar operaciones de limpieza e incremento\r\n\r\n    for (const result of countResults) {\r\n      if (result[1]) {\r\n        totalCount += parseInt(result[1] as string);\r\n      }\r\n    }\r\n\r\n    const remaining = Math.max(0, maxRequests - totalCount);\r\n    const allowed = totalCount <= maxRequests;\r\n    const resetTime = (currentWindow + 1) * windowSize;\r\n\r\n    return {\r\n      allowed,\r\n      count: totalCount,\r\n      remaining,\r\n      resetTime\r\n    };\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Sliding window rate limit failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Obtener estadísticas de rate limiting\r\n */\r\nexport async function getRateLimitStats(pattern: string = 'rate_limit:*'): Promise<{\r\n  totalKeys: number;\r\n  activeWindows: number;\r\n  topKeys: Array<{ key: string; count: number; ttl: number }>;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const keys = await client.keys(pattern);\r\n\r\n    if (keys.length === 0) {\r\n      return {\r\n        totalKeys: 0,\r\n        activeWindows: 0,\r\n        topKeys: []\r\n      };\r\n    }\r\n\r\n    // Obtener información de las claves más activas\r\n    const pipeline = client.pipeline();\r\n    keys.forEach(key => {\r\n      pipeline.get(key);\r\n      pipeline.ttl(key);\r\n    });\r\n\r\n    const results = await pipeline.exec();\r\n\r\n    if (!results) {\r\n      return null;\r\n    }\r\n\r\n    const keyStats: Array<{ key: string; count: number; ttl: number }> = [];\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n      const countResult = results[i * 2];\r\n      const ttlResult = results[i * 2 + 1];\r\n\r\n      if (countResult[1] && ttlResult[1]) {\r\n        keyStats.push({\r\n          key: keys[i],\r\n          count: parseInt(countResult[1] as string),\r\n          ttl: ttlResult[1] as number\r\n        });\r\n      }\r\n    }\r\n\r\n    // Ordenar por count descendente\r\n    keyStats.sort((a, b) => b.count - a.count);\r\n\r\n    return {\r\n      totalKeys: keys.length,\r\n      activeWindows: keyStats.filter(stat => stat.ttl > 0).length,\r\n      topKeys: keyStats.slice(0, 10) // Top 10\r\n    };\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Rate limit stats failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Limpiar claves de rate limiting expiradas\r\n */\r\nexport async function cleanupRateLimitKeys(pattern: string = 'rate_limit:*'): Promise<number> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const keys = await client.keys(pattern);\r\n\r\n    if (keys.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    // Verificar TTL de cada clave y eliminar las expiradas\r\n    const pipeline = client.pipeline();\r\n    keys.forEach(key => {\r\n      pipeline.ttl(key);\r\n    });\r\n\r\n    const ttlResults = await pipeline.exec();\r\n\r\n    if (!ttlResults) {\r\n      return 0;\r\n    }\r\n\r\n    const expiredKeys: string[] = [];\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n      const ttlResult = ttlResults[i];\r\n      if (ttlResult[1] === -2) { // Clave expirada\r\n        expiredKeys.push(keys[i]);\r\n      }\r\n    }\r\n\r\n    if (expiredKeys.length > 0) {\r\n      await client.del(...expiredKeys);\r\n      logger.info(LogCategory.API, `Cleaned up ${expiredKeys.length} expired rate limit keys`);\r\n    }\r\n\r\n    return expiredKeys.length;\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Rate limit cleanup failed', error as Error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n// Exportar cliente Redis para uso directo\r\nexport const redis = getRedisClient();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":["RedisCache","cleanupRateLimitKeys","closeRedisConnection","enterpriseRateLimit","getRateLimitInfo","getRateLimitStats","getRedisClient","incrementRateLimit","isRedisAvailable","redis","redisCache","slidingWindowRateLimit","REDIS_CONFIG","host","process","env","REDIS_HOST","port","parseInt","REDIS_PORT","password","REDIS_PASSWORD","db","REDIS_DB","retryDelayOnFailover","maxRetriesPerRequest","lazyConnect","keepAlive","connectTimeout","commandTimeout","MockRedis","get","key","storage","set","value","args","del","existed","has","delete","exists","incr","current","newValue","toString","expire","seconds","keys","pattern","regex","RegExp","replace","Array","from","filter","test","flushall","clear","lpush","values","list","unshift","length","ltrim","start","stop","trimmed","slice","lrange","ttl","pipeline","MockPipeline","connect","console","log","disconnect","on","event","callback","quit","Map","commands","push","method","exec","results","command","result","error","redisClient","isUsingMock","DISABLE_REDIS","Redis","logger","info","LogCategory","API","warn","message","client","ping","ttlSeconds","setex","countResult","ttlResult","count","windowSeconds","isNewWindow","windowMs","maxRequests","now","Date","window","Math","floor","redisKey","ceil","remaining","max","resetTime","allowed","retryAfter","undefined","debug","precision","windowSize","currentWindow","i","oldWindow","currentKey","windowKey","totalCount","countResults","totalKeys","activeWindows","topKeys","forEach","keyStats","sort","a","b","stat","ttlResults","expiredKeys"],"mappings":"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"}