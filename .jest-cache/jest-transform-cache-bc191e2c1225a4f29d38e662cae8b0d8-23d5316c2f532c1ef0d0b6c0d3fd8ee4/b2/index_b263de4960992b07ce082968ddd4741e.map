{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\enterprise\\metrics\\index.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - METRICS SYSTEM\n// ===================================\n\nimport { redisCache } from '../../integrations/redis'\nimport { logger, LogLevel, LogCategory } from '../logger'\n\n// Tipos de métricas\nexport interface MetricData {\n  timestamp: number\n  value: number\n  labels?: Record<string, string>\n}\n\nexport interface AggregatedMetric {\n  count: number\n  sum: number\n  avg: number\n  min: number\n  max: number\n  p95: number\n  p99: number\n}\n\nexport interface ApiMetrics {\n  requests: {\n    total: number\n    success: number\n    error: number\n    rate_limited: number\n  }\n  response_times: AggregatedMetric\n  error_rates: {\n    '4xx': number\n    '5xx': number\n    network: number\n    timeout: number\n  }\n  retry_stats: {\n    total_retries: number\n    successful_retries: number\n    failed_retries: number\n    avg_attempts: number\n  }\n}\n\nexport interface MercadoPagoMetrics {\n  payment_creation: ApiMetrics\n  payment_queries: ApiMetrics\n  webhook_processing: ApiMetrics\n  overall_health: {\n    uptime_percentage: number\n    avg_response_time: number\n    error_rate: number\n    last_incident: string | null\n  }\n}\n\n// Configuración de métricas\nconst METRICS_CONFIG = {\n  RETENTION_HOURS: 24,\n  AGGREGATION_WINDOW_MINUTES: 5,\n  ALERT_THRESHOLDS: {\n    ERROR_RATE: 0.05, // 5%\n    RESPONSE_TIME_P95: 5000, // 5 segundos\n    RATE_LIMIT_RATE: 0.1, // 10%\n  },\n}\n\n/**\n * Clase principal para manejo de métricas\n */\nexport class MetricsCollector {\n  private static instance: MetricsCollector\n\n  private constructor() {}\n\n  static getInstance(): MetricsCollector {\n    if (!MetricsCollector.instance) {\n      MetricsCollector.instance = new MetricsCollector()\n    }\n    return MetricsCollector.instance\n  }\n\n  /**\n   * Registra una métrica de request\n   */\n  async recordRequest(\n    endpoint: string,\n    method: string,\n    statusCode: number,\n    responseTime: number,\n    labels: Record<string, string> = {}\n  ): Promise<void> {\n    const timestamp = Date.now()\n    const baseKey = `metrics:${endpoint}:${method}`\n\n    try {\n      // Registrar request total\n      await this.incrementCounter(`${baseKey}:requests:total`, timestamp)\n\n      // Registrar por tipo de respuesta\n      if (statusCode >= 200 && statusCode < 300) {\n        await this.incrementCounter(`${baseKey}:requests:success`, timestamp)\n      } else if (statusCode === 429) {\n        await this.incrementCounter(`${baseKey}:requests:rate_limited`, timestamp)\n      } else {\n        await this.incrementCounter(`${baseKey}:requests:error`, timestamp)\n\n        // Categorizar errores\n        if (statusCode >= 400 && statusCode < 500) {\n          await this.incrementCounter(`${baseKey}:errors:4xx`, timestamp)\n        } else if (statusCode >= 500) {\n          await this.incrementCounter(`${baseKey}:errors:5xx`, timestamp)\n        }\n      }\n\n      // Registrar tiempo de respuesta\n      await this.recordValue(`${baseKey}:response_time`, responseTime, timestamp)\n\n      // Log para debugging\n      logger.info(LogCategory.API, 'Metric recorded')\n    } catch (error) {\n      logger.error(LogCategory.API, 'Failed to record metric', error as Error)\n    }\n  }\n\n  /**\n   * Registra una llamada a API (alias para recordRequest)\n   */\n  async recordApiCall(params: {\n    endpoint: string\n    method: string\n    statusCode: number\n    responseTime: number\n    userId?: string\n    error?: string\n  }): Promise<void> {\n    await this.recordRequest(\n      params.endpoint,\n      params.method,\n      params.statusCode,\n      params.responseTime,\n      {\n        userId: params.userId || 'anonymous',\n        error: params.error || '',\n      }\n    )\n  }\n\n  /**\n   * Registra métricas de retry\n   */\n  async recordRetry(\n    operation: string,\n    attempts: number,\n    success: boolean,\n    totalDuration: number\n  ): Promise<void> {\n    const timestamp = Date.now()\n    const baseKey = `metrics:retry:${operation}`\n\n    try {\n      await this.incrementCounter(`${baseKey}:total`, timestamp)\n      await this.recordValue(`${baseKey}:attempts`, attempts, timestamp)\n      await this.recordValue(`${baseKey}:duration`, totalDuration, timestamp)\n\n      if (success) {\n        await this.incrementCounter(`${baseKey}:success`, timestamp)\n      } else {\n        await this.incrementCounter(`${baseKey}:failed`, timestamp)\n      }\n    } catch (error) {\n      logger.error(LogCategory.API, 'Failed to record retry metric', error as Error)\n    }\n  }\n\n  /**\n   * Registra métricas de rate limiting\n   */\n  async recordRateLimit(\n    endpoint: string,\n    blocked: boolean,\n    remaining: number,\n    limit: number\n  ): Promise<void> {\n    const timestamp = Date.now()\n    const baseKey = `metrics:rate_limit:${endpoint}`\n\n    try {\n      await this.incrementCounter(`${baseKey}:checks`, timestamp)\n\n      if (blocked) {\n        await this.incrementCounter(`${baseKey}:blocked`, timestamp)\n      }\n\n      await this.recordValue(`${baseKey}:remaining`, remaining, timestamp)\n      await this.recordValue(`${baseKey}:utilization`, (limit - remaining) / limit, timestamp)\n    } catch (error) {\n      logger.error(LogCategory.API, 'Failed to record rate limit metric', error as Error)\n    }\n  }\n\n  /**\n   * Incrementa un contador\n   */\n  private async incrementCounter(key: string, timestamp: number): Promise<void> {\n    const windowKey = this.getWindowKey(key, timestamp)\n    await redisCache.incr(windowKey)\n    await redisCache.expire(windowKey, METRICS_CONFIG.RETENTION_HOURS * 3600)\n  }\n\n  /**\n   * Registra un valor numérico\n   */\n  private async recordValue(key: string, value: number, timestamp: number): Promise<void> {\n    try {\n      const windowKey = this.getWindowKey(key, timestamp)\n      const listKey = `${windowKey}:values`\n\n      // Obtener cliente Redis (real o mock)\n      const client = redisCache['client'] || redisCache\n\n      // Verificar si el cliente tiene los métodos necesarios\n      if (typeof client.lpush === 'function') {\n        await client.lpush(listKey, value.toString())\n        await client.ltrim(listKey, 0, 999) // Mantener últimos 1000 valores\n        await client.expire(listKey, METRICS_CONFIG.RETENTION_HOURS * 3600)\n      } else {\n        // Fallback para mock básico - usar storage simple\n        await redisCache.set(`${listKey}:latest`, value.toString())\n      }\n    } catch (error) {\n      logger.error(LogCategory.API, 'Failed to record metric value', error as Error)\n    }\n  }\n\n  /**\n   * Genera clave de ventana temporal\n   */\n  private getWindowKey(baseKey: string, timestamp: number): string {\n    const windowStart = Math.floor(\n      timestamp / (METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000)\n    )\n    return `${baseKey}:${windowStart}`\n  }\n\n  /**\n   * Obtiene métricas agregadas para un endpoint\n   */\n  async getApiMetrics(\n    endpoint: string,\n    method: string,\n    hoursBack: number = 1\n  ): Promise<ApiMetrics> {\n    const baseKey = `metrics:${endpoint}:${method}`\n    const now = Date.now()\n    const startTime = now - hoursBack * 60 * 60 * 1000\n\n    try {\n      // Obtener contadores\n      const requests = await this.getCounterSum(baseKey, 'requests', startTime, now)\n      const errors = await this.getCounterSum(baseKey, 'errors', startTime, now)\n\n      // Obtener tiempos de respuesta\n      const responseTimes = await this.getValueStats(`${baseKey}:response_time`, startTime, now)\n\n      // Obtener métricas de retry\n      const retryStats = await this.getRetryStats(endpoint, startTime, now)\n\n      return {\n        requests: {\n          total: requests.total || 0,\n          success: requests.success || 0,\n          error: requests.error || 0,\n          rate_limited: requests.rate_limited || 0,\n        },\n        response_times: responseTimes,\n        error_rates: {\n          '4xx': errors['4xx'] || 0,\n          '5xx': errors['5xx'] || 0,\n          network: errors.network || 0,\n          timeout: errors.timeout || 0,\n        },\n        retry_stats: retryStats,\n      }\n    } catch (error) {\n      logger.error(LogCategory.API, 'Failed to get API metrics', error as Error)\n\n      // Retornar métricas vacías en caso de error\n      return this.getEmptyApiMetrics()\n    }\n  }\n\n  /**\n   * Obtiene suma de contadores en un rango de tiempo\n   */\n  private async getCounterSum(\n    baseKey: string,\n    category: string,\n    startTime: number,\n    endTime: number\n  ): Promise<Record<string, number>> {\n    const result: Record<string, number> = {}\n    const windowSize = METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000\n\n    for (let time = startTime; time <= endTime; time += windowSize) {\n      const windowStart = Math.floor(time / windowSize)\n\n      // Obtener diferentes tipos de contadores\n      const types = [\n        'total',\n        'success',\n        'error',\n        'rate_limited',\n        '4xx',\n        '5xx',\n        'network',\n        'timeout',\n      ]\n\n      for (const type of types) {\n        const key = `${baseKey}:${category}:${type}:${windowStart}`\n        const value = await redisCache.get(key)\n        result[type] = (result[type] || 0) + parseInt(value || '0')\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Obtiene estadísticas de valores numéricos\n   */\n  private async getValueStats(\n    baseKey: string,\n    startTime: number,\n    endTime: number\n  ): Promise<AggregatedMetric> {\n    const values: number[] = []\n    const windowSize = METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000\n\n    for (let time = startTime; time <= endTime; time += windowSize) {\n      const windowStart = Math.floor(time / windowSize)\n      const key = `${baseKey}:${windowStart}:values`\n\n      try {\n        const client = redisCache['client'] || redisCache\n\n        if (typeof client.lrange === 'function') {\n          const windowValues = await client.lrange(key, 0, -1)\n          values.push(...windowValues.map(v => parseFloat(v)).filter(v => !isNaN(v)))\n        } else {\n          // Fallback para mock básico\n          const value = await redisCache.get(`${key}:latest`)\n          if (value) {\n            const numValue = parseFloat(value)\n            if (!isNaN(numValue)) {\n              values.push(numValue)\n            }\n          }\n        }\n      } catch (error) {\n        // Continuar si no se puede obtener valores de una ventana\n      }\n    }\n\n    if (values.length === 0) {\n      return { count: 0, sum: 0, avg: 0, min: 0, max: 0, p95: 0, p99: 0 }\n    }\n\n    values.sort((a, b) => a - b)\n    const sum = values.reduce((a, b) => a + b, 0)\n\n    return {\n      count: values.length,\n      sum,\n      avg: sum / values.length,\n      min: values[0],\n      max: values[values.length - 1],\n      p95: values[Math.floor(values.length * 0.95)] || 0,\n      p99: values[Math.floor(values.length * 0.99)] || 0,\n    }\n  }\n\n  /**\n   * Obtiene estadísticas de retry\n   */\n  private async getRetryStats(\n    operation: string,\n    startTime: number,\n    endTime: number\n  ): Promise<ApiMetrics['retry_stats']> {\n    const baseKey = `metrics:retry:${operation}`\n    const counters = await this.getCounterSum(baseKey, '', startTime, endTime)\n    const attempts = await this.getValueStats(`${baseKey}:attempts`, startTime, endTime)\n\n    return {\n      total_retries: counters.total || 0,\n      successful_retries: counters.success || 0,\n      failed_retries: counters.failed || 0,\n      avg_attempts: attempts.avg || 0,\n    }\n  }\n\n  /**\n   * Obtiene métricas específicas de MercadoPago\n   */\n  async getMercadoPagoMetrics(hoursBack: number = 1): Promise<MercadoPagoMetrics> {\n    try {\n      const [paymentCreation, paymentQueries, webhookProcessing] = await Promise.all([\n        this.getApiMetrics('/api/payments/create-preference', 'POST', hoursBack),\n        this.getApiMetrics('/api/payments/query', 'GET', hoursBack),\n        this.getApiMetrics('/api/webhooks/mercadopago', 'POST', hoursBack),\n      ])\n\n      // Calcular métricas generales de salud\n      const totalRequests =\n        paymentCreation.requests.total +\n        paymentQueries.requests.total +\n        webhookProcessing.requests.total\n\n      const totalErrors =\n        paymentCreation.requests.error +\n        paymentQueries.requests.error +\n        webhookProcessing.requests.error\n\n      const overallErrorRate = totalRequests > 0 ? totalErrors / totalRequests : 0\n\n      const avgResponseTime =\n        totalRequests > 0\n          ? (paymentCreation.response_times.avg * paymentCreation.requests.total +\n              paymentQueries.response_times.avg * paymentQueries.requests.total +\n              webhookProcessing.response_times.avg * webhookProcessing.requests.total) /\n            totalRequests\n          : 0\n\n      return {\n        payment_creation: paymentCreation,\n        payment_queries: paymentQueries,\n        webhook_processing: webhookProcessing,\n        overall_health: {\n          uptime_percentage: overallErrorRate < 0.05 ? 99.9 : 95.0, // Simplificado\n          avg_response_time: avgResponseTime,\n          error_rate: overallErrorRate,\n          last_incident: overallErrorRate > 0.1 ? new Date().toISOString() : null,\n        },\n      }\n    } catch (error) {\n      console.error('Error getting MercadoPago metrics:', error)\n      // Retornar métricas vacías en caso de error\n      const emptyMetrics = this.getEmptyApiMetrics()\n      return {\n        payment_creation: emptyMetrics,\n        payment_queries: emptyMetrics,\n        webhook_processing: emptyMetrics,\n        overall_health: {\n          uptime_percentage: 0,\n          avg_response_time: 0,\n          error_rate: 1,\n          last_incident: new Date().toISOString(),\n        },\n      }\n    }\n  }\n\n  /**\n   * Retorna métricas vacías por defecto\n   */\n  private getEmptyApiMetrics(): ApiMetrics {\n    return {\n      requests: { total: 0, success: 0, error: 0, rate_limited: 0 },\n      response_times: { count: 0, sum: 0, avg: 0, min: 0, max: 0, p95: 0, p99: 0 },\n      error_rates: { '4xx': 0, '5xx': 0, network: 0, timeout: 0 },\n      retry_stats: { total_retries: 0, successful_retries: 0, failed_retries: 0, avg_attempts: 0 },\n    }\n  }\n}\n\n// Instancia singleton\nexport const metricsCollector = MetricsCollector.getInstance()\n"],"names":["MetricsCollector","metricsCollector","METRICS_CONFIG","RETENTION_HOURS","AGGREGATION_WINDOW_MINUTES","ALERT_THRESHOLDS","ERROR_RATE","RESPONSE_TIME_P95","RATE_LIMIT_RATE","getInstance","instance","recordRequest","endpoint","method","statusCode","responseTime","labels","timestamp","Date","now","baseKey","incrementCounter","recordValue","logger","info","LogCategory","API","error","recordApiCall","params","userId","recordRetry","operation","attempts","success","totalDuration","recordRateLimit","blocked","remaining","limit","key","windowKey","getWindowKey","redisCache","incr","expire","value","listKey","client","lpush","toString","ltrim","set","windowStart","Math","floor","getApiMetrics","hoursBack","startTime","requests","getCounterSum","errors","responseTimes","getValueStats","retryStats","getRetryStats","total","rate_limited","response_times","error_rates","network","timeout","retry_stats","getEmptyApiMetrics","category","endTime","result","windowSize","time","types","type","get","parseInt","values","lrange","windowValues","push","map","v","parseFloat","filter","isNaN","numValue","length","count","sum","avg","min","max","p95","p99","sort","a","b","reduce","counters","total_retries","successful_retries","failed_retries","failed","avg_attempts","getMercadoPagoMetrics","paymentCreation","paymentQueries","webhookProcessing","Promise","all","totalRequests","totalErrors","overallErrorRate","avgResponseTime","payment_creation","payment_queries","webhook_processing","overall_health","uptime_percentage","avg_response_time","error_rate","last_incident","toISOString","console","emptyMetrics"],"mappings":"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"}