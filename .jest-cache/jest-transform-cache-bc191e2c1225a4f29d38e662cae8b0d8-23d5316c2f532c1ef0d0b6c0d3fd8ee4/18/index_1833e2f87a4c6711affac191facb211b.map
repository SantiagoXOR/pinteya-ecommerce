{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\enterprise\\metrics\\index.ts"],"sourcesContent":["// ===================================\r\n// PINTEYA E-COMMERCE - METRICS SYSTEM\r\n// ===================================\r\n\r\nimport { redisCache } from '../../integrations/redis';\r\nimport { logger, LogLevel, LogCategory } from '../logger';\r\n\r\n// Tipos de métricas\r\nexport interface MetricData {\r\n  timestamp: number;\r\n  value: number;\r\n  labels?: Record<string, string>;\r\n}\r\n\r\nexport interface AggregatedMetric {\r\n  count: number;\r\n  sum: number;\r\n  avg: number;\r\n  min: number;\r\n  max: number;\r\n  p95: number;\r\n  p99: number;\r\n}\r\n\r\nexport interface ApiMetrics {\r\n  requests: {\r\n    total: number;\r\n    success: number;\r\n    error: number;\r\n    rate_limited: number;\r\n  };\r\n  response_times: AggregatedMetric;\r\n  error_rates: {\r\n    '4xx': number;\r\n    '5xx': number;\r\n    network: number;\r\n    timeout: number;\r\n  };\r\n  retry_stats: {\r\n    total_retries: number;\r\n    successful_retries: number;\r\n    failed_retries: number;\r\n    avg_attempts: number;\r\n  };\r\n}\r\n\r\nexport interface MercadoPagoMetrics {\r\n  payment_creation: ApiMetrics;\r\n  payment_queries: ApiMetrics;\r\n  webhook_processing: ApiMetrics;\r\n  overall_health: {\r\n    uptime_percentage: number;\r\n    avg_response_time: number;\r\n    error_rate: number;\r\n    last_incident: string | null;\r\n  };\r\n}\r\n\r\n// Configuración de métricas\r\nconst METRICS_CONFIG = {\r\n  RETENTION_HOURS: 24,\r\n  AGGREGATION_WINDOW_MINUTES: 5,\r\n  ALERT_THRESHOLDS: {\r\n    ERROR_RATE: 0.05, // 5%\r\n    RESPONSE_TIME_P95: 5000, // 5 segundos\r\n    RATE_LIMIT_RATE: 0.1, // 10%\r\n  },\r\n};\r\n\r\n/**\r\n * Clase principal para manejo de métricas\r\n */\r\nexport class MetricsCollector {\r\n  private static instance: MetricsCollector;\r\n\r\n  private constructor() {}\r\n\r\n  static getInstance(): MetricsCollector {\r\n    if (!MetricsCollector.instance) {\r\n      MetricsCollector.instance = new MetricsCollector();\r\n    }\r\n    return MetricsCollector.instance;\r\n  }\r\n\r\n  /**\r\n   * Registra una métrica de request\r\n   */\r\n  async recordRequest(\r\n    endpoint: string,\r\n    method: string,\r\n    statusCode: number,\r\n    responseTime: number,\r\n    labels: Record<string, string> = {}\r\n  ): Promise<void> {\r\n    const timestamp = Date.now();\r\n    const baseKey = `metrics:${endpoint}:${method}`;\r\n\r\n    try {\r\n      // Registrar request total\r\n      await this.incrementCounter(`${baseKey}:requests:total`, timestamp);\r\n\r\n      // Registrar por tipo de respuesta\r\n      if (statusCode >= 200 && statusCode < 300) {\r\n        await this.incrementCounter(`${baseKey}:requests:success`, timestamp);\r\n      } else if (statusCode === 429) {\r\n        await this.incrementCounter(`${baseKey}:requests:rate_limited`, timestamp);\r\n      } else {\r\n        await this.incrementCounter(`${baseKey}:requests:error`, timestamp);\r\n        \r\n        // Categorizar errores\r\n        if (statusCode >= 400 && statusCode < 500) {\r\n          await this.incrementCounter(`${baseKey}:errors:4xx`, timestamp);\r\n        } else if (statusCode >= 500) {\r\n          await this.incrementCounter(`${baseKey}:errors:5xx`, timestamp);\r\n        }\r\n      }\r\n\r\n      // Registrar tiempo de respuesta\r\n      await this.recordValue(`${baseKey}:response_time`, responseTime, timestamp);\r\n\r\n      // Log para debugging\r\n      logger.info(LogCategory.API, 'Metric recorded');\r\n\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Failed to record metric', error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registra una llamada a API (alias para recordRequest)\r\n   */\r\n  async recordApiCall(params: {\r\n    endpoint: string;\r\n    method: string;\r\n    statusCode: number;\r\n    responseTime: number;\r\n    userId?: string;\r\n    error?: string;\r\n  }): Promise<void> {\r\n    await this.recordRequest(\r\n      params.endpoint,\r\n      params.method,\r\n      params.statusCode,\r\n      params.responseTime,\r\n      {\r\n        userId: params.userId || 'anonymous',\r\n        error: params.error || ''\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Registra métricas de retry\r\n   */\r\n  async recordRetry(\r\n    operation: string,\r\n    attempts: number,\r\n    success: boolean,\r\n    totalDuration: number\r\n  ): Promise<void> {\r\n    const timestamp = Date.now();\r\n    const baseKey = `metrics:retry:${operation}`;\r\n\r\n    try {\r\n      await this.incrementCounter(`${baseKey}:total`, timestamp);\r\n      await this.recordValue(`${baseKey}:attempts`, attempts, timestamp);\r\n      await this.recordValue(`${baseKey}:duration`, totalDuration, timestamp);\r\n\r\n      if (success) {\r\n        await this.incrementCounter(`${baseKey}:success`, timestamp);\r\n      } else {\r\n        await this.incrementCounter(`${baseKey}:failed`, timestamp);\r\n      }\r\n\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Failed to record retry metric', error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registra métricas de rate limiting\r\n   */\r\n  async recordRateLimit(\r\n    endpoint: string,\r\n    blocked: boolean,\r\n    remaining: number,\r\n    limit: number\r\n  ): Promise<void> {\r\n    const timestamp = Date.now();\r\n    const baseKey = `metrics:rate_limit:${endpoint}`;\r\n\r\n    try {\r\n      await this.incrementCounter(`${baseKey}:checks`, timestamp);\r\n      \r\n      if (blocked) {\r\n        await this.incrementCounter(`${baseKey}:blocked`, timestamp);\r\n      }\r\n\r\n      await this.recordValue(`${baseKey}:remaining`, remaining, timestamp);\r\n      await this.recordValue(`${baseKey}:utilization`, (limit - remaining) / limit, timestamp);\r\n\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Failed to record rate limit metric', error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Incrementa un contador\r\n   */\r\n  private async incrementCounter(key: string, timestamp: number): Promise<void> {\r\n    const windowKey = this.getWindowKey(key, timestamp);\r\n    await redisCache.incr(windowKey);\r\n    await redisCache.expire(windowKey, METRICS_CONFIG.RETENTION_HOURS * 3600);\r\n  }\r\n\r\n  /**\r\n   * Registra un valor numérico\r\n   */\r\n  private async recordValue(key: string, value: number, timestamp: number): Promise<void> {\r\n    try {\r\n      const windowKey = this.getWindowKey(key, timestamp);\r\n      const listKey = `${windowKey}:values`;\r\n\r\n      // Obtener cliente Redis (real o mock)\r\n      const client = redisCache['client'] || redisCache;\r\n\r\n      // Verificar si el cliente tiene los métodos necesarios\r\n      if (typeof client.lpush === 'function') {\r\n        await client.lpush(listKey, value.toString());\r\n        await client.ltrim(listKey, 0, 999); // Mantener últimos 1000 valores\r\n        await client.expire(listKey, METRICS_CONFIG.RETENTION_HOURS * 3600);\r\n      } else {\r\n        // Fallback para mock básico - usar storage simple\r\n        await redisCache.set(`${listKey}:latest`, value.toString());\r\n      }\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Failed to record metric value', error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Genera clave de ventana temporal\r\n   */\r\n  private getWindowKey(baseKey: string, timestamp: number): string {\r\n    const windowStart = Math.floor(timestamp / (METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000));\r\n    return `${baseKey}:${windowStart}`;\r\n  }\r\n\r\n  /**\r\n   * Obtiene métricas agregadas para un endpoint\r\n   */\r\n  async getApiMetrics(endpoint: string, method: string, hoursBack: number = 1): Promise<ApiMetrics> {\r\n    const baseKey = `metrics:${endpoint}:${method}`;\r\n    const now = Date.now();\r\n    const startTime = now - (hoursBack * 60 * 60 * 1000);\r\n\r\n    try {\r\n      // Obtener contadores\r\n      const requests = await this.getCounterSum(baseKey, 'requests', startTime, now);\r\n      const errors = await this.getCounterSum(baseKey, 'errors', startTime, now);\r\n      \r\n      // Obtener tiempos de respuesta\r\n      const responseTimes = await this.getValueStats(`${baseKey}:response_time`, startTime, now);\r\n      \r\n      // Obtener métricas de retry\r\n      const retryStats = await this.getRetryStats(endpoint, startTime, now);\r\n\r\n      return {\r\n        requests: {\r\n          total: requests.total || 0,\r\n          success: requests.success || 0,\r\n          error: requests.error || 0,\r\n          rate_limited: requests.rate_limited || 0,\r\n        },\r\n        response_times: responseTimes,\r\n        error_rates: {\r\n          '4xx': errors['4xx'] || 0,\r\n          '5xx': errors['5xx'] || 0,\r\n          network: errors.network || 0,\r\n          timeout: errors.timeout || 0,\r\n        },\r\n        retry_stats: retryStats,\r\n      };\r\n\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Failed to get API metrics', error as Error);\r\n      \r\n      // Retornar métricas vacías en caso de error\r\n      return this.getEmptyApiMetrics();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obtiene suma de contadores en un rango de tiempo\r\n   */\r\n  private async getCounterSum(\r\n    baseKey: string, \r\n    category: string, \r\n    startTime: number, \r\n    endTime: number\r\n  ): Promise<Record<string, number>> {\r\n    const result: Record<string, number> = {};\r\n    const windowSize = METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000;\r\n    \r\n    for (let time = startTime; time <= endTime; time += windowSize) {\r\n      const windowStart = Math.floor(time / windowSize);\r\n      \r\n      // Obtener diferentes tipos de contadores\r\n      const types = ['total', 'success', 'error', 'rate_limited', '4xx', '5xx', 'network', 'timeout'];\r\n      \r\n      for (const type of types) {\r\n        const key = `${baseKey}:${category}:${type}:${windowStart}`;\r\n        const value = await redisCache.get(key);\r\n        result[type] = (result[type] || 0) + (parseInt(value || '0'));\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Obtiene estadísticas de valores numéricos\r\n   */\r\n  private async getValueStats(\r\n    baseKey: string,\r\n    startTime: number,\r\n    endTime: number\r\n  ): Promise<AggregatedMetric> {\r\n    const values: number[] = [];\r\n    const windowSize = METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000;\r\n\r\n    for (let time = startTime; time <= endTime; time += windowSize) {\r\n      const windowStart = Math.floor(time / windowSize);\r\n      const key = `${baseKey}:${windowStart}:values`;\r\n\r\n      try {\r\n        const client = redisCache['client'] || redisCache;\r\n\r\n        if (typeof client.lrange === 'function') {\r\n          const windowValues = await client.lrange(key, 0, -1);\r\n          values.push(...windowValues.map(v => parseFloat(v)).filter(v => !isNaN(v)));\r\n        } else {\r\n          // Fallback para mock básico\r\n          const value = await redisCache.get(`${key}:latest`);\r\n          if (value) {\r\n            const numValue = parseFloat(value);\r\n            if (!isNaN(numValue)) {\r\n              values.push(numValue);\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        // Continuar si no se puede obtener valores de una ventana\r\n      }\r\n    }\r\n\r\n    if (values.length === 0) {\r\n      return { count: 0, sum: 0, avg: 0, min: 0, max: 0, p95: 0, p99: 0 };\r\n    }\r\n\r\n    values.sort((a, b) => a - b);\r\n    const sum = values.reduce((a, b) => a + b, 0);\r\n    \r\n    return {\r\n      count: values.length,\r\n      sum,\r\n      avg: sum / values.length,\r\n      min: values[0],\r\n      max: values[values.length - 1],\r\n      p95: values[Math.floor(values.length * 0.95)] || 0,\r\n      p99: values[Math.floor(values.length * 0.99)] || 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Obtiene estadísticas de retry\r\n   */\r\n  private async getRetryStats(\r\n    operation: string, \r\n    startTime: number, \r\n    endTime: number\r\n  ): Promise<ApiMetrics['retry_stats']> {\r\n    const baseKey = `metrics:retry:${operation}`;\r\n    const counters = await this.getCounterSum(baseKey, '', startTime, endTime);\r\n    const attempts = await this.getValueStats(`${baseKey}:attempts`, startTime, endTime);\r\n\r\n    return {\r\n      total_retries: counters.total || 0,\r\n      successful_retries: counters.success || 0,\r\n      failed_retries: counters.failed || 0,\r\n      avg_attempts: attempts.avg || 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Obtiene métricas específicas de MercadoPago\r\n   */\r\n  async getMercadoPagoMetrics(hoursBack: number = 1): Promise<MercadoPagoMetrics> {\r\n    try {\r\n      const [paymentCreation, paymentQueries, webhookProcessing] = await Promise.all([\r\n        this.getApiMetrics('/api/payments/create-preference', 'POST', hoursBack),\r\n        this.getApiMetrics('/api/payments/query', 'GET', hoursBack),\r\n        this.getApiMetrics('/api/webhooks/mercadopago', 'POST', hoursBack),\r\n      ]);\r\n\r\n      // Calcular métricas generales de salud\r\n      const totalRequests = paymentCreation.requests.total +\r\n                           paymentQueries.requests.total +\r\n                           webhookProcessing.requests.total;\r\n\r\n      const totalErrors = paymentCreation.requests.error +\r\n                         paymentQueries.requests.error +\r\n                         webhookProcessing.requests.error;\r\n\r\n      const overallErrorRate = totalRequests > 0 ? totalErrors / totalRequests : 0;\r\n\r\n      const avgResponseTime = totalRequests > 0 ?\r\n        (paymentCreation.response_times.avg * paymentCreation.requests.total +\r\n         paymentQueries.response_times.avg * paymentQueries.requests.total +\r\n         webhookProcessing.response_times.avg * webhookProcessing.requests.total) / totalRequests : 0;\r\n\r\n      return {\r\n        payment_creation: paymentCreation,\r\n        payment_queries: paymentQueries,\r\n        webhook_processing: webhookProcessing,\r\n        overall_health: {\r\n          uptime_percentage: overallErrorRate < 0.05 ? 99.9 : 95.0, // Simplificado\r\n          avg_response_time: avgResponseTime,\r\n          error_rate: overallErrorRate,\r\n          last_incident: overallErrorRate > 0.1 ? new Date().toISOString() : null,\r\n        },\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting MercadoPago metrics:', error);\r\n      // Retornar métricas vacías en caso de error\r\n      const emptyMetrics = this.getEmptyApiMetrics();\r\n      return {\r\n        payment_creation: emptyMetrics,\r\n        payment_queries: emptyMetrics,\r\n        webhook_processing: emptyMetrics,\r\n        overall_health: {\r\n          uptime_percentage: 0,\r\n          avg_response_time: 0,\r\n          error_rate: 1,\r\n          last_incident: new Date().toISOString(),\r\n        },\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retorna métricas vacías por defecto\r\n   */\r\n  private getEmptyApiMetrics(): ApiMetrics {\r\n    return {\r\n      requests: { total: 0, success: 0, error: 0, rate_limited: 0 },\r\n      response_times: { count: 0, sum: 0, avg: 0, min: 0, max: 0, p95: 0, p99: 0 },\r\n      error_rates: { '4xx': 0, '5xx': 0, network: 0, timeout: 0 },\r\n      retry_stats: { total_retries: 0, successful_retries: 0, failed_retries: 0, avg_attempts: 0 },\r\n    };\r\n  }\r\n}\r\n\r\n// Instancia singleton\r\nexport const metricsCollector = MetricsCollector.getInstance();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":["MetricsCollector","metricsCollector","METRICS_CONFIG","RETENTION_HOURS","AGGREGATION_WINDOW_MINUTES","ALERT_THRESHOLDS","ERROR_RATE","RESPONSE_TIME_P95","RATE_LIMIT_RATE","getInstance","instance","recordRequest","endpoint","method","statusCode","responseTime","labels","timestamp","Date","now","baseKey","incrementCounter","recordValue","logger","info","LogCategory","API","error","recordApiCall","params","userId","recordRetry","operation","attempts","success","totalDuration","recordRateLimit","blocked","remaining","limit","key","windowKey","getWindowKey","redisCache","incr","expire","value","listKey","client","lpush","toString","ltrim","set","windowStart","Math","floor","getApiMetrics","hoursBack","startTime","requests","getCounterSum","errors","responseTimes","getValueStats","retryStats","getRetryStats","total","rate_limited","response_times","error_rates","network","timeout","retry_stats","getEmptyApiMetrics","category","endTime","result","windowSize","time","types","type","get","parseInt","values","lrange","windowValues","push","map","v","parseFloat","filter","isNaN","numValue","length","count","sum","avg","min","max","p95","p99","sort","a","b","reduce","counters","total_retries","successful_retries","failed_retries","failed","avg_attempts","getMercadoPagoMetrics","paymentCreation","paymentQueries","webhookProcessing","Promise","all","totalRequests","totalErrors","overallErrorRate","avgResponseTime","payment_creation","payment_queries","webhook_processing","overall_health","uptime_percentage","avg_response_time","error_rate","last_incident","toISOString","console","emptyMetrics"],"mappings":"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"}