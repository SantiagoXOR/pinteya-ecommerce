96f2cb74221753b5d91afb38738e3b6b
// ===================================
// PINTEYA E-COMMERCE - CACHE MANAGER TESTS
// ===================================
"use strict";
// Mock Redis
jest.mock('@/lib/redis', ()=>({
        redisCache: {
            get: jest.fn(),
            set: jest.fn(),
            del: jest.fn()
        }
    }));
// Mock logger
jest.mock('@/lib/enterprise/logger', ()=>({
        logger: {
            debug: jest.fn(),
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            DEBUG: 'debug',
            INFO: 'info',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            CACHE: 'cache',
            SYSTEM: 'system'
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _cachemanager = require("../../lib/cache-manager");
describe('CacheManager', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Singleton Pattern', ()=>{
        it('should return the same instance', ()=>{
            const instance1 = _cachemanager.CacheManager.getInstance();
            const instance2 = _cachemanager.CacheManager.getInstance();
            expect(instance1).toBe(instance2);
            expect(instance1).toBe(_cachemanager.cacheManager);
        });
    });
    describe('get', ()=>{
        it('should return cached value when available', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const testData = {
                id: 1,
                name: 'Test'
            };
            redisCache.get.mockResolvedValue(JSON.stringify(testData));
            const result = await _cachemanager.cacheManager.get('test-key', _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toEqual(testData);
            expect(redisCache.get).toHaveBeenCalledWith('cache:product:test-key');
        });
        it('should return null when cache miss', async ()=>{
            const { redisCache } = require('@/lib/redis');
            redisCache.get.mockResolvedValue(null);
            const result = await _cachemanager.cacheManager.get('missing-key', _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toBeNull();
        });
        it('should handle errors gracefully', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const { logger } = require('@/lib/enterprise/logger');
            redisCache.get.mockRejectedValue(new Error('Redis error'));
            const result = await _cachemanager.cacheManager.get('error-key', _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toBeNull();
            expect(logger.error).toHaveBeenCalled();
        });
    });
    describe('set', ()=>{
        it('should store value in cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const testData = {
                id: 1,
                name: 'Test'
            };
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.cacheManager.set('test-key', testData, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toBe(true);
            expect(redisCache.set).toHaveBeenCalledWith('cache:product:test-key', JSON.stringify(testData), _cachemanager.CACHE_CONFIGS.PRODUCT_DATA.ttl);
        });
        it('should handle serialization errors', async ()=>{
            const { logger } = require('@/lib/enterprise/logger');
            // Crear objeto circular que no se puede serializar
            const circularObj = {
                name: 'test'
            };
            circularObj.self = circularObj;
            await expect(_cachemanager.cacheManager.set('circular-key', circularObj, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA)).resolves.toBe(false);
            expect(logger.error).toHaveBeenCalled();
        });
    });
    describe('delete', ()=>{
        it('should delete value from cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            redisCache.del.mockResolvedValue(true);
            const result = await _cachemanager.cacheManager.delete('test-key', _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toBe(true);
            expect(redisCache.del).toHaveBeenCalledWith('cache:product:test-key');
        });
    });
    describe('getOrSet', ()=>{
        it('should return cached value if available', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const cachedData = {
                id: 1,
                name: 'Cached'
            };
            const fetcherFn = jest.fn().mockResolvedValue({
                id: 1,
                name: 'Fresh'
            });
            redisCache.get.mockResolvedValue(JSON.stringify(cachedData));
            const result = await _cachemanager.cacheManager.getOrSet('test-key', fetcherFn, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toEqual(cachedData);
            expect(fetcherFn).not.toHaveBeenCalled();
        });
        it('should fetch and cache value if not in cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const freshData = {
                id: 1,
                name: 'Fresh'
            };
            const fetcherFn = jest.fn().mockResolvedValue(freshData);
            redisCache.get.mockResolvedValue(null);
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.cacheManager.getOrSet('test-key', fetcherFn, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA);
            expect(result).toEqual(freshData);
            expect(fetcherFn).toHaveBeenCalled();
        });
        it('should propagate fetcher errors', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const fetcherError = new Error('Fetcher failed');
            const fetcherFn = jest.fn().mockRejectedValue(fetcherError);
            redisCache.get.mockResolvedValue(null);
            await expect(_cachemanager.cacheManager.getOrSet('test-key', fetcherFn, _cachemanager.CACHE_CONFIGS.PRODUCT_DATA)).rejects.toThrow('Fetcher failed');
        });
    });
    describe('Cache Configurations', ()=>{
        it('should have MercadoPago response config', ()=>{
            const config = _cachemanager.CACHE_CONFIGS.MERCADOPAGO_RESPONSE;
            expect(config.ttl).toBe(300);
            expect(config.prefix).toBe('mp_response');
            expect(config.compress).toBe(true);
            expect(config.serialize).toBe(true);
        });
        it('should have payment info config', ()=>{
            const config = _cachemanager.CACHE_CONFIGS.PAYMENT_INFO;
            expect(config.ttl).toBe(1800);
            expect(config.prefix).toBe('payment_info');
            expect(config.serialize).toBe(true);
        });
        it('should have product data config', ()=>{
            const config = _cachemanager.CACHE_CONFIGS.PRODUCT_DATA;
            expect(config.ttl).toBe(900);
            expect(config.prefix).toBe('product');
            expect(config.compress).toBe(true);
            expect(config.serialize).toBe(true);
        });
    });
    describe('Compression', ()=>{
        it('should compress large data when enabled', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const largeData = 'x'.repeat(2000); // String > 1000 chars
            redisCache.set.mockResolvedValue(true);
            await _cachemanager.cacheManager.set('large-key', largeData, {
                ..._cachemanager.CACHE_CONFIGS.PRODUCT_DATA,
                compress: true
            });
            const setCall = redisCache.set.mock.calls[0];
            expect(setCall[1]).toContain('COMPRESSED:');
        });
        it('should decompress data when retrieving', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const originalData = 'test data';
            const compressedData = `COMPRESSED:"${originalData}"`;
            redisCache.get.mockResolvedValue(compressedData);
            const result = await _cachemanager.cacheManager.get('compressed-key', {
                ..._cachemanager.CACHE_CONFIGS.PRODUCT_DATA,
                compress: true
            });
            expect(result).toBe(originalData);
        });
    });
});
describe('CacheUtils', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('cacheMercadoPagoResponse', ()=>{
        it('should cache MercadoPago response', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const responseData = {
                id: 'mp123',
                status: 'approved'
            };
            const fetcherFn = jest.fn().mockResolvedValue(responseData);
            redisCache.get.mockResolvedValue(null);
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.cacheMercadoPagoResponse('test-key', fetcherFn);
            expect(result).toEqual(responseData);
            expect(fetcherFn).toHaveBeenCalled();
        });
    });
    describe('cachePaymentInfo', ()=>{
        it('should cache payment info with payment ID', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const paymentData = {
                id: '123',
                amount: 100
            };
            const fetcherFn = jest.fn().mockResolvedValue(paymentData);
            redisCache.get.mockResolvedValue(null);
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.cachePaymentInfo('123', fetcherFn);
            expect(result).toEqual(paymentData);
            expect(redisCache.get).toHaveBeenCalledWith('cache:payment_info:payment:123');
        });
    });
    describe('cacheProductData', ()=>{
        it('should cache product data with product ID', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const productData = {
                id: '456',
                name: 'Test Product'
            };
            const fetcherFn = jest.fn().mockResolvedValue(productData);
            redisCache.get.mockResolvedValue(null);
            redisCache.set.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.cacheProductData('456', fetcherFn);
            expect(result).toEqual(productData);
            expect(redisCache.get).toHaveBeenCalledWith('cache:product:product:456');
        });
    });
    describe('invalidatePayment', ()=>{
        it('should invalidate payment cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            redisCache.del.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.invalidatePayment('123');
            expect(result).toBe(true);
            expect(redisCache.del).toHaveBeenCalledWith('cache:payment_info:payment:123');
        });
    });
    describe('invalidateProduct', ()=>{
        it('should invalidate product cache', async ()=>{
            const { redisCache } = require('@/lib/redis');
            redisCache.del.mockResolvedValue(true);
            const result = await _cachemanager.CacheUtils.invalidateProduct('456');
            expect(result).toBe(true);
            expect(redisCache.del).toHaveBeenCalledWith('cache:product:product:456');
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxsaWJcXGNhY2hlLW1hbmFnZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBDQUNIRSBNQU5BR0VSIFRFU1RTXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbXBvcnQgeyBDYWNoZU1hbmFnZXIsIGNhY2hlTWFuYWdlciwgQ0FDSEVfQ09ORklHUywgQ2FjaGVVdGlscyB9IGZyb20gJ0AvbGliL2NhY2hlLW1hbmFnZXInO1xyXG5cclxuLy8gTW9jayBSZWRpc1xyXG5qZXN0Lm1vY2soJ0AvbGliL3JlZGlzJywgKCkgPT4gKHtcclxuICByZWRpc0NhY2hlOiB7XHJcbiAgICBnZXQ6IGplc3QuZm4oKSxcclxuICAgIHNldDogamVzdC5mbigpLFxyXG4gICAgZGVsOiBqZXN0LmZuKCksXHJcbiAgfSxcclxufSkpO1xyXG5cclxuLy8gTW9jayBsb2dnZXJcclxuamVzdC5tb2NrKCdAL2xpYi9lbnRlcnByaXNlL2xvZ2dlcicsICgpID0+ICh7XHJcbiAgbG9nZ2VyOiB7XHJcbiAgICBkZWJ1ZzogamVzdC5mbigpLFxyXG4gICAgaW5mbzogamVzdC5mbigpLFxyXG4gICAgd2FybjogamVzdC5mbigpLFxyXG4gICAgZXJyb3I6IGplc3QuZm4oKSxcclxuICB9LFxyXG4gIExvZ0xldmVsOiB7XHJcbiAgICBERUJVRzogJ2RlYnVnJyxcclxuICAgIElORk86ICdpbmZvJyxcclxuICAgIFdBUk46ICd3YXJuJyxcclxuICAgIEVSUk9SOiAnZXJyb3InLFxyXG4gIH0sXHJcbiAgTG9nQ2F0ZWdvcnk6IHtcclxuICAgIENBQ0hFOiAnY2FjaGUnLFxyXG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcclxuICB9LFxyXG59KSk7XHJcblxyXG5kZXNjcmliZSgnQ2FjaGVNYW5hZ2VyJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdTaW5nbGV0b24gUGF0dGVybicsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbnN0YW5jZTEgPSBDYWNoZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgY29uc3QgaW5zdGFuY2UyID0gQ2FjaGVNYW5hZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoaW5zdGFuY2UxKS50b0JlKGluc3RhbmNlMik7XHJcbiAgICAgIGV4cGVjdChpbnN0YW5jZTEpLnRvQmUoY2FjaGVNYW5hZ2VyKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnZ2V0JywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gY2FjaGVkIHZhbHVlIHdoZW4gYXZhaWxhYmxlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJyk7XHJcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ1Rlc3QnIH07XHJcbiAgICAgIFxyXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShKU09OLnN0cmluZ2lmeSh0ZXN0RGF0YSkpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVNYW5hZ2VyLmdldCgndGVzdC1rZXknLCBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHRlc3REYXRhKTtcclxuICAgICAgZXhwZWN0KHJlZGlzQ2FjaGUuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnY2FjaGU6cHJvZHVjdDp0ZXN0LWtleScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCB3aGVuIGNhY2hlIG1pc3MnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKTtcclxuICAgICAgXHJcbiAgICAgIHJlZGlzQ2FjaGUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVNYW5hZ2VyLmdldCgnbWlzc2luZy1rZXknLCBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKTtcclxuICAgICAgY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJ0AvbGliL2VudGVycHJpc2UvbG9nZ2VyJyk7XHJcbiAgICAgIFxyXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlZGlzIGVycm9yJykpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGVNYW5hZ2VyLmdldCgnZXJyb3Ita2V5JywgQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEEpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcclxuICAgICAgZXhwZWN0KGxvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdzZXQnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHN0b3JlIHZhbHVlIGluIGNhY2hlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJyk7XHJcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyBpZDogMSwgbmFtZTogJ1Rlc3QnIH07XHJcbiAgICAgIFxyXG4gICAgICByZWRpc0NhY2hlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlTWFuYWdlci5zZXQoJ3Rlc3Qta2V5JywgdGVzdERhdGEsIENBQ0hFX0NPTkZJR1MuUFJPRFVDVF9EQVRBKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLnNldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgICAgJ2NhY2hlOnByb2R1Y3Q6dGVzdC1rZXknLFxyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHRlc3REYXRhKSxcclxuICAgICAgICBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQS50dGxcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcmlhbGl6YXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnQC9saWIvZW50ZXJwcmlzZS9sb2dnZXInKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENyZWFyIG9iamV0byBjaXJjdWxhciBxdWUgbm8gc2UgcHVlZGUgc2VyaWFsaXphclxyXG4gICAgICBjb25zdCBjaXJjdWxhck9iajogYW55ID0geyBuYW1lOiAndGVzdCcgfTtcclxuICAgICAgY2lyY3VsYXJPYmouc2VsZiA9IGNpcmN1bGFyT2JqO1xyXG5cclxuICAgICAgYXdhaXQgZXhwZWN0KFxyXG4gICAgICAgIGNhY2hlTWFuYWdlci5zZXQoJ2NpcmN1bGFyLWtleScsIGNpcmN1bGFyT2JqLCBDQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSlcclxuICAgICAgKS5yZXNvbHZlcy50b0JlKGZhbHNlKTtcclxuXHJcbiAgICAgIGV4cGVjdChsb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnZGVsZXRlJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBkZWxldGUgdmFsdWUgZnJvbSBjYWNoZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpO1xyXG4gICAgICBcclxuICAgICAgcmVkaXNDYWNoZS5kZWwubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZU1hbmFnZXIuZGVsZXRlKCd0ZXN0LWtleScsIENBQ0hFX0NPTkZJR1MuUFJPRFVDVF9EQVRBKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLmRlbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2NhY2hlOnByb2R1Y3Q6dGVzdC1rZXknKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnZ2V0T3JTZXQnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiBjYWNoZWQgdmFsdWUgaWYgYXZhaWxhYmxlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJyk7XHJcbiAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSB7IGlkOiAxLCBuYW1lOiAnQ2FjaGVkJyB9O1xyXG4gICAgICBjb25zdCBmZXRjaGVyRm4gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBpZDogMSwgbmFtZTogJ0ZyZXNoJyB9KTtcclxuICAgICAgXHJcbiAgICAgIHJlZGlzQ2FjaGUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKEpTT04uc3RyaW5naWZ5KGNhY2hlZERhdGEpKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlTWFuYWdlci5nZXRPclNldCgndGVzdC1rZXknLCBmZXRjaGVyRm4sIENBQ0hFX0NPTkZJR1MuUFJPRFVDVF9EQVRBKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoY2FjaGVkRGF0YSk7XHJcbiAgICAgIGV4cGVjdChmZXRjaGVyRm4pLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGZldGNoIGFuZCBjYWNoZSB2YWx1ZSBpZiBub3QgaW4gY2FjaGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKTtcclxuICAgICAgY29uc3QgZnJlc2hEYXRhID0geyBpZDogMSwgbmFtZTogJ0ZyZXNoJyB9O1xyXG4gICAgICBjb25zdCBmZXRjaGVyRm4gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoZnJlc2hEYXRhKTtcclxuICAgICAgXHJcbiAgICAgIHJlZGlzQ2FjaGUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xyXG4gICAgICByZWRpc0NhY2hlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhY2hlTWFuYWdlci5nZXRPclNldCgndGVzdC1rZXknLCBmZXRjaGVyRm4sIENBQ0hFX0NPTkZJR1MuUFJPRFVDVF9EQVRBKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZnJlc2hEYXRhKTtcclxuICAgICAgZXhwZWN0KGZldGNoZXJGbikudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBwcm9wYWdhdGUgZmV0Y2hlciBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKTtcclxuICAgICAgY29uc3QgZmV0Y2hlckVycm9yID0gbmV3IEVycm9yKCdGZXRjaGVyIGZhaWxlZCcpO1xyXG4gICAgICBjb25zdCBmZXRjaGVyRm4gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUoZmV0Y2hlckVycm9yKTtcclxuICAgICAgXHJcbiAgICAgIHJlZGlzQ2FjaGUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xyXG5cclxuICAgICAgYXdhaXQgZXhwZWN0KFxyXG4gICAgICAgIGNhY2hlTWFuYWdlci5nZXRPclNldCgndGVzdC1rZXknLCBmZXRjaGVyRm4sIENBQ0hFX0NPTkZJR1MuUFJPRFVDVF9EQVRBKVxyXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnRmV0Y2hlciBmYWlsZWQnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnQ2FjaGUgQ29uZmlndXJhdGlvbnMnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGhhdmUgTWVyY2Fkb1BhZ28gcmVzcG9uc2UgY29uZmlnJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb25maWcgPSBDQUNIRV9DT05GSUdTLk1FUkNBRE9QQUdPX1JFU1BPTlNFO1xyXG4gICAgICBcclxuICAgICAgZXhwZWN0KGNvbmZpZy50dGwpLnRvQmUoMzAwKTtcclxuICAgICAgZXhwZWN0KGNvbmZpZy5wcmVmaXgpLnRvQmUoJ21wX3Jlc3BvbnNlJyk7XHJcbiAgICAgIGV4cGVjdChjb25maWcuY29tcHJlc3MpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChjb25maWcuc2VyaWFsaXplKS50b0JlKHRydWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYXZlIHBheW1lbnQgaW5mbyBjb25maWcnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbmZpZyA9IENBQ0hFX0NPTkZJR1MuUEFZTUVOVF9JTkZPO1xyXG4gICAgICBcclxuICAgICAgZXhwZWN0KGNvbmZpZy50dGwpLnRvQmUoMTgwMCk7XHJcbiAgICAgIGV4cGVjdChjb25maWcucHJlZml4KS50b0JlKCdwYXltZW50X2luZm8nKTtcclxuICAgICAgZXhwZWN0KGNvbmZpZy5zZXJpYWxpemUpLnRvQmUodHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhdmUgcHJvZHVjdCBkYXRhIGNvbmZpZycsICgpID0+IHtcclxuICAgICAgY29uc3QgY29uZmlnID0gQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEE7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoY29uZmlnLnR0bCkudG9CZSg5MDApO1xyXG4gICAgICBleHBlY3QoY29uZmlnLnByZWZpeCkudG9CZSgncHJvZHVjdCcpO1xyXG4gICAgICBleHBlY3QoY29uZmlnLmNvbXByZXNzKS50b0JlKHRydWUpO1xyXG4gICAgICBleHBlY3QoY29uZmlnLnNlcmlhbGl6ZSkudG9CZSh0cnVlKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnQ29tcHJlc3Npb24nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGNvbXByZXNzIGxhcmdlIGRhdGEgd2hlbiBlbmFibGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJyk7XHJcbiAgICAgIGNvbnN0IGxhcmdlRGF0YSA9ICd4Jy5yZXBlYXQoMjAwMCk7IC8vIFN0cmluZyA+IDEwMDAgY2hhcnNcclxuICAgICAgXHJcbiAgICAgIHJlZGlzQ2FjaGUuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xyXG5cclxuICAgICAgYXdhaXQgY2FjaGVNYW5hZ2VyLnNldCgnbGFyZ2Uta2V5JywgbGFyZ2VEYXRhLCB7XHJcbiAgICAgICAgLi4uQ0FDSEVfQ09ORklHUy5QUk9EVUNUX0RBVEEsXHJcbiAgICAgICAgY29tcHJlc3M6IHRydWUsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY29uc3Qgc2V0Q2FsbCA9IHJlZGlzQ2FjaGUuc2V0Lm1vY2suY2FsbHNbMF07XHJcbiAgICAgIGV4cGVjdChzZXRDYWxsWzFdKS50b0NvbnRhaW4oJ0NPTVBSRVNTRUQ6Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGRlY29tcHJlc3MgZGF0YSB3aGVuIHJldHJpZXZpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKTtcclxuICAgICAgY29uc3Qgb3JpZ2luYWxEYXRhID0gJ3Rlc3QgZGF0YSc7XHJcbiAgICAgIGNvbnN0IGNvbXByZXNzZWREYXRhID0gYENPTVBSRVNTRUQ6XCIke29yaWdpbmFsRGF0YX1cImA7XHJcbiAgICAgIFxyXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShjb21wcmVzc2VkRGF0YSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWNoZU1hbmFnZXIuZ2V0KCdjb21wcmVzc2VkLWtleScsIHtcclxuICAgICAgICAuLi5DQUNIRV9DT05GSUdTLlBST0RVQ1RfREFUQSxcclxuICAgICAgICBjb21wcmVzczogdHJ1ZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKG9yaWdpbmFsRGF0YSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcblxyXG5kZXNjcmliZSgnQ2FjaGVVdGlscycsICgpID0+IHtcclxuICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnY2FjaGVNZXJjYWRvUGFnb1Jlc3BvbnNlJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBjYWNoZSBNZXJjYWRvUGFnbyByZXNwb25zZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpO1xyXG4gICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7IGlkOiAnbXAxMjMnLCBzdGF0dXM6ICdhcHByb3ZlZCcgfTtcclxuICAgICAgY29uc3QgZmV0Y2hlckZuID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHJlc3BvbnNlRGF0YSk7XHJcbiAgICAgIFxyXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcclxuICAgICAgcmVkaXNDYWNoZS5zZXQubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBDYWNoZVV0aWxzLmNhY2hlTWVyY2Fkb1BhZ29SZXNwb25zZSgndGVzdC1rZXknLCBmZXRjaGVyRm4pO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChyZXNwb25zZURhdGEpO1xyXG4gICAgICBleHBlY3QoZmV0Y2hlckZuKS50b0hhdmVCZWVuQ2FsbGVkKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2NhY2hlUGF5bWVudEluZm8nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGNhY2hlIHBheW1lbnQgaW5mbyB3aXRoIHBheW1lbnQgSUQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKTtcclxuICAgICAgY29uc3QgcGF5bWVudERhdGEgPSB7IGlkOiAnMTIzJywgYW1vdW50OiAxMDAgfTtcclxuICAgICAgY29uc3QgZmV0Y2hlckZuID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHBheW1lbnREYXRhKTtcclxuICAgICAgXHJcbiAgICAgIHJlZGlzQ2FjaGUuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xyXG4gICAgICByZWRpc0NhY2hlLnNldC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IENhY2hlVXRpbHMuY2FjaGVQYXltZW50SW5mbygnMTIzJywgZmV0Y2hlckZuKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwocGF5bWVudERhdGEpO1xyXG4gICAgICBleHBlY3QocmVkaXNDYWNoZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdjYWNoZTpwYXltZW50X2luZm86cGF5bWVudDoxMjMnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnY2FjaGVQcm9kdWN0RGF0YScsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgY2FjaGUgcHJvZHVjdCBkYXRhIHdpdGggcHJvZHVjdCBJRCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpO1xyXG4gICAgICBjb25zdCBwcm9kdWN0RGF0YSA9IHsgaWQ6ICc0NTYnLCBuYW1lOiAnVGVzdCBQcm9kdWN0JyB9O1xyXG4gICAgICBjb25zdCBmZXRjaGVyRm4gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUocHJvZHVjdERhdGEpO1xyXG4gICAgICBcclxuICAgICAgcmVkaXNDYWNoZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XHJcbiAgICAgIHJlZGlzQ2FjaGUuc2V0Lm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQ2FjaGVVdGlscy5jYWNoZVByb2R1Y3REYXRhKCc0NTYnLCBmZXRjaGVyRm4pO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChwcm9kdWN0RGF0YSk7XHJcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2NhY2hlOnByb2R1Y3Q6cHJvZHVjdDo0NTYnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnaW52YWxpZGF0ZVBheW1lbnQnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGludmFsaWRhdGUgcGF5bWVudCBjYWNoZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpO1xyXG4gICAgICBcclxuICAgICAgcmVkaXNDYWNoZS5kZWwubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBDYWNoZVV0aWxzLmludmFsaWRhdGVQYXltZW50KCcxMjMnKTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLmRlbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2NhY2hlOnBheW1lbnRfaW5mbzpwYXltZW50OjEyMycpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdpbnZhbGlkYXRlUHJvZHVjdCcsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgaW52YWxpZGF0ZSBwcm9kdWN0IGNhY2hlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJyk7XHJcbiAgICAgIFxyXG4gICAgICByZWRpc0NhY2hlLmRlbC5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IENhY2hlVXRpbHMuaW52YWxpZGF0ZVByb2R1Y3QoJzQ1NicpO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KHJlZGlzQ2FjaGUuZGVsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnY2FjaGU6cHJvZHVjdDpwcm9kdWN0OjQ1NicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJyZWRpc0NhY2hlIiwiZ2V0IiwiZm4iLCJzZXQiLCJkZWwiLCJsb2dnZXIiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwiZXJyb3IiLCJMb2dMZXZlbCIsIkRFQlVHIiwiSU5GTyIsIldBUk4iLCJFUlJPUiIsIkxvZ0NhdGVnb3J5IiwiQ0FDSEUiLCJTWVNURU0iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJpbnN0YW5jZTEiLCJDYWNoZU1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlMiIsImV4cGVjdCIsInRvQmUiLCJjYWNoZU1hbmFnZXIiLCJyZXF1aXJlIiwidGVzdERhdGEiLCJpZCIsIm5hbWUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN1bHQiLCJDQUNIRV9DT05GSUdTIiwiUFJPRFVDVF9EQVRBIiwidG9FcXVhbCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidG9CZU51bGwiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwidG9IYXZlQmVlbkNhbGxlZCIsInR0bCIsImNpcmN1bGFyT2JqIiwic2VsZiIsInJlc29sdmVzIiwiZGVsZXRlIiwiY2FjaGVkRGF0YSIsImZldGNoZXJGbiIsImdldE9yU2V0Iiwibm90IiwiZnJlc2hEYXRhIiwiZmV0Y2hlckVycm9yIiwicmVqZWN0cyIsInRvVGhyb3ciLCJjb25maWciLCJNRVJDQURPUEFHT19SRVNQT05TRSIsInByZWZpeCIsImNvbXByZXNzIiwic2VyaWFsaXplIiwiUEFZTUVOVF9JTkZPIiwibGFyZ2VEYXRhIiwicmVwZWF0Iiwic2V0Q2FsbCIsImNhbGxzIiwidG9Db250YWluIiwib3JpZ2luYWxEYXRhIiwiY29tcHJlc3NlZERhdGEiLCJyZXNwb25zZURhdGEiLCJzdGF0dXMiLCJDYWNoZVV0aWxzIiwiY2FjaGVNZXJjYWRvUGFnb1Jlc3BvbnNlIiwicGF5bWVudERhdGEiLCJhbW91bnQiLCJjYWNoZVBheW1lbnRJbmZvIiwicHJvZHVjdERhdGEiLCJjYWNoZVByb2R1Y3REYXRhIiwiaW52YWxpZGF0ZVBheW1lbnQiLCJpbnZhbGlkYXRlUHJvZHVjdCJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLDJDQUEyQztBQUMzQyxzQ0FBc0M7O0FBSXRDLGFBQWE7QUFDYkEsS0FBS0MsSUFBSSxDQUFDLGVBQWUsSUFBTyxDQUFBO1FBQzlCQyxZQUFZO1lBQ1ZDLEtBQUtILEtBQUtJLEVBQUU7WUFDWkMsS0FBS0wsS0FBS0ksRUFBRTtZQUNaRSxLQUFLTixLQUFLSSxFQUFFO1FBQ2Q7SUFDRixDQUFBO0FBRUEsY0FBYztBQUNkSixLQUFLQyxJQUFJLENBQUMsMkJBQTJCLElBQU8sQ0FBQTtRQUMxQ00sUUFBUTtZQUNOQyxPQUFPUixLQUFLSSxFQUFFO1lBQ2RLLE1BQU1ULEtBQUtJLEVBQUU7WUFDYk0sTUFBTVYsS0FBS0ksRUFBRTtZQUNiTyxPQUFPWCxLQUFLSSxFQUFFO1FBQ2hCO1FBQ0FRLFVBQVU7WUFDUkMsT0FBTztZQUNQQyxNQUFNO1lBQ05DLE1BQU07WUFDTkMsT0FBTztRQUNUO1FBQ0FDLGFBQWE7WUFDWEMsT0FBTztZQUNQQyxRQUFRO1FBQ1Y7SUFDRixDQUFBOzs7OzhCQTdCc0U7QUErQnRFQyxTQUFTLGdCQUFnQjtJQUN2QkMsV0FBVztRQUNUckIsS0FBS3NCLGFBQWE7SUFDcEI7SUFFQUYsU0FBUyxxQkFBcUI7UUFDNUJHLEdBQUcsbUNBQW1DO1lBQ3BDLE1BQU1DLFlBQVlDLDBCQUFZLENBQUNDLFdBQVc7WUFDMUMsTUFBTUMsWUFBWUYsMEJBQVksQ0FBQ0MsV0FBVztZQUUxQ0UsT0FBT0osV0FBV0ssSUFBSSxDQUFDRjtZQUN2QkMsT0FBT0osV0FBV0ssSUFBSSxDQUFDQywwQkFBWTtRQUNyQztJQUNGO0lBRUFWLFNBQVMsT0FBTztRQUNkRyxHQUFHLDZDQUE2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