{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\integrations\\redis\\index.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - REDIS CONFIGURATION\n// ===================================\n\nimport Redis from 'ioredis'\nimport { logger, LogLevel, LogCategory } from '../../enterprise/logger'\n\n// Configuración de Redis\nconst REDIS_CONFIG = {\n  host: process.env.REDIS_HOST || 'localhost',\n  port: parseInt(process.env.REDIS_PORT || '6379'),\n  password: process.env.REDIS_PASSWORD,\n  db: parseInt(process.env.REDIS_DB || '0'),\n  retryDelayOnFailover: 100,\n  maxRetriesPerRequest: 3,\n  lazyConnect: true,\n  keepAlive: 30000,\n  connectTimeout: 10000,\n  commandTimeout: 5000,\n}\n\n// Mock Redis para desarrollo cuando Redis no está disponible\nclass MockRedis {\n  private storage = new Map<string, any>()\n\n  async get(key: string): Promise<string | null> {\n    return this.storage.get(key) || null\n  }\n\n  async set(key: string, value: any, ...args: any[]): Promise<'OK'> {\n    this.storage.set(key, value)\n    return 'OK'\n  }\n\n  async del(key: string): Promise<number> {\n    const existed = this.storage.has(key)\n    this.storage.delete(key)\n    return existed ? 1 : 0\n  }\n\n  async exists(key: string): Promise<number> {\n    return this.storage.has(key) ? 1 : 0\n  }\n\n  async incr(key: string): Promise<number> {\n    const current = parseInt(this.storage.get(key) || '0')\n    const newValue = current + 1\n    this.storage.set(key, newValue.toString())\n    return newValue\n  }\n\n  async expire(key: string, seconds: number): Promise<number> {\n    // Mock: no implementamos expiración real\n    return 1\n  }\n\n  async keys(pattern: string): Promise<string[]> {\n    const regex = new RegExp(pattern.replace(/\\*/g, '.*'))\n    return Array.from(this.storage.keys()).filter(key => regex.test(key))\n  }\n\n  async flushall(): Promise<'OK'> {\n    this.storage.clear()\n    return 'OK'\n  }\n\n  // Métodos de listas para métricas\n  async lpush(key: string, ...values: string[]): Promise<number> {\n    const list = this.storage.get(key) || []\n    list.unshift(...values)\n    this.storage.set(key, list)\n    return list.length\n  }\n\n  async ltrim(key: string, start: number, stop: number): Promise<'OK'> {\n    const list = this.storage.get(key) || []\n    const trimmed = list.slice(start, stop + 1)\n    this.storage.set(key, trimmed)\n    return 'OK'\n  }\n\n  async lrange(key: string, start: number, stop: number): Promise<string[]> {\n    const list = this.storage.get(key) || []\n    if (stop === -1) {\n      return list.slice(start)\n    }\n    return list.slice(start, stop + 1)\n  }\n\n  async ttl(key: string): Promise<number> {\n    // Mock: retornar -1 (sin expiración) o un valor fijo\n    return this.storage.has(key) ? 3600 : -2\n  }\n\n  // Pipeline mock para operaciones batch\n  pipeline(): MockPipeline {\n    return new MockPipeline(this)\n  }\n\n  // Métodos de conexión mock\n  async connect(): Promise<void> {\n    console.log('[REDIS MOCK] Conectado (simulado)')\n  }\n\n  disconnect(): void {\n    console.log('[REDIS MOCK] Desconectado (simulado)')\n  }\n\n  on(event: string, callback: Function): this {\n    return this\n  }\n\n  async quit(): Promise<'OK'> {\n    console.log('[REDIS MOCK] Desconectado (quit simulado)')\n    return 'OK'\n  }\n}\n\n// Mock Pipeline para operaciones batch\nclass MockPipeline {\n  private commands: Array<{ method: string; args: any[] }> = []\n  private redis: MockRedis\n\n  constructor(redis: MockRedis) {\n    this.redis = redis\n  }\n\n  get(key: string): this {\n    this.commands.push({ method: 'get', args: [key] })\n    return this\n  }\n\n  ttl(key: string): this {\n    this.commands.push({ method: 'ttl', args: [key] })\n    return this\n  }\n\n  incr(key: string): this {\n    this.commands.push({ method: 'incr', args: [key] })\n    return this\n  }\n\n  expire(key: string, seconds: number): this {\n    this.commands.push({ method: 'expire', args: [key, seconds] })\n    return this\n  }\n\n  async exec(): Promise<Array<[Error | null, any]>> {\n    const results: Array<[Error | null, any]> = []\n\n    for (const command of this.commands) {\n      try {\n        const result = await (this.redis as any)[command.method](...command.args)\n        results.push([null, result])\n      } catch (error) {\n        results.push([error as Error, null])\n      }\n    }\n\n    this.commands = [] // Limpiar comandos después de ejecutar\n    return results\n  }\n}\n\n// Cliente Redis singleton\nlet redisClient: Redis | MockRedis | null = null\nlet isUsingMock = false\n\n/**\n * Obtiene o crea la instancia de Redis\n */\nexport function getRedisClient(): Redis | MockRedis {\n  if (!redisClient) {\n    // Verificar si Redis está deshabilitado\n    if (process.env.DISABLE_REDIS === 'true') {\n      console.log('[REDIS] Redis deshabilitado por configuración, usando mock')\n      redisClient = new MockRedis()\n      isUsingMock = true\n      return redisClient\n    }\n\n    try {\n      redisClient = new Redis(REDIS_CONFIG)\n\n      // Event listeners para logging\n      redisClient.on('connect', () => {\n        logger.info(LogCategory.API, 'Redis connected successfully')\n        isUsingMock = false\n      })\n\n      redisClient.on('error', error => {\n        logger.error(LogCategory.API, 'Redis connection error', error)\n        // Si hay error de conexión, usar mock\n        if (!isUsingMock) {\n          console.log('[REDIS] Cambiando a modo mock debido a error de conexión')\n          redisClient = new MockRedis()\n          isUsingMock = true\n        }\n      })\n\n      redisClient.on('close', () => {\n        logger.warn(LogCategory.API, 'Redis connection closed')\n      })\n\n      redisClient.on('reconnecting', () => {\n        logger.info(LogCategory.API, 'Redis reconnecting...')\n      })\n    } catch (error) {\n      console.log('[REDIS] Error inicializando Redis, usando mock:', error.message)\n      redisClient = new MockRedis()\n      isUsingMock = true\n    }\n  }\n\n  return redisClient\n}\n\n/**\n * Verifica si Redis está disponible\n */\nexport async function isRedisAvailable(): Promise<boolean> {\n  try {\n    if (isUsingMock) {\n      return false // Mock no es Redis real\n    }\n    const client = getRedisClient()\n    if (client instanceof MockRedis) {\n      return false\n    }\n    await (client as Redis).ping()\n    return true\n  } catch (error) {\n    logger.error(LogCategory.API, 'Redis health check failed', error as Error)\n    return false\n  }\n}\n\n/**\n * Cierra la conexión de Redis\n */\nexport async function closeRedisConnection(): Promise<void> {\n  if (redisClient) {\n    await redisClient.quit()\n    redisClient = null\n    logger.info(LogCategory.API, 'Redis connection closed gracefully')\n  }\n}\n\n/**\n * Operaciones de cache con manejo de errores\n */\nexport class RedisCache {\n  private client: Redis\n\n  constructor() {\n    this.client = getRedisClient()\n  }\n\n  /**\n   * Obtiene un valor del cache\n   */\n  async get(key: string): Promise<string | null> {\n    try {\n      const value = await this.client.get(key)\n      logger.info(LogCategory.API, 'Cache get operation')\n      return value\n    } catch (error) {\n      logger.error(LogCategory.API, 'Cache get operation failed', error as Error)\n      return null\n    }\n  }\n\n  /**\n   * Establece un valor en el cache\n   */\n  async set(key: string, value: string, ttlSeconds?: number): Promise<boolean> {\n    try {\n      if (ttlSeconds) {\n        await this.client.setex(key, ttlSeconds, value)\n      } else {\n        await this.client.set(key, value)\n      }\n\n      logger.info(LogCategory.API, 'Cache set operation')\n      return true\n    } catch (error) {\n      logger.error(LogCategory.API, 'Cache set operation failed', error as Error)\n      return false\n    }\n  }\n\n  /**\n   * Elimina un valor del cache\n   */\n  async del(key: string): Promise<boolean> {\n    try {\n      const result = await this.client.del(key)\n      logger.info(LogCategory.API, 'Cache delete operation')\n      return result > 0\n    } catch (error) {\n      logger.error(LogCategory.API, 'Cache delete operation failed', error as Error)\n      return false\n    }\n  }\n\n  /**\n   * Incrementa un contador atómicamente\n   */\n  async incr(key: string): Promise<number | null> {\n    try {\n      const result = await this.client.incr(key)\n      logger.info(LogCategory.API, 'Cache increment operation')\n      return result\n    } catch (error) {\n      logger.error(LogCategory.API, 'Cache increment operation failed', error as Error)\n      return null\n    }\n  }\n\n  /**\n   * Establece TTL para una clave existente\n   */\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\n    try {\n      const result = await this.client.expire(key, ttlSeconds)\n      logger.info(LogCategory.API, 'Cache expire operation')\n      return result === 1\n    } catch (error) {\n      logger.error(LogCategory.API, 'Cache expire operation failed', error as Error)\n      return false\n    }\n  }\n\n  /**\n   * Obtiene TTL restante de una clave\n   */\n  async ttl(key: string): Promise<number | null> {\n    try {\n      const result = await this.client.ttl(key)\n      logger.info(LogCategory.API, 'Cache TTL check')\n      return result\n    } catch (error) {\n      logger.error(LogCategory.API, 'Cache TTL check failed', error as Error)\n      return null\n    }\n  }\n}\n\n// Instancia singleton del cache\nexport const redisCache = new RedisCache()\n\n// Funciones de utilidad para rate limiting\nexport async function getRateLimitInfo(key: string): Promise<{\n  count: number\n  ttl: number\n} | null> {\n  try {\n    const client = getRedisClient()\n    const pipeline = client.pipeline()\n    pipeline.get(key)\n    pipeline.ttl(key)\n\n    const results = await pipeline.exec()\n\n    if (!results || results.length !== 2) {\n      return null\n    }\n\n    const [countResult, ttlResult] = results\n    const count = parseInt(countResult[1] as string) || 0\n    const ttl = ttlResult[1] as number\n\n    return { count, ttl }\n  } catch (error) {\n    logger.error(LogCategory.API, 'Rate limit info retrieval failed', error as Error)\n    return null\n  }\n}\n\nexport async function incrementRateLimit(\n  key: string,\n  windowSeconds: number\n): Promise<{\n  count: number\n  ttl: number\n  isNewWindow: boolean\n} | null> {\n  try {\n    const client = getRedisClient()\n    const pipeline = client.pipeline()\n\n    // Incrementar contador\n    pipeline.incr(key)\n    // Establecer TTL solo si es la primera vez\n    pipeline.expire(key, windowSeconds)\n    // Obtener TTL actual\n    pipeline.ttl(key)\n\n    const results = await pipeline.exec()\n\n    if (!results || results.length !== 3) {\n      return null\n    }\n\n    const count = results[0][1] as number\n    const ttl = results[2][1] as number\n    const isNewWindow = count === 1\n\n    return { count, ttl, isNewWindow }\n  } catch (error) {\n    logger.error(LogCategory.API, 'Rate limit increment failed', error as Error)\n    return null\n  }\n}\n\n// =====================================================\n// FUNCIONES ENTERPRISE PARA RATE LIMITING\n// =====================================================\n\n/**\n * Rate limiting enterprise con sliding window\n */\nexport async function enterpriseRateLimit(\n  key: string,\n  windowMs: number,\n  maxRequests: number\n): Promise<{\n  allowed: boolean\n  count: number\n  remaining: number\n  resetTime: number\n  retryAfter?: number\n} | null> {\n  try {\n    const client = getRedisClient()\n    const now = Date.now()\n    const window = Math.floor(now / windowMs)\n    const redisKey = `rate_limit:${key}:${window}`\n\n    // Usar pipeline para operaciones atómicas\n    const pipeline = client.pipeline()\n    pipeline.incr(redisKey)\n    pipeline.expire(redisKey, Math.ceil(windowMs / 1000))\n\n    const results = await pipeline.exec()\n\n    if (!results || results.length !== 2) {\n      return null\n    }\n\n    const count = results[0][1] as number\n    const remaining = Math.max(0, maxRequests - count)\n    const resetTime = (window + 1) * windowMs\n    const allowed = count <= maxRequests\n\n    const result = {\n      allowed,\n      count,\n      remaining,\n      resetTime,\n      retryAfter: allowed ? undefined : Math.ceil((resetTime - now) / 1000),\n    }\n\n    logger.debug(LogCategory.API, 'Enterprise rate limit check', {\n      key: redisKey,\n      count,\n      maxRequests,\n      allowed,\n      remaining,\n    })\n\n    return result\n  } catch (error) {\n    logger.error(LogCategory.API, 'Enterprise rate limit failed', error as Error)\n    return null\n  }\n}\n\n/**\n * Rate limiting con múltiples ventanas (más preciso)\n */\nexport async function slidingWindowRateLimit(\n  key: string,\n  windowMs: number,\n  maxRequests: number,\n  precision: number = 10\n): Promise<{\n  allowed: boolean\n  count: number\n  remaining: number\n  resetTime: number\n} | null> {\n  try {\n    const client = getRedisClient()\n    const now = Date.now()\n    const windowSize = Math.floor(windowMs / precision)\n    const currentWindow = Math.floor(now / windowSize)\n\n    // Limpiar ventanas antiguas y contar requests en ventana actual\n    const pipeline = client.pipeline()\n\n    // Eliminar ventanas más antiguas que el período de rate limiting\n    for (let i = 1; i <= precision; i++) {\n      const oldWindow = currentWindow - precision - i\n      pipeline.del(`${key}:${oldWindow}`)\n    }\n\n    // Incrementar contador para ventana actual\n    const currentKey = `${key}:${currentWindow}`\n    pipeline.incr(currentKey)\n    pipeline.expire(currentKey, Math.ceil(windowMs / 1000))\n\n    // Obtener contadores de todas las ventanas en el período\n    for (let i = 0; i < precision; i++) {\n      const windowKey = `${key}:${currentWindow - i}`\n      pipeline.get(windowKey)\n    }\n\n    const results = await pipeline.exec()\n\n    if (!results) {\n      return null\n    }\n\n    // Calcular total de requests en la ventana deslizante\n    let totalCount = 0\n    const countResults = results.slice(precision + 2) // Saltar operaciones de limpieza e incremento\n\n    for (const result of countResults) {\n      if (result[1]) {\n        totalCount += parseInt(result[1] as string)\n      }\n    }\n\n    const remaining = Math.max(0, maxRequests - totalCount)\n    const allowed = totalCount <= maxRequests\n    const resetTime = (currentWindow + 1) * windowSize\n\n    return {\n      allowed,\n      count: totalCount,\n      remaining,\n      resetTime,\n    }\n  } catch (error) {\n    logger.error(LogCategory.API, 'Sliding window rate limit failed', error as Error)\n    return null\n  }\n}\n\n/**\n * Obtener estadísticas de rate limiting\n */\nexport async function getRateLimitStats(pattern: string = 'rate_limit:*'): Promise<{\n  totalKeys: number\n  activeWindows: number\n  topKeys: Array<{ key: string; count: number; ttl: number }>\n} | null> {\n  try {\n    const client = getRedisClient()\n    const keys = await client.keys(pattern)\n\n    if (keys.length === 0) {\n      return {\n        totalKeys: 0,\n        activeWindows: 0,\n        topKeys: [],\n      }\n    }\n\n    // Obtener información de las claves más activas\n    const pipeline = client.pipeline()\n    keys.forEach(key => {\n      pipeline.get(key)\n      pipeline.ttl(key)\n    })\n\n    const results = await pipeline.exec()\n\n    if (!results) {\n      return null\n    }\n\n    const keyStats: Array<{ key: string; count: number; ttl: number }> = []\n\n    for (let i = 0; i < keys.length; i++) {\n      const countResult = results[i * 2]\n      const ttlResult = results[i * 2 + 1]\n\n      if (countResult[1] && ttlResult[1]) {\n        keyStats.push({\n          key: keys[i],\n          count: parseInt(countResult[1] as string),\n          ttl: ttlResult[1] as number,\n        })\n      }\n    }\n\n    // Ordenar por count descendente\n    keyStats.sort((a, b) => b.count - a.count)\n\n    return {\n      totalKeys: keys.length,\n      activeWindows: keyStats.filter(stat => stat.ttl > 0).length,\n      topKeys: keyStats.slice(0, 10), // Top 10\n    }\n  } catch (error) {\n    logger.error(LogCategory.API, 'Rate limit stats failed', error as Error)\n    return null\n  }\n}\n\n/**\n * Limpiar claves de rate limiting expiradas\n */\nexport async function cleanupRateLimitKeys(pattern: string = 'rate_limit:*'): Promise<number> {\n  try {\n    const client = getRedisClient()\n    const keys = await client.keys(pattern)\n\n    if (keys.length === 0) {\n      return 0\n    }\n\n    // Verificar TTL de cada clave y eliminar las expiradas\n    const pipeline = client.pipeline()\n    keys.forEach(key => {\n      pipeline.ttl(key)\n    })\n\n    const ttlResults = await pipeline.exec()\n\n    if (!ttlResults) {\n      return 0\n    }\n\n    const expiredKeys: string[] = []\n\n    for (let i = 0; i < keys.length; i++) {\n      const ttlResult = ttlResults[i]\n      if (ttlResult[1] === -2) {\n        // Clave expirada\n        expiredKeys.push(keys[i])\n      }\n    }\n\n    if (expiredKeys.length > 0) {\n      await client.del(...expiredKeys)\n      logger.info(LogCategory.API, `Cleaned up ${expiredKeys.length} expired rate limit keys`)\n    }\n\n    return expiredKeys.length\n  } catch (error) {\n    logger.error(LogCategory.API, 'Rate limit cleanup failed', error as Error)\n    return 0\n  }\n}\n\n// Exportar cliente Redis para uso directo\nexport const redis = getRedisClient()\n"],"names":["RedisCache","cleanupRateLimitKeys","closeRedisConnection","enterpriseRateLimit","getRateLimitInfo","getRateLimitStats","getRedisClient","incrementRateLimit","isRedisAvailable","redis","redisCache","slidingWindowRateLimit","REDIS_CONFIG","host","process","env","REDIS_HOST","port","parseInt","REDIS_PORT","password","REDIS_PASSWORD","db","REDIS_DB","retryDelayOnFailover","maxRetriesPerRequest","lazyConnect","keepAlive","connectTimeout","commandTimeout","MockRedis","get","key","storage","set","value","args","del","existed","has","delete","exists","incr","current","newValue","toString","expire","seconds","keys","pattern","regex","RegExp","replace","Array","from","filter","test","flushall","clear","lpush","values","list","unshift","length","ltrim","start","stop","trimmed","slice","lrange","ttl","pipeline","MockPipeline","connect","console","log","disconnect","on","event","callback","quit","Map","commands","push","method","exec","results","command","result","error","redisClient","isUsingMock","DISABLE_REDIS","Redis","logger","info","LogCategory","API","warn","message","client","ping","ttlSeconds","setex","countResult","ttlResult","count","windowSeconds","isNewWindow","windowMs","maxRequests","now","Date","window","Math","floor","redisKey","ceil","remaining","max","resetTime","allowed","retryAfter","undefined","debug","precision","windowSize","currentWindow","i","oldWindow","currentKey","windowKey","totalCount","countResults","totalKeys","activeWindows","topKeys","forEach","keyStats","sort","a","b","stat","ttlResults","expiredKeys"],"mappings":"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"}