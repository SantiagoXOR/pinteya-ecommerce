2ccab9a1caf1ebb6aba09e2a633017e7
/**
 * Tests para Sistema Enterprise de Rate Limiting
 * Valida funcionalidad completa del rate limiting con Redis y fallback en memoria
 */ // Mock de Redis
"use strict";
jest.mock('@/lib/redis', ()=>({
        isRedisAvailable: jest.fn(),
        enterpriseRateLimit: jest.fn(),
        redis: {
            pipeline: jest.fn(()=>({
                    incr: jest.fn(),
                    expire: jest.fn(),
                    exec: jest.fn()
                })),
            ping: jest.fn()
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _enterpriseratelimiter = require("../../lib/rate-limiting/enterprise-rate-limiter");
const _redis = require("../../lib/integrations/redis");
describe('Sistema Enterprise de Rate Limiting', ()=>{
    let mockIsRedisAvailable;
    let mockEnterpriseRateLimit;
    beforeEach(()=>{
        mockIsRedisAvailable = _redis.isRedisAvailable;
        mockEnterpriseRateLimit = _redis.enterpriseRateLimit;
        jest.clearAllMocks();
        // Reset memory store
        _enterpriseratelimiter.memoryStore.clear();
        // Reset métricas
        _enterpriseratelimiter.metricsCollector.reset();
        // Configurar mocks por defecto
        mockIsRedisAvailable.mockResolvedValue(false); // Por defecto usar memoria
        mockEnterpriseRateLimit.mockResolvedValue({
            allowed: true,
            count: 1,
            remaining: 49,
            resetTime: Date.now() + 300000
        });
    });
    describe('Configuraciones Predefinidas', ()=>{
        it('debe tener configuración para autenticación crítica', ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.CRITICAL_AUTH;
            expect(config.windowMs).toBe(15 * 60 * 1000); // 15 minutos
            expect(config.maxRequests).toBe(3);
            expect(config.enableRedis).toBe(true);
            expect(config.enableMetrics).toBe(true);
            expect(config.message).toContain('crítica');
        });
        it('debe tener configuración para APIs admin', ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.ADMIN_API;
            expect(config.windowMs).toBe(5 * 60 * 1000); // 5 minutos
            expect(config.maxRequests).toBe(50);
            expect(config.enableRedis).toBe(true);
            expect(config.enableMetrics).toBe(true);
        });
        it('debe tener configuración para APIs de pagos', ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PAYMENT_API;
            expect(config.windowMs).toBe(10 * 60 * 1000); // 10 minutos
            expect(config.maxRequests).toBe(15);
            expect(config.enableRedis).toBe(true);
            expect(config.onLimitReached).toBeDefined();
        });
        it('debe tener configuración para APIs públicas', ()=>{
            const config = _enterpriseratelimiter.ENTERPRISE_RATE_LIMIT_CONFIGS.PUBLIC_API;
            expect(config.windowMs).toBe(1 * 60 * 1000); // 1 minuto
            expect(config.maxRequests).toBe(100);
            expect(config.enableLogging).toBe(false);
        });
    });
    describe('Generadores de Claves', ()=>{
        const mockRequest = {
            headers: new Map([
                [
                    'x-forwarded-for',
                    '192.168.1.1'
                ],
                [
                    'x-clerk-user-id',
                    'user_123'
                ]
            ]),
            nextUrl: {
                pathname: '/api/test'
            }
        };
        it('debe generar clave por IP', ()=>{
            const key = (0, _enterpriseratelimiter.ipKeyGenerator)(mockRequest);
            expect(key).toBe('ip:192.168.1.1');
        });
        it('debe generar clave por usuario', ()=>{
            const key = (0, _enterpriseratelimiter.userKeyGenerator)(mockRequest);
            expect(key).toBe('user:user_123');
        });
        it('debe generar clave por endpoint', ()=>{
            const key = (0, _enterpriseratelimiter.endpointKeyGenerator)(mockRequest);
            expect(key).toBe('endpoint:192.168.1.1:/api/test');
        });
        it('debe generar clave híbrida', ()=>{
            const key = (0, _enterpriseratelimiter.hybridKeyGenerator)(mockRequest);
            expect(key).toBe('user:user_123:/api/test');
        });
        it('debe usar IP como fallback cuando no hay usuario', ()=>{
            const requestWithoutUser = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.1'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const key = (0, _enterpriseratelimiter.userKeyGenerator)(requestWithoutUser);
            expect(key).toBe('ip:192.168.1.1');
        });
    });
    describe('Rate Limiting con Redis', ()=>{
        it('debe usar Redis cuando está disponible', async ()=>{
            // Configurar Redis como disponible
            mockIsRedisAvailable.mockResolvedValue(true);
            mockEnterpriseRateLimit.mockResolvedValue({
                allowed: true,
                count: 1,
                remaining: 49,
                resetTime: Date.now() + 300000
            });
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.1'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            expect(result.allowed).toBe(true);
            expect(result.source).toBe('redis');
            expect(mockIsRedisAvailable).toHaveBeenCalled();
            expect(mockEnterpriseRateLimit).toHaveBeenCalled();
        });
        it('debe usar fallback en memoria cuando Redis no está disponible', async ()=>{
            // Redis no disponible (configuración por defecto)
            mockIsRedisAvailable.mockResolvedValue(false);
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.1'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            expect(result.allowed).toBe(true);
            expect(result.source).toBe('memory');
            expect(mockIsRedisAvailable).toHaveBeenCalled();
            expect(mockEnterpriseRateLimit).not.toHaveBeenCalled();
        });
        it('debe manejar errores de Redis y usar fallback', async ()=>{
            // Redis disponible pero con error
            mockIsRedisAvailable.mockResolvedValue(true);
            mockEnterpriseRateLimit.mockRejectedValue(new Error('Redis error'));
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.1'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            expect(result.allowed).toBe(true);
            expect(result.source).toBe('memory');
        });
    });
    describe('Rate Limiting en Memoria', ()=>{
        beforeEach(()=>{
            mockIsRedisAvailable.mockResolvedValue(false);
        });
        it('debe permitir primera request', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.1'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            expect(result.allowed).toBe(true);
            expect(result.remaining).toBe(49); // 50 - 1
            expect(result.source).toBe('memory');
        });
        it('debe incrementar contador en requests subsecuentes', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.1'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            // Primera request
            const result1 = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            expect(result1.remaining).toBe(49);
            // Segunda request
            const result2 = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            expect(result2.remaining).toBe(48);
        });
        it('debe bloquear cuando se excede el límite', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.2'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            // Hacer 3 requests (límite para CRITICAL_AUTH)
            for(let i = 0; i < 3; i++){
                const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'CRITICAL_AUTH');
                expect(result.allowed).toBe(true);
            }
            // Cuarta request debe ser bloqueada
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'CRITICAL_AUTH');
            expect(result.allowed).toBe(false);
            expect(result.retryAfter).toBeDefined();
        });
        it('debe resetear contador después de la ventana', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.3'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            // Configuración con ventana muy corta para testing
            const customConfig = {
                windowMs: 100
            } // 100ms
            ;
            // Primera request
            const result1 = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API', customConfig);
            expect(result1.allowed).toBe(true);
            // Esperar que expire la ventana
            await new Promise((resolve)=>setTimeout(resolve, 150));
            // Nueva request después de expiración
            const result2 = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API', customConfig);
            expect(result2.allowed).toBe(true);
            expect(result2.remaining).toBe(49); // Contador reseteado
        });
    });
    describe('Métricas y Logging', ()=>{
        beforeEach(()=>{
            mockIsRedisAvailable.mockResolvedValue(false);
        });
        it('debe registrar métricas cuando está habilitado', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.4'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.totalRequests).toBe(1);
            expect(metrics.allowedRequests).toBe(1);
            expect(metrics.memoryFallbacks).toBe(1);
        });
        it('debe registrar requests bloqueadas en métricas', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.5'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            // Exceder límite
            for(let i = 0; i < 4; i++){
                await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'CRITICAL_AUTH');
            }
            const metrics = _enterpriseratelimiter.metricsCollector.getMetrics();
            expect(metrics.totalRequests).toBe(4);
            expect(metrics.allowedRequests).toBe(3);
            expect(metrics.blockedRequests).toBe(1);
        });
        it('debe incluir métricas de tiempo de respuesta', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.6'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            expect(result.metrics).toBeDefined();
            expect(result.metrics?.responseTime).toBeGreaterThanOrEqual(0); // Puede ser 0 en tests rápidos
            expect(result.metrics?.keyGenerated).toBeDefined();
            expect(typeof result.metrics?.responseTime).toBe('number');
        });
    });
    describe('Configuraciones Personalizadas', ()=>{
        beforeEach(()=>{
            mockIsRedisAvailable.mockResolvedValue(false);
        });
        it('debe aplicar configuración personalizada', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.7'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const customConfig = {
                maxRequests: 2,
                windowMs: 60000
            };
            // Primera y segunda request deben pasar
            const result1 = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API', customConfig);
            expect(result1.allowed).toBe(true);
            const result2 = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API', customConfig);
            expect(result2.allowed).toBe(true);
            // Tercera request debe ser bloqueada
            const result3 = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API', customConfig);
            expect(result3.allowed).toBe(false);
        });
        it('debe usar generador de clave personalizado', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.8'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const customConfig = {
                keyGenerator: ()=>'custom_key'
            };
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API', customConfig);
            expect(result.allowed).toBe(true);
            expect(result.metrics?.keyGenerated).toBe('custom_key');
        });
    });
    describe('Manejo de Errores', ()=>{
        it('debe manejar configuración no encontrada', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.9'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'INVALID_CONFIG');
            expect(result.allowed).toBe(true);
            expect(result.error).toContain('no encontrada');
            expect(result.code).toBe('CONFIG_NOT_FOUND');
            expect(result.source).toBe('error');
        });
        it('debe permitir requests en caso de error interno', async ()=>{
            mockIsRedisAvailable.mockRejectedValue(new Error('Internal error'));
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.10'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API');
            expect(result.allowed).toBe(true);
            expect(result.error).toContain('Error interno');
            expect(result.code).toBe('INTERNAL_ERROR');
            expect(result.source).toBe('error');
        });
    });
    describe('Store en Memoria', ()=>{
        it('debe proporcionar estadísticas del store', ()=>{
            const stats = _enterpriseratelimiter.memoryStore.getStats();
            expect(stats).toHaveProperty('entries');
            expect(stats).toHaveProperty('memoryUsage');
            expect(typeof stats.entries).toBe('number');
            expect(typeof stats.memoryUsage).toBe('number');
        });
        it('debe limpiar entradas expiradas', async ()=>{
            const mockRequest = {
                headers: new Map([
                    [
                        'x-forwarded-for',
                        '192.168.1.11'
                    ]
                ]),
                nextUrl: {
                    pathname: '/api/test'
                }
            };
            // Crear entrada con TTL muy corto
            await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API', {
                windowMs: 50
            });
            // Esperar expiración
            await new Promise((resolve)=>setTimeout(resolve, 100));
            // Nueva request debería crear nueva entrada
            const result = await (0, _enterpriseratelimiter.checkEnterpriseRateLimit)(mockRequest, 'ADMIN_API', {
                windowMs: 60000
            });
            expect(result.remaining).toBe(49); // Contador reseteado
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxyYXRlLWxpbWl0aW5nXFxlbnRlcnByaXNlLXJhdGUtbGltaXRlci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgcGFyYSBTaXN0ZW1hIEVudGVycHJpc2UgZGUgUmF0ZSBMaW1pdGluZ1xuICogVmFsaWRhIGZ1bmNpb25hbGlkYWQgY29tcGxldGEgZGVsIHJhdGUgbGltaXRpbmcgY29uIFJlZGlzIHkgZmFsbGJhY2sgZW4gbWVtb3JpYVxuICovXG5cbi8vIE1vY2sgZGUgUmVkaXNcbmplc3QubW9jaygnQC9saWIvcmVkaXMnLCAoKSA9PiAoe1xuICBpc1JlZGlzQXZhaWxhYmxlOiBqZXN0LmZuKCksXG4gIGVudGVycHJpc2VSYXRlTGltaXQ6IGplc3QuZm4oKSxcbiAgcmVkaXM6IHtcbiAgICBwaXBlbGluZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgaW5jcjogamVzdC5mbigpLFxuICAgICAgZXhwaXJlOiBqZXN0LmZuKCksXG4gICAgICBleGVjOiBqZXN0LmZuKCksXG4gICAgfSkpLFxuICAgIHBpbmc6IGplc3QuZm4oKSxcbiAgfSxcbn0pKVxuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJ1xuaW1wb3J0IHtcbiAgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0LFxuICBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUyxcbiAgaXBLZXlHZW5lcmF0b3IsXG4gIHVzZXJLZXlHZW5lcmF0b3IsXG4gIGVuZHBvaW50S2V5R2VuZXJhdG9yLFxuICBoeWJyaWRLZXlHZW5lcmF0b3IsXG4gIG1lbW9yeVN0b3JlLFxuICBtZXRyaWNzQ29sbGVjdG9yLFxufSBmcm9tICdAL2xpYi9yYXRlLWxpbWl0aW5nL2VudGVycHJpc2UtcmF0ZS1saW1pdGVyJ1xuaW1wb3J0IHsgaXNSZWRpc0F2YWlsYWJsZSwgZW50ZXJwcmlzZVJhdGVMaW1pdCB9IGZyb20gJ0AvbGliL2ludGVncmF0aW9ucy9yZWRpcydcblxuZGVzY3JpYmUoJ1Npc3RlbWEgRW50ZXJwcmlzZSBkZSBSYXRlIExpbWl0aW5nJywgKCkgPT4ge1xuICBsZXQgbW9ja0lzUmVkaXNBdmFpbGFibGU6IGplc3QuTW9ja2VkRnVuY3Rpb248dHlwZW9mIGlzUmVkaXNBdmFpbGFibGU+XG4gIGxldCBtb2NrRW50ZXJwcmlzZVJhdGVMaW1pdDogamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZW50ZXJwcmlzZVJhdGVMaW1pdD5cblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrSXNSZWRpc0F2YWlsYWJsZSA9IGlzUmVkaXNBdmFpbGFibGUgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgaXNSZWRpc0F2YWlsYWJsZT5cbiAgICBtb2NrRW50ZXJwcmlzZVJhdGVMaW1pdCA9IGVudGVycHJpc2VSYXRlTGltaXQgYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZW50ZXJwcmlzZVJhdGVMaW1pdD5cblxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG5cbiAgICAvLyBSZXNldCBtZW1vcnkgc3RvcmVcbiAgICBtZW1vcnlTdG9yZS5jbGVhcigpXG5cbiAgICAvLyBSZXNldCBtw6l0cmljYXNcbiAgICBtZXRyaWNzQ29sbGVjdG9yLnJlc2V0KClcblxuICAgIC8vIENvbmZpZ3VyYXIgbW9ja3MgcG9yIGRlZmVjdG9cbiAgICBtb2NrSXNSZWRpc0F2YWlsYWJsZS5tb2NrUmVzb2x2ZWRWYWx1ZShmYWxzZSkgLy8gUG9yIGRlZmVjdG8gdXNhciBtZW1vcmlhXG4gICAgbW9ja0VudGVycHJpc2VSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgYWxsb3dlZDogdHJ1ZSxcbiAgICAgIGNvdW50OiAxLFxuICAgICAgcmVtYWluaW5nOiA0OSxcbiAgICAgIHJlc2V0VGltZTogRGF0ZS5ub3coKSArIDMwMDAwMCxcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdDb25maWd1cmFjaW9uZXMgUHJlZGVmaW5pZGFzJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIHRlbmVyIGNvbmZpZ3VyYWNpw7NuIHBhcmEgYXV0ZW50aWNhY2nDs24gY3LDrXRpY2EnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5DUklUSUNBTF9BVVRIXG5cbiAgICAgIGV4cGVjdChjb25maWcud2luZG93TXMpLnRvQmUoMTUgKiA2MCAqIDEwMDApIC8vIDE1IG1pbnV0b3NcbiAgICAgIGV4cGVjdChjb25maWcubWF4UmVxdWVzdHMpLnRvQmUoMylcbiAgICAgIGV4cGVjdChjb25maWcuZW5hYmxlUmVkaXMpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChjb25maWcuZW5hYmxlTWV0cmljcykudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KGNvbmZpZy5tZXNzYWdlKS50b0NvbnRhaW4oJ2Nyw610aWNhJylcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgdGVuZXIgY29uZmlndXJhY2nDs24gcGFyYSBBUElzIGFkbWluJywgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0gRU5URVJQUklTRV9SQVRFX0xJTUlUX0NPTkZJR1MuQURNSU5fQVBJXG5cbiAgICAgIGV4cGVjdChjb25maWcud2luZG93TXMpLnRvQmUoNSAqIDYwICogMTAwMCkgLy8gNSBtaW51dG9zXG4gICAgICBleHBlY3QoY29uZmlnLm1heFJlcXVlc3RzKS50b0JlKDUwKVxuICAgICAgZXhwZWN0KGNvbmZpZy5lbmFibGVSZWRpcykudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KGNvbmZpZy5lbmFibGVNZXRyaWNzKS50b0JlKHRydWUpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIHRlbmVyIGNvbmZpZ3VyYWNpw7NuIHBhcmEgQVBJcyBkZSBwYWdvcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IEVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTLlBBWU1FTlRfQVBJXG5cbiAgICAgIGV4cGVjdChjb25maWcud2luZG93TXMpLnRvQmUoMTAgKiA2MCAqIDEwMDApIC8vIDEwIG1pbnV0b3NcbiAgICAgIGV4cGVjdChjb25maWcubWF4UmVxdWVzdHMpLnRvQmUoMTUpXG4gICAgICBleHBlY3QoY29uZmlnLmVuYWJsZVJlZGlzKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QoY29uZmlnLm9uTGltaXRSZWFjaGVkKS50b0JlRGVmaW5lZCgpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIHRlbmVyIGNvbmZpZ3VyYWNpw7NuIHBhcmEgQVBJcyBww7pibGljYXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb25maWcgPSBFTlRFUlBSSVNFX1JBVEVfTElNSVRfQ09ORklHUy5QVUJMSUNfQVBJXG5cbiAgICAgIGV4cGVjdChjb25maWcud2luZG93TXMpLnRvQmUoMSAqIDYwICogMTAwMCkgLy8gMSBtaW51dG9cbiAgICAgIGV4cGVjdChjb25maWcubWF4UmVxdWVzdHMpLnRvQmUoMTAwKVxuICAgICAgZXhwZWN0KGNvbmZpZy5lbmFibGVMb2dnaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0dlbmVyYWRvcmVzIGRlIENsYXZlcycsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1xuICAgICAgICBbJ3gtZm9yd2FyZGVkLWZvcicsICcxOTIuMTY4LjEuMSddLFxuICAgICAgICBbJ3gtY2xlcmstdXNlci1pZCcsICd1c2VyXzEyMyddLFxuICAgICAgXSksXG4gICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS90ZXN0JyB9LFxuICAgIH0gYXMgYW55XG5cbiAgICBpdCgnZGViZSBnZW5lcmFyIGNsYXZlIHBvciBJUCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGlwS2V5R2VuZXJhdG9yKG1vY2tSZXF1ZXN0KVxuICAgICAgZXhwZWN0KGtleSkudG9CZSgnaXA6MTkyLjE2OC4xLjEnKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBnZW5lcmFyIGNsYXZlIHBvciB1c3VhcmlvJywgKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXNlcktleUdlbmVyYXRvcihtb2NrUmVxdWVzdClcbiAgICAgIGV4cGVjdChrZXkpLnRvQmUoJ3VzZXI6dXNlcl8xMjMnKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBnZW5lcmFyIGNsYXZlIHBvciBlbmRwb2ludCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGVuZHBvaW50S2V5R2VuZXJhdG9yKG1vY2tSZXF1ZXN0KVxuICAgICAgZXhwZWN0KGtleSkudG9CZSgnZW5kcG9pbnQ6MTkyLjE2OC4xLjE6L2FwaS90ZXN0JylcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgZ2VuZXJhciBjbGF2ZSBow61icmlkYScsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IGh5YnJpZEtleUdlbmVyYXRvcihtb2NrUmVxdWVzdClcbiAgICAgIGV4cGVjdChrZXkpLnRvQmUoJ3VzZXI6dXNlcl8xMjM6L2FwaS90ZXN0JylcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgdXNhciBJUCBjb21vIGZhbGxiYWNrIGN1YW5kbyBubyBoYXkgdXN1YXJpbycsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RXaXRob3V0VXNlciA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IE1hcChbWyd4LWZvcndhcmRlZC1mb3InLCAnMTkyLjE2OC4xLjEnXV0pLFxuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS90ZXN0JyB9LFxuICAgICAgfSBhcyBhbnlcblxuICAgICAgY29uc3Qga2V5ID0gdXNlcktleUdlbmVyYXRvcihyZXF1ZXN0V2l0aG91dFVzZXIpXG4gICAgICBleHBlY3Qoa2V5KS50b0JlKCdpcDoxOTIuMTY4LjEuMScpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUmF0ZSBMaW1pdGluZyBjb24gUmVkaXMnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgdXNhciBSZWRpcyBjdWFuZG8gZXN0w6EgZGlzcG9uaWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENvbmZpZ3VyYXIgUmVkaXMgY29tbyBkaXNwb25pYmxlXG4gICAgICBtb2NrSXNSZWRpc0F2YWlsYWJsZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKVxuICAgICAgbW9ja0VudGVycHJpc2VSYXRlTGltaXQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBhbGxvd2VkOiB0cnVlLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgcmVtYWluaW5nOiA0OSxcbiAgICAgICAgcmVzZXRUaW1lOiBEYXRlLm5vdygpICsgMzAwMDAwLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1sneC1mb3J3YXJkZWQtZm9yJywgJzE5Mi4xNjguMS4xJ11dKSxcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvdGVzdCcgfSxcbiAgICAgIH0gYXMgYW55XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgJ0FETUlOX0FQSScpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5zb3VyY2UpLnRvQmUoJ3JlZGlzJylcbiAgICAgIGV4cGVjdChtb2NrSXNSZWRpc0F2YWlsYWJsZSkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3QobW9ja0VudGVycHJpc2VSYXRlTGltaXQpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSB1c2FyIGZhbGxiYWNrIGVuIG1lbW9yaWEgY3VhbmRvIFJlZGlzIG5vIGVzdMOhIGRpc3BvbmlibGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBSZWRpcyBubyBkaXNwb25pYmxlIChjb25maWd1cmFjacOzbiBwb3IgZGVmZWN0bylcbiAgICAgIG1vY2tJc1JlZGlzQXZhaWxhYmxlLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlKVxuXG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IE1hcChbWyd4LWZvcndhcmRlZC1mb3InLCAnMTkyLjE2OC4xLjEnXV0pLFxuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS90ZXN0JyB9LFxuICAgICAgfSBhcyBhbnlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KG1vY2tSZXF1ZXN0LCAnQURNSU5fQVBJJylcblxuICAgICAgZXhwZWN0KHJlc3VsdC5hbGxvd2VkKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QocmVzdWx0LnNvdXJjZSkudG9CZSgnbWVtb3J5JylcbiAgICAgIGV4cGVjdChtb2NrSXNSZWRpc0F2YWlsYWJsZSkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3QobW9ja0VudGVycHJpc2VSYXRlTGltaXQpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgbWFuZWphciBlcnJvcmVzIGRlIFJlZGlzIHkgdXNhciBmYWxsYmFjaycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFJlZGlzIGRpc3BvbmlibGUgcGVybyBjb24gZXJyb3JcbiAgICAgIG1vY2tJc1JlZGlzQXZhaWxhYmxlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpXG4gICAgICBtb2NrRW50ZXJwcmlzZVJhdGVMaW1pdC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlZGlzIGVycm9yJykpXG5cbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ3gtZm9yd2FyZGVkLWZvcicsICcxOTIuMTY4LjEuMSddXSksXG4gICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Rlc3QnIH0sXG4gICAgICB9IGFzIGFueVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdBRE1JTl9BUEknKVxuXG4gICAgICBleHBlY3QocmVzdWx0LmFsbG93ZWQpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChyZXN1bHQuc291cmNlKS50b0JlKCdtZW1vcnknKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1JhdGUgTGltaXRpbmcgZW4gTWVtb3JpYScsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tJc1JlZGlzQXZhaWxhYmxlLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBwZXJtaXRpciBwcmltZXJhIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IE1hcChbWyd4LWZvcndhcmRlZC1mb3InLCAnMTkyLjE2OC4xLjEnXV0pLFxuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS90ZXN0JyB9LFxuICAgICAgfSBhcyBhbnlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KG1vY2tSZXF1ZXN0LCAnQURNSU5fQVBJJylcblxuICAgICAgZXhwZWN0KHJlc3VsdC5hbGxvd2VkKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QocmVzdWx0LnJlbWFpbmluZykudG9CZSg0OSkgLy8gNTAgLSAxXG4gICAgICBleHBlY3QocmVzdWx0LnNvdXJjZSkudG9CZSgnbWVtb3J5JylcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgaW5jcmVtZW50YXIgY29udGFkb3IgZW4gcmVxdWVzdHMgc3Vic2VjdWVudGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1sneC1mb3J3YXJkZWQtZm9yJywgJzE5Mi4xNjguMS4xJ11dKSxcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvdGVzdCcgfSxcbiAgICAgIH0gYXMgYW55XG5cbiAgICAgIC8vIFByaW1lcmEgcmVxdWVzdFxuICAgICAgY29uc3QgcmVzdWx0MSA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgJ0FETUlOX0FQSScpXG4gICAgICBleHBlY3QocmVzdWx0MS5yZW1haW5pbmcpLnRvQmUoNDkpXG5cbiAgICAgIC8vIFNlZ3VuZGEgcmVxdWVzdFxuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgJ0FETUlOX0FQSScpXG4gICAgICBleHBlY3QocmVzdWx0Mi5yZW1haW5pbmcpLnRvQmUoNDgpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIGJsb3F1ZWFyIGN1YW5kbyBzZSBleGNlZGUgZWwgbMOtbWl0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ3gtZm9yd2FyZGVkLWZvcicsICcxOTIuMTY4LjEuMiddXSksXG4gICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Rlc3QnIH0sXG4gICAgICB9IGFzIGFueVxuXG4gICAgICAvLyBIYWNlciAzIHJlcXVlc3RzIChsw61taXRlIHBhcmEgQ1JJVElDQUxfQVVUSClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgJ0NSSVRJQ0FMX0FVVEgnKVxuICAgICAgICBleHBlY3QocmVzdWx0LmFsbG93ZWQpLnRvQmUodHJ1ZSlcbiAgICAgIH1cblxuICAgICAgLy8gQ3VhcnRhIHJlcXVlc3QgZGViZSBzZXIgYmxvcXVlYWRhXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdDUklUSUNBTF9BVVRIJylcbiAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdChyZXN1bHQucmV0cnlBZnRlcikudG9CZURlZmluZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSByZXNldGVhciBjb250YWRvciBkZXNwdcOpcyBkZSBsYSB2ZW50YW5hJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1sneC1mb3J3YXJkZWQtZm9yJywgJzE5Mi4xNjguMS4zJ11dKSxcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvdGVzdCcgfSxcbiAgICAgIH0gYXMgYW55XG5cbiAgICAgIC8vIENvbmZpZ3VyYWNpw7NuIGNvbiB2ZW50YW5hIG11eSBjb3J0YSBwYXJhIHRlc3RpbmdcbiAgICAgIGNvbnN0IGN1c3RvbUNvbmZpZyA9IHsgd2luZG93TXM6IDEwMCB9IC8vIDEwMG1zXG5cbiAgICAgIC8vIFByaW1lcmEgcmVxdWVzdFxuICAgICAgY29uc3QgcmVzdWx0MSA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgJ0FETUlOX0FQSScsIGN1c3RvbUNvbmZpZylcbiAgICAgIGV4cGVjdChyZXN1bHQxLmFsbG93ZWQpLnRvQmUodHJ1ZSlcblxuICAgICAgLy8gRXNwZXJhciBxdWUgZXhwaXJlIGxhIHZlbnRhbmFcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTApKVxuXG4gICAgICAvLyBOdWV2YSByZXF1ZXN0IGRlc3B1w6lzIGRlIGV4cGlyYWNpw7NuXG4gICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KG1vY2tSZXF1ZXN0LCAnQURNSU5fQVBJJywgY3VzdG9tQ29uZmlnKVxuICAgICAgZXhwZWN0KHJlc3VsdDIuYWxsb3dlZCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdDIucmVtYWluaW5nKS50b0JlKDQ5KSAvLyBDb250YWRvciByZXNldGVhZG9cbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdNw6l0cmljYXMgeSBMb2dnaW5nJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja0lzUmVkaXNBdmFpbGFibGUubW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIHJlZ2lzdHJhciBtw6l0cmljYXMgY3VhbmRvIGVzdMOhIGhhYmlsaXRhZG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IE1hcChbWyd4LWZvcndhcmRlZC1mb3InLCAnMTkyLjE2OC4xLjQnXV0pLFxuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS90ZXN0JyB9LFxuICAgICAgfSBhcyBhbnlcblxuICAgICAgYXdhaXQgY2hlY2tFbnRlcnByaXNlUmF0ZUxpbWl0KG1vY2tSZXF1ZXN0LCAnQURNSU5fQVBJJylcblxuICAgICAgY29uc3QgbWV0cmljcyA9IG1ldHJpY3NDb2xsZWN0b3IuZ2V0TWV0cmljcygpXG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbFJlcXVlc3RzKS50b0JlKDEpXG4gICAgICBleHBlY3QobWV0cmljcy5hbGxvd2VkUmVxdWVzdHMpLnRvQmUoMSlcbiAgICAgIGV4cGVjdChtZXRyaWNzLm1lbW9yeUZhbGxiYWNrcykudG9CZSgxKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSByZWdpc3RyYXIgcmVxdWVzdHMgYmxvcXVlYWRhcyBlbiBtw6l0cmljYXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IE1hcChbWyd4LWZvcndhcmRlZC1mb3InLCAnMTkyLjE2OC4xLjUnXV0pLFxuICAgICAgICBuZXh0VXJsOiB7IHBhdGhuYW1lOiAnL2FwaS90ZXN0JyB9LFxuICAgICAgfSBhcyBhbnlcblxuICAgICAgLy8gRXhjZWRlciBsw61taXRlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdDUklUSUNBTF9BVVRIJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWV0cmljcyA9IG1ldHJpY3NDb2xsZWN0b3IuZ2V0TWV0cmljcygpXG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbFJlcXVlc3RzKS50b0JlKDQpXG4gICAgICBleHBlY3QobWV0cmljcy5hbGxvd2VkUmVxdWVzdHMpLnRvQmUoMylcbiAgICAgIGV4cGVjdChtZXRyaWNzLmJsb2NrZWRSZXF1ZXN0cykudG9CZSgxKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBpbmNsdWlyIG3DqXRyaWNhcyBkZSB0aWVtcG8gZGUgcmVzcHVlc3RhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1sneC1mb3J3YXJkZWQtZm9yJywgJzE5Mi4xNjguMS42J11dKSxcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvdGVzdCcgfSxcbiAgICAgIH0gYXMgYW55XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgJ0FETUlOX0FQSScpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQubWV0cmljcykudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlc3VsdC5tZXRyaWNzPy5yZXNwb25zZVRpbWUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCkgLy8gUHVlZGUgc2VyIDAgZW4gdGVzdHMgcsOhcGlkb3NcbiAgICAgIGV4cGVjdChyZXN1bHQubWV0cmljcz8ua2V5R2VuZXJhdGVkKS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdC5tZXRyaWNzPy5yZXNwb25zZVRpbWUpLnRvQmUoJ251bWJlcicpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnQ29uZmlndXJhY2lvbmVzIFBlcnNvbmFsaXphZGFzJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja0lzUmVkaXNBdmFpbGFibGUubW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIGFwbGljYXIgY29uZmlndXJhY2nDs24gcGVyc29uYWxpemFkYScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ3gtZm9yd2FyZGVkLWZvcicsICcxOTIuMTY4LjEuNyddXSksXG4gICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Rlc3QnIH0sXG4gICAgICB9IGFzIGFueVxuXG4gICAgICBjb25zdCBjdXN0b21Db25maWcgPSB7XG4gICAgICAgIG1heFJlcXVlc3RzOiAyLFxuICAgICAgICB3aW5kb3dNczogNjAwMDAsXG4gICAgICB9XG5cbiAgICAgIC8vIFByaW1lcmEgeSBzZWd1bmRhIHJlcXVlc3QgZGViZW4gcGFzYXJcbiAgICAgIGNvbnN0IHJlc3VsdDEgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdBRE1JTl9BUEknLCBjdXN0b21Db25maWcpXG4gICAgICBleHBlY3QocmVzdWx0MS5hbGxvd2VkKS50b0JlKHRydWUpXG5cbiAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdBRE1JTl9BUEknLCBjdXN0b21Db25maWcpXG4gICAgICBleHBlY3QocmVzdWx0Mi5hbGxvd2VkKS50b0JlKHRydWUpXG5cbiAgICAgIC8vIFRlcmNlcmEgcmVxdWVzdCBkZWJlIHNlciBibG9xdWVhZGFcbiAgICAgIGNvbnN0IHJlc3VsdDMgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdBRE1JTl9BUEknLCBjdXN0b21Db25maWcpXG4gICAgICBleHBlY3QocmVzdWx0My5hbGxvd2VkKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSB1c2FyIGdlbmVyYWRvciBkZSBjbGF2ZSBwZXJzb25hbGl6YWRvJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1sneC1mb3J3YXJkZWQtZm9yJywgJzE5Mi4xNjguMS44J11dKSxcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvdGVzdCcgfSxcbiAgICAgIH0gYXMgYW55XG5cbiAgICAgIGNvbnN0IGN1c3RvbUNvbmZpZyA9IHtcbiAgICAgICAga2V5R2VuZXJhdG9yOiAoKSA9PiAnY3VzdG9tX2tleScsXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgJ0FETUlOX0FQSScsIGN1c3RvbUNvbmZpZylcbiAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5tZXRyaWNzPy5rZXlHZW5lcmF0ZWQpLnRvQmUoJ2N1c3RvbV9rZXknKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ01hbmVqbyBkZSBFcnJvcmVzJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIG1hbmVqYXIgY29uZmlndXJhY2nDs24gbm8gZW5jb250cmFkYScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tSZXF1ZXN0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgTWFwKFtbJ3gtZm9yd2FyZGVkLWZvcicsICcxOTIuMTY4LjEuOSddXSksXG4gICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Rlc3QnIH0sXG4gICAgICB9IGFzIGFueVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdJTlZBTElEX0NPTkZJRycgYXMgYW55KVxuXG4gICAgICBleHBlY3QocmVzdWx0LmFsbG93ZWQpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbignbm8gZW5jb250cmFkYScpXG4gICAgICBleHBlY3QocmVzdWx0LmNvZGUpLnRvQmUoJ0NPTkZJR19OT1RfRk9VTkQnKVxuICAgICAgZXhwZWN0KHJlc3VsdC5zb3VyY2UpLnRvQmUoJ2Vycm9yJylcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgcGVybWl0aXIgcmVxdWVzdHMgZW4gY2FzbyBkZSBlcnJvciBpbnRlcm5vJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0lzUmVkaXNBdmFpbGFibGUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvcicpKVxuXG4gICAgICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IE1hcChbWyd4LWZvcndhcmRlZC1mb3InLCAnMTkyLjE2OC4xLjEwJ11dKSxcbiAgICAgICAgbmV4dFVybDogeyBwYXRobmFtZTogJy9hcGkvdGVzdCcgfSxcbiAgICAgIH0gYXMgYW55XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoZWNrRW50ZXJwcmlzZVJhdGVMaW1pdChtb2NrUmVxdWVzdCwgJ0FETUlOX0FQSScpXG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYWxsb3dlZCkudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdFcnJvciBpbnRlcm5vJylcbiAgICAgIGV4cGVjdChyZXN1bHQuY29kZSkudG9CZSgnSU5URVJOQUxfRVJST1InKVxuICAgICAgZXhwZWN0KHJlc3VsdC5zb3VyY2UpLnRvQmUoJ2Vycm9yJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdTdG9yZSBlbiBNZW1vcmlhJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIHByb3BvcmNpb25hciBlc3RhZMOtc3RpY2FzIGRlbCBzdG9yZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRzID0gbWVtb3J5U3RvcmUuZ2V0U3RhdHMoKVxuXG4gICAgICBleHBlY3Qoc3RhdHMpLnRvSGF2ZVByb3BlcnR5KCdlbnRyaWVzJylcbiAgICAgIGV4cGVjdChzdGF0cykudG9IYXZlUHJvcGVydHkoJ21lbW9yeVVzYWdlJylcbiAgICAgIGV4cGVjdCh0eXBlb2Ygc3RhdHMuZW50cmllcykudG9CZSgnbnVtYmVyJylcbiAgICAgIGV4cGVjdCh0eXBlb2Ygc3RhdHMubWVtb3J5VXNhZ2UpLnRvQmUoJ251bWJlcicpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIGxpbXBpYXIgZW50cmFkYXMgZXhwaXJhZGFzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1JlcXVlc3QgPSB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBNYXAoW1sneC1mb3J3YXJkZWQtZm9yJywgJzE5Mi4xNjguMS4xMSddXSksXG4gICAgICAgIG5leHRVcmw6IHsgcGF0aG5hbWU6ICcvYXBpL3Rlc3QnIH0sXG4gICAgICB9IGFzIGFueVxuXG4gICAgICAvLyBDcmVhciBlbnRyYWRhIGNvbiBUVEwgbXV5IGNvcnRvXG4gICAgICBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdBRE1JTl9BUEknLCB7IHdpbmRvd01zOiA1MCB9KVxuXG4gICAgICAvLyBFc3BlcmFyIGV4cGlyYWNpw7NuXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSlcblxuICAgICAgLy8gTnVldmEgcmVxdWVzdCBkZWJlcsOtYSBjcmVhciBudWV2YSBlbnRyYWRhXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGVja0VudGVycHJpc2VSYXRlTGltaXQobW9ja1JlcXVlc3QsICdBRE1JTl9BUEknLCB7IHdpbmRvd01zOiA2MDAwMCB9KVxuICAgICAgZXhwZWN0KHJlc3VsdC5yZW1haW5pbmcpLnRvQmUoNDkpIC8vIENvbnRhZG9yIHJlc2V0ZWFkb1xuICAgIH0pXG4gIH0pXG59KVxuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiaXNSZWRpc0F2YWlsYWJsZSIsImZuIiwiZW50ZXJwcmlzZVJhdGVMaW1pdCIsInJlZGlzIiwicGlwZWxpbmUiLCJpbmNyIiwiZXhwaXJlIiwiZXhlYyIsInBpbmciLCJkZXNjcmliZSIsIm1vY2tJc1JlZGlzQXZhaWxhYmxlIiwibW9ja0VudGVycHJpc2VSYXRlTGltaXQiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1lbW9yeVN0b3JlIiwiY2xlYXIiLCJtZXRyaWNzQ29sbGVjdG9yIiwicmVzZXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImFsbG93ZWQiLCJjb3VudCIsInJlbWFpbmluZyIsInJlc2V0VGltZSIsIkRhdGUiLCJub3ciLCJpdCIsImNvbmZpZyIsIkVOVEVSUFJJU0VfUkFURV9MSU1JVF9DT05GSUdTIiwiQ1JJVElDQUxfQVVUSCIsImV4cGVjdCIsIndpbmRvd01zIiwidG9CZSIsIm1heFJlcXVlc3RzIiwiZW5hYmxlUmVkaXMiLCJlbmFibGVNZXRyaWNzIiwibWVzc2FnZSIsInRvQ29udGFpbiIsIkFETUlOX0FQSSIsIlBBWU1FTlRfQVBJIiwib25MaW1pdFJlYWNoZWQiLCJ0b0JlRGVmaW5lZCIsIlBVQkxJQ19BUEkiLCJlbmFibGVMb2dnaW5nIiwibW9ja1JlcXVlc3QiLCJoZWFkZXJzIiwiTWFwIiwibmV4dFVybCIsInBhdGhuYW1lIiwia2V5IiwiaXBLZXlHZW5lcmF0b3IiLCJ1c2VyS2V5R2VuZXJhdG9yIiwiZW5kcG9pbnRLZXlHZW5lcmF0b3IiLCJoeWJyaWRLZXlHZW5lcmF0b3IiLCJyZXF1ZXN0V2l0aG91dFVzZXIiLCJyZXN1bHQiLCJjaGVja0VudGVycHJpc2VSYXRlTGltaXQiLCJzb3VyY2UiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibm90IiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsInJlc3VsdDEiLCJyZXN1bHQyIiwiaSIsInJldHJ5QWZ0ZXIiLCJjdXN0b21Db25maWciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJtZXRyaWNzIiwiZ2V0TWV0cmljcyIsInRvdGFsUmVxdWVzdHMiLCJhbGxvd2VkUmVxdWVzdHMiLCJtZW1vcnlGYWxsYmFja3MiLCJibG9ja2VkUmVxdWVzdHMiLCJyZXNwb25zZVRpbWUiLCJ0b0JlR3JlYXRlclRoYW5PckVxdWFsIiwia2V5R2VuZXJhdGVkIiwicmVzdWx0MyIsImtleUdlbmVyYXRvciIsImVycm9yIiwiY29kZSIsInN0YXRzIiwiZ2V0U3RhdHMiLCJ0b0hhdmVQcm9wZXJ0eSIsImVudHJpZXMiLCJtZW1vcnlVc2FnZSJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQsZ0JBQWdCOztBQUNoQkEsS0FBS0MsSUFBSSxDQUFDLGVBQWUsSUFBTyxDQUFBO1FBQzlCQyxrQkFBa0JGLEtBQUtHLEVBQUU7UUFDekJDLHFCQUFxQkosS0FBS0csRUFBRTtRQUM1QkUsT0FBTztZQUNMQyxVQUFVTixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO29CQUN2QkksTUFBTVAsS0FBS0csRUFBRTtvQkFDYkssUUFBUVIsS0FBS0csRUFBRTtvQkFDZk0sTUFBTVQsS0FBS0csRUFBRTtnQkFDZixDQUFBO1lBQ0FPLE1BQU1WLEtBQUtHLEVBQUU7UUFDZjtJQUNGLENBQUE7Ozs7dUNBWU87dUJBQytDO0FBRXREUSxTQUFTLHVD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