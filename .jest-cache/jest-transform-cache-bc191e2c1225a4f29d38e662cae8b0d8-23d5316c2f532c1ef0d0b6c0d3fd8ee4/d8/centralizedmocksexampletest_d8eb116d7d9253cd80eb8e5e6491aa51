33802dcc59ab984199364741af5cc921
// ===================================
// EJEMPLO DE USO DE MOCKS CENTRALIZADOS - PINTEYA E-COMMERCE
// ===================================
/**
 * Test de ejemplo que demuestra el uso de los mocks centralizados
 * Este archivo sirve como referencia para futuros tests
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useProducts = require("../../hooks/useProducts");
const _apimocks = require("../__mocks__/api-mocks");
const _hooksmocks = require("../__mocks__/hooks-mocks");
describe('Ejemplo de Mocks Centralizados', ()=>{
    // Setup de mocks usando helper centralizado
    const { mockFetch, resetMocks, mockSuccess, mockError, mockHttpError } = (0, _apimocks.setupApiMocks)();
    beforeEach(()=>{
        resetMocks();
    });
    describe('API Mocks Centralizados', ()=>{
        it('debe usar respuesta exitosa por defecto', async ()=>{
            // El mock ya está configurado con respuesta exitosa por defecto
            const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.products).toHaveLength(3); // mockProducts tiene 3 items
            expect(result.current.error).toBeNull();
        });
        it('debe manejar errores usando helper mockError', async ()=>{
            mockError('Network connection failed');
            const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.error).toBe('Error obteniendo productos');
            expect(result.current.products).toEqual([]);
        });
        it('debe manejar errores HTTP usando helper mockHttpError', async ()=>{
            mockHttpError(500, 'Internal Server Error');
            const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.error).toBe('Error obteniendo productos');
            expect(result.current.products).toEqual([]);
        });
        it('debe usar respuestas predefinidas', async ()=>{
            // Usar respuesta vacía predefinida
            mockSuccess(_apimocks.mockApiResponses.products.empty);
            const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.products).toEqual([]);
            expect(result.current.pagination.total).toBe(0);
        });
        it('debe usar configuraciones mock comunes', async ()=>{
            // Usar configuración de error 404
            mockFetch.mockResolvedValueOnce(_apimocks.mockConfigurations.notFound());
            const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.error).toBe('Error obteniendo productos');
        });
    });
    describe('Hook Mocks Centralizados', ()=>{
        it('debe crear mock de useProducts con estado por defecto', ()=>{
            const mockHook = (0, _hooksmocks.createMockUseProducts)();
            expect(mockHook.products).toHaveLength(3);
            expect(mockHook.loading).toBe(false);
            expect(mockHook.error).toBeNull();
            expect(mockHook.hasProducts).toBe(true);
            expect(typeof mockHook.fetchProducts).toBe('function');
        });
        it('debe crear mock de useProducts con estado personalizado', ()=>{
            const mockHook = (0, _hooksmocks.createMockUseProducts)(_hooksmocks.mockUseProductsState.loading);
            expect(mockHook.products).toEqual([]);
            expect(mockHook.loading).toBe(true);
            expect(mockHook.error).toBeNull();
            expect(mockHook.hasProducts).toBe(false);
        });
        it('debe crear mock de useProducts con estado de error', ()=>{
            const mockHook = (0, _hooksmocks.createMockUseProducts)(_hooksmocks.mockUseProductsState.error);
            expect(mockHook.products).toEqual([]);
            expect(mockHook.loading).toBe(false);
            expect(mockHook.error).toBe('Error obteniendo productos');
            expect(mockHook.hasError).toBe(true);
        });
    });
    describe('Ventajas de Mocks Centralizados', ()=>{
        it('debe proporcionar datos consistentes entre tests', async ()=>{
            // Primer test
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            await (0, _react.waitFor)(()=>expect(result1.current.loading).toBe(false));
            // Segundo test con reset
            resetMocks();
            const { result: result2 } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            await (0, _react.waitFor)(()=>expect(result2.current.loading).toBe(false));
            // Ambos deben tener los mismos datos mock
            expect(result1.current.products).toEqual(result2.current.products);
        });
        it('debe facilitar testing de casos edge', async ()=>{
            // Caso: respuesta con delay para testing de loading states
            mockFetch.mockResolvedValueOnce(_apimocks.mockConfigurations.delayed(_apimocks.mockApiResponses.products.success, 100));
            const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            // Inicialmente debe estar cargando
            expect(result.current.loading).toBe(true);
            // Después del delay debe tener datos
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.products).toHaveLength(3);
        });
        it('debe permitir testing de múltiples llamadas API', async ()=>{
            // Primera llamada: éxito
            mockSuccess(_apimocks.mockApiResponses.products.success);
            // Segunda llamada: error
            mockError('Second call failed');
            const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
            // Primera llamada exitosa
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.products).toHaveLength(3);
            // Simular segunda llamada (ej: refresh)
            result.current.fetchProducts();
            await (0, _react.waitFor)(()=>{
                expect(result.current.loading).toBe(false);
            });
            expect(result.current.error).toBe('Error obteniendo productos');
        });
    });
    describe('Reutilización de Mocks', ()=>{
        it('debe reutilizar mocks entre diferentes hooks', ()=>{
            // Los mismos datos mock pueden usarse para diferentes hooks
            const productsData = _apimocks.mockApiResponses.products.success.data;
            expect(productsData).toHaveLength(3);
            expect(productsData[0]).toHaveProperty('name');
            expect(productsData[0]).toHaveProperty('price');
            expect(productsData[0]).toHaveProperty('category');
        });
        it('debe mantener estructura consistente de respuestas', ()=>{
            const responses = [
                _apimocks.mockApiResponses.products.success,
                _apimocks.mockApiResponses.products.empty,
                _apimocks.mockApiResponses.products.error
            ];
            responses.forEach((response)=>{
                expect(response).toHaveProperty('success');
                expect(response).toHaveProperty('data');
                expect(response).toHaveProperty('pagination');
            });
        });
    });
}); // ===================================
 // DOCUMENTACIÓN DE MEJORES PRÁCTICAS
 // ===================================
 /**
 * MEJORES PRÁCTICAS PARA USAR MOCKS CENTRALIZADOS:
 *
 * 1. SETUP CONSISTENTE:
 *    - Usar setupApiMocks() en beforeEach
 *    - Llamar resetMocks() para limpiar estado
 *
 * 2. HELPERS ESPECÍFICOS:
 *    - mockSuccess() para respuestas exitosas
 *    - mockError() para errores de red
 *    - mockHttpError() para errores HTTP específicos
 *
 * 3. DATOS REALISTAS:
 *    - Usar mockApiResponses.* para datos predefinidos
 *    - Mantener estructura consistente con API real
 *
 * 4. CASOS EDGE:
 *    - Usar mockConfigurations.* para casos especiales
 *    - Testing de loading states con delayed responses
 *
 * 5. REUTILIZACIÓN:
 *    - Importar mocks desde archivos centralizados
 *    - Evitar duplicar datos mock en cada test
 *
 * 6. MANTENIMIENTO:
 *    - Actualizar mocks cuando cambie la API
 *    - Mantener sincronizados con tipos TypeScript
 */ 

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxleGFtcGxlc1xcY2VudHJhbGl6ZWQtbW9ja3MtZXhhbXBsZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFSkVNUExPIERFIFVTTyBERSBNT0NLUyBDRU5UUkFMSVpBRE9TIC0gUElOVEVZQSBFLUNPTU1FUkNFXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFRlc3QgZGUgZWplbXBsbyBxdWUgZGVtdWVzdHJhIGVsIHVzbyBkZSBsb3MgbW9ja3MgY2VudHJhbGl6YWRvc1xuICogRXN0ZSBhcmNoaXZvIHNpcnZlIGNvbW8gcmVmZXJlbmNpYSBwYXJhIGZ1dHVyb3MgdGVzdHNcbiAqL1xuXG5pbXBvcnQgeyByZW5kZXJIb29rLCB3YWl0Rm9yIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCdcbmltcG9ydCB7IHVzZVByb2R1Y3RzIH0gZnJvbSAnQC9ob29rcy91c2VQcm9kdWN0cydcbmltcG9ydCB7IHNldHVwQXBpTW9ja3MsIG1vY2tBcGlSZXNwb25zZXMsIG1vY2tDb25maWd1cmF0aW9ucyB9IGZyb20gJy4uL19fbW9ja3NfXy9hcGktbW9ja3MnXG5pbXBvcnQgeyBjcmVhdGVNb2NrVXNlUHJvZHVjdHMsIG1vY2tVc2VQcm9kdWN0c1N0YXRlIH0gZnJvbSAnLi4vX19tb2Nrc19fL2hvb2tzLW1vY2tzJ1xuXG5kZXNjcmliZSgnRWplbXBsbyBkZSBNb2NrcyBDZW50cmFsaXphZG9zJywgKCkgPT4ge1xuICAvLyBTZXR1cCBkZSBtb2NrcyB1c2FuZG8gaGVscGVyIGNlbnRyYWxpemFkb1xuICBjb25zdCB7IG1vY2tGZXRjaCwgcmVzZXRNb2NrcywgbW9ja1N1Y2Nlc3MsIG1vY2tFcnJvciwgbW9ja0h0dHBFcnJvciB9ID0gc2V0dXBBcGlNb2NrcygpXG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgcmVzZXRNb2NrcygpXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0FQSSBNb2NrcyBDZW50cmFsaXphZG9zJywgKCkgPT4ge1xuICAgIGl0KCdkZWJlIHVzYXIgcmVzcHVlc3RhIGV4aXRvc2EgcG9yIGRlZmVjdG8nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBFbCBtb2NrIHlhIGVzdMOhIGNvbmZpZ3VyYWRvIGNvbiByZXNwdWVzdGEgZXhpdG9zYSBwb3IgZGVmZWN0b1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnByb2R1Y3RzKS50b0hhdmVMZW5ndGgoMykgLy8gbW9ja1Byb2R1Y3RzIHRpZW5lIDMgaXRlbXNcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZU51bGwoKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBtYW5lamFyIGVycm9yZXMgdXNhbmRvIGhlbHBlciBtb2NrRXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrRXJyb3IoJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQnKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgICB9KVxuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmUoJ0Vycm9yIG9idGVuaWVuZG8gcHJvZHVjdG9zJylcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5wcm9kdWN0cykudG9FcXVhbChbXSlcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgbWFuZWphciBlcnJvcmVzIEhUVFAgdXNhbmRvIGhlbHBlciBtb2NrSHR0cEVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0h0dHBFcnJvcig1MDAsICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgICB9KVxuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmUoJ0Vycm9yIG9idGVuaWVuZG8gcHJvZHVjdG9zJylcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5wcm9kdWN0cykudG9FcXVhbChbXSlcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgdXNhciByZXNwdWVzdGFzIHByZWRlZmluaWRhcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFVzYXIgcmVzcHVlc3RhIHZhY8OtYSBwcmVkZWZpbmlkYVxuICAgICAgbW9ja1N1Y2Nlc3MobW9ja0FwaVJlc3BvbnNlcy5wcm9kdWN0cy5lbXB0eSlcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnByb2R1Y3RzKS50b0VxdWFsKFtdKVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnBhZ2luYXRpb24udG90YWwpLnRvQmUoMClcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgdXNhciBjb25maWd1cmFjaW9uZXMgbW9jayBjb211bmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVXNhciBjb25maWd1cmFjacOzbiBkZSBlcnJvciA0MDRcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UobW9ja0NvbmZpZ3VyYXRpb25zLm5vdEZvdW5kKCkpXG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSlcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZSgnRXJyb3Igb2J0ZW5pZW5kbyBwcm9kdWN0b3MnKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ0hvb2sgTW9ja3MgQ2VudHJhbGl6YWRvcycsICgpID0+IHtcbiAgICBpdCgnZGViZSBjcmVhciBtb2NrIGRlIHVzZVByb2R1Y3RzIGNvbiBlc3RhZG8gcG9yIGRlZmVjdG8nLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSG9vayA9IGNyZWF0ZU1vY2tVc2VQcm9kdWN0cygpXG5cbiAgICAgIGV4cGVjdChtb2NrSG9vay5wcm9kdWN0cykudG9IYXZlTGVuZ3RoKDMpXG4gICAgICBleHBlY3QobW9ja0hvb2subG9hZGluZykudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdChtb2NrSG9vay5lcnJvcikudG9CZU51bGwoKVxuICAgICAgZXhwZWN0KG1vY2tIb29rLmhhc1Byb2R1Y3RzKS50b0JlKHRydWUpXG4gICAgICBleHBlY3QodHlwZW9mIG1vY2tIb29rLmZldGNoUHJvZHVjdHMpLnRvQmUoJ2Z1bmN0aW9uJylcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgY3JlYXIgbW9jayBkZSB1c2VQcm9kdWN0cyBjb24gZXN0YWRvIHBlcnNvbmFsaXphZG8nLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrSG9vayA9IGNyZWF0ZU1vY2tVc2VQcm9kdWN0cyhtb2NrVXNlUHJvZHVjdHNTdGF0ZS5sb2FkaW5nKVxuXG4gICAgICBleHBlY3QobW9ja0hvb2sucHJvZHVjdHMpLnRvRXF1YWwoW10pXG4gICAgICBleHBlY3QobW9ja0hvb2subG9hZGluZykudG9CZSh0cnVlKVxuICAgICAgZXhwZWN0KG1vY2tIb29rLmVycm9yKS50b0JlTnVsbCgpXG4gICAgICBleHBlY3QobW9ja0hvb2suaGFzUHJvZHVjdHMpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIGl0KCdkZWJlIGNyZWFyIG1vY2sgZGUgdXNlUHJvZHVjdHMgY29uIGVzdGFkbyBkZSBlcnJvcicsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tIb29rID0gY3JlYXRlTW9ja1VzZVByb2R1Y3RzKG1vY2tVc2VQcm9kdWN0c1N0YXRlLmVycm9yKVxuXG4gICAgICBleHBlY3QobW9ja0hvb2sucHJvZHVjdHMpLnRvRXF1YWwoW10pXG4gICAgICBleHBlY3QobW9ja0hvb2subG9hZGluZykudG9CZShmYWxzZSlcbiAgICAgIGV4cGVjdChtb2NrSG9vay5lcnJvcikudG9CZSgnRXJyb3Igb2J0ZW5pZW5kbyBwcm9kdWN0b3MnKVxuICAgICAgZXhwZWN0KG1vY2tIb29rLmhhc0Vycm9yKS50b0JlKHRydWUpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnVmVudGFqYXMgZGUgTW9ja3MgQ2VudHJhbGl6YWRvcycsICgpID0+IHtcbiAgICBpdCgnZGViZSBwcm9wb3JjaW9uYXIgZGF0b3MgY29uc2lzdGVudGVzIGVudHJlIHRlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gUHJpbWVyIHRlc3RcbiAgICAgIGNvbnN0IHsgcmVzdWx0OiByZXN1bHQxIH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IGV4cGVjdChyZXN1bHQxLmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSkpXG5cbiAgICAgIC8vIFNlZ3VuZG8gdGVzdCBjb24gcmVzZXRcbiAgICAgIHJlc2V0TW9ja3MoKVxuICAgICAgY29uc3QgeyByZXN1bHQ6IHJlc3VsdDIgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4gZXhwZWN0KHJlc3VsdDIuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKSlcblxuICAgICAgLy8gQW1ib3MgZGViZW4gdGVuZXIgbG9zIG1pc21vcyBkYXRvcyBtb2NrXG4gICAgICBleHBlY3QocmVzdWx0MS5jdXJyZW50LnByb2R1Y3RzKS50b0VxdWFsKHJlc3VsdDIuY3VycmVudC5wcm9kdWN0cylcbiAgICB9KVxuXG4gICAgaXQoJ2RlYmUgZmFjaWxpdGFyIHRlc3RpbmcgZGUgY2Fzb3MgZWRnZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENhc286IHJlc3B1ZXN0YSBjb24gZGVsYXkgcGFyYSB0ZXN0aW5nIGRlIGxvYWRpbmcgc3RhdGVzXG4gICAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKFxuICAgICAgICBtb2NrQ29uZmlndXJhdGlvbnMuZGVsYXllZChtb2NrQXBpUmVzcG9uc2VzLnByb2R1Y3RzLnN1Y2Nlc3MsIDEwMClcbiAgICAgIClcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgICAgLy8gSW5pY2lhbG1lbnRlIGRlYmUgZXN0YXIgY2FyZ2FuZG9cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKHRydWUpXG5cbiAgICAgIC8vIERlc3B1w6lzIGRlbCBkZWxheSBkZWJlIHRlbmVyIGRhdG9zXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgICB9KVxuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucHJvZHVjdHMpLnRvSGF2ZUxlbmd0aCgzKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBwZXJtaXRpciB0ZXN0aW5nIGRlIG3Dumx0aXBsZXMgbGxhbWFkYXMgQVBJJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gUHJpbWVyYSBsbGFtYWRhOiDDqXhpdG9cbiAgICAgIG1vY2tTdWNjZXNzKG1vY2tBcGlSZXNwb25zZXMucHJvZHVjdHMuc3VjY2VzcylcblxuICAgICAgLy8gU2VndW5kYSBsbGFtYWRhOiBlcnJvclxuICAgICAgbW9ja0Vycm9yKCdTZWNvbmQgY2FsbCBmYWlsZWQnKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgICAvLyBQcmltZXJhIGxsYW1hZGEgZXhpdG9zYVxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgICAgfSlcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5wcm9kdWN0cykudG9IYXZlTGVuZ3RoKDMpXG5cbiAgICAgIC8vIFNpbXVsYXIgc2VndW5kYSBsbGFtYWRhIChlajogcmVmcmVzaClcbiAgICAgIHJlc3VsdC5jdXJyZW50LmZldGNoUHJvZHVjdHMoKVxuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgICB9KVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlKCdFcnJvciBvYnRlbmllbmRvIHByb2R1Y3RvcycpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnUmV1dGlsaXphY2nDs24gZGUgTW9ja3MnLCAoKSA9PiB7XG4gICAgaXQoJ2RlYmUgcmV1dGlsaXphciBtb2NrcyBlbnRyZSBkaWZlcmVudGVzIGhvb2tzJywgKCkgPT4ge1xuICAgICAgLy8gTG9zIG1pc21vcyBkYXRvcyBtb2NrIHB1ZWRlbiB1c2Fyc2UgcGFyYSBkaWZlcmVudGVzIGhvb2tzXG4gICAgICBjb25zdCBwcm9kdWN0c0RhdGEgPSBtb2NrQXBpUmVzcG9uc2VzLnByb2R1Y3RzLnN1Y2Nlc3MuZGF0YVxuXG4gICAgICBleHBlY3QocHJvZHVjdHNEYXRhKS50b0hhdmVMZW5ndGgoMylcbiAgICAgIGV4cGVjdChwcm9kdWN0c0RhdGFbMF0pLnRvSGF2ZVByb3BlcnR5KCduYW1lJylcbiAgICAgIGV4cGVjdChwcm9kdWN0c0RhdGFbMF0pLnRvSGF2ZVByb3BlcnR5KCdwcmljZScpXG4gICAgICBleHBlY3QocHJvZHVjdHNEYXRhWzBdKS50b0hhdmVQcm9wZXJ0eSgnY2F0ZWdvcnknKVxuICAgIH0pXG5cbiAgICBpdCgnZGViZSBtYW50ZW5lciBlc3RydWN0dXJhIGNvbnNpc3RlbnRlIGRlIHJlc3B1ZXN0YXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZXMgPSBbXG4gICAgICAgIG1vY2tBcGlSZXNwb25zZXMucHJvZHVjdHMuc3VjY2VzcyxcbiAgICAgICAgbW9ja0FwaVJlc3BvbnNlcy5wcm9kdWN0cy5lbXB0eSxcbiAgICAgICAgbW9ja0FwaVJlc3BvbnNlcy5wcm9kdWN0cy5lcnJvcixcbiAgICAgIF1cblxuICAgICAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgICBleHBlY3QocmVzcG9uc2UpLnRvSGF2ZVByb3BlcnR5KCdzdWNjZXNzJylcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlKS50b0hhdmVQcm9wZXJ0eSgnZGF0YScpXG4gICAgICAgIGV4cGVjdChyZXNwb25zZSkudG9IYXZlUHJvcGVydHkoJ3BhZ2luYXRpb24nKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufSlcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERPQ1VNRU5UQUNJw5NOIERFIE1FSk9SRVMgUFLDgUNUSUNBU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBNRUpPUkVTIFBSw4FDVElDQVMgUEFSQSBVU0FSIE1PQ0tTIENFTlRSQUxJWkFET1M6XG4gKlxuICogMS4gU0VUVVAgQ09OU0lTVEVOVEU6XG4gKiAgICAtIFVzYXIgc2V0dXBBcGlNb2NrcygpIGVuIGJlZm9yZUVhY2hcbiAqICAgIC0gTGxhbWFyIHJlc2V0TW9ja3MoKSBwYXJhIGxpbXBpYXIgZXN0YWRvXG4gKlxuICogMi4gSEVMUEVSUyBFU1BFQ8ONRklDT1M6XG4gKiAgICAtIG1vY2tTdWNjZXNzKCkgcGFyYSByZXNwdWVzdGFzIGV4aXRvc2FzXG4gKiAgICAtIG1vY2tFcnJvcigpIHBhcmEgZXJyb3JlcyBkZSByZWRcbiAqICAgIC0gbW9ja0h0dHBFcnJvcigpIHBhcmEgZXJyb3JlcyBIVFRQIGVzcGVjw61maWNvc1xuICpcbiAqIDMuIERBVE9TIFJFQUxJU1RBUzpcbiAqICAgIC0gVXNhciBtb2NrQXBpUmVzcG9uc2VzLiogcGFyYSBkYXRvcyBwcmVkZWZpbmlkb3NcbiAqICAgIC0gTWFudGVuZXIgZXN0cnVjdHVyYSBjb25zaXN0ZW50ZSBjb24gQVBJIHJlYWxcbiAqXG4gKiA0LiBDQVNPUyBFREdFOlxuICogICAgLSBVc2FyIG1vY2tDb25maWd1cmF0aW9ucy4qIHBhcmEgY2Fzb3MgZXNwZWNpYWxlc1xuICogICAgLSBUZXN0aW5nIGRlIGxvYWRpbmcgc3RhdGVzIGNvbiBkZWxheWVkIHJlc3BvbnNlc1xuICpcbiAqIDUuIFJFVVRJTElaQUNJw5NOOlxuICogICAgLSBJbXBvcnRhciBtb2NrcyBkZXNkZSBhcmNoaXZvcyBjZW50cmFsaXphZG9zXG4gKiAgICAtIEV2aXRhciBkdXBsaWNhciBkYXRvcyBtb2NrIGVuIGNhZGEgdGVzdFxuICpcbiAqIDYuIE1BTlRFTklNSUVOVE86XG4gKiAgICAtIEFjdHVhbGl6YXIgbW9ja3MgY3VhbmRvIGNhbWJpZSBsYSBBUElcbiAqICAgIC0gTWFudGVuZXIgc2luY3Jvbml6YWRvcyBjb24gdGlwb3MgVHlwZVNjcmlwdFxuICovXG4iXSwibmFtZXMiOlsiZGVzY3JpYmUiLCJtb2NrRmV0Y2giLCJyZXNldE1vY2tzIiwibW9ja1N1Y2Nlc3MiLCJtb2NrRXJyb3IiLCJtb2NrSHR0cEVycm9yIiwic2V0dXBBcGlNb2NrcyIsImJlZm9yZUVhY2giLCJpdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VQcm9kdWN0cyIsIndhaXRGb3IiLCJleHBlY3QiLCJjdXJyZW50IiwibG9hZGluZyIsInRvQmUiLCJwcm9kdWN0cyIsInRvSGF2ZUxlbmd0aCIsImVycm9yIiwidG9CZU51bGwiLCJ0b0VxdWFsIiwibW9ja0FwaVJlc3BvbnNlcyIsImVtcHR5IiwicGFnaW5hdGlvbiIsInRvdGFsIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwibW9ja0NvbmZpZ3VyYXRpb25zIiwibm90Rm91bmQiLCJtb2NrSG9vayIsImNyZWF0ZU1vY2tVc2VQcm9kdWN0cyIsImhhc1Byb2R1Y3RzIiwiZmV0Y2hQcm9kdWN0cyIsIm1vY2tVc2VQcm9kdWN0c1N0YXRlIiwiaGFzRXJyb3IiLCJyZXN1bHQxIiwicmVzdWx0MiIsImRlbGF5ZWQiLCJzdWNjZXNzIiwicHJvZHVjdHNEYXRhIiwiZGF0YSIsInRvSGF2ZVByb3BlcnR5IiwicmVzcG9uc2VzIiwiZm9yRWFjaCIsInJlc3BvbnNlIl0sIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0M7QUFDdEMsNkRBQTZEO0FBQzdELHNDQUFzQztBQUV0Qzs7O0NBR0M7Ozs7dUJBRW1DOzZCQUNSOzBCQUN3Qzs0QkFDUjtBQUU1REEsU0FBUyxrQ0FBa0M7SUFDekMsNENBQTRDO0lBQzVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUUsR0FBR0MsSUFBQUEsdUJBQWE7SUFFdEZDLFdBQVc7UUFDVEw7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