1cf11930b5f7437201081d44ea0e9806
// ===================================
// PINTEYA E-COMMERCE - METRICS TESTS
// ===================================
"use strict";
// Mock Redis
jest.mock('@/lib/redis', ()=>({
        redisCache: {
            incr: jest.fn(),
            expire: jest.fn(),
            get: jest.fn(),
            client: {
                lpush: jest.fn(),
                ltrim: jest.fn(),
                expire: jest.fn(),
                lrange: jest.fn()
            }
        }
    }));
// Mock logger
jest.mock('@/lib/enterprise/logger', ()=>({
        logger: {
            debug: jest.fn(),
            info: jest.fn(),
            warn: jest.fn(),
            error: jest.fn()
        },
        LogLevel: {
            DEBUG: 'debug',
            INFO: 'info',
            WARN: 'warn',
            ERROR: 'error'
        },
        LogCategory: {
            SYSTEM: 'system'
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _metrics = require("../../lib/enterprise/metrics");
describe('MetricsCollector', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Singleton Pattern', ()=>{
        it('should return the same instance', ()=>{
            const instance1 = _metrics.MetricsCollector.getInstance();
            const instance2 = _metrics.MetricsCollector.getInstance();
            expect(instance1).toBe(instance2);
            expect(instance1).toBe(_metrics.metricsCollector);
        });
    });
    describe('recordRequest', ()=>{
        it('should record successful request metrics', async ()=>{
            const { redisCache } = require('@/lib/redis');
            await _metrics.metricsCollector.recordRequest('create-preference', 'POST', 200, 1500, {
                clientIP: '192.168.1.1'
            });
            // Verificar que se registraron las métricas correctas
            expect(redisCache.incr).toHaveBeenCalledWith(expect.stringContaining('metrics:create-preference:POST:requests:total'));
            expect(redisCache.incr).toHaveBeenCalledWith(expect.stringContaining('metrics:create-preference:POST:requests:success'));
            expect(redisCache.client.lpush).toHaveBeenCalledWith(expect.stringContaining('metrics:create-preference:POST:response_time'), '1500');
        });
        it('should record error request metrics', async ()=>{
            const { redisCache } = require('@/lib/redis');
            await _metrics.metricsCollector.recordRequest('create-preference', 'POST', 500, 2000);
            expect(redisCache.incr).toHaveBeenCalledWith(expect.stringContaining('metrics:create-preference:POST:requests:total'));
            expect(redisCache.incr).toHaveBeenCalledWith(expect.stringContaining('metrics:create-preference:POST:requests:error'));
            expect(redisCache.incr).toHaveBeenCalledWith(expect.stringContaining('metrics:create-preference:POST:errors:5xx'));
        });
        it('should record rate limited request metrics', async ()=>{
            const { redisCache } = require('@/lib/redis');
            await _metrics.metricsCollector.recordRequest('webhook', 'POST', 429, 500);
            expect(redisCache.incr).toHaveBeenCalledWith(expect.stringContaining('metrics:webhook:POST:requests:total'));
            expect(redisCache.incr).toHaveBeenCalledWith(expect.stringContaining('metrics:webhook:POST:requests:rate_limited'));
        });
        it('should categorize 4xx errors correctly', async ()=>{
            const { redisCache } = require('@/lib/redis');
            await _metrics.metricsCollector.recordRequest('create-preference', 'POST', 400, 300);
            expect(redisCache.incr).toHaveBeenCalledWith(expect.stringContaining('metrics:create-preference:POST:errors:4xx'));
        });
        it('should handle errors gracefully', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const { logger } = require('@/lib/enterprise/logger');
            redisCache.incr.mockRejectedValue(new Error('Redis error'));
            // No debería lanzar error
            await expect(_metrics.metricsCollector.recordRequest('test-endpoint', 'GET', 200, 1000)).resolves.not.toThrow();
            expect(logger.error).toHaveBeenCalled();
        });
    });
    describe('recordRetry', ()=>{
        it('should record successful retry metrics without errors', async ()=>{
            await expect(_metrics.metricsCollector.recordRetry('createPaymentPreference', 3, true, 5000)).resolves.not.toThrow();
        });
        it('should record failed retry metrics without errors', async ()=>{
            await expect(_metrics.metricsCollector.recordRetry('getPaymentInfo', 2, false, 3000)).resolves.not.toThrow();
        });
    });
    describe('recordRateLimit', ()=>{
        it('should record rate limit metrics without errors', async ()=>{
            await expect(_metrics.metricsCollector.recordRateLimit('create-preference', false, 8, 10)).resolves.not.toThrow();
        });
        it('should record blocked rate limit metrics without errors', async ()=>{
            await expect(_metrics.metricsCollector.recordRateLimit('webhook', true, 0, 100)).resolves.not.toThrow();
        });
    });
    describe('getApiMetrics', ()=>{
        it('should return empty metrics when no data available', async ()=>{
            const { redisCache } = require('@/lib/redis');
            // Mock empty responses
            redisCache.get.mockResolvedValue(null);
            redisCache.client.lrange.mockResolvedValue([]);
            const metrics = await _metrics.metricsCollector.getApiMetrics('test-endpoint', 'GET', 1);
            expect(metrics).toEqual({
                requests: {
                    total: 0,
                    success: 0,
                    error: 0,
                    rate_limited: 0
                },
                response_times: {
                    count: 0,
                    sum: 0,
                    avg: 0,
                    min: 0,
                    max: 0,
                    p95: 0,
                    p99: 0
                },
                error_rates: {
                    '4xx': 0,
                    '5xx': 0,
                    network: 0,
                    timeout: 0
                },
                retry_stats: {
                    total_retries: 0,
                    successful_retries: 0,
                    failed_retries: 0,
                    avg_attempts: 0
                }
            });
        });
        it('should aggregate metrics correctly', async ()=>{
            const { redisCache } = require('@/lib/redis');
            // Mock counter data
            redisCache.get.mockImplementation((key)=>{
                if (key.includes('total')) {
                    return '100';
                }
                if (key.includes('success')) {
                    return '95';
                }
                if (key.includes('error')) {
                    return '5';
                }
                return '0';
            });
            // Mock response time data
            redisCache.client.lrange.mockResolvedValue([
                '1000',
                '1500',
                '2000',
                '800',
                '1200'
            ]);
            const metrics = await _metrics.metricsCollector.getApiMetrics('test-endpoint', 'GET', 1);
            expect(metrics.requests.total).toBeGreaterThan(0);
            expect(metrics.requests.success).toBeGreaterThan(0);
            expect(metrics.response_times.count).toBeGreaterThan(0);
            expect(metrics.response_times.avg).toBeGreaterThan(0);
        });
        it('should handle errors gracefully and return empty metrics', async ()=>{
            const { redisCache } = require('@/lib/redis');
            const { logger } = require('@/lib/enterprise/logger');
            redisCache.get.mockRejectedValue(new Error('Redis error'));
            const metrics = await _metrics.metricsCollector.getApiMetrics('test-endpoint', 'GET', 1);
            expect(logger.error).toHaveBeenCalled();
            expect(metrics.requests.total).toBe(0);
        });
    });
    describe('Window Key Generation', ()=>{
        it('should generate consistent window keys', ()=>{
            const collector = new _metrics.MetricsCollector();
            const timestamp1 = 1640995200000 // 2022-01-01 00:00:00
            ;
            const timestamp2 = 1640995260000 // 2022-01-01 00:01:00 (same window)
            ;
            const timestamp3 = 1640995500000 // 2022-01-01 00:05:00 (next window)
            ;
            const key1 = collector.getWindowKey('test:metric', timestamp1);
            const key2 = collector.getWindowKey('test:metric', timestamp2);
            const key3 = collector.getWindowKey('test:metric', timestamp3);
            expect(key1).toBe(key2); // Same 5-minute window
            expect(key1).not.toBe(key3); // Different window
        });
    });
    describe('Value Statistics', ()=>{
        it('should calculate percentiles correctly', async ()=>{
            const collector = _metrics.metricsCollector;
            const { redisCache } = require('@/lib/redis');
            // Mock response times: [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]
            const values = Array.from({
                length: 10
            }, (_, i)=>((i + 1) * 100).toString());
            // Mock para que solo devuelva valores una vez
            redisCache.client.lrange.mockResolvedValueOnce(values).mockResolvedValue([]);
            const stats = await collector.getValueStats('test:response_time', 0, Date.now());
            expect(stats.count).toBe(10);
            expect(stats.min).toBe(100);
            expect(stats.max).toBe(1000);
            expect(stats.avg).toBe(550);
            expect(stats.p95).toBeGreaterThan(900); // 95th percentile
            expect(stats.p99).toBeGreaterThan(950); // 99th percentile
        });
        it('should handle empty value arrays', async ()=>{
            const collector = _metrics.metricsCollector;
            const { redisCache } = require('@/lib/redis');
            redisCache.client.lrange.mockResolvedValue([]);
            const stats = await collector.getValueStats('test:response_time', 0, Date.now());
            expect(stats).toEqual({
                count: 0,
                sum: 0,
                avg: 0,
                min: 0,
                max: 0,
                p95: 0,
                p99: 0
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxsaWJcXG1ldHJpY3MudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUElOVEVZQSBFLUNPTU1FUkNFIC0gTUVUUklDUyBURVNUU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuaW1wb3J0IHsgTWV0cmljc0NvbGxlY3RvciwgbWV0cmljc0NvbGxlY3RvciB9IGZyb20gJ0AvbGliL2VudGVycHJpc2UvbWV0cmljcydcblxuLy8gTW9jayBSZWRpc1xuamVzdC5tb2NrKCdAL2xpYi9yZWRpcycsICgpID0+ICh7XG4gIHJlZGlzQ2FjaGU6IHtcbiAgICBpbmNyOiBqZXN0LmZuKCksXG4gICAgZXhwaXJlOiBqZXN0LmZuKCksXG4gICAgZ2V0OiBqZXN0LmZuKCksXG4gICAgY2xpZW50OiB7XG4gICAgICBscHVzaDogamVzdC5mbigpLFxuICAgICAgbHRyaW06IGplc3QuZm4oKSxcbiAgICAgIGV4cGlyZTogamVzdC5mbigpLFxuICAgICAgbHJhbmdlOiBqZXN0LmZuKCksXG4gICAgfSxcbiAgfSxcbn0pKVxuXG4vLyBNb2NrIGxvZ2dlclxuamVzdC5tb2NrKCdAL2xpYi9lbnRlcnByaXNlL2xvZ2dlcicsICgpID0+ICh7XG4gIGxvZ2dlcjoge1xuICAgIGRlYnVnOiBqZXN0LmZuKCksXG4gICAgaW5mbzogamVzdC5mbigpLFxuICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICBlcnJvcjogamVzdC5mbigpLFxuICB9LFxuICBMb2dMZXZlbDoge1xuICAgIERFQlVHOiAnZGVidWcnLFxuICAgIElORk86ICdpbmZvJyxcbiAgICBXQVJOOiAnd2FybicsXG4gICAgRVJST1I6ICdlcnJvcicsXG4gIH0sXG4gIExvZ0NhdGVnb3J5OiB7XG4gICAgU1lTVEVNOiAnc3lzdGVtJyxcbiAgfSxcbn0pKVxuXG5kZXNjcmliZSgnTWV0cmljc0NvbGxlY3RvcicsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgfSlcblxuICBkZXNjcmliZSgnU2luZ2xldG9uIFBhdHRlcm4nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIHNhbWUgaW5zdGFuY2UnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTEgPSBNZXRyaWNzQ29sbGVjdG9yLmdldEluc3RhbmNlKClcbiAgICAgIGNvbnN0IGluc3RhbmNlMiA9IE1ldHJpY3NDb2xsZWN0b3IuZ2V0SW5zdGFuY2UoKVxuXG4gICAgICBleHBlY3QoaW5zdGFuY2UxKS50b0JlKGluc3RhbmNlMilcbiAgICAgIGV4cGVjdChpbnN0YW5jZTEpLnRvQmUobWV0cmljc0NvbGxlY3RvcilcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdyZWNvcmRSZXF1ZXN0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVjb3JkIHN1Y2Nlc3NmdWwgcmVxdWVzdCBtZXRyaWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpXG5cbiAgICAgIGF3YWl0IG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkUmVxdWVzdCgnY3JlYXRlLXByZWZlcmVuY2UnLCAnUE9TVCcsIDIwMCwgMTUwMCwge1xuICAgICAgICBjbGllbnRJUDogJzE5Mi4xNjguMS4xJyxcbiAgICAgIH0pXG5cbiAgICAgIC8vIFZlcmlmaWNhciBxdWUgc2UgcmVnaXN0cmFyb24gbGFzIG3DqXRyaWNhcyBjb3JyZWN0YXNcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLmluY3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnbWV0cmljczpjcmVhdGUtcHJlZmVyZW5jZTpQT1NUOnJlcXVlc3RzOnRvdGFsJylcbiAgICAgIClcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLmluY3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnbWV0cmljczpjcmVhdGUtcHJlZmVyZW5jZTpQT1NUOnJlcXVlc3RzOnN1Y2Nlc3MnKVxuICAgICAgKVxuICAgICAgZXhwZWN0KHJlZGlzQ2FjaGUuY2xpZW50LmxwdXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ21ldHJpY3M6Y3JlYXRlLXByZWZlcmVuY2U6UE9TVDpyZXNwb25zZV90aW1lJyksXG4gICAgICAgICcxNTAwJ1xuICAgICAgKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlY29yZCBlcnJvciByZXF1ZXN0IG1ldHJpY3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcblxuICAgICAgYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRSZXF1ZXN0KCdjcmVhdGUtcHJlZmVyZW5jZScsICdQT1NUJywgNTAwLCAyMDAwKVxuXG4gICAgICBleHBlY3QocmVkaXNDYWNoZS5pbmNyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ21ldHJpY3M6Y3JlYXRlLXByZWZlcmVuY2U6UE9TVDpyZXF1ZXN0czp0b3RhbCcpXG4gICAgICApXG4gICAgICBleHBlY3QocmVkaXNDYWNoZS5pbmNyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ21ldHJpY3M6Y3JlYXRlLXByZWZlcmVuY2U6UE9TVDpyZXF1ZXN0czplcnJvcicpXG4gICAgICApXG4gICAgICBleHBlY3QocmVkaXNDYWNoZS5pbmNyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ21ldHJpY3M6Y3JlYXRlLXByZWZlcmVuY2U6UE9TVDplcnJvcnM6NXh4JylcbiAgICAgIClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZWNvcmQgcmF0ZSBsaW1pdGVkIHJlcXVlc3QgbWV0cmljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKVxuXG4gICAgICBhd2FpdCBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZFJlcXVlc3QoJ3dlYmhvb2snLCAnUE9TVCcsIDQyOSwgNTAwKVxuXG4gICAgICBleHBlY3QocmVkaXNDYWNoZS5pbmNyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ21ldHJpY3M6d2ViaG9vazpQT1NUOnJlcXVlc3RzOnRvdGFsJylcbiAgICAgIClcbiAgICAgIGV4cGVjdChyZWRpc0NhY2hlLmluY3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnbWV0cmljczp3ZWJob29rOlBPU1Q6cmVxdWVzdHM6cmF0ZV9saW1pdGVkJylcbiAgICAgIClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjYXRlZ29yaXplIDR4eCBlcnJvcnMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpXG5cbiAgICAgIGF3YWl0IG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkUmVxdWVzdCgnY3JlYXRlLXByZWZlcmVuY2UnLCAnUE9TVCcsIDQwMCwgMzAwKVxuXG4gICAgICBleHBlY3QocmVkaXNDYWNoZS5pbmNyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ21ldHJpY3M6Y3JlYXRlLXByZWZlcmVuY2U6UE9TVDplcnJvcnM6NHh4JylcbiAgICAgIClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcbiAgICAgIGNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKCdAL2xpYi9lbnRlcnByaXNlL2xvZ2dlcicpXG5cbiAgICAgIHJlZGlzQ2FjaGUuaW5jci5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlZGlzIGVycm9yJykpXG5cbiAgICAgIC8vIE5vIGRlYmVyw61hIGxhbnphciBlcnJvclxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZFJlcXVlc3QoJ3Rlc3QtZW5kcG9pbnQnLCAnR0VUJywgMjAwLCAxMDAwKVxuICAgICAgKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpXG5cbiAgICAgIGV4cGVjdChsb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ3JlY29yZFJldHJ5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVjb3JkIHN1Y2Nlc3NmdWwgcmV0cnkgbWV0cmljcyB3aXRob3V0IGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRSZXRyeSgnY3JlYXRlUGF5bWVudFByZWZlcmVuY2UnLCAzLCB0cnVlLCA1MDAwKVxuICAgICAgKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmVjb3JkIGZhaWxlZCByZXRyeSBtZXRyaWNzIHdpdGhvdXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICBtZXRyaWNzQ29sbGVjdG9yLnJlY29yZFJldHJ5KCdnZXRQYXltZW50SW5mbycsIDIsIGZhbHNlLCAzMDAwKVxuICAgICAgKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgncmVjb3JkUmF0ZUxpbWl0JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmVjb3JkIHJhdGUgbGltaXQgbWV0cmljcyB3aXRob3V0IGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgbWV0cmljc0NvbGxlY3Rvci5yZWNvcmRSYXRlTGltaXQoJ2NyZWF0ZS1wcmVmZXJlbmNlJywgZmFsc2UsIDgsIDEwKVxuICAgICAgKS5yZXNvbHZlcy5ub3QudG9UaHJvdygpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmVjb3JkIGJsb2NrZWQgcmF0ZSBsaW1pdCBtZXRyaWNzIHdpdGhvdXQgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgZXhwZWN0KG1ldHJpY3NDb2xsZWN0b3IucmVjb3JkUmF0ZUxpbWl0KCd3ZWJob29rJywgdHJ1ZSwgMCwgMTAwKSkucmVzb2x2ZXMubm90LnRvVGhyb3coKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ2dldEFwaU1ldHJpY3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZW1wdHkgbWV0cmljcyB3aGVuIG5vIGRhdGEgYXZhaWxhYmxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpXG5cbiAgICAgIC8vIE1vY2sgZW1wdHkgcmVzcG9uc2VzXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKVxuICAgICAgcmVkaXNDYWNoZS5jbGllbnQubHJhbmdlLm1vY2tSZXNvbHZlZFZhbHVlKFtdKVxuXG4gICAgICBjb25zdCBtZXRyaWNzID0gYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5nZXRBcGlNZXRyaWNzKCd0ZXN0LWVuZHBvaW50JywgJ0dFVCcsIDEpXG5cbiAgICAgIGV4cGVjdChtZXRyaWNzKS50b0VxdWFsKHtcbiAgICAgICAgcmVxdWVzdHM6IHsgdG90YWw6IDAsIHN1Y2Nlc3M6IDAsIGVycm9yOiAwLCByYXRlX2xpbWl0ZWQ6IDAgfSxcbiAgICAgICAgcmVzcG9uc2VfdGltZXM6IHsgY291bnQ6IDAsIHN1bTogMCwgYXZnOiAwLCBtaW46IDAsIG1heDogMCwgcDk1OiAwLCBwOTk6IDAgfSxcbiAgICAgICAgZXJyb3JfcmF0ZXM6IHsgJzR4eCc6IDAsICc1eHgnOiAwLCBuZXR3b3JrOiAwLCB0aW1lb3V0OiAwIH0sXG4gICAgICAgIHJldHJ5X3N0YXRzOiB7XG4gICAgICAgICAgdG90YWxfcmV0cmllczogMCxcbiAgICAgICAgICBzdWNjZXNzZnVsX3JldHJpZXM6IDAsXG4gICAgICAgICAgZmFpbGVkX3JldHJpZXM6IDAsXG4gICAgICAgICAgYXZnX2F0dGVtcHRzOiAwLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBhZ2dyZWdhdGUgbWV0cmljcyBjb3JyZWN0bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlZGlzQ2FjaGUgfSA9IHJlcXVpcmUoJ0AvbGliL3JlZGlzJylcblxuICAgICAgLy8gTW9jayBjb3VudGVyIGRhdGFcbiAgICAgIHJlZGlzQ2FjaGUuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbihrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCd0b3RhbCcpKSB7XG4gICAgICAgICAgcmV0dXJuICcxMDAnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleS5pbmNsdWRlcygnc3VjY2VzcycpKSB7XG4gICAgICAgICAgcmV0dXJuICc5NSdcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCdlcnJvcicpKSB7XG4gICAgICAgICAgcmV0dXJuICc1J1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnMCdcbiAgICAgIH0pXG5cbiAgICAgIC8vIE1vY2sgcmVzcG9uc2UgdGltZSBkYXRhXG4gICAgICByZWRpc0NhY2hlLmNsaWVudC5scmFuZ2UubW9ja1Jlc29sdmVkVmFsdWUoWycxMDAwJywgJzE1MDAnLCAnMjAwMCcsICc4MDAnLCAnMTIwMCddKVxuXG4gICAgICBjb25zdCBtZXRyaWNzID0gYXdhaXQgbWV0cmljc0NvbGxlY3Rvci5nZXRBcGlNZXRyaWNzKCd0ZXN0LWVuZHBvaW50JywgJ0dFVCcsIDEpXG5cbiAgICAgIGV4cGVjdChtZXRyaWNzLnJlcXVlc3RzLnRvdGFsKS50b0JlR3JlYXRlclRoYW4oMClcbiAgICAgIGV4cGVjdChtZXRyaWNzLnJlcXVlc3RzLnN1Y2Nlc3MpLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgICAgZXhwZWN0KG1ldHJpY3MucmVzcG9uc2VfdGltZXMuY291bnQpLnRvQmVHcmVhdGVyVGhhbigwKVxuICAgICAgZXhwZWN0KG1ldHJpY3MucmVzcG9uc2VfdGltZXMuYXZnKS50b0JlR3JlYXRlclRoYW4oMClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHkgYW5kIHJldHVybiBlbXB0eSBtZXRyaWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZWRpc0NhY2hlIH0gPSByZXF1aXJlKCdAL2xpYi9yZWRpcycpXG4gICAgICBjb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnQC9saWIvZW50ZXJwcmlzZS9sb2dnZXInKVxuXG4gICAgICByZWRpc0NhY2hlLmdldC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlZGlzIGVycm9yJykpXG5cbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBhd2FpdCBtZXRyaWNzQ29sbGVjdG9yLmdldEFwaU1ldHJpY3MoJ3Rlc3QtZW5kcG9pbnQnLCAnR0VUJywgMSlcblxuICAgICAgZXhwZWN0KGxvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3QobWV0cmljcy5yZXF1ZXN0cy50b3RhbCkudG9CZSgwKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1dpbmRvdyBLZXkgR2VuZXJhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIGNvbnNpc3RlbnQgd2luZG93IGtleXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb2xsZWN0b3IgPSBuZXcgKE1ldHJpY3NDb2xsZWN0b3IgYXMgYW55KSgpXG4gICAgICBjb25zdCB0aW1lc3RhbXAxID0gMTY0MDk5NTIwMDAwMCAvLyAyMDIyLTAxLTAxIDAwOjAwOjAwXG4gICAgICBjb25zdCB0aW1lc3RhbXAyID0gMTY0MDk5NTI2MDAwMCAvLyAyMDIyLTAxLTAxIDAwOjAxOjAwIChzYW1lIHdpbmRvdylcbiAgICAgIGNvbnN0IHRpbWVzdGFtcDMgPSAxNjQwOTk1NTAwMDAwIC8vIDIwMjItMDEtMDEgMDA6MDU6MDAgKG5leHQgd2luZG93KVxuXG4gICAgICBjb25zdCBrZXkxID0gY29sbGVjdG9yLmdldFdpbmRvd0tleSgndGVzdDptZXRyaWMnLCB0aW1lc3RhbXAxKVxuICAgICAgY29uc3Qga2V5MiA9IGNvbGxlY3Rvci5nZXRXaW5kb3dLZXkoJ3Rlc3Q6bWV0cmljJywgdGltZXN0YW1wMilcbiAgICAgIGNvbnN0IGtleTMgPSBjb2xsZWN0b3IuZ2V0V2luZG93S2V5KCd0ZXN0Om1ldHJpYycsIHRpbWVzdGFtcDMpXG5cbiAgICAgIGV4cGVjdChrZXkxKS50b0JlKGtleTIpIC8vIFNhbWUgNS1taW51dGUgd2luZG93XG4gICAgICBleHBlY3Qoa2V5MSkubm90LnRvQmUoa2V5MykgLy8gRGlmZmVyZW50IHdpbmRvd1xuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ1ZhbHVlIFN0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgcGVyY2VudGlsZXMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29sbGVjdG9yID0gbWV0cmljc0NvbGxlY3RvciBhcyBhbnlcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKVxuXG4gICAgICAvLyBNb2NrIHJlc3BvbnNlIHRpbWVzOiBbMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMCwgMTAwMF1cbiAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwIH0sIChfLCBpKSA9PiAoKGkgKyAxKSAqIDEwMCkudG9TdHJpbmcoKSlcblxuICAgICAgLy8gTW9jayBwYXJhIHF1ZSBzb2xvIGRldnVlbHZhIHZhbG9yZXMgdW5hIHZlelxuICAgICAgcmVkaXNDYWNoZS5jbGllbnQubHJhbmdlLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh2YWx1ZXMpLm1vY2tSZXNvbHZlZFZhbHVlKFtdKVxuXG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGNvbGxlY3Rvci5nZXRWYWx1ZVN0YXRzKCd0ZXN0OnJlc3BvbnNlX3RpbWUnLCAwLCBEYXRlLm5vdygpKVxuXG4gICAgICBleHBlY3Qoc3RhdHMuY291bnQpLnRvQmUoMTApXG4gICAgICBleHBlY3Qoc3RhdHMubWluKS50b0JlKDEwMClcbiAgICAgIGV4cGVjdChzdGF0cy5tYXgpLnRvQmUoMTAwMClcbiAgICAgIGV4cGVjdChzdGF0cy5hdmcpLnRvQmUoNTUwKVxuICAgICAgZXhwZWN0KHN0YXRzLnA5NSkudG9CZUdyZWF0ZXJUaGFuKDkwMCkgLy8gOTV0aCBwZXJjZW50aWxlXG4gICAgICBleHBlY3Qoc3RhdHMucDk5KS50b0JlR3JlYXRlclRoYW4oOTUwKSAvLyA5OXRoIHBlcmNlbnRpbGVcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgdmFsdWUgYXJyYXlzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29sbGVjdG9yID0gbWV0cmljc0NvbGxlY3RvciBhcyBhbnlcbiAgICAgIGNvbnN0IHsgcmVkaXNDYWNoZSB9ID0gcmVxdWlyZSgnQC9saWIvcmVkaXMnKVxuXG4gICAgICByZWRpc0NhY2hlLmNsaWVudC5scmFuZ2UubW9ja1Jlc29sdmVkVmFsdWUoW10pXG5cbiAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgY29sbGVjdG9yLmdldFZhbHVlU3RhdHMoJ3Rlc3Q6cmVzcG9uc2VfdGltZScsIDAsIERhdGUubm93KCkpXG5cbiAgICAgIGV4cGVjdChzdGF0cykudG9FcXVhbCh7XG4gICAgICAgIGNvdW50OiAwLFxuICAgICAgICBzdW06IDAsXG4gICAgICAgIGF2ZzogMCxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDAsXG4gICAgICAgIHA5NTogMCxcbiAgICAgICAgcDk5OiAwLFxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufSlcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInJlZGlzQ2FjaGUiLCJpbmNyIiwiZm4iLCJleHBpcmUiLCJnZXQiLCJjbGllbnQiLCJscHVzaCIsImx0cmltIiwibHJhbmdlIiwibG9nZ2VyIiwiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwiTG9nTGV2ZWwiLCJERUJVRyIsIklORk8iLCJXQVJOIiwiRVJST1IiLCJMb2dDYXRlZ29yeSIsIlNZU1RFTSIsImRlc2NyaWJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImluc3RhbmNlMSIsIk1ldHJpY3NDb2xsZWN0b3IiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlMiIsImV4cGVjdCIsInRvQmUiLCJtZXRyaWNzQ29sbGVjdG9yIiwicmVxdWlyZSIsInJlY29yZFJlcXVlc3QiLCJjbGllbnRJUCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwic3RyaW5nQ29udGFpbmluZyIsIm1vY2tSZWplY3RlZFZhbHVlIiwiRXJyb3IiLCJyZXNvbHZlcyIsIm5vdCIsInRvVGhyb3ciLCJ0b0hhdmVCZWVuQ2FsbGVkIiwicmVjb3JkUmV0cnkiLCJyZWNvcmRSYXRlTGltaXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsIm1ldHJpY3MiLCJnZXRBcGlNZXRyaWNzIiwidG9FcXVhbCIsInJlcXVlc3RzIiwidG90YWwiLCJzdWNjZXNzIiwicmF0ZV9saW1pdGVkIiwicmVzcG9uc2VfdGltZXMiLCJjb3VudCIsInN1bSIsImF2ZyIsIm1pbiIsIm1heCIsInA5NSIsInA5OSIsImVycm9yX3JhdGVzIiwibmV0d29yayIsInRpbWVvdXQiLCJyZXRyeV9zdGF0cyIsInRvdGFsX3JldHJpZXMiLCJzdWNjZXNzZnVsX3JldHJpZXMiLCJmYWlsZWRfcmV0cmllcyIsImF2Z19hdHRlbXB0cyIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImtleSIsImluY2x1ZGVzIiwidG9CZUdyZWF0ZXJUaGFuIiwiY29sbGVjdG9yIiwidGltZXN0YW1wMSIsInRpbWVzdGFtcDIiLCJ0aW1lc3RhbXAzIiwia2V5MSIsImdldFdpbmRvd0tleSIsImtleTIiLCJrZXkzIiwidmFsdWVzIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJ0b1N0cmluZyIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsInN0YXRzIiwiZ2V0VmFsdWVTdGF0cyIsIkRhdGUiLCJub3ciXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckMsc0NBQXNDOztBQUl0QyxhQUFhO0FBQ2JBLEtBQUtDLElBQUksQ0FBQyxlQUFlLElBQU8sQ0FBQTtRQUM5QkMsWUFBWTtZQUNWQyxNQUFNSCxLQUFLSSxFQUFFO1lBQ2JDLFFBQVFMLEtBQUtJLEVBQUU7WUFDZkUsS0FBS04sS0FBS0ksRUFBRTtZQUNaRyxRQUFRO2dCQUNOQyxPQUFPUixLQUFLSSxFQUFFO2dCQUNkSyxPQUFPVCxLQUFLSSxFQUFFO2dCQUNkQyxRQUFRTCxLQUFLSSxFQUFFO2dCQUNmTSxRQUFRVixLQUFLSSxFQUFFO1lBQ2pCO1FBQ0Y7SUFDRixDQUFBO0FBRUEsY0FBYztBQUNkSixLQUFLQyxJQUFJLENBQUMsMkJBQTJCLElBQU8sQ0FBQTtRQUMxQ1UsUUFBUTtZQUNOQyxPQUFPWixLQUFLSSxFQUFFO1lB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