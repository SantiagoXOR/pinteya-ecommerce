a7a22ff830ec75c37f7a1c83b11bb738
/**
 * Test independiente para useProductList sin dependencias de configuración global
 * Ejecutar con: npx jest src/hooks/admin/__tests__/useProductList.standalone.test.ts --no-cache --no-coverage
 */ // Mock React hooks
"use strict";
jest.mock('react', ()=>({
        useState: mockUseState,
        useEffect: mockUseEffect
    }));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockUseState = jest.fn();
const mockUseEffect = jest.fn();
// Mock fetch
global.fetch = jest.fn();
describe('useProductList Hook - Standalone Tests', ()=>{
    let mockSetProducts;
    let mockSetIsLoading;
    let mockSetError;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock useState calls
        mockSetProducts = jest.fn();
        mockSetIsLoading = jest.fn();
        mockSetError = jest.fn();
        mockUseState.mockReturnValueOnce([
            [],
            mockSetProducts
        ]) // products state
        .mockReturnValueOnce([
            true,
            mockSetIsLoading
        ]) // isLoading state
        .mockReturnValueOnce([
            null,
            mockSetError
        ]); // error state
        // Mock useEffect to immediately call the effect
        mockUseEffect.mockImplementation((effect)=>{
            effect();
        });
    });
    afterEach(()=>{
        jest.restoreAllMocks();
    });
    it('should initialize with correct default state', async ()=>{
        // Mock successful API response
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: [],
                        total: 0
                    }
                })
        });
        // Import and execute the hook
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        const result = useProductList();
        // Verify initial state setup
        expect(mockUseState).toHaveBeenCalledTimes(3);
        expect(mockUseState).toHaveBeenNthCalledWith(1, []); // products
        expect(mockUseState).toHaveBeenNthCalledWith(2, true); // isLoading
        expect(mockUseState).toHaveBeenNthCalledWith(3, null); // error
        // Verify return value structure
        expect(result).toEqual({
            products: [],
            isLoading: true,
            error: null
        });
    });
    it('should call fetch with correct URL', async ()=>{
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: [],
                        total: 0
                    }
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        expect(global.fetch).toHaveBeenCalledWith('/api/admin/products-direct?limit=25');
    });
    it('should handle successful API response', async ()=>{
        const mockProducts = [
            {
                id: 1,
                name: 'Test Product',
                description: 'Test Description',
                price: 1000,
                stock: 50,
                category_id: 1,
                images: {
                    main: '/test.jpg',
                    gallery: [],
                    previews: [],
                    thumbnails: []
                },
                created_at: '2025-01-01T00:00:00Z',
                updated_at: '2025-01-01T00:00:00Z',
                category_name: 'Test Category'
            }
        ];
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: true,
                    data: {
                        products: mockProducts,
                        total: 1
                    }
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetIsLoading).toHaveBeenCalledWith(true);
        expect(mockSetError).toHaveBeenCalledWith(null);
        expect(mockSetProducts).toHaveBeenCalledWith(mockProducts);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle API errors', async ()=>{
        global.fetch.mockResolvedValueOnce({
            ok: false,
            status: 500,
            statusText: 'Internal Server Error'
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Error 500: Internal Server Error');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle network errors', async ()=>{
        global.fetch.mockRejectedValueOnce(new Error('Network error'));
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Network error');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should handle invalid response structure', async ()=>{
        global.fetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    success: false,
                    error: 'Invalid request'
                })
        });
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        useProductList();
        // Wait for async operations
        await new Promise((resolve)=>setTimeout(resolve, 0));
        expect(mockSetError).toHaveBeenCalledWith('Estructura de respuesta inválida');
        expect(mockSetProducts).toHaveBeenCalledWith([]);
        expect(mockSetIsLoading).toHaveBeenCalledWith(false);
    });
    it('should export correct TypeScript types', async ()=>{
        const module = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        expect(typeof module.useProductList).toBe('function');
        expect(module.Product).toBeDefined;
        expect(module.ProductListResponse).toBeDefined;
    });
    it('should follow React Hooks best practices', async ()=>{
        const { useProductList } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../useProductList")));
        // Hook should be a function
        expect(typeof useProductList).toBe('function');
        // Hook name should start with 'use'
        expect(useProductList.name).toBe('useProductList');
        // Hook follows React best practices
        expect(useProductList.name).toMatch(/^use/);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcaG9va3NcXGFkbWluXFxfX3Rlc3RzX19cXHVzZVByb2R1Y3RMaXN0LnN0YW5kYWxvbmUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVGVzdCBpbmRlcGVuZGllbnRlIHBhcmEgdXNlUHJvZHVjdExpc3Qgc2luIGRlcGVuZGVuY2lhcyBkZSBjb25maWd1cmFjacOzbiBnbG9iYWxcclxuICogRWplY3V0YXIgY29uOiBucHggamVzdCBzcmMvaG9va3MvYWRtaW4vX190ZXN0c19fL3VzZVByb2R1Y3RMaXN0LnN0YW5kYWxvbmUudGVzdC50cyAtLW5vLWNhY2hlIC0tbm8tY292ZXJhZ2VcclxuICovXHJcblxyXG4vLyBNb2NrIFJlYWN0IGhvb2tzXHJcbmNvbnN0IG1vY2tVc2VTdGF0ZSA9IGplc3QuZm4oKTtcclxuY29uc3QgbW9ja1VzZUVmZmVjdCA9IGplc3QuZm4oKTtcclxuXHJcbmplc3QubW9jaygncmVhY3QnLCAoKSA9PiAoe1xyXG4gIHVzZVN0YXRlOiBtb2NrVXNlU3RhdGUsXHJcbiAgdXNlRWZmZWN0OiBtb2NrVXNlRWZmZWN0XHJcbn0pKTtcclxuXHJcbi8vIE1vY2sgZmV0Y2hcclxuZ2xvYmFsLmZldGNoID0gamVzdC5mbigpO1xyXG5cclxuZGVzY3JpYmUoJ3VzZVByb2R1Y3RMaXN0IEhvb2sgLSBTdGFuZGFsb25lIFRlc3RzJywgKCkgPT4ge1xyXG4gIGxldCBtb2NrU2V0UHJvZHVjdHM6IGplc3QuTW9jaztcclxuICBsZXQgbW9ja1NldElzTG9hZGluZzogamVzdC5Nb2NrO1xyXG4gIGxldCBtb2NrU2V0RXJyb3I6IGplc3QuTW9jaztcclxuXHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcclxuICAgIFxyXG4gICAgLy8gTW9jayB1c2VTdGF0ZSBjYWxsc1xyXG4gICAgbW9ja1NldFByb2R1Y3RzID0gamVzdC5mbigpO1xyXG4gICAgbW9ja1NldElzTG9hZGluZyA9IGplc3QuZm4oKTtcclxuICAgIG1vY2tTZXRFcnJvciA9IGplc3QuZm4oKTtcclxuICAgIFxyXG4gICAgbW9ja1VzZVN0YXRlXHJcbiAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKFtbXSwgbW9ja1NldFByb2R1Y3RzXSkgLy8gcHJvZHVjdHMgc3RhdGVcclxuICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoW3RydWUsIG1vY2tTZXRJc0xvYWRpbmddKSAvLyBpc0xvYWRpbmcgc3RhdGVcclxuICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoW251bGwsIG1vY2tTZXRFcnJvcl0pOyAvLyBlcnJvciBzdGF0ZVxyXG4gICAgXHJcbiAgICAvLyBNb2NrIHVzZUVmZmVjdCB0byBpbW1lZGlhdGVseSBjYWxsIHRoZSBlZmZlY3RcclxuICAgIG1vY2tVc2VFZmZlY3QubW9ja0ltcGxlbWVudGF0aW9uKChlZmZlY3QpID0+IHtcclxuICAgICAgZWZmZWN0KCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgYWZ0ZXJFYWNoKCgpID0+IHtcclxuICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIGNvcnJlY3QgZGVmYXVsdCBzdGF0ZScsIGFzeW5jICgpID0+IHtcclxuICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBBUEkgcmVzcG9uc2VcclxuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xyXG4gICAgICBvazogdHJ1ZSxcclxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcclxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgIHByb2R1Y3RzOiBbXSxcclxuICAgICAgICAgIHRvdGFsOiAwXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSW1wb3J0IGFuZCBleGVjdXRlIHRoZSBob29rXHJcbiAgICBjb25zdCB7IHVzZVByb2R1Y3RMaXN0IH0gPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0Jyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSB1c2VQcm9kdWN0TGlzdCgpO1xyXG5cclxuICAgIC8vIFZlcmlmeSBpbml0aWFsIHN0YXRlIHNldHVwXHJcbiAgICBleHBlY3QobW9ja1VzZVN0YXRlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XHJcbiAgICBleHBlY3QobW9ja1VzZVN0YXRlKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aCgxLCBbXSk7IC8vIHByb2R1Y3RzXHJcbiAgICBleHBlY3QobW9ja1VzZVN0YXRlKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aCgyLCB0cnVlKTsgLy8gaXNMb2FkaW5nXHJcbiAgICBleHBlY3QobW9ja1VzZVN0YXRlKS50b0hhdmVCZWVuTnRoQ2FsbGVkV2l0aCgzLCBudWxsKTsgLy8gZXJyb3JcclxuXHJcbiAgICAvLyBWZXJpZnkgcmV0dXJuIHZhbHVlIHN0cnVjdHVyZVxyXG4gICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XHJcbiAgICAgIHByb2R1Y3RzOiBbXSxcclxuICAgICAgaXNMb2FkaW5nOiB0cnVlLFxyXG4gICAgICBlcnJvcjogbnVsbFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgY2FsbCBmZXRjaCB3aXRoIGNvcnJlY3QgVVJMJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XHJcbiAgICAgIG9rOiB0cnVlLFxyXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgcHJvZHVjdHM6IFtdLFxyXG4gICAgICAgICAgdG90YWw6IDBcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZVByb2R1Y3RMaXN0IH0gPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0Jyk7XHJcbiAgICB1c2VQcm9kdWN0TGlzdCgpO1xyXG5cclxuICAgIGV4cGVjdChnbG9iYWwuZmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXBpL2FkbWluL3Byb2R1Y3RzLWRpcmVjdD9saW1pdD0yNScpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIGhhbmRsZSBzdWNjZXNzZnVsIEFQSSByZXNwb25zZScsIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IG1vY2tQcm9kdWN0cyA9IFtcclxuICAgICAge1xyXG4gICAgICAgIGlkOiAxLFxyXG4gICAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QnLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBEZXNjcmlwdGlvbicsXHJcbiAgICAgICAgcHJpY2U6IDEwMDAsXHJcbiAgICAgICAgc3RvY2s6IDUwLFxyXG4gICAgICAgIGNhdGVnb3J5X2lkOiAxLFxyXG4gICAgICAgIGltYWdlczogeyBtYWluOiAnL3Rlc3QuanBnJywgZ2FsbGVyeTogW10sIHByZXZpZXdzOiBbXSwgdGh1bWJuYWlsczogW10gfSxcclxuICAgICAgICBjcmVhdGVkX2F0OiAnMjAyNS0wMS0wMVQwMDowMDowMFonLFxyXG4gICAgICAgIHVwZGF0ZWRfYXQ6ICcyMDI1LTAxLTAxVDAwOjAwOjAwWicsXHJcbiAgICAgICAgY2F0ZWdvcnlfbmFtZTogJ1Rlc3QgQ2F0ZWdvcnknXHJcbiAgICAgIH1cclxuICAgIF07XHJcblxyXG4gICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XHJcbiAgICAgIG9rOiB0cnVlLFxyXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgcHJvZHVjdHM6IG1vY2tQcm9kdWN0cyxcclxuICAgICAgICAgIHRvdGFsOiAxXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VQcm9kdWN0TGlzdCB9ID0gYXdhaXQgaW1wb3J0KCcuLi91c2VQcm9kdWN0TGlzdCcpO1xyXG4gICAgdXNlUHJvZHVjdExpc3QoKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBhc3luYyBvcGVyYXRpb25zXHJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xyXG5cclxuICAgIGV4cGVjdChtb2NrU2V0SXNMb2FkaW5nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh0cnVlKTtcclxuICAgIGV4cGVjdChtb2NrU2V0RXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG51bGwpO1xyXG4gICAgZXhwZWN0KG1vY2tTZXRQcm9kdWN0cykudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja1Byb2R1Y3RzKTtcclxuICAgIGV4cGVjdChtb2NrU2V0SXNMb2FkaW5nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmYWxzZSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgaGFuZGxlIEFQSSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAoZ2xvYmFsLmZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcclxuICAgICAgb2s6IGZhbHNlLFxyXG4gICAgICBzdGF0dXM6IDUwMCxcclxuICAgICAgc3RhdHVzVGV4dDogJ0ludGVybmFsIFNlcnZlciBFcnJvcidcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKTtcclxuICAgIHVzZVByb2R1Y3RMaXN0KCk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcclxuXHJcbiAgICBleHBlY3QobW9ja1NldEVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgNTAwOiBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InKTtcclxuICAgIGV4cGVjdChtb2NrU2V0UHJvZHVjdHMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFtdKTtcclxuICAgIGV4cGVjdChtb2NrU2V0SXNMb2FkaW5nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmYWxzZSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgKGdsb2JhbC5mZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VQcm9kdWN0TGlzdCB9ID0gYXdhaXQgaW1wb3J0KCcuLi91c2VQcm9kdWN0TGlzdCcpO1xyXG4gICAgdXNlUHJvZHVjdExpc3QoKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBhc3luYyBvcGVyYXRpb25zXHJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xyXG5cclxuICAgIGV4cGVjdChtb2NrU2V0RXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdOZXR3b3JrIGVycm9yJyk7XHJcbiAgICBleHBlY3QobW9ja1NldFByb2R1Y3RzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbXSk7XHJcbiAgICBleHBlY3QobW9ja1NldElzTG9hZGluZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmFsc2UpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHJlc3BvbnNlIHN0cnVjdHVyZScsIGFzeW5jICgpID0+IHtcclxuICAgIChnbG9iYWwuZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xyXG4gICAgICBvazogdHJ1ZSxcclxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcclxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcclxuICAgICAgICBlcnJvcjogJ0ludmFsaWQgcmVxdWVzdCdcclxuICAgICAgfSlcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUHJvZHVjdExpc3QgfSA9IGF3YWl0IGltcG9ydCgnLi4vdXNlUHJvZHVjdExpc3QnKTtcclxuICAgIHVzZVByb2R1Y3RMaXN0KCk7XHJcblxyXG4gICAgLy8gV2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTtcclxuXHJcbiAgICBleHBlY3QobW9ja1NldEVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXN0cnVjdHVyYSBkZSByZXNwdWVzdGEgaW52w6FsaWRhJyk7XHJcbiAgICBleHBlY3QobW9ja1NldFByb2R1Y3RzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbXSk7XHJcbiAgICBleHBlY3QobW9ja1NldElzTG9hZGluZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmFsc2UpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIGV4cG9ydCBjb3JyZWN0IFR5cGVTY3JpcHQgdHlwZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBpbXBvcnQoJy4uL3VzZVByb2R1Y3RMaXN0Jyk7XHJcbiAgICBcclxuICAgIGV4cGVjdCh0eXBlb2YgbW9kdWxlLnVzZVByb2R1Y3RMaXN0KS50b0JlKCdmdW5jdGlvbicpO1xyXG4gICAgZXhwZWN0KG1vZHVsZS5Qcm9kdWN0KS50b0JlRGVmaW5lZDtcclxuICAgIGV4cGVjdChtb2R1bGUuUHJvZHVjdExpc3RSZXNwb25zZSkudG9CZURlZmluZWQ7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgZm9sbG93IFJlYWN0IEhvb2tzIGJlc3QgcHJhY3RpY2VzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgeyB1c2VQcm9kdWN0TGlzdCB9ID0gYXdhaXQgaW1wb3J0KCcuLi91c2VQcm9kdWN0TGlzdCcpO1xyXG4gICAgXHJcbiAgICAvLyBIb29rIHNob3VsZCBiZSBhIGZ1bmN0aW9uXHJcbiAgICBleHBlY3QodHlwZW9mIHVzZVByb2R1Y3RMaXN0KS50b0JlKCdmdW5jdGlvbicpO1xyXG4gICAgXHJcbiAgICAvLyBIb29rIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggJ3VzZSdcclxuICAgIGV4cGVjdCh1c2VQcm9kdWN0TGlzdC5uYW1lKS50b0JlKCd1c2VQcm9kdWN0TGlzdCcpO1xyXG4gICAgXHJcbiAgICAvLyBIb29rIGZvbGxvd3MgUmVhY3QgYmVzdCBwcmFjdGljZXNcclxuICAgIGV4cGVjdCh1c2VQcm9kdWN0TGlzdC5uYW1lKS50b01hdGNoKC9edXNlLyk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJ1c2VTdGF0ZSIsIm1vY2tVc2VTdGF0ZSIsInVzZUVmZmVjdCIsIm1vY2tVc2VFZmZlY3QiLCJmbiIsImdsb2JhbCIsImZldGNoIiwiZGVzY3JpYmUiLCJtb2NrU2V0UHJvZHVjdHMiLCJtb2NrU2V0SXNMb2FkaW5nIiwibW9ja1NldEVycm9yIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrUmV0dXJuVmFsdWVPbmNlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiZWZmZWN0IiwiYWZ0ZXJFYWNoIiwicmVzdG9yZUFsbE1vY2tzIiwiaXQiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJvayIsImpzb24iLCJzdWNjZXNzIiwiZGF0YSIsInByb2R1Y3RzIiwidG90YWwiLCJ1c2VQcm9kdWN0TGlzdCIsInJlc3VsdCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoIiwidG9FcXVhbCIsImlzTG9hZGluZyIsImVycm9yIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJtb2NrUHJvZHVjdHMiLCJpZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInByaWNlIiwic3RvY2siLCJjYXRlZ29yeV9pZCIsImltYWdlcyIsIm1haW4iLCJnYWxsZXJ5IiwicHJldmlld3MiLCJ0aHVtYm5haWxzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJjYXRlZ29yeV9uYW1lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwibW9kdWxlIiwidG9CZSIsIlByb2R1Y3QiLCJ0b0JlRGVmaW5lZCIsIlByb2R1Y3RMaXN0UmVzcG9uc2UiLCJ0b01hdGNoIl0sIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0MsR0FFRCxtQkFBbUI7O0FBSW5CQSxLQUFLQyxJQUFJLENBQUMsU0FBUyxJQUFPLENBQUE7UUFDeEJDLFVBQVVDO1FBQ1ZDLFdBQVdDO0lBQ2IsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTkEsTUFBTUYsZUFBZUgsS0FBS00sRUFBRTtBQUM1QixNQUFNRCxnQkFBZ0JMLEtBQUtNLEVBQUU7QUFPN0IsYUFBYTtBQUNiQyxPQUFPQyxLQUFLLEdBQUdSLEtBQUtNLEVBQUU7QUFFdEJHLFNBQVMsMENBQTBDO0lBQ2pELElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUVKQyxXQUFXO1FBQ1RiLEtBQUtjLGFBQWE7UUFFbEIsc0JBQXNCO1FBQ3RCSixrQkFBa0JWLEtBQUtNLEVBQUU7UUFDekJLLG1CQUFtQlgsS0FBS00sRUFBRTtRQUMxQk0sZUFBZVosS0FBS00sRUFBRTtRQUV0QkgsYUFDR1ks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