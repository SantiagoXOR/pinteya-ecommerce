{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\app\\api\\search\\trending\\route.ts"],"sourcesContent":["// Configuración para Node.js Runtime\nexport const runtime = 'nodejs'\n\n// ===================================\n// API: /api/search/trending - Búsquedas populares/trending\n// ===================================\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getSupabaseClient } from '@/lib/integrations/supabase'\nimport { ApiResponse } from '@/types/api'\n\n// ===================================\n// MEJORAS DE SEGURIDAD - ALTA PRIORIDAD\n// ===================================\nimport { withRateLimit, RATE_LIMIT_CONFIGS } from '@/lib/rate-limiting/rate-limiter'\nimport { API_TIMEOUTS, withDatabaseTimeout, getEndpointTimeouts } from '@/lib/config/api-timeouts'\nimport { createSecurityLogger } from '@/lib/logging/security-logger'\n\nexport interface TrendingSearch {\n  id: string\n  query: string\n  count: number\n  category?: string\n  href: string\n  type: 'trending'\n}\n\nexport interface TrendingSearchesResponse {\n  trending: TrendingSearch[]\n  lastUpdated: string\n}\n\n// Búsquedas trending generadas dinámicamente basadas en productos reales\nasync function generateDynamicTrendingSearches(\n  supabase: any,\n  limit: number = 6\n): Promise<TrendingSearch[]> {\n  try {\n    // Obtener productos más populares y marcas para generar búsquedas trending realistas\n    const { data: products, error: productsError } = await supabase\n      .from('products')\n      .select('name, brand, category_id, categories(name)')\n      .eq('is_active', true)\n      .limit(20)\n\n    if (productsError || !products) {\n      console.warn('Error obteniendo productos para trending:', productsError)\n      return getFallbackTrendingSearches(limit)\n    }\n\n    // Generar búsquedas trending basadas en productos reales\n    const trendingSearches: TrendingSearch[] = []\n    const usedQueries = new Set<string>()\n\n    // Agregar búsquedas por marca\n    const brands = [...new Set(products.map(p => p.brand).filter(Boolean))]\n    brands.slice(0, 2).forEach((brand, index) => {\n      if (brand && !usedQueries.has(brand.toLowerCase())) {\n        trendingSearches.push({\n          id: `trending-brand-${index + 1}`,\n          query: brand,\n          count: Math.floor(Math.random() * 50) + 20, // Rango realista 20-70\n          category: 'marcas',\n          href: `/search?q=${encodeURIComponent(brand)}`,\n          type: 'trending',\n        })\n        usedQueries.add(brand.toLowerCase())\n      }\n    })\n\n    // Agregar búsquedas por categoría\n    const categories = [...new Set(products.map(p => p.categories?.name).filter(Boolean))]\n    categories.slice(0, 2).forEach((category, index) => {\n      if (category && !usedQueries.has(category.toLowerCase())) {\n        trendingSearches.push({\n          id: `trending-category-${index + 1}`,\n          query: category,\n          count: Math.floor(Math.random() * 40) + 15, // Rango realista 15-55\n          category: 'pinturas',\n          href: `/search?q=${encodeURIComponent(category)}`,\n          type: 'trending',\n        })\n        usedQueries.add(category.toLowerCase())\n      }\n    })\n\n    // Agregar búsquedas por productos específicos\n    const popularProducts = products.slice(0, 2)\n    popularProducts.forEach((product, index) => {\n      const productName = product.name\n      if (productName && !usedQueries.has(productName.toLowerCase())) {\n        trendingSearches.push({\n          id: `trending-product-${index + 1}`,\n          query: productName,\n          count: Math.floor(Math.random() * 30) + 10, // Rango realista 10-40\n          category: 'productos',\n          href: `/search?q=${encodeURIComponent(productName)}`,\n          type: 'trending',\n        })\n        usedQueries.add(productName.toLowerCase())\n      }\n    })\n\n    // Ordenar por count descendente y limitar\n    return trendingSearches.sort((a, b) => b.count - a.count).slice(0, limit)\n  } catch (error) {\n    console.error('Error generando trending searches dinámicas:', error)\n    return getFallbackTrendingSearches(limit)\n  }\n}\n\n// Fallback con datos mínimos (solo si falla todo lo demás)\nfunction getFallbackTrendingSearches(limit: number = 6): TrendingSearch[] {\n  const fallbackSearches = [\n    { query: 'Pintura', category: 'pinturas' },\n    { query: 'Esmalte', category: 'pinturas' },\n    { query: 'Látex', category: 'pinturas' },\n    { query: 'Barniz', category: 'pinturas' },\n    { query: 'Imprimación', category: 'pinturas' },\n    { query: 'Rodillos', category: 'herramientas' },\n  ]\n\n  return fallbackSearches.slice(0, limit).map((search, index) => ({\n    id: `fallback-${index + 1}`,\n    query: search.query,\n    count: Math.floor(Math.random() * 20) + 5, // Rango mínimo 5-25\n    category: search.category,\n    href: `/search?q=${encodeURIComponent(search.query.toLowerCase())}`,\n    type: 'trending' as const,\n  }))\n}\n\nexport async function GET(request: NextRequest) {\n  // Crear logger de seguridad con contexto\n  const securityLogger = createSecurityLogger(request)\n\n  // Aplicar rate limiting para APIs de búsqueda\n  const rateLimitResult = await withRateLimit(request, RATE_LIMIT_CONFIGS.search, async () => {\n    // Log de acceso a la API\n    securityLogger.log({\n      type: 'data_access',\n      severity: 'low',\n      message: 'Trending search API accessed',\n      context: securityLogger.context,\n      metadata: {\n        endpoint: '/api/search/trending',\n        method: 'GET',\n        userAgent: request.headers.get('user-agent'),\n      },\n    })\n\n    try {\n      const { searchParams } = new URL(request.url)\n      const limit = parseInt(searchParams.get('limit') || '6')\n      const days = parseInt(searchParams.get('days') || '7')\n      const category = searchParams.get('category')\n\n      console.log('🔥 API /api/search/trending: Obteniendo búsquedas trending', {\n        limit,\n        days,\n        category,\n      })\n\n      const supabase = getSupabaseClient()\n\n      let trendingSearches: TrendingSearch[] = []\n\n      // Intentar obtener búsquedas trending reales del sistema de analytics\n      if (supabase) {\n        try {\n          const startDate = new Date()\n          startDate.setDate(startDate.getDate() - days)\n\n          // Query para obtener búsquedas más populares de analytics_events\n          let query = supabase\n            .from('analytics_events')\n            .select('label, metadata')\n            .eq('category', 'search')\n            .eq('action', 'search_query')\n            .gte('created_at', startDate.toISOString())\n            .not('label', 'is', null)\n\n          if (category) {\n            query = query.eq('metadata->>category', category)\n          }\n\n          const { data: analyticsData, error } = await withDatabaseTimeout(\n            async signal => await query,\n            API_TIMEOUTS.database\n          )\n\n          if (!error && analyticsData && analyticsData.length > 0) {\n            // Procesar datos de analytics para obtener trending\n            const searchCounts = new Map<string, number>()\n            const searchCategories = new Map<string, string>()\n\n            analyticsData.forEach(event => {\n              if (event.label) {\n                const query = event.label.toLowerCase().trim()\n                if (query.length > 2) {\n                  // Solo queries de más de 2 caracteres\n                  searchCounts.set(query, (searchCounts.get(query) || 0) + 1)\n\n                  // Extraer categoría del metadata si existe\n                  if (event.metadata && event.metadata.category) {\n                    searchCategories.set(query, event.metadata.category)\n                  }\n                }\n              }\n            })\n\n            // Convertir a array y ordenar por popularidad\n            const sortedSearches = Array.from(searchCounts.entries())\n              .sort((a, b) => b[1] - a[1])\n              .slice(0, limit)\n\n            trendingSearches = sortedSearches.map(([query, count], index) => ({\n              id: `trending-real-${index + 1}`,\n              query: query.charAt(0).toUpperCase() + query.slice(1),\n              count,\n              category: searchCategories.get(query),\n              href: `/search?q=${encodeURIComponent(query)}`,\n              type: 'trending' as const,\n            }))\n          }\n        } catch (analyticsError) {\n          console.warn(\n            '⚠️ Error obteniendo trending de analytics, usando fallback:',\n            analyticsError\n          )\n        }\n      }\n\n      // Si no hay datos reales o hay pocos, generar dinámicamente\n      if (trendingSearches.length < 3) {\n        console.log('🔄 Generando búsquedas trending dinámicas desde productos')\n\n        try {\n          const dynamicSearches = await generateDynamicTrendingSearches(supabase, limit)\n\n          // Filtrar por categoría si se especifica\n          let filteredSearches = dynamicSearches\n          if (category) {\n            filteredSearches = dynamicSearches.filter(search => search.category === category)\n          }\n\n          // Combinar datos reales con dinámicos si es necesario\n          const needed = limit - trendingSearches.length\n          const additionalSearches = filteredSearches.slice(0, needed)\n\n          trendingSearches = [...trendingSearches, ...additionalSearches]\n        } catch (error) {\n          console.error('Error generando trending dinámicas, usando fallback:', error)\n          const fallbackSearches = getFallbackTrendingSearches(limit - trendingSearches.length)\n          trendingSearches = [...trendingSearches, ...fallbackSearches]\n        }\n      }\n\n      // Limitar al número solicitado\n      trendingSearches = trendingSearches.slice(0, limit)\n\n      const response: ApiResponse<TrendingSearchesResponse> = {\n        data: {\n          trending: trendingSearches,\n          lastUpdated: new Date().toISOString(),\n        },\n        success: true,\n      }\n\n      console.log('🔥 Trending searches response:', {\n        count: trendingSearches.length,\n        hasRealData: trendingSearches.some(s => s.id.includes('real')),\n        categories: [...new Set(trendingSearches.map(s => s.category).filter(Boolean))],\n      })\n\n      // Log de operación exitosa\n      securityLogger.log({\n        type: 'data_access',\n        severity: 'low',\n        message: 'Trending searches retrieved successfully',\n        context: securityLogger.context,\n        metadata: {\n          searchesCount: trendingSearches.length,\n          limit: limit,\n          days: days,\n          category: category,\n        },\n      })\n\n      return NextResponse.json(response)\n    } catch (error) {\n      console.error('❌ Error en /api/search/trending:', error)\n\n      // Log de error de seguridad\n      securityLogger.logApiError(\n        securityLogger.context,\n        error instanceof Error ? error : new Error('Unknown error'),\n        {\n          endpoint: '/api/search/trending',\n        }\n      )\n\n      // En caso de error, devolver búsquedas por defecto\n      const fallbackResponse: ApiResponse<TrendingSearchesResponse> = {\n        data: {\n          trending: defaultTrendingSearches.slice(\n            0,\n            parseInt(request.nextUrl.searchParams.get('limit') || '6')\n          ),\n          lastUpdated: new Date().toISOString(),\n        },\n        success: true,\n      }\n\n      return NextResponse.json(fallbackResponse)\n    }\n  })\n\n  // Manejar rate limit excedido\n  if (rateLimitResult instanceof NextResponse) {\n    securityLogger.logRateLimitExceeded(securityLogger.context, {\n      endpoint: '/api/search/trending',\n      method: 'GET',\n    })\n    return rateLimitResult\n  }\n\n  return rateLimitResult\n}\n\n// Método POST para registrar una búsqueda (para analytics)\nexport async function POST(request: NextRequest) {\n  try {\n    // Validar que el request tenga contenido\n    const contentType = request.headers.get('content-type')\n    if (!contentType || !contentType.includes('application/json')) {\n      return NextResponse.json({ error: 'Content-Type debe ser application/json' }, { status: 400 })\n    }\n\n    // Obtener el texto del body primero para validar\n    const bodyText = await request.text()\n    if (!bodyText || bodyText.trim() === '' || bodyText === '\"\"' || bodyText === \"''\") {\n      return NextResponse.json(\n        { error: 'Body de la request no puede estar vacío' },\n        { status: 400 }\n      )\n    }\n\n    // Parsear JSON de forma segura\n    let requestData\n    try {\n      requestData = JSON.parse(bodyText)\n    } catch (parseError) {\n      console.error('Error parsing JSON in POST /api/search/trending:', parseError)\n      return NextResponse.json({ error: 'JSON inválido en el body de la request' }, { status: 400 })\n    }\n\n    const { query, category, userId, sessionId } = requestData\n\n    if (!query || typeof query !== 'string') {\n      return NextResponse.json({ error: 'Query de búsqueda requerida' }, { status: 400 })\n    }\n\n    const supabase = getSupabaseClient()\n\n    if (supabase) {\n      // Registrar la búsqueda en analytics usando función optimizada\n      const { error } = await supabase.rpc('insert_analytics_event_optimized', {\n        p_event_name: 'search',\n        p_category: 'search',\n        p_action: 'search',\n        p_label: query.toLowerCase().trim().substring(0, 50),\n        p_user_id: userId,\n        p_session_id: sessionId || 'anonymous',\n        p_page: '/search',\n        p_user_agent: null,\n      })\n\n      if (error) {\n        console.error('Error registrando búsqueda en analytics:', error)\n      } else {\n      }\n    }\n\n    return NextResponse.json({ success: true })\n  } catch (error) {\n    console.error('❌ Error registrando búsqueda:', error)\n    return NextResponse.json({ error: 'Error interno del servidor' }, { status: 500 })\n  }\n}\n"],"names":["GET","POST","runtime","generateDynamicTrendingSearches","supabase","limit","data","products","error","productsError","from","select","eq","console","warn","getFallbackTrendingSearches","trendingSearches","usedQueries","Set","brands","map","p","brand","filter","Boolean","slice","forEach","index","has","toLowerCase","push","id","query","count","Math","floor","random","category","href","encodeURIComponent","type","add","categories","name","popularProducts","product","productName","sort","a","b","fallbackSearches","search","request","securityLogger","createSecurityLogger","rateLimitResult","withRateLimit","RATE_LIMIT_CONFIGS","log","severity","message","context","metadata","endpoint","method","userAgent","headers","get","searchParams","URL","url","parseInt","days","getSupabaseClient","startDate","Date","setDate","getDate","gte","toISOString","not","analyticsData","withDatabaseTimeout","signal","API_TIMEOUTS","database","length","searchCounts","Map","searchCategories","event","label","trim","set","sortedSearches","Array","entries","charAt","toUpperCase","analyticsError","dynamicSearches","filteredSearches","needed","additionalSearches","response","trending","lastUpdated","success","hasRealData","some","s","includes","searchesCount","NextResponse","json","logApiError","Error","fallbackResponse","defaultTrendingSearches","nextUrl","logRateLimitExceeded","contentType","status","bodyText","text","requestData","JSON","parse","parseError","userId","sessionId","rpc","p_event_name","p_category","p_action","p_label","substring","p_user_id","p_session_id","p_page","p_user_agent"],"mappings":"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"}