0db830d11d3b5737a4480e09679ffb24
// ===================================
// PINTEYA E-COMMERCE - REDIS CONFIGURATION
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get RedisCache () {
        return RedisCache;
    },
    get cleanupRateLimitKeys () {
        return cleanupRateLimitKeys;
    },
    get closeRedisConnection () {
        return closeRedisConnection;
    },
    get enterpriseRateLimit () {
        return enterpriseRateLimit;
    },
    get getRateLimitInfo () {
        return getRateLimitInfo;
    },
    get getRateLimitStats () {
        return getRateLimitStats;
    },
    get getRedisClient () {
        return getRedisClient;
    },
    get incrementRateLimit () {
        return incrementRateLimit;
    },
    get isRedisAvailable () {
        return isRedisAvailable;
    },
    get redis () {
        return redis;
    },
    get redisCache () {
        return redisCache;
    },
    get slidingWindowRateLimit () {
        return slidingWindowRateLimit;
    }
});
const _ioredis = /*#__PURE__*/ _interop_require_default(require("ioredis"));
const _logger = require("../../enterprise/logger");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Configuración de Redis
const REDIS_CONFIG = {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD,
    db: parseInt(process.env.REDIS_DB || '0'),
    retryDelayOnFailover: 100,
    maxRetriesPerRequest: 3,
    lazyConnect: true,
    keepAlive: 30000,
    connectTimeout: 10000,
    commandTimeout: 5000
};
// Mock Redis para desarrollo cuando Redis no está disponible
class MockRedis {
    async get(key) {
        return this.storage.get(key) || null;
    }
    async set(key, value, ...args) {
        this.storage.set(key, value);
        return 'OK';
    }
    async del(key) {
        const existed = this.storage.has(key);
        this.storage.delete(key);
        return existed ? 1 : 0;
    }
    async exists(key) {
        return this.storage.has(key) ? 1 : 0;
    }
    async incr(key) {
        const current = parseInt(this.storage.get(key) || '0');
        const newValue = current + 1;
        this.storage.set(key, newValue.toString());
        return newValue;
    }
    async expire(key, seconds) {
        // Mock: no implementamos expiración real
        return 1;
    }
    async keys(pattern) {
        const regex = new RegExp(pattern.replace(/\*/g, '.*'));
        return Array.from(this.storage.keys()).filter((key)=>regex.test(key));
    }
    async flushall() {
        this.storage.clear();
        return 'OK';
    }
    // Métodos de listas para métricas
    async lpush(key, ...values) {
        const list = this.storage.get(key) || [];
        list.unshift(...values);
        this.storage.set(key, list);
        return list.length;
    }
    async ltrim(key, start, stop) {
        const list = this.storage.get(key) || [];
        const trimmed = list.slice(start, stop + 1);
        this.storage.set(key, trimmed);
        return 'OK';
    }
    async lrange(key, start, stop) {
        const list = this.storage.get(key) || [];
        if (stop === -1) {
            return list.slice(start);
        }
        return list.slice(start, stop + 1);
    }
    async ttl(key) {
        // Mock: retornar -1 (sin expiración) o un valor fijo
        return this.storage.has(key) ? 3600 : -2;
    }
    // Pipeline mock para operaciones batch
    pipeline() {
        return new MockPipeline(this);
    }
    // Métodos de conexión mock
    async connect() {
        console.log('[REDIS MOCK] Conectado (simulado)');
    }
    disconnect() {
        console.log('[REDIS MOCK] Desconectado (simulado)');
    }
    on(event, callback) {
        return this;
    }
    async quit() {
        console.log('[REDIS MOCK] Desconectado (quit simulado)');
        return 'OK';
    }
    constructor(){
        this.storage = new Map();
    }
}
// Mock Pipeline para operaciones batch
class MockPipeline {
    constructor(redis){
        this.commands = [];
        this.redis = redis;
    }
    get(key) {
        this.commands.push({
            method: 'get',
            args: [
                key
            ]
        });
        return this;
    }
    ttl(key) {
        this.commands.push({
            method: 'ttl',
            args: [
                key
            ]
        });
        return this;
    }
    incr(key) {
        this.commands.push({
            method: 'incr',
            args: [
                key
            ]
        });
        return this;
    }
    expire(key, seconds) {
        this.commands.push({
            method: 'expire',
            args: [
                key,
                seconds
            ]
        });
        return this;
    }
    async exec() {
        const results = [];
        for (const command of this.commands){
            try {
                const result = await this.redis[command.method](...command.args);
                results.push([
                    null,
                    result
                ]);
            } catch (error) {
                results.push([
                    error,
                    null
                ]);
            }
        }
        this.commands = []; // Limpiar comandos después de ejecutar
        return results;
    }
}
// Cliente Redis singleton
let redisClient = null;
let isUsingMock = false;
function getRedisClient() {
    if (!redisClient) {
        // Verificar si Redis está deshabilitado
        if (process.env.DISABLE_REDIS === 'true') {
            console.log('[REDIS] Redis deshabilitado por configuración, usando mock');
            redisClient = new MockRedis();
            isUsingMock = true;
            return redisClient;
        }
        try {
            redisClient = new _ioredis.default(REDIS_CONFIG);
            // Event listeners para logging
            redisClient.on('connect', ()=>{
                _logger.logger.info(_logger.LogCategory.API, 'Redis connected successfully');
                isUsingMock = false;
            });
            redisClient.on('error', (error)=>{
                _logger.logger.error(_logger.LogCategory.API, 'Redis connection error', error);
                // Si hay error de conexión, usar mock
                if (!isUsingMock) {
                    console.log('[REDIS] Cambiando a modo mock debido a error de conexión');
                    redisClient = new MockRedis();
                    isUsingMock = true;
                }
            });
            redisClient.on('close', ()=>{
                _logger.logger.warn(_logger.LogCategory.API, 'Redis connection closed');
            });
            redisClient.on('reconnecting', ()=>{
                _logger.logger.info(_logger.LogCategory.API, 'Redis reconnecting...');
            });
        } catch (error) {
            console.log('[REDIS] Error inicializando Redis, usando mock:', error.message);
            redisClient = new MockRedis();
            isUsingMock = true;
        }
    }
    return redisClient;
}
async function isRedisAvailable() {
    try {
        if (isUsingMock) {
            return false; // Mock no es Redis real
        }
        const client = getRedisClient();
        if (client instanceof MockRedis) {
            return false;
        }
        await client.ping();
        return true;
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Redis health check failed', error);
        return false;
    }
}
async function closeRedisConnection() {
    if (redisClient) {
        await redisClient.quit();
        redisClient = null;
        _logger.logger.info(_logger.LogCategory.API, 'Redis connection closed gracefully');
    }
}
class RedisCache {
    constructor(){
        this.client = getRedisClient();
    }
    /**
   * Obtiene un valor del cache
   */ async get(key) {
        try {
            const value = await this.client.get(key);
            _logger.logger.info(_logger.LogCategory.API, 'Cache get operation');
            return value;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache get operation failed', error);
            return null;
        }
    }
    /**
   * Establece un valor en el cache
   */ async set(key, value, ttlSeconds) {
        try {
            if (ttlSeconds) {
                await this.client.setex(key, ttlSeconds, value);
            } else {
                await this.client.set(key, value);
            }
            _logger.logger.info(_logger.LogCategory.API, 'Cache set operation');
            return true;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache set operation failed', error);
            return false;
        }
    }
    /**
   * Elimina un valor del cache
   */ async del(key) {
        try {
            const result = await this.client.del(key);
            _logger.logger.info(_logger.LogCategory.API, 'Cache delete operation');
            return result > 0;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache delete operation failed', error);
            return false;
        }
    }
    /**
   * Incrementa un contador atómicamente
   */ async incr(key) {
        try {
            const result = await this.client.incr(key);
            _logger.logger.info(_logger.LogCategory.API, 'Cache increment operation');
            return result;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache increment operation failed', error);
            return null;
        }
    }
    /**
   * Establece TTL para una clave existente
   */ async expire(key, ttlSeconds) {
        try {
            const result = await this.client.expire(key, ttlSeconds);
            _logger.logger.info(_logger.LogCategory.API, 'Cache expire operation');
            return result === 1;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache expire operation failed', error);
            return false;
        }
    }
    /**
   * Obtiene TTL restante de una clave
   */ async ttl(key) {
        try {
            const result = await this.client.ttl(key);
            _logger.logger.info(_logger.LogCategory.API, 'Cache TTL check');
            return result;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache TTL check failed', error);
            return null;
        }
    }
}
const redisCache = new RedisCache();
async function getRateLimitInfo(key) {
    try {
        const client = getRedisClient();
        const pipeline = client.pipeline();
        pipeline.get(key);
        pipeline.ttl(key);
        const results = await pipeline.exec();
        if (!results || results.length !== 2) {
            return null;
        }
        const [countResult, ttlResult] = results;
        const count = parseInt(countResult[1]) || 0;
        const ttl = ttlResult[1];
        return {
            count,
            ttl
        };
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Rate limit info retrieval failed', error);
        return null;
    }
}
async function incrementRateLimit(key, windowSeconds) {
    try {
        const client = getRedisClient();
        const pipeline = client.pipeline();
        // Incrementar contador
        pipeline.incr(key);
        // Establecer TTL solo si es la primera vez
        pipeline.expire(key, windowSeconds);
        // Obtener TTL actual
        pipeline.ttl(key);
        const results = await pipeline.exec();
        if (!results || results.length !== 3) {
            return null;
        }
        const count = results[0][1];
        const ttl = results[2][1];
        const isNewWindow = count === 1;
        return {
            count,
            ttl,
            isNewWindow
        };
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Rate limit increment failed', error);
        return null;
    }
}
async function enterpriseRateLimit(key, windowMs, maxRequests) {
    try {
        const client = getRedisClient();
        const now = Date.now();
        const window = Math.floor(now / windowMs);
        const redisKey = `rate_limit:${key}:${window}`;
        // Usar pipeline para operaciones atómicas
        const pipeline = client.pipeline();
        pipeline.incr(redisKey);
        pipeline.expire(redisKey, Math.ceil(windowMs / 1000));
        const results = await pipeline.exec();
        if (!results || results.length !== 2) {
            return null;
        }
        const count = results[0][1];
        const remaining = Math.max(0, maxRequests - count);
        const resetTime = (window + 1) * windowMs;
        const allowed = count <= maxRequests;
        const result = {
            allowed,
            count,
            remaining,
            resetTime,
            retryAfter: allowed ? undefined : Math.ceil((resetTime - now) / 1000)
        };
        _logger.logger.debug(_logger.LogCategory.API, 'Enterprise rate limit check', {
            key: redisKey,
            count,
            maxRequests,
            allowed,
            remaining
        });
        return result;
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Enterprise rate limit failed', error);
        return null;
    }
}
async function slidingWindowRateLimit(key, windowMs, maxRequests, precision = 10) {
    try {
        const client = getRedisClient();
        const now = Date.now();
        const windowSize = Math.floor(windowMs / precision);
        const currentWindow = Math.floor(now / windowSize);
        // Limpiar ventanas antiguas y contar requests en ventana actual
        const pipeline = client.pipeline();
        // Eliminar ventanas más antiguas que el período de rate limiting
        for(let i = 1; i <= precision; i++){
            const oldWindow = currentWindow - precision - i;
            pipeline.del(`${key}:${oldWindow}`);
        }
        // Incrementar contador para ventana actual
        const currentKey = `${key}:${currentWindow}`;
        pipeline.incr(currentKey);
        pipeline.expire(currentKey, Math.ceil(windowMs / 1000));
        // Obtener contadores de todas las ventanas en el período
        for(let i = 0; i < precision; i++){
            const windowKey = `${key}:${currentWindow - i}`;
            pipeline.get(windowKey);
        }
        const results = await pipeline.exec();
        if (!results) {
            return null;
        }
        // Calcular total de requests en la ventana deslizante
        let totalCount = 0;
        const countResults = results.slice(precision + 2); // Saltar operaciones de limpieza e incremento
        for (const result of countResults){
            if (result[1]) {
                totalCount += parseInt(result[1]);
            }
        }
        const remaining = Math.max(0, maxRequests - totalCount);
        const allowed = totalCount <= maxRequests;
        const resetTime = (currentWindow + 1) * windowSize;
        return {
            allowed,
            count: totalCount,
            remaining,
            resetTime
        };
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Sliding window rate limit failed', error);
        return null;
    }
}
async function getRateLimitStats(pattern = 'rate_limit:*') {
    try {
        const client = getRedisClient();
        const keys = await client.keys(pattern);
        if (keys.length === 0) {
            return {
                totalKeys: 0,
                activeWindows: 0,
                topKeys: []
            };
        }
        // Obtener información de las claves más activas
        const pipeline = client.pipeline();
        keys.forEach((key)=>{
            pipeline.get(key);
            pipeline.ttl(key);
        });
        const results = await pipeline.exec();
        if (!results) {
            return null;
        }
        const keyStats = [];
        for(let i = 0; i < keys.length; i++){
            const countResult = results[i * 2];
            const ttlResult = results[i * 2 + 1];
            if (countResult[1] && ttlResult[1]) {
                keyStats.push({
                    key: keys[i],
                    count: parseInt(countResult[1]),
                    ttl: ttlResult[1]
                });
            }
        }
        // Ordenar por count descendente
        keyStats.sort((a, b)=>b.count - a.count);
        return {
            totalKeys: keys.length,
            activeWindows: keyStats.filter((stat)=>stat.ttl > 0).length,
            topKeys: keyStats.slice(0, 10) // Top 10
        };
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Rate limit stats failed', error);
        return null;
    }
}
async function cleanupRateLimitKeys(pattern = 'rate_limit:*') {
    try {
        const client = getRedisClient();
        const keys = await client.keys(pattern);
        if (keys.length === 0) {
            return 0;
        }
        // Verificar TTL de cada clave y eliminar las expiradas
        const pipeline = client.pipeline();
        keys.forEach((key)=>{
            pipeline.ttl(key);
        });
        const ttlResults = await pipeline.exec();
        if (!ttlResults) {
            return 0;
        }
        const expiredKeys = [];
        for(let i = 0; i < keys.length; i++){
            const ttlResult = ttlResults[i];
            if (ttlResult[1] === -2) {
                expiredKeys.push(keys[i]);
            }
        }
        if (expiredKeys.length > 0) {
            await client.del(...expiredKeys);
            _logger.logger.info(_logger.LogCategory.API, `Cleaned up ${expiredKeys.length} expired rate limit keys`);
        }
        return expiredKeys.length;
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Rate limit cleanup failed', error);
        return 0;
    }
}
const redis = getRedisClient();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcbGliXFxpbnRlZ3JhdGlvbnNcXHJlZGlzXFxpbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBSRURJUyBDT05GSUdVUkFUSU9OXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbXBvcnQgUmVkaXMgZnJvbSAnaW9yZWRpcyc7XHJcbmltcG9ydCB7IGxvZ2dlciwgTG9nTGV2ZWwsIExvZ0NhdGVnb3J5IH0gZnJvbSAnLi4vLi4vZW50ZXJwcmlzZS9sb2dnZXInO1xyXG5cclxuLy8gQ29uZmlndXJhY2nDs24gZGUgUmVkaXNcclxuY29uc3QgUkVESVNfQ09ORklHID0ge1xyXG4gIGhvc3Q6IHByb2Nlc3MuZW52LlJFRElTX0hPU1QgfHwgJ2xvY2FsaG9zdCcsXHJcbiAgcG9ydDogcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVESVNfUE9SVCB8fCAnNjM3OScpLFxyXG4gIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5SRURJU19QQVNTV09SRCxcclxuICBkYjogcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVESVNfREIgfHwgJzAnKSxcclxuICByZXRyeURlbGF5T25GYWlsb3ZlcjogMTAwLFxyXG4gIG1heFJldHJpZXNQZXJSZXF1ZXN0OiAzLFxyXG4gIGxhenlDb25uZWN0OiB0cnVlLFxyXG4gIGtlZXBBbGl2ZTogMzAwMDAsXHJcbiAgY29ubmVjdFRpbWVvdXQ6IDEwMDAwLFxyXG4gIGNvbW1hbmRUaW1lb3V0OiA1MDAwLFxyXG59O1xyXG5cclxuLy8gTW9jayBSZWRpcyBwYXJhIGRlc2Fycm9sbG8gY3VhbmRvIFJlZGlzIG5vIGVzdMOhIGRpc3BvbmlibGVcclxuY2xhc3MgTW9ja1JlZGlzIHtcclxuICBwcml2YXRlIHN0b3JhZ2UgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG5cclxuICBhc3luYyBnZXQoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0KGtleSkgfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHNldChrZXk6IHN0cmluZywgdmFsdWU6IGFueSwgLi4uYXJnczogYW55W10pOiBQcm9taXNlPCdPSyc+IHtcclxuICAgIHRoaXMuc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gJ09LJztcclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbChrZXk6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICBjb25zdCBleGlzdGVkID0gdGhpcy5zdG9yYWdlLmhhcyhrZXkpO1xyXG4gICAgdGhpcy5zdG9yYWdlLmRlbGV0ZShrZXkpO1xyXG4gICAgcmV0dXJuIGV4aXN0ZWQgPyAxIDogMDtcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4aXN0cyhrZXk6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmhhcyhrZXkpID8gMSA6IDA7XHJcbiAgfVxyXG5cclxuICBhc3luYyBpbmNyKGtleTogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgIGNvbnN0IGN1cnJlbnQgPSBwYXJzZUludCh0aGlzLnN0b3JhZ2UuZ2V0KGtleSkgfHwgJzAnKTtcclxuICAgIGNvbnN0IG5ld1ZhbHVlID0gY3VycmVudCArIDE7XHJcbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KGtleSwgbmV3VmFsdWUudG9TdHJpbmcoKSk7XHJcbiAgICByZXR1cm4gbmV3VmFsdWU7XHJcbiAgfVxyXG5cclxuICBhc3luYyBleHBpcmUoa2V5OiBzdHJpbmcsIHNlY29uZHM6IG51bWJlcik6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAvLyBNb2NrOiBubyBpbXBsZW1lbnRhbW9zIGV4cGlyYWNpw7NuIHJlYWxcclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMga2V5cyhwYXR0ZXJuOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XHJcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9cXCovZywgJy4qJykpO1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdG9yYWdlLmtleXMoKSkuZmlsdGVyKGtleSA9PiByZWdleC50ZXN0KGtleSkpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZmx1c2hhbGwoKTogUHJvbWlzZTwnT0snPiB7XHJcbiAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcclxuICAgIHJldHVybiAnT0snO1xyXG4gIH1cclxuXHJcbiAgLy8gTcOpdG9kb3MgZGUgbGlzdGFzIHBhcmEgbcOpdHJpY2FzXHJcbiAgYXN5bmMgbHB1c2goa2V5OiBzdHJpbmcsIC4uLnZhbHVlczogc3RyaW5nW10pOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgY29uc3QgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXQoa2V5KSB8fCBbXTtcclxuICAgIGxpc3QudW5zaGlmdCguLi52YWx1ZXMpO1xyXG4gICAgdGhpcy5zdG9yYWdlLnNldChrZXksIGxpc3QpO1xyXG4gICAgcmV0dXJuIGxpc3QubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgbHRyaW0oa2V5OiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIsIHN0b3A6IG51bWJlcik6IFByb21pc2U8J09LJz4ge1xyXG4gICAgY29uc3QgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXQoa2V5KSB8fCBbXTtcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBsaXN0LnNsaWNlKHN0YXJ0LCBzdG9wICsgMSk7XHJcbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KGtleSwgdHJpbW1lZCk7XHJcbiAgICByZXR1cm4gJ09LJztcclxuICB9XHJcblxyXG4gIGFzeW5jIGxyYW5nZShrZXk6IHN0cmluZywgc3RhcnQ6IG51bWJlciwgc3RvcDogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gICAgY29uc3QgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXQoa2V5KSB8fCBbXTtcclxuICAgIGlmIChzdG9wID09PSAtMSkge1xyXG4gICAgICByZXR1cm4gbGlzdC5zbGljZShzdGFydCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGlzdC5zbGljZShzdGFydCwgc3RvcCArIDEpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdHRsKGtleTogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgIC8vIE1vY2s6IHJldG9ybmFyIC0xIChzaW4gZXhwaXJhY2nDs24pIG8gdW4gdmFsb3IgZmlqb1xyXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5oYXMoa2V5KSA/IDM2MDAgOiAtMjtcclxuICB9XHJcblxyXG4gIC8vIFBpcGVsaW5lIG1vY2sgcGFyYSBvcGVyYWNpb25lcyBiYXRjaFxyXG4gIHBpcGVsaW5lKCk6IE1vY2tQaXBlbGluZSB7XHJcbiAgICByZXR1cm4gbmV3IE1vY2tQaXBlbGluZSh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8vIE3DqXRvZG9zIGRlIGNvbmV4acOzbiBtb2NrXHJcbiAgYXN5bmMgY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnNvbGUubG9nKCdbUkVESVMgTU9DS10gQ29uZWN0YWRvIChzaW11bGFkbyknKTtcclxuICB9XHJcblxyXG4gIGRpc2Nvbm5lY3QoKTogdm9pZCB7XHJcbiAgICBjb25zb2xlLmxvZygnW1JFRElTIE1PQ0tdIERlc2NvbmVjdGFkbyAoc2ltdWxhZG8pJyk7XHJcbiAgfVxyXG5cclxuICBvbihldmVudDogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pOiB0aGlzIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcXVpdCgpOiBQcm9taXNlPCdPSyc+IHtcclxuICAgIGNvbnNvbGUubG9nKCdbUkVESVMgTU9DS10gRGVzY29uZWN0YWRvIChxdWl0IHNpbXVsYWRvKScpO1xyXG4gICAgcmV0dXJuICdPSyc7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBNb2NrIFBpcGVsaW5lIHBhcmEgb3BlcmFjaW9uZXMgYmF0Y2hcclxuY2xhc3MgTW9ja1BpcGVsaW5lIHtcclxuICBwcml2YXRlIGNvbW1hbmRzOiBBcnJheTx7IG1ldGhvZDogc3RyaW5nOyBhcmdzOiBhbnlbXSB9PiA9IFtdO1xyXG4gIHByaXZhdGUgcmVkaXM6IE1vY2tSZWRpcztcclxuXHJcbiAgY29uc3RydWN0b3IocmVkaXM6IE1vY2tSZWRpcykge1xyXG4gICAgdGhpcy5yZWRpcyA9IHJlZGlzO1xyXG4gIH1cclxuXHJcbiAgZ2V0KGtleTogc3RyaW5nKTogdGhpcyB7XHJcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goeyBtZXRob2Q6ICdnZXQnLCBhcmdzOiBba2V5XSB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgdHRsKGtleTogc3RyaW5nKTogdGhpcyB7XHJcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goeyBtZXRob2Q6ICd0dGwnLCBhcmdzOiBba2V5XSB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgaW5jcihrZXk6IHN0cmluZyk6IHRoaXMge1xyXG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHsgbWV0aG9kOiAnaW5jcicsIGFyZ3M6IFtrZXldIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICBleHBpcmUoa2V5OiBzdHJpbmcsIHNlY29uZHM6IG51bWJlcik6IHRoaXMge1xyXG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHsgbWV0aG9kOiAnZXhwaXJlJywgYXJnczogW2tleSwgc2Vjb25kc10gfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIGFzeW5jIGV4ZWMoKTogUHJvbWlzZTxBcnJheTxbRXJyb3IgfCBudWxsLCBhbnldPj4ge1xyXG4gICAgY29uc3QgcmVzdWx0czogQXJyYXk8W0Vycm9yIHwgbnVsbCwgYW55XT4gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgdGhpcy5jb21tYW5kcykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICh0aGlzLnJlZGlzIGFzIGFueSlbY29tbWFuZC5tZXRob2RdKC4uLmNvbW1hbmQuYXJncyk7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKFtudWxsLCByZXN1bHRdKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICByZXN1bHRzLnB1c2goW2Vycm9yIGFzIEVycm9yLCBudWxsXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbW1hbmRzID0gW107IC8vIExpbXBpYXIgY29tYW5kb3MgZGVzcHXDqXMgZGUgZWplY3V0YXJcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxufVxyXG5cclxuLy8gQ2xpZW50ZSBSZWRpcyBzaW5nbGV0b25cclxubGV0IHJlZGlzQ2xpZW50OiBSZWRpcyB8IE1vY2tSZWRpcyB8IG51bGwgPSBudWxsO1xyXG5sZXQgaXNVc2luZ01vY2sgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBPYnRpZW5lIG8gY3JlYSBsYSBpbnN0YW5jaWEgZGUgUmVkaXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWRpc0NsaWVudCgpOiBSZWRpcyB8IE1vY2tSZWRpcyB7XHJcbiAgaWYgKCFyZWRpc0NsaWVudCkge1xyXG4gICAgLy8gVmVyaWZpY2FyIHNpIFJlZGlzIGVzdMOhIGRlc2hhYmlsaXRhZG9cclxuICAgIGlmIChwcm9jZXNzLmVudi5ESVNBQkxFX1JFRElTID09PSAndHJ1ZScpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1tSRURJU10gUmVkaXMgZGVzaGFiaWxpdGFkbyBwb3IgY29uZmlndXJhY2nDs24sIHVzYW5kbyBtb2NrJyk7XHJcbiAgICAgIHJlZGlzQ2xpZW50ID0gbmV3IE1vY2tSZWRpcygpO1xyXG4gICAgICBpc1VzaW5nTW9jayA9IHRydWU7XHJcbiAgICAgIHJldHVybiByZWRpc0NsaWVudDtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICByZWRpc0NsaWVudCA9IG5ldyBSZWRpcyhSRURJU19DT05GSUcpO1xyXG5cclxuICAgICAgLy8gRXZlbnQgbGlzdGVuZXJzIHBhcmEgbG9nZ2luZ1xyXG4gICAgICByZWRpc0NsaWVudC5vbignY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdSZWRpcyBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICAgICAgaXNVc2luZ01vY2sgPSBmYWxzZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZWRpc0NsaWVudC5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnUmVkaXMgY29ubmVjdGlvbiBlcnJvcicsIGVycm9yKTtcclxuICAgICAgICAvLyBTaSBoYXkgZXJyb3IgZGUgY29uZXhpw7NuLCB1c2FyIG1vY2tcclxuICAgICAgICBpZiAoIWlzVXNpbmdNb2NrKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1JFRElTXSBDYW1iaWFuZG8gYSBtb2RvIG1vY2sgZGViaWRvIGEgZXJyb3IgZGUgY29uZXhpw7NuJyk7XHJcbiAgICAgICAgICByZWRpc0NsaWVudCA9IG5ldyBNb2NrUmVkaXMoKTtcclxuICAgICAgICAgIGlzVXNpbmdNb2NrID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmVkaXNDbGllbnQub24oJ2Nsb3NlJywgKCkgPT4ge1xyXG4gICAgICAgIGxvZ2dlci53YXJuKExvZ0NhdGVnb3J5LkFQSSwgJ1JlZGlzIGNvbm5lY3Rpb24gY2xvc2VkJyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmVkaXNDbGllbnQub24oJ3JlY29ubmVjdGluZycsICgpID0+IHtcclxuICAgICAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdSZWRpcyByZWNvbm5lY3RpbmcuLi4nKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1tSRURJU10gRXJyb3IgaW5pY2lhbGl6YW5kbyBSZWRpcywgdXNhbmRvIG1vY2s6JywgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgIHJlZGlzQ2xpZW50ID0gbmV3IE1vY2tSZWRpcygpO1xyXG4gICAgICBpc1VzaW5nTW9jayA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVkaXNDbGllbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWZXJpZmljYSBzaSBSZWRpcyBlc3TDoSBkaXNwb25pYmxlXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNSZWRpc0F2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICB0cnkge1xyXG4gICAgaWYgKGlzVXNpbmdNb2NrKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTW9jayBubyBlcyBSZWRpcyByZWFsXHJcbiAgICB9XHJcbiAgICBjb25zdCBjbGllbnQgPSBnZXRSZWRpc0NsaWVudCgpO1xyXG4gICAgaWYgKGNsaWVudCBpbnN0YW5jZW9mIE1vY2tSZWRpcykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhd2FpdCAoY2xpZW50IGFzIFJlZGlzKS5waW5nKCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ1JlZGlzIGhlYWx0aCBjaGVjayBmYWlsZWQnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2llcnJhIGxhIGNvbmV4acOzbiBkZSBSZWRpc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsb3NlUmVkaXNDb25uZWN0aW9uKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gIGlmIChyZWRpc0NsaWVudCkge1xyXG4gICAgYXdhaXQgcmVkaXNDbGllbnQucXVpdCgpO1xyXG4gICAgcmVkaXNDbGllbnQgPSBudWxsO1xyXG4gICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuQVBJLCAnUmVkaXMgY29ubmVjdGlvbiBjbG9zZWQgZ3JhY2VmdWxseScpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE9wZXJhY2lvbmVzIGRlIGNhY2hlIGNvbiBtYW5lam8gZGUgZXJyb3Jlc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlZGlzQ2FjaGUge1xyXG4gIHByaXZhdGUgY2xpZW50OiBSZWRpcztcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmNsaWVudCA9IGdldFJlZGlzQ2xpZW50KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPYnRpZW5lIHVuIHZhbG9yIGRlbCBjYWNoZVxyXG4gICAqL1xyXG4gIGFzeW5jIGdldChrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLmNsaWVudC5nZXQoa2V5KTtcclxuICAgICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgZ2V0IG9wZXJhdGlvbicpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgZ2V0IG9wZXJhdGlvbiBmYWlsZWQnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXN0YWJsZWNlIHVuIHZhbG9yIGVuIGVsIGNhY2hlXHJcbiAgICovXHJcbiAgYXN5bmMgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCB0dGxTZWNvbmRzPzogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodHRsU2Vjb25kcykge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnNldGV4KGtleSwgdHRsU2Vjb25kcywgdmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnNldChrZXksIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgc2V0IG9wZXJhdGlvbicpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdDYWNoZSBzZXQgb3BlcmF0aW9uIGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRWxpbWluYSB1biB2YWxvciBkZWwgY2FjaGVcclxuICAgKi9cclxuICBhc3luYyBkZWwoa2V5OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LmRlbChrZXkpO1xyXG4gICAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdDYWNoZSBkZWxldGUgb3BlcmF0aW9uJyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQgPiAwO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0NhY2hlIGRlbGV0ZSBvcGVyYXRpb24gZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmNyZW1lbnRhIHVuIGNvbnRhZG9yIGF0w7NtaWNhbWVudGVcclxuICAgKi9cclxuICBhc3luYyBpbmNyKGtleTogc3RyaW5nKTogUHJvbWlzZTxudW1iZXIgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC5pbmNyKGtleSk7XHJcbiAgICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgJ0NhY2hlIGluY3JlbWVudCBvcGVyYXRpb24nKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdDYWNoZSBpbmNyZW1lbnQgb3BlcmF0aW9uIGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFc3RhYmxlY2UgVFRMIHBhcmEgdW5hIGNsYXZlIGV4aXN0ZW50ZVxyXG4gICAqL1xyXG4gIGFzeW5jIGV4cGlyZShrZXk6IHN0cmluZywgdHRsU2Vjb25kczogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC5leHBpcmUoa2V5LCB0dGxTZWNvbmRzKTtcclxuICAgICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgZXhwaXJlIG9wZXJhdGlvbicpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSAxO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0NhY2hlIGV4cGlyZSBvcGVyYXRpb24gZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPYnRpZW5lIFRUTCByZXN0YW50ZSBkZSB1bmEgY2xhdmVcclxuICAgKi9cclxuICBhc3luYyB0dGwoa2V5OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlciB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnR0bChrZXkpO1xyXG4gICAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdDYWNoZSBUVEwgY2hlY2snKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdDYWNoZSBUVEwgY2hlY2sgZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEluc3RhbmNpYSBzaW5nbGV0b24gZGVsIGNhY2hlXHJcbmV4cG9ydCBjb25zdCByZWRpc0NhY2hlID0gbmV3IFJlZGlzQ2FjaGUoKTtcclxuXHJcbi8vIEZ1bmNpb25lcyBkZSB1dGlsaWRhZCBwYXJhIHJhdGUgbGltaXRpbmdcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJhdGVMaW1pdEluZm8oa2V5OiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICBjb3VudDogbnVtYmVyO1xyXG4gIHR0bDogbnVtYmVyO1xyXG59IHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjbGllbnQgPSBnZXRSZWRpc0NsaWVudCgpO1xyXG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcclxuICAgIHBpcGVsaW5lLmdldChrZXkpO1xyXG4gICAgcGlwZWxpbmUudHRsKGtleSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBwaXBlbGluZS5leGVjKCk7XHJcbiAgICBcclxuICAgIGlmICghcmVzdWx0cyB8fCByZXN1bHRzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBbY291bnRSZXN1bHQsIHR0bFJlc3VsdF0gPSByZXN1bHRzO1xyXG4gICAgY29uc3QgY291bnQgPSBwYXJzZUludChjb3VudFJlc3VsdFsxXSBhcyBzdHJpbmcpIHx8IDA7XHJcbiAgICBjb25zdCB0dGwgPSB0dGxSZXN1bHRbMV0gYXMgbnVtYmVyO1xyXG5cclxuICAgIHJldHVybiB7IGNvdW50LCB0dGwgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ1JhdGUgbGltaXQgaW5mbyByZXRyaWV2YWwgZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5jcmVtZW50UmF0ZUxpbWl0KGtleTogc3RyaW5nLCB3aW5kb3dTZWNvbmRzOiBudW1iZXIpOiBQcm9taXNlPHtcclxuICBjb3VudDogbnVtYmVyO1xyXG4gIHR0bDogbnVtYmVyO1xyXG4gIGlzTmV3V2luZG93OiBib29sZWFuO1xyXG59IHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjbGllbnQgPSBnZXRSZWRpc0NsaWVudCgpO1xyXG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcclxuXHJcbiAgICAvLyBJbmNyZW1lbnRhciBjb250YWRvclxyXG4gICAgcGlwZWxpbmUuaW5jcihrZXkpO1xyXG4gICAgLy8gRXN0YWJsZWNlciBUVEwgc29sbyBzaSBlcyBsYSBwcmltZXJhIHZlelxyXG4gICAgcGlwZWxpbmUuZXhwaXJlKGtleSwgd2luZG93U2Vjb25kcyk7XHJcbiAgICAvLyBPYnRlbmVyIFRUTCBhY3R1YWxcclxuICAgIHBpcGVsaW5lLnR0bChrZXkpO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBwaXBlbGluZS5leGVjKCk7XHJcblxyXG4gICAgaWYgKCFyZXN1bHRzIHx8IHJlc3VsdHMubGVuZ3RoICE9PSAzKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvdW50ID0gcmVzdWx0c1swXVsxXSBhcyBudW1iZXI7XHJcbiAgICBjb25zdCB0dGwgPSByZXN1bHRzWzJdWzFdIGFzIG51bWJlcjtcclxuICAgIGNvbnN0IGlzTmV3V2luZG93ID0gY291bnQgPT09IDE7XHJcblxyXG4gICAgcmV0dXJuIHsgY291bnQsIHR0bCwgaXNOZXdXaW5kb3cgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ1JhdGUgbGltaXQgaW5jcmVtZW50IGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gRlVOQ0lPTkVTIEVOVEVSUFJJU0UgUEFSQSBSQVRFIExJTUlUSU5HXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4vKipcclxuICogUmF0ZSBsaW1pdGluZyBlbnRlcnByaXNlIGNvbiBzbGlkaW5nIHdpbmRvd1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVudGVycHJpc2VSYXRlTGltaXQoXHJcbiAga2V5OiBzdHJpbmcsXHJcbiAgd2luZG93TXM6IG51bWJlcixcclxuICBtYXhSZXF1ZXN0czogbnVtYmVyXHJcbik6IFByb21pc2U8e1xyXG4gIGFsbG93ZWQ6IGJvb2xlYW47XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICByZW1haW5pbmc6IG51bWJlcjtcclxuICByZXNldFRpbWU6IG51bWJlcjtcclxuICByZXRyeUFmdGVyPzogbnVtYmVyO1xyXG59IHwgbnVsbD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjbGllbnQgPSBnZXRSZWRpc0NsaWVudCgpO1xyXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IHdpbmRvdyA9IE1hdGguZmxvb3Iobm93IC8gd2luZG93TXMpO1xyXG4gICAgY29uc3QgcmVkaXNLZXkgPSBgcmF0ZV9saW1pdDoke2tleX06JHt3aW5kb3d9YDtcclxuXHJcbiAgICAvLyBVc2FyIHBpcGVsaW5lIHBhcmEgb3BlcmFjaW9uZXMgYXTDs21pY2FzXHJcbiAgICBjb25zdCBwaXBlbGluZSA9IGNsaWVudC5waXBlbGluZSgpO1xyXG4gICAgcGlwZWxpbmUuaW5jcihyZWRpc0tleSk7XHJcbiAgICBwaXBlbGluZS5leHBpcmUocmVkaXNLZXksIE1hdGguY2VpbCh3aW5kb3dNcyAvIDEwMDApKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcGlwZWxpbmUuZXhlYygpO1xyXG5cclxuICAgIGlmICghcmVzdWx0cyB8fCByZXN1bHRzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb3VudCA9IHJlc3VsdHNbMF1bMV0gYXMgbnVtYmVyO1xyXG4gICAgY29uc3QgcmVtYWluaW5nID0gTWF0aC5tYXgoMCwgbWF4UmVxdWVzdHMgLSBjb3VudCk7XHJcbiAgICBjb25zdCByZXNldFRpbWUgPSAod2luZG93ICsgMSkgKiB3aW5kb3dNcztcclxuICAgIGNvbnN0IGFsbG93ZWQgPSBjb3VudCA8PSBtYXhSZXF1ZXN0cztcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSB7XHJcbiAgICAgIGFsbG93ZWQsXHJcbiAgICAgIGNvdW50LFxyXG4gICAgICByZW1haW5pbmcsXHJcbiAgICAgIHJlc2V0VGltZSxcclxuICAgICAgcmV0cnlBZnRlcjogYWxsb3dlZCA/IHVuZGVmaW5lZCA6IE1hdGguY2VpbCgocmVzZXRUaW1lIC0gbm93KSAvIDEwMDApXHJcbiAgICB9O1xyXG5cclxuICAgIGxvZ2dlci5kZWJ1ZyhMb2dDYXRlZ29yeS5BUEksICdFbnRlcnByaXNlIHJhdGUgbGltaXQgY2hlY2snLCB7XHJcbiAgICAgIGtleTogcmVkaXNLZXksXHJcbiAgICAgIGNvdW50LFxyXG4gICAgICBtYXhSZXF1ZXN0cyxcclxuICAgICAgYWxsb3dlZCxcclxuICAgICAgcmVtYWluaW5nXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnRW50ZXJwcmlzZSByYXRlIGxpbWl0IGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJhdGUgbGltaXRpbmcgY29uIG3Dumx0aXBsZXMgdmVudGFuYXMgKG3DoXMgcHJlY2lzbylcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGlkaW5nV2luZG93UmF0ZUxpbWl0KFxyXG4gIGtleTogc3RyaW5nLFxyXG4gIHdpbmRvd01zOiBudW1iZXIsXHJcbiAgbWF4UmVxdWVzdHM6IG51bWJlcixcclxuICBwcmVjaXNpb246IG51bWJlciA9IDEwXHJcbik6IFByb21pc2U8e1xyXG4gIGFsbG93ZWQ6IGJvb2xlYW47XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICByZW1haW5pbmc6IG51bWJlcjtcclxuICByZXNldFRpbWU6IG51bWJlcjtcclxufSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2xpZW50ID0gZ2V0UmVkaXNDbGllbnQoKTtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCB3aW5kb3dTaXplID0gTWF0aC5mbG9vcih3aW5kb3dNcyAvIHByZWNpc2lvbik7XHJcbiAgICBjb25zdCBjdXJyZW50V2luZG93ID0gTWF0aC5mbG9vcihub3cgLyB3aW5kb3dTaXplKTtcclxuXHJcbiAgICAvLyBMaW1waWFyIHZlbnRhbmFzIGFudGlndWFzIHkgY29udGFyIHJlcXVlc3RzIGVuIHZlbnRhbmEgYWN0dWFsXHJcbiAgICBjb25zdCBwaXBlbGluZSA9IGNsaWVudC5waXBlbGluZSgpO1xyXG5cclxuICAgIC8vIEVsaW1pbmFyIHZlbnRhbmFzIG3DoXMgYW50aWd1YXMgcXVlIGVsIHBlcsOtb2RvIGRlIHJhdGUgbGltaXRpbmdcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHByZWNpc2lvbjsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IG9sZFdpbmRvdyA9IGN1cnJlbnRXaW5kb3cgLSBwcmVjaXNpb24gLSBpO1xyXG4gICAgICBwaXBlbGluZS5kZWwoYCR7a2V5fToke29sZFdpbmRvd31gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbmNyZW1lbnRhciBjb250YWRvciBwYXJhIHZlbnRhbmEgYWN0dWFsXHJcbiAgICBjb25zdCBjdXJyZW50S2V5ID0gYCR7a2V5fToke2N1cnJlbnRXaW5kb3d9YDtcclxuICAgIHBpcGVsaW5lLmluY3IoY3VycmVudEtleSk7XHJcbiAgICBwaXBlbGluZS5leHBpcmUoY3VycmVudEtleSwgTWF0aC5jZWlsKHdpbmRvd01zIC8gMTAwMCkpO1xyXG5cclxuICAgIC8vIE9idGVuZXIgY29udGFkb3JlcyBkZSB0b2RhcyBsYXMgdmVudGFuYXMgZW4gZWwgcGVyw61vZG9cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlY2lzaW9uOyBpKyspIHtcclxuICAgICAgY29uc3Qgd2luZG93S2V5ID0gYCR7a2V5fToke2N1cnJlbnRXaW5kb3cgLSBpfWA7XHJcbiAgICAgIHBpcGVsaW5lLmdldCh3aW5kb3dLZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBwaXBlbGluZS5leGVjKCk7XHJcblxyXG4gICAgaWYgKCFyZXN1bHRzKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGFyIHRvdGFsIGRlIHJlcXVlc3RzIGVuIGxhIHZlbnRhbmEgZGVzbGl6YW50ZVxyXG4gICAgbGV0IHRvdGFsQ291bnQgPSAwO1xyXG4gICAgY29uc3QgY291bnRSZXN1bHRzID0gcmVzdWx0cy5zbGljZShwcmVjaXNpb24gKyAyKTsgLy8gU2FsdGFyIG9wZXJhY2lvbmVzIGRlIGxpbXBpZXphIGUgaW5jcmVtZW50b1xyXG5cclxuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIGNvdW50UmVzdWx0cykge1xyXG4gICAgICBpZiAocmVzdWx0WzFdKSB7XHJcbiAgICAgICAgdG90YWxDb3VudCArPSBwYXJzZUludChyZXN1bHRbMV0gYXMgc3RyaW5nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlbWFpbmluZyA9IE1hdGgubWF4KDAsIG1heFJlcXVlc3RzIC0gdG90YWxDb3VudCk7XHJcbiAgICBjb25zdCBhbGxvd2VkID0gdG90YWxDb3VudCA8PSBtYXhSZXF1ZXN0cztcclxuICAgIGNvbnN0IHJlc2V0VGltZSA9IChjdXJyZW50V2luZG93ICsgMSkgKiB3aW5kb3dTaXplO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIGFsbG93ZWQsXHJcbiAgICAgIGNvdW50OiB0b3RhbENvdW50LFxyXG4gICAgICByZW1haW5pbmcsXHJcbiAgICAgIHJlc2V0VGltZVxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ1NsaWRpbmcgd2luZG93IHJhdGUgbGltaXQgZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogT2J0ZW5lciBlc3RhZMOtc3RpY2FzIGRlIHJhdGUgbGltaXRpbmdcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSYXRlTGltaXRTdGF0cyhwYXR0ZXJuOiBzdHJpbmcgPSAncmF0ZV9saW1pdDoqJyk6IFByb21pc2U8e1xyXG4gIHRvdGFsS2V5czogbnVtYmVyO1xyXG4gIGFjdGl2ZVdpbmRvd3M6IG51bWJlcjtcclxuICB0b3BLZXlzOiBBcnJheTx7IGtleTogc3RyaW5nOyBjb3VudDogbnVtYmVyOyB0dGw6IG51bWJlciB9PjtcclxufSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2xpZW50ID0gZ2V0UmVkaXNDbGllbnQoKTtcclxuICAgIGNvbnN0IGtleXMgPSBhd2FpdCBjbGllbnQua2V5cyhwYXR0ZXJuKTtcclxuXHJcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbEtleXM6IDAsXHJcbiAgICAgICAgYWN0aXZlV2luZG93czogMCxcclxuICAgICAgICB0b3BLZXlzOiBbXVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9idGVuZXIgaW5mb3JtYWNpw7NuIGRlIGxhcyBjbGF2ZXMgbcOhcyBhY3RpdmFzXHJcbiAgICBjb25zdCBwaXBlbGluZSA9IGNsaWVudC5waXBlbGluZSgpO1xyXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIHBpcGVsaW5lLmdldChrZXkpO1xyXG4gICAgICBwaXBlbGluZS50dGwoa2V5KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBwaXBlbGluZS5leGVjKCk7XHJcblxyXG4gICAgaWYgKCFyZXN1bHRzKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGtleVN0YXRzOiBBcnJheTx7IGtleTogc3RyaW5nOyBjb3VudDogbnVtYmVyOyB0dGw6IG51bWJlciB9PiA9IFtdO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBjb3VudFJlc3VsdCA9IHJlc3VsdHNbaSAqIDJdO1xyXG4gICAgICBjb25zdCB0dGxSZXN1bHQgPSByZXN1bHRzW2kgKiAyICsgMV07XHJcblxyXG4gICAgICBpZiAoY291bnRSZXN1bHRbMV0gJiYgdHRsUmVzdWx0WzFdKSB7XHJcbiAgICAgICAga2V5U3RhdHMucHVzaCh7XHJcbiAgICAgICAgICBrZXk6IGtleXNbaV0sXHJcbiAgICAgICAgICBjb3VudDogcGFyc2VJbnQoY291bnRSZXN1bHRbMV0gYXMgc3RyaW5nKSxcclxuICAgICAgICAgIHR0bDogdHRsUmVzdWx0WzFdIGFzIG51bWJlclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3JkZW5hciBwb3IgY291bnQgZGVzY2VuZGVudGVcclxuICAgIGtleVN0YXRzLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbEtleXM6IGtleXMubGVuZ3RoLFxyXG4gICAgICBhY3RpdmVXaW5kb3dzOiBrZXlTdGF0cy5maWx0ZXIoc3RhdCA9PiBzdGF0LnR0bCA+IDApLmxlbmd0aCxcclxuICAgICAgdG9wS2V5czoga2V5U3RhdHMuc2xpY2UoMCwgMTApIC8vIFRvcCAxMFxyXG4gICAgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ1JhdGUgbGltaXQgc3RhdHMgZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTGltcGlhciBjbGF2ZXMgZGUgcmF0ZSBsaW1pdGluZyBleHBpcmFkYXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGVhbnVwUmF0ZUxpbWl0S2V5cyhwYXR0ZXJuOiBzdHJpbmcgPSAncmF0ZV9saW1pdDoqJyk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNsaWVudCA9IGdldFJlZGlzQ2xpZW50KCk7XHJcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgY2xpZW50LmtleXMocGF0dGVybik7XHJcblxyXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZlcmlmaWNhciBUVEwgZGUgY2FkYSBjbGF2ZSB5IGVsaW1pbmFyIGxhcyBleHBpcmFkYXNcclxuICAgIGNvbnN0IHBpcGVsaW5lID0gY2xpZW50LnBpcGVsaW5lKCk7XHJcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgcGlwZWxpbmUudHRsKGtleSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB0dGxSZXN1bHRzID0gYXdhaXQgcGlwZWxpbmUuZXhlYygpO1xyXG5cclxuICAgIGlmICghdHRsUmVzdWx0cykge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBleHBpcmVkS2V5czogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgdHRsUmVzdWx0ID0gdHRsUmVzdWx0c1tpXTtcclxuICAgICAgaWYgKHR0bFJlc3VsdFsxXSA9PT0gLTIpIHsgLy8gQ2xhdmUgZXhwaXJhZGFcclxuICAgICAgICBleHBpcmVkS2V5cy5wdXNoKGtleXNbaV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGV4cGlyZWRLZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgYXdhaXQgY2xpZW50LmRlbCguLi5leHBpcmVkS2V5cyk7XHJcbiAgICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgYENsZWFuZWQgdXAgJHtleHBpcmVkS2V5cy5sZW5ndGh9IGV4cGlyZWQgcmF0ZSBsaW1pdCBrZXlzYCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV4cGlyZWRLZXlzLmxlbmd0aDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ1JhdGUgbGltaXQgY2xlYW51cCBmYWlsZWQnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9ydGFyIGNsaWVudGUgUmVkaXMgcGFyYSB1c28gZGlyZWN0b1xyXG5leHBvcnQgY29uc3QgcmVkaXMgPSBnZXRSZWRpc0NsaWVudCgpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOlsiUmVkaXNDYWNoZSIsImNsZWFudXBSYXRlTGltaXRLZXlzIiwiY2xvc2VSZWRpc0Nvbm5lY3Rpb24iLCJlbnRlcnByaXNlUmF0ZUxpbWl0IiwiZ2V0UmF0ZUxpbWl0SW5mbyIsImdldFJhdGVMaW1pdFN0YXRzIiwiZ2V0UmVkaXNDbGllbnQiLCJpbmNyZW1lbnRSYXRlTGltaXQiLCJpc1JlZGlzQXZhaWxhYmxlIiwicmVkaXMiLCJyZWRpc0NhY2hlIiwic2xpZGluZ1dpbmRvd1JhdGVMaW1pdCIsIlJFRElTX0NPTkZJRyIsImhvc3QiLCJwcm9jZXNzIiwiZW52IiwiUkVESVNfSE9TVCIsInBvcnQiLCJwYXJzZUludCIsIlJFRElTX1BPUlQiLCJwYXNzd29yZCIsIlJFRElTX1BBU1NXT1JEIiwiZGIiLCJSRURJU19EQiIsInJldHJ5RGVsYXlPbkZhaWxvdmVyIiwibWF4UmV0cmllc1BlclJlcXVlc3QiLCJsYXp5Q29ubmVjdCIsImtlZXBBbGl2ZSIsImNvbm5lY3RUaW1lb3V0IiwiY29tbWFuZFRpbWVvdXQiLCJNb2NrUmVkaXMiLCJnZXQiLCJrZXkiLCJzdG9yYWdlIiwic2V0IiwidmFsdWUiLCJhcmdzIiwiZGVsIiwiZXhpc3RlZCIsImhhcyIsImRlbGV0ZSIsImV4aXN0cyIsImluY3IiLCJjdXJyZW50IiwibmV3VmFsdWUiLCJ0b1N0cmluZyIsImV4cGlyZSIsInNlY29uZHMiLCJrZXlzIiwicGF0dGVybiIsInJlZ2V4IiwiUmVnRXhwIiwicmVwbGFjZSIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsInRlc3QiLCJmbHVzaGFsbCIsImNsZWFyIiwibHB1c2giLCJ2YWx1ZXMiLCJsaXN0IiwidW5zaGlmdCIsImxlbmd0aCIsImx0cmltIiwic3RhcnQiLCJzdG9wIiwidHJpbW1lZCIsInNsaWNlIiwibHJhbmdlIiwidHRsIiwicGlwZWxpbmUiLCJNb2NrUGlwZWxpbmUiLCJjb25uZWN0IiwiY29uc29sZSIsImxvZyIsImRpc2Nvbm5lY3QiLCJvbiIsImV2ZW50IiwiY2FsbGJhY2siLCJxdWl0IiwiTWFwIiwiY29tbWFuZHMiLCJwdXNoIiwibWV0aG9kIiwiZXhlYyIsInJlc3VsdHMiLCJjb21tYW5kIiwicmVzdWx0IiwiZXJyb3IiLCJyZWRpc0NsaWVudCIsImlzVXNpbmdNb2NrIiwiRElTQUJMRV9SRURJUyIsIlJlZGlzIiwibG9nZ2VyIiwiaW5mbyIsIkxvZ0NhdGVnb3J5IiwiQVBJIiwid2FybiIsIm1lc3NhZ2UiLCJjbGllbnQiLCJwaW5nIiwidHRsU2Vjb25kcyIsInNldGV4IiwiY291bnRSZXN1bHQiLCJ0dGxSZXN1bHQiLCJjb3VudCIsIndpbmRvd1NlY29uZHMiLCJpc05ld1dpbmRvdyIsIndpbmRvd01zIiwibWF4UmVxdWVzdHMiLCJub3ciLCJEYXRlIiwid2luZG93IiwiTWF0aCIsImZsb29yIiwicmVkaXNLZXkiLCJjZWlsIiwicmVtYWluaW5nIiwibWF4IiwicmVzZXRUaW1lIiwiYWxsb3dlZCIsInJldHJ5QWZ0ZXIiLCJ1bmRlZmluZWQiLCJkZWJ1ZyIsInByZWNpc2lvbiIsIndpbmRvd1NpemUiLCJjdXJyZW50V2luZG93IiwiaSIsIm9sZFdpbmRvdyIsImN1cnJlbnRLZXkiLCJ3aW5kb3dLZXkiLCJ0b3RhbENvdW50IiwiY291bnRSZXN1bHRzIiwidG90YWxLZXlzIiwiYWN0aXZlV2luZG93cyIsInRvcEtleXMiLCJmb3JFYWNoIiwia2V5U3RhdHMiLCJzb3J0IiwiYSIsImIiLCJzdGF0IiwidHRsUmVzdWx0cyIsImV4cGlyZWRLZXlzIl0sIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0M7QUFDdEMsMkNBQTJDO0FBQzNDLHNDQUFzQzs7Ozs7Ozs7Ozs7O1FBMFB6QkE7ZUFBQUE7O1FBeVdTQztlQUFBQTs7UUFwWEFDO2VBQUFBOztRQW1MQUM7ZUFBQUE7O1FBbkVBQztlQUFBQTs7UUFzTUFDO2VBQUFBOztRQTVYTkM7ZUFBQUE7O1FBaU5NQztlQUFBQTs7UUEvSkFDO2VBQUFBOztRQW1iVEM7ZUFBQUE7O1FBbFRBQztlQUFBQTs7UUFpSVNDO2VBQUFBOzs7Z0VBM2RKO3dCQUM0Qjs7Ozs7O0FBRTlDLHlCQUF5QjtBQUN6QixNQUFNQyxlQUFlO0lBQ25CQyxNQUFNQyxRQUFRQyxHQUFHLENBQUNDLFVBQVUsSUFBSTtJQUNoQ0MsTUFBTUMsU0FBU0osUUFBUUMsR0FBRyxDQUFDSSxVQUFVLElBQUk7SUFDekNDLFVBQVVOLFFBQVFDLEdBQUcsQ0FBQ00sY0FBYztJQUNwQ0MsSUFBSUosU0FBU0osUUFBUUMsR0FBRyxDQUFDUSxRQUFRLElBQUk7SUFDckNDLHNCQUFzQjtJQUN0QkMsc0JBQXNCO0lBQ3RCQyxhQUFhO0lBQ2JDLFdBQVc7SUFDWEMsZ0JBQWdCO0lBQ2hCQyxnQkFBZ0I7QUFDbEI7QUFFQSw2REFBNkQ7QUFDN0QsTUFBTUM7SUFHSixNQUFNQyxJQUFJQyxHQUFXLEVBQTBCO1FBQzdDLE9BQU8sSUFBSSxDQUFDQyxPQUFPLENBQUNGLEdBQUcsQ0FBQ0MsUUFBUTtJQUNsQztJQUVBLE1BQU1FLElBQUlGLEdBQVcsRUFBRUcsS0FBVSxFQUFFLEdBQUdDLElBQVcsRUFBaUI7UUFDaEUsSUFBSSxDQUFDSCxPQUFPLENBQUNDLEdBQUcsQ0FBQ0YsS0FBS0c7UUFDdEIsT0FBTztJQUNUO0lBRUEsTUFBTUUsSUFBSUwsR0FBVyxFQUFtQjtRQUN0QyxNQUFNTSxVQUFVLElBQUksQ0FBQ0wsT0FBTyxDQUFDTSxHQUFHLENBQUNQO1FBQ2pDLElBQUksQ0FBQ0MsT0FBTyxDQUFDTyxNQUFNLENBQUNSO1FBQ3BCLE9BQU9NLFVBQVUsSUFBSTtJQUN2QjtJQUVBLE1BQU1HLE9BQU9ULEdBQVcsRUFBbUI7UUFDekMsT0FBTyxJQUFJLENBQUNDLE9BQU8sQ0FBQ00sR0FBRyxDQUFDUCxPQUFPLElBQUk7SUFDckM7SUFFQSxNQUFNVSxLQUFLVixHQUFXLEVBQW1CO1FBQ3ZDLE1BQU1XLFVBQVV6QixTQUFTLElBQUksQ0FBQ2UsT0FBTyxDQUFDRixHQUFHLENBQUNDLFFBQVE7UUFDbEQsTUFBTVksV0FBV0QsVUFBVTtRQUMzQixJQUFJLENBQUNWLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDRixLQUFLWSxTQUFTQyxRQUFRO1FBQ3ZDLE9BQU9EO0lBQ1Q7SUFFQSxNQUFNRSxPQUFPZCxHQUFXLEVBQUVlLE9BQWUsRUFBbUI7UUFDMUQseUNBQXlDO1FBQ3pDLE9BQU87SUFDVDtJQUVBLE1BQU1DLEtBQUtDLE9BQWUsRUFBcUI7UUFDN0MsTUFBTUMsUUFBUSxJQUFJQyxPQUFPRixRQUFRRyxPQUFPLENBQUMsT0FBTztRQUNoRCxPQUFPQyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDckIsT0FBTyxDQUFDZSxJQUFJLElBQUlPLE1BQU0sQ0FBQ3ZCLENBQUFBLE1BQU9rQixNQUFNTSxJQUFJLENBQUN4QjtJQUNsRTtJQUVBLE1BQU15QixXQUEwQjtRQUM5QixJQUFJLENBQUN4QixPQUFPLENBQUN5QixLQUFLO1FBQ2xCLE9BQU87SUFDVDtJQUVBLGtDQUFrQztJQUNsQyxNQUFNQyxNQUFNM0IsR0FBVyxFQUFFLEdBQUc0QixNQUFnQixFQUFtQjtRQUM3RCxNQUFNQyxPQUFPLElBQUksQ0FBQzVCLE9BQU8sQ0FBQ0YsR0FBRyxDQUFDQyxRQUFRLEVBQUU7UUFDeEM2QixLQUFLQyxPQUFPLElBQUlGO1FBQ2hCLElBQUksQ0FBQzNCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDRixLQUFLNkI7UUFDdEIsT0FBT0EsS0FBS0UsTUFBTTtJQUNwQjtJQUVBLE1BQU1DLE1BQU1oQyxHQUFXLEVBQUVpQyxLQUFhLEVBQUVDLElBQVksRUFBaUI7UUFDbkUsTUFBTUwsT0FBTyxJQUFJLENBQUM1QixPQUFPLENBQUNGLEdBQUcsQ0FBQ0MsUUFBUSxFQUFFO1FBQ3hDLE1BQU1tQyxVQUFVTixLQUFLTyxLQUFLLENBQUNILE9BQU9DLE9BQU87UUFDekMsSUFBSSxDQUFDakMsT0FBTyxDQUFDQyxHQUFHLENBQUNGLEtBQUttQztRQUN0QixPQUFPO0lBQ1Q7SUFFQSxNQUFNRSxPQUFPckMsR0FBVyxFQUFFaUMsS0FBYSxFQUFFQyxJQUFZLEVBQXFCO1FBQ3hFLE1BQU1MLE9BQU8sSUFBSSxDQUFDNUIsT0FBTyxDQUFDRixHQUFHLENBQUNDLFFBQVEsRUFBRTtRQUN4QyxJQUFJa0MsU0FBUyxDQUFDLEdBQUc7WUFDZixPQUFPTCxLQUFLTyxLQUFLLENBQUNIO1FBQ3BCO1FBQ0EsT0FBT0osS0FBS08sS0FBSyxDQUFDSCxPQUFPQyxPQUFPO0lBQ2xDO0lBRUEsTUFBTUksSUFBSXRDLEdBQVcsRUFBbUI7UUFDdEMscURBQXFEO1FBQ3JELE9BQU8sSUFBSSxDQUFDQyxPQUFPLENBQUNNLEdBQUcsQ0FBQ1AsT0FBTyxPQUFPLENBQUM7SUFDekM7SUFFQSx1Q0FBdUM7SUFDdkN1QyxXQUF5QjtRQUN2QixPQUFPLElBQUlDLGFBQWEsSUFBSTtJQUM5QjtJQUVBLDJCQUEyQjtJQUMzQixNQUFNQyxVQUF5QjtRQUM3QkMsUUFBUUMsR0FBRyxDQUFDO0lBQ2Q7SUFFQUMsYUFBbUI7UUFDakJGLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0lBRUFFLEdBQUdDLEtBQWEsRUFBRUMsUUFBa0IsRUFBUTtRQUMxQyxPQUFPLElBQUk7SUFDYjtJQUVBLE1BQU1DLE9BQXNCO1FBQzFCTixRQUFRQyxHQUFHLENBQUM7UUFDWixPQUFPO0lBQ1Q7O2FBNUZRMUMsVUFBVSxJQUFJZ0Q7O0FBNkZ4QjtBQUVBLHVDQUF1QztBQUN2QyxNQUFNVDtJQUlKLFlBQVkvRCxLQUFnQixDQUFFO2FBSHRCeUUsV0FBbUQsRUFBRTtRQUkzRCxJQUFJLENBQUN6RSxLQUFLLEdBQUdBO0lBQ2Y7SUFFQXNCLElBQUlDLEdBQVcsRUFBUTtRQUNyQixJQUFJLENBQUNrRCxRQUFRLENBQUNDLElBQUksQ0FBQztZQUFFQyxRQUFRO1lBQU9oRCxNQUFNO2dCQUFDSjthQUFJO1FBQUM7UUFDaEQsT0FBTyxJQUFJO0lBQ2I7SUFFQXNDLElBQUl0QyxHQUFXLEVBQVE7UUFDckIsSUFBSSxDQUFDa0QsUUFBUSxDQUFDQyxJQUFJLENBQUM7WUFBRUMsUUFBUTtZQUFPaEQsTUFBTTtnQkFBQ0o7YUFBSTtRQUFDO1FBQ2hELE9BQU8sSUFBSTtJQUNiO0lBRUFVLEtBQUtWLEdBQVcsRUFBUTtRQUN0QixJQUFJLENBQUNrRCxRQUFRLENBQUNDLElBQUksQ0FBQztZQUFFQyxRQUFRO1lBQVFoRCxNQUFNO2dCQUFDSjthQUFJO1FBQUM7UUFDakQsT0FBTyxJQUFJO0lBQ2I7SUFFQWMsT0FBT2QsR0FBVyxFQUFFZSxPQUFlLEVBQVE7UUFDekMsSUFBSSxDQUFDbUMsUUFBUSxDQUFDQyxJQUFJLENBQUM7WUFBRUMsUUFBUTtZQUFVaEQsTUFBTTtnQkFBQ0o7Z0JBQUtlO2FBQVE7UUFBQztRQUM1RCxPQUFPLElBQUk7SUFDYjtJQUVBLE1BQU1zQyxPQUE0QztRQUNoRCxNQUFNQyxVQUFzQyxFQUFFO1FBRTlDLEtBQUssTUFBTUMsV0FBVyxJQUFJLENBQUNMLFFBQVEsQ0FBRTtZQUNuQyxJQUFJO2dCQUNGLE1BQU1NLFNBQVMsTUFBTSxBQUFDLElBQUksQ0FBQy9FLEtBQUssQUFBUSxDQUFDOEUsUUFBUUgsTUFBTSxDQUFDLElBQUlHLFFBQVFuRCxJQUFJO2dCQUN4RWtELFFBQVFILElBQUksQ0FBQztvQkFBQztvQkFBTUs7aUJBQU87WUFDN0IsRUFBRSxPQUFPQyxPQUFPO2dCQUNkSCxRQUFRSCxJQUFJLENBQUM7b0JBQUNNO29CQUFnQjtpQkFBSztZQUNyQztRQUNGO1FBRUEsSUFBSSxDQUFDUCxRQUFRLEdBQUcsRUFBRSxFQUFFLHVDQUF1QztRQUMzRCxPQUFPSTtJQUNUO0FBQ0Y7QUFFQSwwQkFBMEI7QUFDMUIsSUFBSUksY0FBd0M7QUFDNUMsSUFBSUMsY0FBYztBQUtYLFNBQVNyRjtJQUNkLElBQUksQ0FBQ29GLGFBQWE7UUFDaEIsd0NBQXdDO1FBQ3hDLElBQUk1RSxRQUFRQyxHQUFHLENBQUM2RSxhQUFhLEtBQUssUUFBUTtZQUN4Q2xCLFFBQVFDLEdBQUcsQ0FBQztZQUNaZSxjQUFjLElBQUk1RDtZQUNsQjZELGNBQWM7WUFDZCxPQUFPRDtRQUNUO1FBRUEsSUFBSTtZQUNGQSxjQUFjLElBQUlHLGdCQUFLLENBQUNqRjtZQUV4QiwrQkFBK0I7WUFDL0I4RSxZQUFZYixFQUFFLENBQUMsV0FBVztnQkFDeEJpQixjQUFNLENBQUNDLElBQUksQ0FBQ0MsbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFO2dCQUM3Qk4sY0FBYztZQUNoQjtZQUVBRCxZQUFZYixFQUFFLENBQUMsU0FBUyxDQUFDWTtnQkFDdkJLLGNBQU0sQ0FBQ0wsS0FBSyxDQUFDTyxtQkFBVyxDQUFDQyxHQUFHLEVBQUUsMEJBQTBCUjtnQkFDeEQsc0NBQXNDO2dCQUN0QyxJQUFJLENBQUNFLGFBQWE7b0JBQ2hCakIsUUFBUUMsR0FBRyxDQUFDO29CQUNaZSxjQUFjLElBQUk1RDtvQkFDbEI2RCxjQUFjO2dCQUNoQjtZQUNGO1lBRUFELFlBQVliLEVBQUUsQ0FBQyxTQUFTO2dCQUN0QmlCLGNBQU0sQ0FBQ0ksSUFBSSxDQUFDRixtQkFBVyxDQUFDQyxHQUFHLEVBQUU7WUFDL0I7WUFFQVAsWUFBWWIsRUFBRSxDQUFDLGdCQUFnQjtnQkFDN0JpQixjQUFNLENBQUNDLElBQUksQ0FBQ0MsbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFO1lBQy9CO1FBRUYsRUFBRSxPQUFPUixPQUFPO1lBQ2RmLFFBQVFDLEdBQUcsQ0FBQyxtREFBbURjLE1BQU1VLE9BQU87WUFDNUVULGNBQWMsSUFBSTVEO1lBQ2xCNkQsY0FBYztRQUNoQjtJQUNGO0lBRUEsT0FBT0Q7QUFDVDtBQUtPLGVBQWVsRjtJQUNwQixJQUFJO1FBQ0YsSUFBSW1GLGFBQWE7WUFDZixPQUFPLE9BQU8sd0JBQXdCO1FBQ3hDO1FBQ0EsTUFBTVMsU0FBUzlGO1FBQ2YsSUFBSThGLGtCQUFrQnRFLFdBQVc7WUFDL0IsT0FBTztRQUNUO1FBQ0EsTUFBTSxBQUFDc0UsT0FBaUJDLElBQUk7UUFDNUIsT0FBTztJQUNULEVBQUUsT0FBT1osT0FBTztRQUNkSyxjQUFNLENBQUNMLEtBQUssQ0FBQ08sbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFLDZCQUE2QlI7UUFDM0QsT0FBTztJQUNUO0FBQ0Y7QUFLTyxlQUFldkY7SUFDcEIsSUFBSXdGLGFBQWE7UUFDZixNQUFNQSxZQUFZVixJQUFJO1FBQ3RCVSxjQUFjO1FBQ2RJLGNBQU0sQ0FBQ0MsSUFBSSxDQUFDQyxtQkFBVyxDQUFDQyxHQUFHLEVBQUU7SUFDL0I7QUFDRjtBQUtPLE1BQU1qRztJQUdYLGFBQWM7UUFDWixJQUFJLENBQUNvRyxNQUFNLEdBQUc5RjtJQUNoQjtJQUVBOztHQUVDLEdBQ0QsTUFBTXlCLElBQUlDLEdBQVcsRUFBMEI7UUFDN0MsSUFBSTtZQUNGLE1BQU1HLFFBQVEsTUFBTSxJQUFJLENBQUNpRSxNQUFNLENBQUNyRSxHQUFHLENBQUNDO1lBQ3BDOEQsY0FBTSxDQUFDQyxJQUFJLENBQUNDLG1CQUFXLENBQUNDLEdBQUcsRUFBRTtZQUM3QixPQUFPOUQ7UUFDVCxFQUFFLE9BQU9zRCxPQUFPO1lBQ2RLLGNBQU0sQ0FBQ0wsS0FBSyxDQUFDTyxtQkFBVyxDQUFDQyxHQUFHLEVBQUUsOEJBQThCUjtZQUM1RCxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTXZELElBQUlGLEdBQVcsRUFBRUcsS0FBYSxFQUFFbUUsVUFBbUIsRUFBb0I7UUFDM0UsSUFBSTtZQUNGLElBQUlBLFlBQVk7Z0JBQ2QsTUFBTSxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csS0FBSyxDQUFDdkUsS0FBS3NFLFlBQVluRTtZQUMzQyxPQUFPO2dCQUNMLE1BQU0sSUFBSSxDQUFDaUUsTUFBTSxDQUFDbEUsR0FBRyxDQUFDRixLQUFLRztZQUM3QjtZQUVBMkQsY0FBTSxDQUFDQyxJQUFJLENBQUNDLG1CQUFXLENBQUNDLEdBQUcsRUFBRTtZQUM3QixPQUFPO1FBQ1QsRUFBRSxPQUFPUixPQUFPO1lBQ2RLLGNBQU0sQ0FBQ0wsS0FBSyxDQUFDTyxtQkFBVyxDQUFDQyxHQUFHLEVBQUUsOEJBQThCUjtZQUM1RCxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTXBELElBQUlMLEdBQVcsRUFBb0I7UUFDdkMsSUFBSTtZQUNGLE1BQU13RCxTQUFTLE1BQU0sSUFBSSxDQUFDWSxNQUFNLENBQUMvRCxHQUFHLENBQUNMO1lBQ3JDOEQsY0FBTSxDQUFDQyxJQUFJLENBQUNDLG1CQUFXLENBQUNDLEdBQUcsRUFBRTtZQUM3QixPQUFPVCxTQUFTO1FBQ2xCLEVBQUUsT0FBT0MsT0FBTztZQUNkSyxjQUFNLENBQUNMLEtBQUssQ0FBQ08sbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFLGlDQUFpQ1I7WUFDL0QsT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU0vQyxLQUFLVixHQUFXLEVBQTBCO1FBQzlDLElBQUk7WUFDRixNQUFNd0QsU0FBUyxNQUFNLElBQUksQ0FBQ1ksTUFBTSxDQUFDMUQsSUFBSSxDQUFDVjtZQUN0QzhELGNBQU0sQ0FBQ0MsSUFBSSxDQUFDQyxtQkFBVyxDQUFDQyxHQUFHLEVBQUU7WUFDN0IsT0FBT1Q7UUFDVCxFQUFFLE9BQU9DLE9BQU87WUFDZEssY0FBTSxDQUFDTCxLQUFLLENBQUNPLG1CQUFXLENBQUNDLEdBQUcsRUFBRSxvQ0FBb0NSO1lBQ2xFLE9BQU87UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNM0MsT0FBT2QsR0FBVyxFQUFFc0UsVUFBa0IsRUFBb0I7UUFDOUQsSUFBSTtZQUNGLE1BQU1kLFNBQVMsTUFBTSxJQUFJLENBQUNZLE1BQU0sQ0FBQ3RELE1BQU0sQ0FBQ2QsS0FBS3NFO1lBQzdDUixjQUFNLENBQUNDLElBQUksQ0FBQ0MsbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFO1lBQzdCLE9BQU9ULFdBQVc7UUFDcEIsRUFBRSxPQUFPQyxPQUFPO1lBQ2RLLGNBQU0sQ0FBQ0wsS0FBSyxDQUFDTyxtQkFBVyxDQUFDQyxHQUFHLEVBQUUsaUNBQWlDUjtZQUMvRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTW5CLElBQUl0QyxHQUFXLEVBQTBCO1FBQzdDLElBQUk7WUFDRixNQUFNd0QsU0FBUyxNQUFNLElBQUksQ0FBQ1ksTUFBTSxDQUFDOUIsR0FBRyxDQUFDdEM7WUFDckM4RCxjQUFNLENBQUNDLElBQUksQ0FBQ0MsbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFO1lBQzdCLE9BQU9UO1FBQ1QsRUFBRSxPQUFPQyxPQUFPO1lBQ2RLLGNBQU0sQ0FBQ0wsS0FBSyxDQUFDTyxtQkFBVyxDQUFDQyxHQUFHLEVBQUUsMEJBQTBCUjtZQUN4RCxPQUFPO1FBQ1Q7SUFDRjtBQUNGO0FBR08sTUFBTS9FLGFBQWEsSUFBSVY7QUFHdkIsZUFBZUksaUJBQWlCNEIsR0FBVztJQUloRCxJQUFJO1FBQ0YsTUFBTW9FLFNBQVM5RjtRQUNmLE1BQU1pRSxXQUFXNkIsT0FBTzdCLFFBQVE7UUFDaENBLFNBQVN4QyxHQUFHLENBQUNDO1FBQ2J1QyxTQUFTRCxHQUFHLENBQUN0QztRQUViLE1BQU1zRCxVQUFVLE1BQU1mLFNBQVNjLElBQUk7UUFFbkMsSUFBSSxDQUFDQyxXQUFXQSxRQUFRdkIsTUFBTSxLQUFLLEdBQUc7WUFDcEMsT0FBTztRQUNUO1FBRUEsTUFBTSxDQUFDeUMsYUFBYUMsVUFBVSxHQUFHbkI7UUFDakMsTUFBTW9CLFFBQVF4RixTQUFTc0YsV0FBVyxDQUFDLEVBQUUsS0FBZTtRQUNwRCxNQUFNbEMsTUFBTW1DLFNBQVMsQ0FBQyxFQUFFO1FBRXhCLE9BQU87WUFBRUM7WUFBT3BDO1FBQUk7SUFDdEIsRUFBRSxPQUFPbUIsT0FBTztRQUNkSyxjQUFNLENBQUNMLEtBQUssQ0FBQ08sbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFLG9DQUFvQ1I7UUFDbEUsT0FBTztJQUNUO0FBQ0Y7QUFFTyxlQUFlbEYsbUJBQW1CeUIsR0FBVyxFQUFFMkUsYUFBcUI7SUFLekUsSUFBSTtRQUNGLE1BQU1QLFNBQVM5RjtRQUNmLE1BQU1pRSxXQUFXNkIsT0FBTzdCLFFBQVE7UUFFaEMsdUJBQXVCO1FBQ3ZCQSxTQUFTN0IsSUFBSSxDQUFDVjtRQUNkLDJDQUEyQztRQUMzQ3VDLFNBQVN6QixNQUFNLENBQUNkLEtBQUsyRTtRQUNyQixxQkFBcUI7UUFDckJwQyxTQUFTRCxHQUFHLENBQUN0QztRQUViLE1BQU1zRCxVQUFVLE1BQU1mLFNBQVNjLElBQUk7UUFFbkMsSUFBSSxDQUFDQyxXQUFXQSxRQUFRdkIsTUFBTSxLQUFLLEdBQUc7WUFDcEMsT0FBTztRQUNUO1FBRUEsTUFBTTJDLFFBQVFwQixPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDM0IsTUFBTWhCLE1BQU1nQixPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDekIsTUFBTXNCLGNBQWNGLFVBQVU7UUFFOUIsT0FBTztZQUFFQTtZQUFPcEM7WUFBS3NDO1FBQVk7SUFDbkMsRUFBRSxPQUFPbkIsT0FBTztRQUNkSyxjQUFNLENBQUNMLEtBQUssQ0FBQ08sbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFLCtCQUErQlI7UUFDN0QsT0FBTztJQUNUO0FBQ0Y7QUFTTyxlQUFldEYsb0JBQ3BCNkIsR0FBVyxFQUNYNkUsUUFBZ0IsRUFDaEJDLFdBQW1CO0lBUW5CLElBQUk7UUFDRixNQUFNVixTQUFTOUY7UUFDZixNQUFNeUcsTUFBTUMsS0FBS0QsR0FBRztRQUNwQixNQUFNRSxTQUFTQyxLQUFLQyxLQUFLLENBQUNKLE1BQU1GO1FBQ2hDLE1BQU1PLFdBQVcsQ0FBQyxXQUFXLEVBQUVwRixJQUFJLENBQUMsRUFBRWlGLFFBQVE7UUFFOUMsMENBQTBDO1FBQzFDLE1BQU0xQyxXQUFXNkIsT0FBTzdCLFFBQVE7UUFDaENBLFNBQVM3QixJQUFJLENBQUMwRTtRQUNkN0MsU0FBU3pCLE1BQU0sQ0FBQ3NFLFVBQVVGLEtBQUtHLElBQUksQ0FBQ1IsV0FBVztRQUUvQyxNQUFNdkIsVUFBVSxNQUFNZixTQUFTYyxJQUFJO1FBRW5DLElBQUksQ0FBQ0MsV0FBV0EsUUFBUXZCLE1BQU0sS0FBSyxHQUFHO1lBQ3BDLE9BQU87UUFDVDtRQUVBLE1BQU0yQyxRQUFRcEIsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQzNCLE1BQU1nQyxZQUFZSixLQUFLSyxHQUFHLENBQUMsR0FBR1QsY0FBY0o7UUFDNUMsTUFBTWMsWUFBWSxBQUFDUCxDQUFBQSxTQUFTLENBQUEsSUFBS0o7UUFDakMsTUFBTVksVUFBVWYsU0FBU0k7UUFFekIsTUFBTXRCLFNBQVM7WUFDYmlDO1lBQ0FmO1lBQ0FZO1lBQ0FFO1lBQ0FFLFlBQVlELFVBQVVFLFlBQVlULEtBQUtHLElBQUksQ0FBQyxBQUFDRyxDQUFBQSxZQUFZVCxHQUFFLElBQUs7UUFDbEU7UUFFQWpCLGNBQU0sQ0FBQzhCLEtBQUssQ0FBQzVCLG1CQUFXLENBQUNDLEdBQUcsRUFBRSwrQkFBK0I7WUFDM0RqRSxLQUFLb0Y7WUFDTFY7WUFDQUk7WUFDQVc7WUFDQUg7UUFDRjtRQUVBLE9BQU85QjtJQUNULEVBQUUsT0FBT0MsT0FBTztRQUNkSyxjQUFNLENBQUNMLEtBQUssQ0FBQ08sbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFLGdDQUFnQ1I7UUFDOUQsT0FBTztJQUNUO0FBQ0Y7QUFLTyxlQUFlOUUsdUJBQ3BCcUIsR0FBVyxFQUNYNkUsUUFBZ0IsRUFDaEJDLFdBQW1CLEVBQ25CZSxZQUFvQixFQUFFO0lBT3RCLElBQUk7UUFDRixNQUFNekIsU0FBUzlGO1FBQ2YsTUFBTXlHLE1BQU1DLEtBQUtELEdBQUc7UUFDcEIsTUFBTWUsYUFBYVosS0FBS0MsS0FBSyxDQUFDTixXQUFXZ0I7UUFDekMsTUFBTUUsZ0JBQWdCYixLQUFLQyxLQUFLLENBQUNKLE1BQU1lO1FBRXZDLGdFQUFnRTtRQUNoRSxNQUFNdkQsV0FBVzZCLE9BQU83QixRQUFRO1FBRWhDLGlFQUFpRTtRQUNqRSxJQUFLLElBQUl5RCxJQUFJLEdBQUdBLEtBQUtILFdBQVdHLElBQUs7WUFDbkMsTUFBTUMsWUFBWUYsZ0JBQWdCRixZQUFZRztZQUM5Q3pELFNBQVNsQyxHQUFHLENBQUMsR0FBR0wsSUFBSSxDQUFDLEVBQUVpRyxXQUFXO1FBQ3BDO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU1DLGFBQWEsR0FBR2xHLElBQUksQ0FBQyxFQUFFK0YsZUFBZTtRQUM1Q3hELFNBQVM3QixJQUFJLENBQUN3RjtRQUNkM0QsU0FBU3pCLE1BQU0sQ0FBQ29GLFlBQVloQixLQUFLRyxJQUFJLENBQUNSLFdBQVc7UUFFakQseURBQXlEO1FBQ3pELElBQUssSUFBSW1CLElBQUksR0FBR0EsSUFBSUgsV0FBV0csSUFBSztZQUNsQyxNQUFNRyxZQUFZLEdBQUduRyxJQUFJLENBQUMsRUFBRStGLGdCQUFnQkMsR0FBRztZQUMvQ3pELFNBQVN4QyxHQUFHLENBQUNvRztRQUNmO1FBRUEsTUFBTTdDLFVBQVUsTUFBTWYsU0FBU2MsSUFBSTtRQUVuQyxJQUFJLENBQUNDLFNBQVM7WUFDWixPQUFPO1FBQ1Q7UUFFQSxzREFBc0Q7UUFDdEQsSUFBSThDLGFBQWE7UUFDakIsTUFBTUMsZUFBZS9DLFFBQVFsQixLQUFLLENBQUN5RCxZQUFZLElBQUksOENBQThDO1FBRWpHLEtBQUssTUFBTXJDLFVBQVU2QyxhQUFjO1lBQ2pDLElBQUk3QyxNQUFNLENBQUMsRUFBRSxFQUFFO2dCQUNiNEMsY0FBY2xILFNBQVNzRSxNQUFNLENBQUMsRUFBRTtZQUNsQztRQUNGO1FBRUEsTUFBTThCLFlBQVlKLEtBQUtLLEdBQUcsQ0FBQyxHQUFHVCxjQUFjc0I7UUFDNUMsTUFBTVgsVUFBVVcsY0FBY3RCO1FBQzlCLE1BQU1VLFlBQVksQUFBQ08sQ0FBQUEsZ0JBQWdCLENBQUEsSUFBS0Q7UUFFeEMsT0FBTztZQUNMTDtZQUNBZixPQUFPMEI7WUFDUGQ7WUFDQUU7UUFDRjtJQUNGLEVBQUUsT0FBTy9CLE9BQU87UUFDZEssY0FBTSxDQUFDTCxLQUFLLENBQUNPLG1CQUFXLENBQUNDLEdBQUcsRUFBRSxvQ0FBb0NSO1FBQ2xFLE9BQU87SUFDVDtBQUNGO0FBS08sZUFBZXBGLGtCQUFrQjRDLFVBQWtCLGNBQWM7SUFLdEUsSUFBSTtRQUNGLE1BQU1tRCxTQUFTOUY7UUFDZixNQUFNMEMsT0FBTyxNQUFNb0QsT0FBT3BELElBQUksQ0FBQ0M7UUFFL0IsSUFBSUQsS0FBS2UsTUFBTSxLQUFLLEdBQUc7WUFDckIsT0FBTztnQkFDTHVFLFdBQVc7Z0JBQ1hDLGVBQWU7Z0JBQ2ZDLFNBQVMsRUFBRTtZQUNiO1FBQ0Y7UUFFQSxnREFBZ0Q7UUFDaEQsTUFBTWpFLFdBQVc2QixPQUFPN0IsUUFBUTtRQUNoQ3ZCLEtBQUt5RixPQUFPLENBQUN6RyxDQUFBQTtZQUNYdUMsU0FBU3hDLEdBQUcsQ0FBQ0M7WUFDYnVDLFNBQVNELEdBQUcsQ0FBQ3RDO1FBQ2Y7UUFFQSxNQUFNc0QsVUFBVSxNQUFNZixTQUFTYyxJQUFJO1FBRW5DLElBQUksQ0FBQ0MsU0FBUztZQUNaLE9BQU87UUFDVDtRQUVBLE1BQU1vRCxXQUErRCxFQUFFO1FBRXZFLElBQUssSUFBSVYsSUFBSSxHQUFHQSxJQUFJaEYsS0FBS2UsTUFBTSxFQUFFaUUsSUFBSztZQUNwQyxNQUFNeEIsY0FBY2xCLE9BQU8sQ0FBQzBDLElBQUksRUFBRTtZQUNsQyxNQUFNdkIsWUFBWW5CLE9BQU8sQ0FBQzBDLElBQUksSUFBSSxFQUFFO1lBRXBDLElBQUl4QixXQUFXLENBQUMsRUFBRSxJQUFJQyxTQUFTLENBQUMsRUFBRSxFQUFFO2dCQUNsQ2lDLFNBQVN2RCxJQUFJLENBQUM7b0JBQ1puRCxLQUFLZ0IsSUFBSSxDQUFDZ0YsRUFBRTtvQkFDWnRCLE9BQU94RixTQUFTc0YsV0FBVyxDQUFDLEVBQUU7b0JBQzlCbEMsS0FBS21DLFNBQVMsQ0FBQyxFQUFFO2dCQUNuQjtZQUNGO1FBQ0Y7UUFFQSxnQ0FBZ0M7UUFDaENpQyxTQUFTQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRW5DLEtBQUssR0FBR2tDLEVBQUVsQyxLQUFLO1FBRXpDLE9BQU87WUFDTDRCLFdBQVd0RixLQUFLZSxNQUFNO1lBQ3RCd0UsZUFBZUcsU0FBU25GLE1BQU0sQ0FBQ3VGLENBQUFBLE9BQVFBLEtBQUt4RSxHQUFHLEdBQUcsR0FBR1AsTUFBTTtZQUMzRHlFLFNBQVNFLFNBQVN0RSxLQUFLLENBQUMsR0FBRyxJQUFJLFNBQVM7UUFDMUM7SUFDRixFQUFFLE9BQU9xQixPQUFPO1FBQ2RLLGNBQU0sQ0FBQ0wsS0FBSyxDQUFDTyxtQkFBVyxDQUFDQyxHQUFHLEVBQUUsMkJBQTJCUjtRQUN6RCxPQUFPO0lBQ1Q7QUFDRjtBQUtPLGVBQWV4RixxQkFBcUJnRCxVQUFrQixjQUFjO0lBQ3pFLElBQUk7UUFDRixNQUFNbUQsU0FBUzlGO1FBQ2YsTUFBTTBDLE9BQU8sTUFBTW9ELE9BQU9wRCxJQUFJLENBQUNDO1FBRS9CLElBQUlELEtBQUtlLE1BQU0sS0FBSyxHQUFHO1lBQ3JCLE9BQU87UUFDVDtRQUVBLHVEQUF1RDtRQUN2RCxNQUFNUSxXQUFXNkIsT0FBTzdCLFFBQVE7UUFDaEN2QixLQUFLeUYsT0FBTyxDQUFDekcsQ0FBQUE7WUFDWHVDLFNBQVNELEdBQUcsQ0FBQ3RDO1FBQ2Y7UUFFQSxNQUFNK0csYUFBYSxNQUFNeEUsU0FBU2MsSUFBSTtRQUV0QyxJQUFJLENBQUMwRCxZQUFZO1lBQ2YsT0FBTztRQUNUO1FBRUEsTUFBTUMsY0FBd0IsRUFBRTtRQUVoQyxJQUFLLElBQUloQixJQUFJLEdBQUdBLElBQUloRixLQUFLZSxNQUFNLEVBQUVpRSxJQUFLO1lBQ3BDLE1BQU12QixZQUFZc0MsVUFBVSxDQUFDZixFQUFFO1lBQy9CLElBQUl2QixTQUFTLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRztnQkFDdkJ1QyxZQUFZN0QsSUFBSSxDQUFDbkMsSUFBSSxDQUFDZ0YsRUFBRTtZQUMxQjtRQUNGO1FBRUEsSUFBSWdCLFlBQVlqRixNQUFNLEdBQUcsR0FBRztZQUMxQixNQUFNcUMsT0FBTy9ELEdBQUcsSUFBSTJHO1lBQ3BCbEQsY0FBTSxDQUFDQyxJQUFJLENBQUNDLG1CQUFXLENBQUNDLEdBQUcsRUFBRSxDQUFDLFdBQVcsRUFBRStDLFlBQVlqRixNQUFNLENBQUMsd0JBQXdCLENBQUM7UUFDekY7UUFFQSxPQUFPaUYsWUFBWWpGLE1BQU07SUFDM0IsRUFBRSxPQUFPMEIsT0FBTztRQUNkSyxjQUFNLENBQUNMLEtBQUssQ0FBQ08sbUJBQVcsQ0FBQ0MsR0FBRyxFQUFFLDZCQUE2QlI7UUFDM0QsT0FBTztJQUNUO0FBQ0Y7QUFHTyxNQUFNaEYsUUFBUUgifQ==