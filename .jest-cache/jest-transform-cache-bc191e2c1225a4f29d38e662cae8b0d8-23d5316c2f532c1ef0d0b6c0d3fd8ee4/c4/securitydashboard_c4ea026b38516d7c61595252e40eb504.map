{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\auth\\security-dashboard.ts"],"sourcesContent":["/**\n * Dashboard de Seguridad\n * Proporciona una interfaz unificada para monitoreo y gestión de seguridad\n */\n\nimport {\n  getSecurityMetrics,\n  getActiveSecurityAlerts,\n  analyzeSecurityPatterns,\n  runSecurityHealthCheck,\n  generateSecurityReport,\n  startSecurityMonitoring,\n  stopSecurityMonitoring,\n  type SecurityMetrics,\n  type SecurityAlert,\n  type SecurityReport,\n} from './security-audit-enhanced'\n\n// =====================================================\n// TIPOS Y INTERFACES DEL DASHBOARD\n// =====================================================\n\nexport interface SecurityDashboardData {\n  metrics: SecurityMetrics\n  alerts: SecurityAlert[]\n  healthCheck: {\n    status: 'healthy' | 'warning' | 'critical'\n    issues: string[]\n    recommendations: string[]\n  }\n  recentActivity: {\n    totalEvents: number\n    criticalEvents: number\n    newAlerts: number\n    resolvedAlerts: number\n  }\n  trends: {\n    eventsLast7Days: number[]\n    alertsLast7Days: number[]\n    securityScoreTrend: number[]\n  }\n}\n\nexport interface SecurityDashboardConfig {\n  refreshInterval: number // en segundos\n  alertThresholds: {\n    criticalEvents: number\n    authFailures: number\n    suspiciousActivities: number\n    securityScore: number\n  }\n  autoAnalysis: boolean\n  notifications: {\n    email: boolean\n    slack: boolean\n    webhook?: string\n  }\n}\n\n// =====================================================\n// CLASE PRINCIPAL DEL DASHBOARD\n// =====================================================\n\nexport class SecurityDashboard {\n  private config: SecurityDashboardConfig\n  private monitoringInterval?: NodeJS.Timeout\n  private refreshInterval?: NodeJS.Timeout\n  private lastUpdate: Date\n  private cachedData?: SecurityDashboardData\n\n  constructor(config: Partial<SecurityDashboardConfig> = {}) {\n    this.config = {\n      refreshInterval: 30, // 30 segundos por defecto\n      alertThresholds: {\n        criticalEvents: 1,\n        authFailures: 10,\n        suspiciousActivities: 5,\n        securityScore: 70,\n      },\n      autoAnalysis: true,\n      notifications: {\n        email: false,\n        slack: false,\n      },\n      ...config,\n    }\n    this.lastUpdate = new Date()\n  }\n\n  /**\n   * Inicia el dashboard de seguridad\n   */\n  async start(): Promise<void> {\n    try {\n      console.log('[SECURITY DASHBOARD] Iniciando dashboard de seguridad...')\n\n      // Cargar datos iniciales\n      await this.refreshData()\n\n      // Iniciar monitoreo automático si está habilitado\n      if (this.config.autoAnalysis) {\n        this.monitoringInterval = startSecurityMonitoring(5) // cada 5 minutos\n      }\n\n      // Iniciar refresh automático de datos\n      this.refreshInterval = setInterval(async () => {\n        await this.refreshData()\n      }, this.config.refreshInterval * 1000)\n\n      console.log('[SECURITY DASHBOARD] Dashboard iniciado exitosamente')\n    } catch (error) {\n      console.error('[SECURITY DASHBOARD] Error iniciando dashboard:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Detiene el dashboard de seguridad\n   */\n  stop(): void {\n    console.log('[SECURITY DASHBOARD] Deteniendo dashboard...')\n\n    if (this.monitoringInterval) {\n      stopSecurityMonitoring(this.monitoringInterval)\n      this.monitoringInterval = undefined\n    }\n\n    if (this.refreshInterval) {\n      clearInterval(this.refreshInterval)\n      this.refreshInterval = undefined\n    }\n\n    console.log('[SECURITY DASHBOARD] Dashboard detenido')\n  }\n\n  /**\n   * Actualiza los datos del dashboard\n   */\n  async refreshData(): Promise<SecurityDashboardData> {\n    try {\n      console.log('[SECURITY DASHBOARD] Actualizando datos...')\n\n      // Obtener datos en paralelo\n      const [metrics, alerts, healthCheck] = await Promise.all([\n        getSecurityMetrics(),\n        getActiveSecurityAlerts(),\n        runSecurityHealthCheck(),\n      ])\n\n      // Calcular actividad reciente (comparar con datos anteriores)\n      const recentActivity = {\n        totalEvents: metrics.total_events_24h,\n        criticalEvents: metrics.critical_events_24h,\n        newAlerts: alerts.filter(\n          a => new Date(a.first_occurrence) > new Date(Date.now() - 24 * 60 * 60 * 1000)\n        ).length,\n        resolvedAlerts: 0, // TODO: implementar cuando se tenga histórico\n      }\n\n      // Generar tendencias (simuladas por ahora)\n      const trends = {\n        eventsLast7Days: await this.getEventsTrend(7),\n        alertsLast7Days: await this.getAlertsTrend(7),\n        securityScoreTrend: await this.getSecurityScoreTrend(7),\n      }\n\n      this.cachedData = {\n        metrics,\n        alerts,\n        healthCheck: {\n          status: healthCheck.status,\n          issues: healthCheck.issues,\n          recommendations: healthCheck.recommendations,\n        },\n        recentActivity,\n        trends,\n      }\n\n      this.lastUpdate = new Date()\n\n      // Verificar umbrales y generar alertas si es necesario\n      await this.checkThresholds(metrics, alerts)\n\n      console.log('[SECURITY DASHBOARD] Datos actualizados exitosamente')\n      return this.cachedData\n    } catch (error) {\n      console.error('[SECURITY DASHBOARD] Error actualizando datos:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Obtiene los datos actuales del dashboard\n   */\n  async getData(forceRefresh: boolean = false): Promise<SecurityDashboardData> {\n    if (\n      forceRefresh ||\n      !this.cachedData ||\n      Date.now() - this.lastUpdate.getTime() > this.config.refreshInterval * 1000\n    ) {\n      return await this.refreshData()\n    }\n    return this.cachedData\n  }\n\n  /**\n   * Ejecuta un análisis manual de seguridad\n   */\n  async runManualAnalysis(userId?: string): Promise<SecurityAlert[]> {\n    try {\n      console.log('[SECURITY DASHBOARD] Ejecutando análisis manual...')\n\n      const alerts = await analyzeSecurityPatterns(userId)\n\n      // Actualizar datos después del análisis\n      await this.refreshData()\n\n      console.log(`[SECURITY DASHBOARD] Análisis completado: ${alerts.length} alertas generadas`)\n      return alerts\n    } catch (error) {\n      console.error('[SECURITY DASHBOARD] Error en análisis manual:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Genera un reporte de seguridad\n   */\n  async generateReport(startDate: Date, endDate: Date): Promise<SecurityReport> {\n    try {\n      console.log('[SECURITY DASHBOARD] Generando reporte de seguridad...')\n\n      const report = await generateSecurityReport(startDate, endDate)\n\n      console.log('[SECURITY DASHBOARD] Reporte generado exitosamente')\n      return report\n    } catch (error) {\n      console.error('[SECURITY DASHBOARD] Error generando reporte:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Obtiene el estado actual del dashboard\n   */\n  getStatus(): {\n    isRunning: boolean\n    lastUpdate: Date\n    config: SecurityDashboardConfig\n    uptime: number\n  } {\n    return {\n      isRunning: !!this.refreshInterval,\n      lastUpdate: this.lastUpdate,\n      config: this.config,\n      uptime: Date.now() - this.lastUpdate.getTime(),\n    }\n  }\n\n  /**\n   * Actualiza la configuración del dashboard\n   */\n  updateConfig(newConfig: Partial<SecurityDashboardConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n    console.log('[SECURITY DASHBOARD] Configuración actualizada')\n  }\n\n  // =====================================================\n  // MÉTODOS PRIVADOS\n  // =====================================================\n\n  /**\n   * Verifica umbrales y genera notificaciones\n   */\n  private async checkThresholds(metrics: SecurityMetrics, alerts: SecurityAlert[]): Promise<void> {\n    const issues: string[] = []\n\n    if (metrics.critical_events_24h >= this.config.alertThresholds.criticalEvents) {\n      issues.push(\n        `Eventos críticos: ${metrics.critical_events_24h} (umbral: ${this.config.alertThresholds.criticalEvents})`\n      )\n    }\n\n    if (metrics.auth_failures_24h >= this.config.alertThresholds.authFailures) {\n      issues.push(\n        `Fallos de autenticación: ${metrics.auth_failures_24h} (umbral: ${this.config.alertThresholds.authFailures})`\n      )\n    }\n\n    if (metrics.suspicious_activities_24h >= this.config.alertThresholds.suspiciousActivities) {\n      issues.push(\n        `Actividades sospechosas: ${metrics.suspicious_activities_24h} (umbral: ${this.config.alertThresholds.suspiciousActivities})`\n      )\n    }\n\n    if (metrics.security_score <= this.config.alertThresholds.securityScore) {\n      issues.push(\n        `Score de seguridad bajo: ${metrics.security_score} (umbral: ${this.config.alertThresholds.securityScore})`\n      )\n    }\n\n    if (issues.length > 0) {\n      console.warn('[SECURITY DASHBOARD] Umbrales excedidos:', issues)\n      await this.sendNotifications(issues)\n    }\n  }\n\n  /**\n   * Envía notificaciones según la configuración\n   */\n  private async sendNotifications(issues: string[]): Promise<void> {\n    try {\n      if (this.config.notifications.webhook) {\n        // Enviar webhook\n        const payload = {\n          timestamp: new Date().toISOString(),\n          source: 'security-dashboard',\n          level: 'warning',\n          message: 'Umbrales de seguridad excedidos',\n          issues,\n        }\n\n        await fetch(this.config.notifications.webhook, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(payload),\n        })\n      }\n\n      // TODO: Implementar notificaciones por email y Slack\n      if (this.config.notifications.email) {\n        console.log('[SECURITY DASHBOARD] Enviando notificación por email...')\n      }\n\n      if (this.config.notifications.slack) {\n        console.log('[SECURITY DASHBOARD] Enviando notificación por Slack...')\n      }\n    } catch (error) {\n      console.error('[SECURITY DASHBOARD] Error enviando notificaciones:', error)\n    }\n  }\n\n  /**\n   * Obtiene tendencia de eventos (simulada)\n   */\n  private async getEventsTrend(days: number): Promise<number[]> {\n    // TODO: Implementar consulta real a la base de datos\n    return Array(days)\n      .fill(0)\n      .map(() => Math.floor(Math.random() * 100))\n  }\n\n  /**\n   * Obtiene tendencia de alertas (simulada)\n   */\n  private async getAlertsTrend(days: number): Promise<number[]> {\n    // TODO: Implementar consulta real a la base de datos\n    return Array(days)\n      .fill(0)\n      .map(() => Math.floor(Math.random() * 10))\n  }\n\n  /**\n   * Obtiene tendencia del score de seguridad (simulada)\n   */\n  private async getSecurityScoreTrend(days: number): Promise<number[]> {\n    // TODO: Implementar consulta real a la base de datos\n    return Array(days)\n      .fill(0)\n      .map(() => Math.floor(Math.random() * 40) + 60)\n  }\n}\n\n// =====================================================\n// INSTANCIA SINGLETON DEL DASHBOARD\n// =====================================================\n\nlet dashboardInstance: SecurityDashboard | null = null\n\n/**\n * Obtiene la instancia singleton del dashboard\n */\nexport function getSecurityDashboard(config?: Partial<SecurityDashboardConfig>): SecurityDashboard {\n  if (!dashboardInstance) {\n    dashboardInstance = new SecurityDashboard(config)\n  }\n  return dashboardInstance\n}\n\n/**\n * Inicia el dashboard global de seguridad\n */\nexport async function startGlobalSecurityDashboard(\n  config?: Partial<SecurityDashboardConfig>\n): Promise<SecurityDashboard> {\n  const dashboard = getSecurityDashboard(config)\n  await dashboard.start()\n  return dashboard\n}\n\n/**\n * Detiene el dashboard global de seguridad\n */\nexport function stopGlobalSecurityDashboard(): void {\n  if (dashboardInstance) {\n    dashboardInstance.stop()\n    dashboardInstance = null\n  }\n}\n"],"names":["SecurityDashboard","getSecurityDashboard","startGlobalSecurityDashboard","stopGlobalSecurityDashboard","config","refreshInterval","alertThresholds","criticalEvents","authFailures","suspiciousActivities","securityScore","autoAnalysis","notifications","email","slack","lastUpdate","Date","start","console","log","refreshData","monitoringInterval","startSecurityMonitoring","setInterval","error","stop","stopSecurityMonitoring","undefined","clearInterval","metrics","alerts","healthCheck","Promise","all","getSecurityMetrics","getActiveSecurityAlerts","runSecurityHealthCheck","recentActivity","totalEvents","total_events_24h","critical_events_24h","newAlerts","filter","a","first_occurrence","now","length","resolvedAlerts","trends","eventsLast7Days","getEventsTrend","alertsLast7Days","getAlertsTrend","securityScoreTrend","getSecurityScoreTrend","cachedData","status","issues","recommendations","checkThresholds","getData","forceRefresh","getTime","runManualAnalysis","userId","analyzeSecurityPatterns","generateReport","startDate","endDate","report","generateSecurityReport","getStatus","isRunning","uptime","updateConfig","newConfig","push","auth_failures_24h","suspicious_activities_24h","security_score","warn","sendNotifications","webhook","payload","timestamp","toISOString","source","level","message","fetch","method","headers","body","JSON","stringify","days","Array","fill","map","Math","floor","random","dashboardInstance","dashboard"],"mappings":"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"}