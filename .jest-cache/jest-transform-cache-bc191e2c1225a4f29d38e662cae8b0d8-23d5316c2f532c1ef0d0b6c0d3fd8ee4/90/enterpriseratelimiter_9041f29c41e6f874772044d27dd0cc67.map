{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\rate-limiting\\enterprise-rate-limiter.ts"],"sourcesContent":["/**\n * Sistema Enterprise de Rate Limiting\n * Unifica todas las implementaciones de rate limiting con Redis y fallback en memoria\n */\n\nimport { NextRequest } from 'next/server'\nimport type { NextApiRequest } from 'next'\nimport { isRedisAvailable, enterpriseRateLimit } from '@/lib/integrations/redis'\n\n// =====================================================\n// TIPOS Y INTERFACES\n// =====================================================\n\nexport interface EnterpriseRateLimitConfig {\n  windowMs: number\n  maxRequests: number\n  message?: string\n  keyGenerator?: (request: NextRequest | NextApiRequest) => string\n  skipSuccessfulRequests?: boolean\n  skipFailedRequests?: boolean\n  enableRedis?: boolean\n  enableMemoryFallback?: boolean\n  enableMetrics?: boolean\n  enableLogging?: boolean\n  customHeaders?: Record<string, string>\n  onLimitReached?: (key: string, request: NextRequest | NextApiRequest) => void\n}\n\nexport interface EnterpriseRateLimitResult {\n  allowed: boolean\n  limit: number\n  remaining: number\n  resetTime: number\n  retryAfter?: number\n  error?: string\n  code?: string\n  source: 'redis' | 'memory' | 'error'\n  metrics?: {\n    responseTime: number\n    cacheHit: boolean\n    keyGenerated: string\n  }\n}\n\nexport interface RateLimitMetrics {\n  totalRequests: number\n  allowedRequests: number\n  blockedRequests: number\n  redisHits: number\n  memoryFallbacks: number\n  errors: number\n  averageResponseTime: number\n  topBlockedIPs: Array<{ ip: string; count: number }>\n  topEndpoints: Array<{ endpoint: string; count: number }>\n}\n\n// =====================================================\n// CONFIGURACIONES PREDEFINIDAS ENTERPRISE\n// =====================================================\n\nexport const ENTERPRISE_RATE_LIMIT_CONFIGS: Record<string, EnterpriseRateLimitConfig> = {\n  // Autenticación crítica\n  CRITICAL_AUTH: {\n    windowMs: 15 * 60 * 1000, // 15 minutos\n    maxRequests: 3, // 3 intentos por 15 minutos\n    message: 'Demasiados intentos de autenticación crítica. Intenta en 15 minutos.',\n    enableRedis: true,\n    enableMetrics: true,\n    enableLogging: true,\n  },\n\n  // Admin APIs\n  ADMIN_API: {\n    windowMs: 5 * 60 * 1000, // 5 minutos\n    maxRequests: 50, // 50 requests por 5 minutos\n    message: 'Límite de requests administrativas excedido. Intenta en 5 minutos.',\n    enableRedis: true,\n    enableMetrics: true,\n    enableLogging: true,\n  },\n\n  // APIs de pagos\n  PAYMENT_API: {\n    windowMs: 10 * 60 * 1000, // 10 minutos\n    maxRequests: 15, // 15 requests por 10 minutos\n    message: 'Límite de requests de pagos excedido. Intenta en 10 minutos.',\n    enableRedis: true,\n    enableMetrics: true,\n    enableLogging: true,\n    onLimitReached: (key, request) => {\n      console.warn(`[PAYMENT_RATE_LIMIT] Límite excedido para ${key}`)\n    },\n  },\n\n  // APIs públicas de productos\n  PUBLIC_API: {\n    windowMs: 1 * 60 * 1000, // 1 minuto\n    maxRequests: 100, // 100 requests por minuto\n    message: 'Límite de requests públicas excedido. Intenta en 1 minuto.',\n    enableRedis: true,\n    enableMetrics: true,\n    enableLogging: false, // No loggear APIs públicas\n  },\n\n  // Webhooks\n  WEBHOOK_API: {\n    windowMs: 1 * 60 * 1000, // 1 minuto\n    maxRequests: 200, // 200 webhooks por minuto\n    message: 'Límite de webhooks excedido.',\n    enableRedis: true,\n    enableMetrics: true,\n    enableLogging: true,\n  },\n\n  // Búsquedas y consultas\n  SEARCH_API: {\n    windowMs: 1 * 60 * 1000, // 1 minuto\n    maxRequests: 60, // 60 búsquedas por minuto\n    message: 'Límite de búsquedas excedido. Intenta en 1 minuto.',\n    enableRedis: true,\n    enableMetrics: true,\n    enableLogging: false,\n  },\n\n  // Upload de archivos\n  UPLOAD_API: {\n    windowMs: 5 * 60 * 1000, // 5 minutos\n    maxRequests: 10, // 10 uploads por 5 minutos\n    message: 'Límite de uploads excedido. Intenta en 5 minutos.',\n    enableRedis: true,\n    enableMetrics: true,\n    enableLogging: true,\n  },\n\n  // APIs de desarrollo/debug\n  DEBUG_API: {\n    windowMs: 1 * 60 * 1000, // 1 minuto\n    maxRequests: 30, // 30 requests por minuto\n    message: 'Límite de debug APIs excedido.',\n    enableRedis: false, // Usar memoria para debug\n    enableMetrics: true,\n    enableLogging: true,\n  },\n}\n\n// =====================================================\n// GENERADORES DE CLAVES\n// =====================================================\n\n/**\n * Generador de clave por IP\n */\nexport function ipKeyGenerator(request: NextRequest | NextApiRequest): string {\n  const ip = getClientIP(request)\n  return `ip:${ip}`\n}\n\n/**\n * Generador de clave por usuario autenticado\n */\nexport function userKeyGenerator(request: NextRequest | NextApiRequest): string {\n  // Intentar obtener user ID de diferentes fuentes\n  const userId = getUserId(request)\n  const ip = getClientIP(request)\n\n  return userId ? `user:${userId}` : `ip:${ip}`\n}\n\n/**\n * Generador de clave por endpoint\n */\nexport function endpointKeyGenerator(request: NextRequest | NextApiRequest): string {\n  const ip = getClientIP(request)\n  const endpoint = getEndpoint(request)\n\n  return `endpoint:${ip}:${endpoint}`\n}\n\n/**\n * Generador de clave híbrido (usuario + endpoint)\n */\nexport function hybridKeyGenerator(request: NextRequest | NextApiRequest): string {\n  const userId = getUserId(request)\n  const ip = getClientIP(request)\n  const endpoint = getEndpoint(request)\n\n  const userPart = userId ? `user:${userId}` : `ip:${ip}`\n  return `${userPart}:${endpoint}`\n}\n\n// =====================================================\n// UTILIDADES\n// =====================================================\n\n/**\n * Obtiene la IP del cliente\n */\nfunction getClientIP(request: NextRequest | NextApiRequest): string {\n  // Intentar diferentes headers de IP\n  const headers = ['x-forwarded-for', 'x-real-ip', 'x-client-ip', 'cf-connecting-ip']\n\n  for (const header of headers) {\n    let ip: string | null = null\n\n    if ('headers' in request && typeof request.headers.get === 'function') {\n      // NextRequest\n      ip = (request as NextRequest).headers.get(header)\n    } else if ('headers' in request) {\n      // NextApiRequest\n      const headerValue = (request as NextApiRequest).headers[header]\n      ip = Array.isArray(headerValue) ? headerValue[0] : headerValue || null\n    }\n\n    if (ip) {\n      // Tomar la primera IP si hay múltiples\n      return ip.split(',')[0].trim()\n    }\n  }\n\n  return 'unknown'\n}\n\n/**\n * Obtiene el ID del usuario autenticado\n */\nfunction getUserId(request: NextRequest | NextApiRequest): string | null {\n  // Intentar obtener de diferentes fuentes\n\n  // 1. Headers de Clerk\n  let userId: string | null = null\n\n  if ('headers' in request && typeof request.headers.get === 'function') {\n    // NextRequest\n    userId = (request as NextRequest).headers.get('x-clerk-user-id')\n  } else if ('headers' in request) {\n    // NextApiRequest\n    const headerValue = (request as NextApiRequest).headers['x-clerk-user-id']\n    userId = Array.isArray(headerValue) ? headerValue[0] : headerValue || null\n  }\n\n  // 2. Contexto enterprise si está disponible\n  if (!userId && (request as any).enterpriseAuth?.userId) {\n    userId = (request as any).enterpriseAuth.userId\n  }\n\n  // 3. Contexto de autenticación si está disponible\n  if (!userId && (request as any).auth?.userId) {\n    userId = (request as any).auth.userId\n  }\n\n  return userId\n}\n\n/**\n * Obtiene el endpoint de la request\n */\nfunction getEndpoint(request: NextRequest | NextApiRequest): string {\n  if ('nextUrl' in request) {\n    // NextRequest\n    return (request as NextRequest).nextUrl.pathname\n  } else if ('url' in request) {\n    // NextApiRequest\n    try {\n      const url = new URL((request as NextApiRequest).url || '', 'http://localhost')\n      return url.pathname\n    } catch {\n      return '/unknown'\n    }\n  }\n\n  return '/unknown'\n}\n\n// =====================================================\n// STORE EN MEMORIA (FALLBACK)\n// =====================================================\n\ninterface MemoryRateLimitEntry {\n  count: number\n  resetTime: number\n  firstRequest: number\n}\n\nclass MemoryRateLimitStore {\n  private store = new Map<string, MemoryRateLimitEntry>()\n  private cleanupInterval: NodeJS.Timeout\n\n  constructor() {\n    // Limpiar entradas expiradas cada 5 minutos\n    this.cleanupInterval = setInterval(\n      () => {\n        this.cleanup()\n      },\n      5 * 60 * 1000\n    )\n  }\n\n  get(key: string): MemoryRateLimitEntry | null {\n    const entry = this.store.get(key)\n\n    if (!entry) {\n      return null\n    }\n\n    // Verificar si ha expirado\n    if (Date.now() > entry.resetTime) {\n      this.store.delete(key)\n      return null\n    }\n\n    return entry\n  }\n\n  set(key: string, entry: MemoryRateLimitEntry): void {\n    this.store.set(key, entry)\n  }\n\n  increment(key: string): number {\n    const entry = this.get(key)\n    if (entry) {\n      entry.count++\n      this.set(key, entry)\n      return entry.count\n    }\n    return 0\n  }\n\n  private cleanup(): void {\n    const now = Date.now()\n    let cleaned = 0\n\n    for (const [key, entry] of this.store.entries()) {\n      if (now > entry.resetTime) {\n        this.store.delete(key)\n        cleaned++\n      }\n    }\n\n    if (cleaned > 0) {\n      console.log(`[MEMORY_RATE_LIMIT] Limpiadas ${cleaned} entradas expiradas`)\n    }\n  }\n\n  getStats(): { entries: number; memoryUsage: number } {\n    const entries = this.store.size\n    const memoryUsage = JSON.stringify([...this.store.entries()]).length\n\n    return { entries, memoryUsage }\n  }\n\n  clear(): void {\n    this.store.clear()\n  }\n\n  destroy(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval)\n    }\n    this.store.clear()\n  }\n}\n\n// Instancia global del store en memoria\nconst memoryStore = new MemoryRateLimitStore()\n\n// =====================================================\n// MÉTRICAS GLOBALES\n// =====================================================\n\nclass RateLimitMetricsCollector {\n  private metrics: RateLimitMetrics = {\n    totalRequests: 0,\n    allowedRequests: 0,\n    blockedRequests: 0,\n    redisHits: 0,\n    memoryFallbacks: 0,\n    errors: 0,\n    averageResponseTime: 0,\n    topBlockedIPs: [],\n    topEndpoints: [],\n  }\n\n  private responseTimes: number[] = []\n  private blockedIPs = new Map<string, number>()\n  private endpointCounts = new Map<string, number>()\n\n  recordRequest(result: EnterpriseRateLimitResult, ip: string, endpoint: string): void {\n    this.metrics.totalRequests++\n\n    if (result.allowed) {\n      this.metrics.allowedRequests++\n    } else {\n      this.metrics.blockedRequests++\n\n      // Registrar IP bloqueada\n      const currentCount = this.blockedIPs.get(ip) || 0\n      this.blockedIPs.set(ip, currentCount + 1)\n    }\n\n    // Registrar fuente\n    if (result.source === 'redis') {\n      this.metrics.redisHits++\n    } else if (result.source === 'memory') {\n      this.metrics.memoryFallbacks++\n    } else if (result.source === 'error') {\n      this.metrics.errors++\n    }\n\n    // Registrar tiempo de respuesta\n    if (result.metrics?.responseTime) {\n      this.responseTimes.push(result.metrics.responseTime)\n\n      // Mantener solo los últimos 1000 tiempos\n      if (this.responseTimes.length > 1000) {\n        this.responseTimes = this.responseTimes.slice(-1000)\n      }\n\n      // Calcular promedio\n      this.metrics.averageResponseTime =\n        this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length\n    }\n\n    // Registrar endpoint\n    const endpointCount = this.endpointCounts.get(endpoint) || 0\n    this.endpointCounts.set(endpoint, endpointCount + 1)\n\n    // Actualizar tops\n    this.updateTopLists()\n  }\n\n  private updateTopLists(): void {\n    // Top IPs bloqueadas\n    this.metrics.topBlockedIPs = Array.from(this.blockedIPs.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10)\n      .map(([ip, count]) => ({ ip, count }))\n\n    // Top endpoints\n    this.metrics.topEndpoints = Array.from(this.endpointCounts.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10)\n      .map(([endpoint, count]) => ({ endpoint, count }))\n  }\n\n  getMetrics(): RateLimitMetrics {\n    return { ...this.metrics }\n  }\n\n  reset(): void {\n    this.metrics = {\n      totalRequests: 0,\n      allowedRequests: 0,\n      blockedRequests: 0,\n      redisHits: 0,\n      memoryFallbacks: 0,\n      errors: 0,\n      averageResponseTime: 0,\n      topBlockedIPs: [],\n      topEndpoints: [],\n    }\n    this.responseTimes = []\n    this.blockedIPs.clear()\n    this.endpointCounts.clear()\n  }\n}\n\n// Instancia global del collector de métricas\nconst metricsCollector = new RateLimitMetricsCollector()\n\n// Exportar para uso externo\nexport { memoryStore, metricsCollector }\n\n// =====================================================\n// IMPLEMENTACIÓN REDIS\n// =====================================================\n\n// Función isRedisAvailable ahora se importa desde @/lib/redis\n\n/**\n * Rate limiting con Redis\n */\nasync function rateLimitWithRedis(\n  key: string,\n  config: EnterpriseRateLimitConfig\n): Promise<EnterpriseRateLimitResult> {\n  const startTime = Date.now()\n\n  try {\n    // Usar la función importada de Redis\n    const result = await enterpriseRateLimit(key, config)\n\n    if (result) {\n      return {\n        allowed: result.allowed,\n        limit: result.limit || config.maxRequests,\n        remaining: result.remaining || 0,\n        resetTime: result.resetTime || Date.now() + config.windowMs,\n        retryAfter: result.allowed ? undefined : Math.ceil(config.windowMs / 1000),\n        source: 'redis',\n        metrics: {\n          responseTime: Date.now() - startTime,\n          cacheHit: true,\n          keyGenerated: key,\n        },\n      }\n    }\n\n    // Si no hay resultado, usar implementación manual\n    const { redis } = await import('@/lib/redis')\n    const now = Date.now()\n    const window = Math.floor(now / config.windowMs)\n    const redisKey = `rate_limit:${key}:${window}`\n\n    // Usar pipeline para operaciones atómicas\n    const pipeline = redis.pipeline()\n    pipeline.incr(redisKey)\n    pipeline.expire(redisKey, Math.ceil(config.windowMs / 1000))\n\n    const results = await pipeline.exec()\n    const count = (results?.[0]?.[1] as number) || 1\n\n    const remaining = Math.max(0, config.maxRequests - count)\n    const resetTime = (window + 1) * config.windowMs\n    const allowed = count <= config.maxRequests\n\n    return {\n      allowed,\n      limit: config.maxRequests,\n      remaining,\n      resetTime,\n      retryAfter: allowed ? undefined : Math.ceil((resetTime - now) / 1000),\n      source: 'redis',\n      metrics: {\n        responseTime: Date.now() - startTime,\n        cacheHit: true,\n        keyGenerated: redisKey,\n      },\n    }\n  } catch (error) {\n    console.error('[RATE_LIMIT] Error en Redis:', error)\n\n    // Fallback a memoria en caso de error\n    return rateLimitWithMemory(key, config)\n  }\n}\n\n/**\n * Rate limiting con memoria (fallback)\n */\nfunction rateLimitWithMemory(\n  key: string,\n  config: EnterpriseRateLimitConfig\n): EnterpriseRateLimitResult {\n  const startTime = Date.now()\n  const now = Date.now()\n\n  let entry = memoryStore.get(key)\n\n  if (!entry) {\n    // Primera request en esta ventana\n    entry = {\n      count: 1,\n      resetTime: now + config.windowMs,\n      firstRequest: now,\n    }\n    memoryStore.set(key, entry)\n\n    return {\n      allowed: true,\n      limit: config.maxRequests,\n      remaining: config.maxRequests - 1,\n      resetTime: entry.resetTime,\n      source: 'memory',\n      metrics: {\n        responseTime: Date.now() - startTime,\n        cacheHit: false,\n        keyGenerated: key,\n      },\n    }\n  }\n\n  // Incrementar contador\n  entry.count++\n  memoryStore.set(key, entry)\n\n  const allowed = entry.count <= config.maxRequests\n  const remaining = Math.max(0, config.maxRequests - entry.count)\n\n  return {\n    allowed,\n    limit: config.maxRequests,\n    remaining,\n    resetTime: entry.resetTime,\n    retryAfter: allowed ? undefined : Math.ceil((entry.resetTime - now) / 1000),\n    source: 'memory',\n    metrics: {\n      responseTime: Date.now() - startTime,\n      cacheHit: true,\n      keyGenerated: key,\n    },\n  }\n}\n\n// =====================================================\n// FUNCIÓN PRINCIPAL DE RATE LIMITING\n// =====================================================\n\n/**\n * Función principal de rate limiting enterprise\n */\nexport async function checkEnterpriseRateLimit(\n  request: NextRequest | NextApiRequest,\n  configName: keyof typeof ENTERPRISE_RATE_LIMIT_CONFIGS,\n  customConfig?: Partial<EnterpriseRateLimitConfig>\n): Promise<EnterpriseRateLimitResult> {\n  const baseConfig = ENTERPRISE_RATE_LIMIT_CONFIGS[configName]\n\n  if (!baseConfig) {\n    return {\n      allowed: true,\n      limit: 1000,\n      remaining: 999,\n      resetTime: Date.now() + 60000,\n      error: `Configuración '${configName}' no encontrada`,\n      code: 'CONFIG_NOT_FOUND',\n      source: 'error',\n    }\n  }\n\n  const config = { ...baseConfig, ...customConfig }\n  const keyGenerator = config.keyGenerator || hybridKeyGenerator\n  const key = keyGenerator(request)\n\n  let result: EnterpriseRateLimitResult\n\n  try {\n    // Intentar Redis primero si está habilitado\n    if (config.enableRedis !== false && (await isRedisAvailable())) {\n      result = await rateLimitWithRedis(key, config)\n    } else {\n      result = rateLimitWithMemory(key, config)\n    }\n\n    // Registrar métricas si está habilitado\n    if (config.enableMetrics) {\n      const ip = getClientIP(request)\n      const endpoint = getEndpoint(request)\n      metricsCollector.recordRequest(result, ip, endpoint)\n    }\n\n    // Logging si está habilitado\n    if (config.enableLogging) {\n      if (!result.allowed) {\n        console.warn(\n          `[RATE_LIMIT] Límite excedido para ${key}: ${result.remaining}/${result.limit}`\n        )\n\n        // Callback personalizado si está definido\n        if (config.onLimitReached) {\n          config.onLimitReached(key, request)\n        }\n      }\n    }\n\n    return result\n  } catch (error) {\n    console.error('[RATE_LIMIT] Error en checkEnterpriseRateLimit:', error)\n\n    return {\n      allowed: true, // Permitir en caso de error\n      limit: config.maxRequests,\n      remaining: config.maxRequests,\n      resetTime: Date.now() + config.windowMs,\n      error: 'Error interno en rate limiting',\n      code: 'INTERNAL_ERROR',\n      source: 'error',\n    }\n  }\n}\n"],"names":["ENTERPRISE_RATE_LIMIT_CONFIGS","checkEnterpriseRateLimit","endpointKeyGenerator","hybridKeyGenerator","ipKeyGenerator","memoryStore","metricsCollector","userKeyGenerator","CRITICAL_AUTH","windowMs","maxRequests","message","enableRedis","enableMetrics","enableLogging","ADMIN_API","PAYMENT_API","onLimitReached","key","request","console","warn","PUBLIC_API","WEBHOOK_API","SEARCH_API","UPLOAD_API","DEBUG_API","ip","getClientIP","userId","getUserId","endpoint","getEndpoint","userPart","headers","header","get","headerValue","Array","isArray","split","trim","enterpriseAuth","auth","nextUrl","pathname","url","URL","MemoryRateLimitStore","store","Map","cleanupInterval","setInterval","cleanup","entry","Date","now","resetTime","delete","set","increment","count","cleaned","entries","log","getStats","size","memoryUsage","JSON","stringify","length","clear","destroy","clearInterval","RateLimitMetricsCollector","recordRequest","result","metrics","totalRequests","allowed","allowedRequests","blockedRequests","currentCount","blockedIPs","source","redisHits","memoryFallbacks","errors","responseTime","responseTimes","push","slice","averageResponseTime","reduce","a","b","endpointCount","endpointCounts","updateTopLists","topBlockedIPs","from","sort","map","topEndpoints","getMetrics","reset","rateLimitWithRedis","config","startTime","enterpriseRateLimit","limit","remaining","retryAfter","undefined","Math","ceil","cacheHit","keyGenerated","redis","window","floor","redisKey","pipeline","incr","expire","results","exec","max","error","rateLimitWithMemory","firstRequest","configName","customConfig","baseConfig","code","keyGenerator","isRedisAvailable"],"mappings":"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"}