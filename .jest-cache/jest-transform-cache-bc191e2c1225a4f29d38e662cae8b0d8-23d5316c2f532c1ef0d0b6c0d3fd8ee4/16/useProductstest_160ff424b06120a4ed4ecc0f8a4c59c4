4e83a291679c8ccb013ba908b2896e39
// ===================================
// PINTEYA E-COMMERCE - TEST useProducts HOOK
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useProducts = require("../../hooks/useProducts");
// Mock data
const mockProductsResponse = {
    success: true,
    data: [
        {
            id: 1,
            name: 'Test Product 1',
            slug: 'test-product-1',
            description: 'Test description',
            price: 1000,
            discounted_price: 900,
            stock: 10,
            category_id: 1,
            images: {
                previews: [
                    '/test1.jpg'
                ]
            },
            category: {
                id: 1,
                name: 'Test Category',
                slug: 'test-category'
            }
        },
        {
            id: 2,
            name: 'Test Product 2',
            slug: 'test-product-2',
            description: 'Test description 2',
            price: 2000,
            discounted_price: null,
            stock: 5,
            category_id: 2,
            images: {
                previews: [
                    '/test2.jpg'
                ]
            },
            category: {
                id: 2,
                name: 'Test Category 2',
                slug: 'test-category-2'
            }
        }
    ],
    pagination: {
        page: 1,
        limit: 12,
        total: 2,
        totalPages: 1
    }
};
const mockCategoriesResponse = {
    success: true,
    data: [
        {
            id: 1,
            name: 'Test Category',
            slug: 'test-category'
        },
        {
            id: 2,
            name: 'Test Category 2',
            slug: 'test-category-2'
        }
    ]
};
// Mock fetch
const mockFetch = jest.fn();
global.fetch = mockFetch;
// Helper function to create complete mock response
const createMockResponse = (data, options = {})=>({
        ok: options.ok ?? true,
        status: options.status ?? 200,
        statusText: options.statusText ?? 'OK',
        json: async ()=>data,
        text: async ()=>JSON.stringify(data),
        headers: new Headers(),
        url: 'http://localhost:3000/api/products',
        clone: jest.fn()
    });
describe('useProducts Hook', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        mockFetch.mockResolvedValue(createMockResponse(mockProductsResponse));
    });
    it('fetches products on mount', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        // Initially loading should be true
        expect(result.current.loading).toBe(true);
        expect(result.current.products).toEqual([]);
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Should have fetched products - the hook may not include default parameters
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/api/products'), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
        expect(result.current.products).toHaveLength(2);
        // Products are adapted, so we check the adapted structure
        expect(result.current.products[0]).toBeDefined();
    });
    it('fetches products successfully', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Should have fetched products
        expect(mockFetch).toHaveBeenCalled();
        expect(result.current.products).toHaveLength(2);
        expect(result.current.hasError).toBe(false);
    });
    it('handles search functionality', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock search response
        mockFetch.mockResolvedValueOnce(createMockResponse({
            ...mockProductsResponse,
            data: [
                mockProductsResponse.data[0]
            ]
        }));
        // Perform search
        await (0, _react.act)(async ()=>{
            await result.current.searchProducts('Test Product 1');
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/api/products'), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('handles category filtering', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock category filter response
        mockFetch.mockResolvedValueOnce(createMockResponse({
            ...mockProductsResponse,
            data: [
                mockProductsResponse.data[0]
            ]
        }));
        // Filter by category
        await (0, _react.act)(async ()=>{
            await result.current.filterByCategory('1');
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*category=1/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('handles pagination', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock page 2 response
        mockFetch.mockResolvedValueOnce(createMockResponse({
            ...mockProductsResponse,
            pagination: {
                ...mockProductsResponse.pagination,
                page: 2
            }
        }));
        // Go to page 2
        await (0, _react.act)(async ()=>{
            await result.current.fetchProducts({
                page: 2
            });
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*page=2/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
        expect(result.current.pagination.page).toBe(2);
    });
    it('handles price range filtering', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock price filter response
        mockFetch.mockResolvedValueOnce(createMockResponse(mockProductsResponse));
        // Filter by price range
        await (0, _react.act)(async ()=>{
            await result.current.fetchProducts({
                priceMin: 500,
                priceMax: 1500
            });
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*priceMin=500.*priceMax=1500/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('handles sorting', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock sort response
        mockFetch.mockResolvedValueOnce(createMockResponse(mockProductsResponse));
        // Sort by price ascending
        await (0, _react.act)(async ()=>{
            await result.current.fetchProducts({
                sortBy: 'price',
                sortOrder: 'asc'
            });
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*sortBy=price.*sortOrder=asc/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('handles API errors gracefully', async ()=>{
        mockFetch.mockRejectedValueOnce(new Error('API Error'));
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // getProducts() captura el error y devuelve un objeto con success: false
        // El hook useProducts entonces establece el mensaje genérico
        expect(result.current.error).toBe('Error obteniendo productos');
        expect(result.current.products).toEqual([]);
    });
    it('handles HTTP error responses', async ()=>{
        mockFetch.mockResolvedValueOnce(createMockResponse({
            error: 'Server Error'
        }, {
            ok: false,
            status: 500,
            statusText: 'Internal Server Error'
        }));
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // getProducts() usa safeApiResponseJson() que detecta !response.ok
        // y devuelve un objeto con success: false y message con detalles del error
        // El hook useProducts entonces establece el mensaje genérico
        expect(result.current.error).toBe('Error obteniendo productos');
        expect(result.current.products).toEqual([]);
    });
    it('clears filters correctly', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Apply some filters first
        await (0, _react.act)(async ()=>{
            await result.current.searchProducts('test');
        });
        await (0, _react.act)(async ()=>{
            await result.current.filterByCategory('1');
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock reset response
        mockFetch.mockResolvedValueOnce(createMockResponse(mockProductsResponse));
        // Clear filters
        await (0, _react.act)(async ()=>{
            await result.current.clearFilters();
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*page=1/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('maintains loading state during requests', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        // Initial loading
        expect(result.current.loading).toBe(true);
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Mock slow response
        let resolvePromise;
        const slowPromise = new Promise((resolve)=>{
            resolvePromise = resolve;
        });
        mockFetch.mockReturnValueOnce(slowPromise);
        // Start new request
        (0, _react.act)(()=>{
            result.current.searchProducts('test');
        });
        // Should be loading again
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(true);
        });
        // Resolve the promise
        resolvePromise({
            ok: true,
            json: async ()=>mockProductsResponse
        });
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlUHJvZHVjdHMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUElOVEVZQSBFLUNPTU1FUkNFIC0gVEVTVCB1c2VQcm9kdWN0cyBIT09LXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbXBvcnQgeyByZW5kZXJIb29rLCB3YWl0Rm9yLCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0J1xuaW1wb3J0IHsgdXNlUHJvZHVjdHMgfSBmcm9tICdAL2hvb2tzL3VzZVByb2R1Y3RzJ1xuXG4vLyBNb2NrIGRhdGFcbmNvbnN0IG1vY2tQcm9kdWN0c1Jlc3BvbnNlID0ge1xuICBzdWNjZXNzOiB0cnVlLFxuICBkYXRhOiBbXG4gICAge1xuICAgICAgaWQ6IDEsXG4gICAgICBuYW1lOiAnVGVzdCBQcm9kdWN0IDEnLFxuICAgICAgc2x1ZzogJ3Rlc3QtcHJvZHVjdC0xJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBkZXNjcmlwdGlvbicsXG4gICAgICBwcmljZTogMTAwMCxcbiAgICAgIGRpc2NvdW50ZWRfcHJpY2U6IDkwMCxcbiAgICAgIHN0b2NrOiAxMCxcbiAgICAgIGNhdGVnb3J5X2lkOiAxLFxuICAgICAgaW1hZ2VzOiB7IHByZXZpZXdzOiBbJy90ZXN0MS5qcGcnXSB9LFxuICAgICAgY2F0ZWdvcnk6IHsgaWQ6IDEsIG5hbWU6ICdUZXN0IENhdGVnb3J5Jywgc2x1ZzogJ3Rlc3QtY2F0ZWdvcnknIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogMixcbiAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QgMicsXG4gICAgICBzbHVnOiAndGVzdC1wcm9kdWN0LTInLFxuICAgICAgZGVzY3JpcHRpb246ICdUZXN0IGRlc2NyaXB0aW9uIDInLFxuICAgICAgcHJpY2U6IDIwMDAsXG4gICAgICBkaXNjb3VudGVkX3ByaWNlOiBudWxsLFxuICAgICAgc3RvY2s6IDUsXG4gICAgICBjYXRlZ29yeV9pZDogMixcbiAgICAgIGltYWdlczogeyBwcmV2aWV3czogWycvdGVzdDIuanBnJ10gfSxcbiAgICAgIGNhdGVnb3J5OiB7IGlkOiAyLCBuYW1lOiAnVGVzdCBDYXRlZ29yeSAyJywgc2x1ZzogJ3Rlc3QtY2F0ZWdvcnktMicgfSxcbiAgICB9LFxuICBdLFxuICBwYWdpbmF0aW9uOiB7XG4gICAgcGFnZTogMSxcbiAgICBsaW1pdDogMTIsXG4gICAgdG90YWw6IDIsXG4gICAgdG90YWxQYWdlczogMSxcbiAgfSxcbn1cblxuY29uc3QgbW9ja0NhdGVnb3JpZXNSZXNwb25zZSA9IHtcbiAgc3VjY2VzczogdHJ1ZSxcbiAgZGF0YTogW1xuICAgIHsgaWQ6IDEsIG5hbWU6ICdUZXN0IENhdGVnb3J5Jywgc2x1ZzogJ3Rlc3QtY2F0ZWdvcnknIH0sXG4gICAgeyBpZDogMiwgbmFtZTogJ1Rlc3QgQ2F0ZWdvcnkgMicsIHNsdWc6ICd0ZXN0LWNhdGVnb3J5LTInIH0sXG4gIF0sXG59XG5cbi8vIE1vY2sgZmV0Y2hcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKVxuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgY29tcGxldGUgbW9jayByZXNwb25zZVxuY29uc3QgY3JlYXRlTW9ja1Jlc3BvbnNlID0gKFxuICBkYXRhOiBhbnksXG4gIG9wdGlvbnM6IHsgb2s/OiBib29sZWFuOyBzdGF0dXM/OiBudW1iZXI7IHN0YXR1c1RleHQ/OiBzdHJpbmcgfSA9IHt9XG4pID0+ICh7XG4gIG9rOiBvcHRpb25zLm9rID8/IHRydWUsXG4gIHN0YXR1czogb3B0aW9ucy5zdGF0dXMgPz8gMjAwLFxuICBzdGF0dXNUZXh0OiBvcHRpb25zLnN0YXR1c1RleHQgPz8gJ09LJyxcbiAganNvbjogYXN5bmMgKCkgPT4gZGF0YSxcbiAgdGV4dDogYXN5bmMgKCkgPT4gSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCksXG4gIHVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvcHJvZHVjdHMnLFxuICBjbG9uZTogamVzdC5mbigpLFxufSlcblxuZGVzY3JpYmUoJ3VzZVByb2R1Y3RzIEhvb2snLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpXG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlKGNyZWF0ZU1vY2tSZXNwb25zZShtb2NrUHJvZHVjdHNSZXNwb25zZSkpXG4gIH0pXG5cbiAgaXQoJ2ZldGNoZXMgcHJvZHVjdHMgb24gbW91bnQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgIC8vIEluaXRpYWxseSBsb2FkaW5nIHNob3VsZCBiZSB0cnVlXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUodHJ1ZSlcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucHJvZHVjdHMpLnRvRXF1YWwoW10pXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBTaG91bGQgaGF2ZSBmZXRjaGVkIHByb2R1Y3RzIC0gdGhlIGhvb2sgbWF5IG5vdCBpbmNsdWRlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJy9hcGkvcHJvZHVjdHMnKSxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICB9KVxuICAgIClcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucHJvZHVjdHMpLnRvSGF2ZUxlbmd0aCgyKVxuICAgIC8vIFByb2R1Y3RzIGFyZSBhZGFwdGVkLCBzbyB3ZSBjaGVjayB0aGUgYWRhcHRlZCBzdHJ1Y3R1cmVcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucHJvZHVjdHNbMF0pLnRvQmVEZWZpbmVkKClcbiAgfSlcblxuICBpdCgnZmV0Y2hlcyBwcm9kdWN0cyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIC8vIFNob3VsZCBoYXZlIGZldGNoZWQgcHJvZHVjdHNcbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucHJvZHVjdHMpLnRvSGF2ZUxlbmd0aCgyKVxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNFcnJvcikudG9CZShmYWxzZSlcbiAgfSlcblxuICBpdCgnaGFuZGxlcyBzZWFyY2ggZnVuY3Rpb25hbGl0eScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSlcbiAgICB9KVxuXG4gICAgLy8gQ2xlYXIgcHJldmlvdXMgY2FsbHNcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKClcblxuICAgIC8vIE1vY2sgc2VhcmNoIHJlc3BvbnNlXG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZShcbiAgICAgIGNyZWF0ZU1vY2tSZXNwb25zZSh7XG4gICAgICAgIC4uLm1vY2tQcm9kdWN0c1Jlc3BvbnNlLFxuICAgICAgICBkYXRhOiBbbW9ja1Byb2R1Y3RzUmVzcG9uc2UuZGF0YVswXV0sIC8vIE9ubHkgZmlyc3QgcHJvZHVjdFxuICAgICAgfSlcbiAgICApXG5cbiAgICAvLyBQZXJmb3JtIHNlYXJjaFxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5zZWFyY2hQcm9kdWN0cygnVGVzdCBQcm9kdWN0IDEnKVxuICAgIH0pXG5cbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCcvYXBpL3Byb2R1Y3RzJyksXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgfSlcbiAgICApXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgY2F0ZWdvcnkgZmlsdGVyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBDbGVhciBwcmV2aW91cyBjYWxsc1xuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxuXG4gICAgLy8gTW9jayBjYXRlZ29yeSBmaWx0ZXIgcmVzcG9uc2VcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKFxuICAgICAgY3JlYXRlTW9ja1Jlc3BvbnNlKHtcbiAgICAgICAgLi4ubW9ja1Byb2R1Y3RzUmVzcG9uc2UsXG4gICAgICAgIGRhdGE6IFttb2NrUHJvZHVjdHNSZXNwb25zZS5kYXRhWzBdXSwgLy8gT25seSBmaXJzdCBwcm9kdWN0XG4gICAgICB9KVxuICAgIClcblxuICAgIC8vIEZpbHRlciBieSBjYXRlZ29yeVxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5maWx0ZXJCeUNhdGVnb3J5KCcxJylcbiAgICB9KVxuXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcL2FwaVxcL3Byb2R1Y3RzXFw/LipjYXRlZ29yeT0xLyksXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgfSlcbiAgICApXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgcGFnaW5hdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSlcbiAgICB9KVxuXG4gICAgLy8gQ2xlYXIgcHJldmlvdXMgY2FsbHNcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKClcblxuICAgIC8vIE1vY2sgcGFnZSAyIHJlc3BvbnNlXG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZShcbiAgICAgIGNyZWF0ZU1vY2tSZXNwb25zZSh7XG4gICAgICAgIC4uLm1vY2tQcm9kdWN0c1Jlc3BvbnNlLFxuICAgICAgICBwYWdpbmF0aW9uOiB7IC4uLm1vY2tQcm9kdWN0c1Jlc3BvbnNlLnBhZ2luYXRpb24sIHBhZ2U6IDIgfSxcbiAgICAgIH0pXG4gICAgKVxuXG4gICAgLy8gR28gdG8gcGFnZSAyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmZldGNoUHJvZHVjdHMoeyBwYWdlOiAyIH0pXG4gICAgfSlcblxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXC9hcGlcXC9wcm9kdWN0c1xcPy4qcGFnZT0yLyksXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgfSlcbiAgICApXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnBhZ2luYXRpb24ucGFnZSkudG9CZSgyKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIHByaWNlIHJhbmdlIGZpbHRlcmluZycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSlcbiAgICB9KVxuXG4gICAgLy8gQ2xlYXIgcHJldmlvdXMgY2FsbHNcbiAgICBtb2NrRmV0Y2gubW9ja0NsZWFyKClcblxuICAgIC8vIE1vY2sgcHJpY2UgZmlsdGVyIHJlc3BvbnNlXG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZShjcmVhdGVNb2NrUmVzcG9uc2UobW9ja1Byb2R1Y3RzUmVzcG9uc2UpKVxuXG4gICAgLy8gRmlsdGVyIGJ5IHByaWNlIHJhbmdlXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmZldGNoUHJvZHVjdHMoeyBwcmljZU1pbjogNTAwLCBwcmljZU1heDogMTUwMCB9KVxuICAgIH0pXG5cbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFwvYXBpXFwvcHJvZHVjdHNcXD8uKnByaWNlTWluPTUwMC4qcHJpY2VNYXg9MTUwMC8pLFxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIH0pXG4gICAgKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIHNvcnRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIC8vIENsZWFyIHByZXZpb3VzIGNhbGxzXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpXG5cbiAgICAvLyBNb2NrIHNvcnQgcmVzcG9uc2VcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKGNyZWF0ZU1vY2tSZXNwb25zZShtb2NrUHJvZHVjdHNSZXNwb25zZSkpXG5cbiAgICAvLyBTb3J0IGJ5IHByaWNlIGFzY2VuZGluZ1xuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5mZXRjaFByb2R1Y3RzKHsgc29ydEJ5OiAncHJpY2UnLCBzb3J0T3JkZXI6ICdhc2MnIH0pXG4gICAgfSlcblxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXC9hcGlcXC9wcm9kdWN0c1xcPy4qc29ydEJ5PXByaWNlLipzb3J0T3JkZXI9YXNjLyksXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgfSlcbiAgICApXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgQVBJIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tGZXRjaC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdBUEkgRXJyb3InKSlcblxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBnZXRQcm9kdWN0cygpIGNhcHR1cmEgZWwgZXJyb3IgeSBkZXZ1ZWx2ZSB1biBvYmpldG8gY29uIHN1Y2Nlc3M6IGZhbHNlXG4gICAgLy8gRWwgaG9vayB1c2VQcm9kdWN0cyBlbnRvbmNlcyBlc3RhYmxlY2UgZWwgbWVuc2FqZSBnZW7DqXJpY29cbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmUoJ0Vycm9yIG9idGVuaWVuZG8gcHJvZHVjdG9zJylcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucHJvZHVjdHMpLnRvRXF1YWwoW10pXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgSFRUUCBlcnJvciByZXNwb25zZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZShcbiAgICAgIGNyZWF0ZU1vY2tSZXNwb25zZShcbiAgICAgICAgeyBlcnJvcjogJ1NlcnZlciBFcnJvcicgfSxcbiAgICAgICAgeyBvazogZmFsc2UsIHN0YXR1czogNTAwLCBzdGF0dXNUZXh0OiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyB9XG4gICAgICApXG4gICAgKVxuXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIC8vIGdldFByb2R1Y3RzKCkgdXNhIHNhZmVBcGlSZXNwb25zZUpzb24oKSBxdWUgZGV0ZWN0YSAhcmVzcG9uc2Uub2tcbiAgICAvLyB5IGRldnVlbHZlIHVuIG9iamV0byBjb24gc3VjY2VzczogZmFsc2UgeSBtZXNzYWdlIGNvbiBkZXRhbGxlcyBkZWwgZXJyb3JcbiAgICAvLyBFbCBob29rIHVzZVByb2R1Y3RzIGVudG9uY2VzIGVzdGFibGVjZSBlbCBtZW5zYWplIGdlbsOpcmljb1xuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZSgnRXJyb3Igb2J0ZW5pZW5kbyBwcm9kdWN0b3MnKVxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5wcm9kdWN0cykudG9FcXVhbChbXSlcbiAgfSlcblxuICBpdCgnY2xlYXJzIGZpbHRlcnMgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBBcHBseSBzb21lIGZpbHRlcnMgZmlyc3RcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuc2VhcmNoUHJvZHVjdHMoJ3Rlc3QnKVxuICAgIH0pXG5cbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuZmlsdGVyQnlDYXRlZ29yeSgnMScpXG4gICAgfSlcblxuICAgIC8vIENsZWFyIHByZXZpb3VzIGNhbGxzXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpXG5cbiAgICAvLyBNb2NrIHJlc2V0IHJlc3BvbnNlXG4gICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZShjcmVhdGVNb2NrUmVzcG9uc2UobW9ja1Byb2R1Y3RzUmVzcG9uc2UpKVxuXG4gICAgLy8gQ2xlYXIgZmlsdGVyc1xuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5jbGVhckZpbHRlcnMoKVxuICAgIH0pXG5cbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFwvYXBpXFwvcHJvZHVjdHNcXD8uKnBhZ2U9MS8pLFxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgIH0pXG4gICAgKVxuICB9KVxuXG4gIGl0KCdtYWludGFpbnMgbG9hZGluZyBzdGF0ZSBkdXJpbmcgcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgIC8vIEluaXRpYWwgbG9hZGluZ1xuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKHRydWUpXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBNb2NrIHNsb3cgcmVzcG9uc2VcbiAgICBsZXQgcmVzb2x2ZVByb21pc2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkXG4gICAgY29uc3Qgc2xvd1Byb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZVxuICAgIH0pXG5cbiAgICBtb2NrRmV0Y2gubW9ja1JldHVyblZhbHVlT25jZShzbG93UHJvbWlzZSlcblxuICAgIC8vIFN0YXJ0IG5ldyByZXF1ZXN0XG4gICAgYWN0KCgpID0+IHtcbiAgICAgIHJlc3VsdC5jdXJyZW50LnNlYXJjaFByb2R1Y3RzKCd0ZXN0JylcbiAgICB9KVxuXG4gICAgLy8gU2hvdWxkIGJlIGxvYWRpbmcgYWdhaW5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKHRydWUpXG4gICAgfSlcblxuICAgIC8vIFJlc29sdmUgdGhlIHByb21pc2VcbiAgICByZXNvbHZlUHJvbWlzZSEoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrUHJvZHVjdHNSZXNwb25zZSxcbiAgICB9KVxuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSlcbiAgICB9KVxuICB9KVxufSlcbiJdLCJuYW1lcyI6WyJtb2NrUHJvZHVjdHNSZXNwb25zZSIsInN1Y2Nlc3MiLCJkYXRhIiwiaWQiLCJuYW1lIiwic2x1ZyIsImRlc2NyaXB0aW9uIiwicHJpY2UiLCJkaXNjb3VudGVkX3ByaWNlIiwic3RvY2siLCJjYXRlZ29yeV9pZCIsImltYWdlcyIsInByZXZpZXdzIiwiY2F0ZWdvcnkiLCJwYWdpbmF0aW9uIiwicGFnZSIsImxpbWl0IiwidG90YWwiLCJ0b3RhbFBhZ2VzIiwibW9ja0NhdGVnb3JpZXNSZXNwb25zZSIsIm1vY2tGZXRjaCIsImplc3QiLCJmbiIsImdsb2JhbCIsImZldGNoIiwiY3JlYXRlTW9ja1Jlc3BvbnNlIiwib3B0aW9ucyIsIm9rIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImpzb24iLCJ0ZXh0IiwiSlNPTiIsInN0cmluZ2lmeSIsImhlYWRlcnMiLCJIZWFkZXJzIiwidXJsIiwiY2xvbmUiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJpdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VQcm9kdWN0cyIsImV4cGVjdCIsImN1cnJlbnQiLCJsb2FkaW5nIiwidG9CZSIsInByb2R1Y3RzIiwidG9FcXVhbCIsIndhaXRGb3IiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInN0cmluZ0NvbnRhaW5pbmciLCJvYmplY3RDb250YWluaW5nIiwibWV0aG9kIiwidG9IYXZlTGVuZ3RoIiwidG9CZURlZmluZWQiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwiaGFzRXJyb3IiLCJtb2NrQ2xlYXIiLCJtb2NrUmVzb2x2ZWRWYWx1ZU9uY2UiLCJhY3QiLCJzZWFyY2hQcm9kdWN0cyIsImZpbHRlckJ5Q2F0ZWdvcnkiLCJzdHJpbmdNYXRjaGluZyIsImZldGNoUHJvZHVjdHMiLCJwcmljZU1pbiIsInByaWNlTWF4Iiwic29ydEJ5Iiwic29ydE9yZGVyIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwiRXJyb3IiLCJlcnJvciIsImNsZWFyRmlsdGVycyIsInJlc29sdmVQcm9taXNlIiwic2xvd1Byb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0Qyw2Q0FBNkM7QUFDN0Msc0NBQXNDOzs7Ozt1QkFFRzs2QkFDYjtBQUU1QixZQUFZO0FBQ1osTUFBTUEsdUJBQXVCO0lBQzNCQyxTQUFTO0lBQ1RD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