8bb113aacce2a62a3245908c39bb6349
// ===================================
// TESTS: useSearchErrorHandler Hook - Manejo robusto de errores
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useSearchErrorHandler = require("../../hooks/useSearchErrorHandler");
// ===================================
// SETUP
// ===================================
beforeEach(()=>{
    jest.clearAllMocks();
    jest.useFakeTimers();
    // Mock console methods to reduce noise
    jest.spyOn(console, 'warn').mockImplementation(()=>{});
    jest.spyOn(console, 'error').mockImplementation(()=>{});
});
afterEach(()=>{
    jest.useRealTimers();
    jest.restoreAllMocks();
});
// ===================================
// TESTS BÁSICOS
// ===================================
describe('useSearchErrorHandler Hook', ()=>{
    it('should initialize with default state', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        expect(result.current.currentError).toBe(null);
        expect(result.current.retryCount).toBe(0);
        expect(result.current.isRetrying).toBe(false);
        expect(result.current.hasError).toBe(false);
    });
    it('should accept custom retry configuration', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                retryConfig: {
                    maxRetries: 5,
                    baseDelay: 500
                }
            }));
        expect(result.current.retryConfig.maxRetries).toBe(5);
        expect(result.current.retryConfig.baseDelay).toBe(500);
    });
});
// ===================================
// TESTS DE CLASIFICACIÓN DE ERRORES
// ===================================
describe('useSearchErrorHandler - Error Classification', ()=>{
    it('should classify network errors correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const networkError = new TypeError('fetch failed');
        networkError.name = 'TypeError';
        (0, _react.act)(()=>{
            const error = result.current.handleError(networkError);
            expect(error.type).toBe('network');
            expect(error.retryable).toBe(true);
            expect(error.message).toContain('conexión');
        });
    });
    it('should classify timeout errors correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const timeoutError = new Error('timeout');
        timeoutError.name = 'AbortError';
        (0, _react.act)(()=>{
            const error = result.current.handleError(timeoutError);
            expect(error.type).toBe('timeout');
            expect(error.retryable).toBe(true);
            expect(error.message).toContain('tardó demasiado');
        });
    });
    it('should classify server errors correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const serverError = {
            status: 500,
            message: 'Internal Server Error'
        };
        (0, _react.act)(()=>{
            const error = result.current.handleError(serverError);
            expect(error.type).toBe('server');
            expect(error.retryable).toBe(true);
            expect(error.code).toBe('500');
        });
    });
    it('should classify validation errors correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const validationError = {
            status: 400,
            message: 'Bad Request'
        };
        (0, _react.act)(()=>{
            const error = result.current.handleError(validationError);
            expect(error.type).toBe('validation');
            expect(error.retryable).toBe(false);
            expect(error.code).toBe('400');
        });
    });
});
// ===================================
// TESTS DE RETRY AUTOMÁTICO
// ===================================
describe('useSearchErrorHandler - Retry Logic', ()=>{
    it('should retry failed operations with exponential backoff', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                retryConfig: {
                    maxRetries: 3,
                    baseDelay: 100,
                    backoffFactor: 2
                }
            }));
        let callCount = 0;
        const failingOperation = jest.fn().mockImplementation(()=>{
            callCount++;
            if (callCount < 3) {
                throw new Error('Network error');
            }
            return Promise.resolve('success');
        });
        let executePromise;
        await (0, _react.act)(async ()=>{
            executePromise = result.current.executeWithRetry(failingOperation, 'test operation');
        });
        // Avanzar timers para los retries
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(100); // Primer retry
            await Promise.resolve();
            jest.advanceTimersByTime(200); // Segundo retry
            await Promise.resolve();
        });
        const result_value = await executePromise;
        expect(result_value).toBe('success');
        expect(failingOperation).toHaveBeenCalledTimes(3);
    });
    it('should not retry non-retryable errors', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        const error = new Error('Bad Request');
        error.status = 400;
        const nonRetryableOperation = jest.fn().mockRejectedValue(error);
        await (0, _react.act)(async ()=>{
            await expect(result.current.executeWithRetry(nonRetryableOperation, 'validation test')).rejects.toThrow();
        });
        expect(nonRetryableOperation).toHaveBeenCalledTimes(1);
    });
    it('should stop retrying after max attempts', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                retryConfig: {
                    maxRetries: 2,
                    baseDelay: 1
                } // Delay muy pequeño
            }));
        const alwaysFailingOperation = jest.fn().mockRejectedValue(new Error('Persistent error'));
        // Usar real timers para este test
        jest.useRealTimers();
        await expect(result.current.executeWithRetry(alwaysFailingOperation, 'persistent failure test')).rejects.toThrow('Persistent error');
        expect(alwaysFailingOperation).toHaveBeenCalledTimes(3); // Original + 2 retries
        // Restaurar fake timers
        jest.useFakeTimers();
    });
});
// ===================================
// TESTS DE CALLBACKS
// ===================================
describe('useSearchErrorHandler - Callbacks', ()=>{
    it('should call onError callback when error occurs', ()=>{
        const onError = jest.fn();
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                onError
            }));
        const testError = new Error('Test error');
        (0, _react.act)(()=>{
            result.current.handleError(testError);
        });
        expect(onError).toHaveBeenCalledWith(expect.objectContaining({
            type: 'unknown',
            message: 'Test error',
            retryable: true
        }));
    });
    it('should call onRetrySuccess callback on successful retry', async ()=>{
        const onRetrySuccess = jest.fn();
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                onRetrySuccess,
                retryConfig: {
                    maxRetries: 2,
                    baseDelay: 50
                }
            }));
        let callCount = 0;
        const retryOperation = jest.fn().mockImplementation(()=>{
            callCount++;
            if (callCount === 1) {
                throw new Error('First failure');
            }
            return Promise.resolve('success');
        });
        let executePromise;
        await (0, _react.act)(async ()=>{
            executePromise = result.current.executeWithRetry(retryOperation);
        });
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(50);
            await Promise.resolve();
        });
        await executePromise;
        expect(onRetrySuccess).toHaveBeenCalled();
    });
    it('should call onRetryFailed callback when all retries fail', async ()=>{
        const onRetryFailed = jest.fn();
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                onRetryFailed,
                retryConfig: {
                    maxRetries: 1,
                    baseDelay: 1
                } // Delay muy pequeño
            }));
        const failingOperation = jest.fn().mockRejectedValue(new Error('Always fails'));
        // Usar real timers para este test
        jest.useRealTimers();
        await expect(result.current.executeWithRetry(failingOperation)).rejects.toThrow();
        expect(onRetryFailed).toHaveBeenCalledWith(expect.objectContaining({
            type: 'unknown',
            message: 'Always fails'
        }), 1 // número de intentos
        );
        // Restaurar fake timers
        jest.useFakeTimers();
    });
});
// ===================================
// TESTS DE ESTADO
// ===================================
describe('useSearchErrorHandler - State Management', ()=>{
    it('should update retry state during retries', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)({
                retryConfig: {
                    maxRetries: 2,
                    baseDelay: 50
                }
            }));
        let callCount = 0;
        const retryOperation = jest.fn().mockImplementation(()=>{
            callCount++;
            if (callCount < 3) {
                throw new Error('Retry test');
            }
            return Promise.resolve('success');
        });
        let executePromise;
        await (0, _react.act)(async ()=>{
            executePromise = result.current.executeWithRetry(retryOperation);
        });
        // Verificar estado durante primer retry
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(50);
            await Promise.resolve();
        });
        expect(result.current.isRetrying).toBe(true);
        expect(result.current.retryCount).toBe(1);
        // Completar la operación
        await (0, _react.act)(async ()=>{
            jest.advanceTimersByTime(100);
            await Promise.resolve();
        });
        await executePromise;
        expect(result.current.isRetrying).toBe(false);
        expect(result.current.retryCount).toBe(0);
    });
    it('should clear error state', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useSearchErrorHandler.useSearchErrorHandler)());
        // Simular error
        (0, _react.act)(()=>{
            result.current.handleError(new Error('Test error'));
        });
        expect(result.current.hasError).toBe(true);
        // Limpiar error
        (0, _react.act)(()=>{
            result.current.clearError();
        });
        expect(result.current.hasError).toBe(false);
        expect(result.current.currentError).toBe(null);
        expect(result.current.retryCount).toBe(0);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlU2VhcmNoRXJyb3JIYW5kbGVyLnRlc3QudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFRFU1RTOiB1c2VTZWFyY2hFcnJvckhhbmRsZXIgSG9vayAtIE1hbmVqbyByb2J1c3RvIGRlIGVycm9yZXNcclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCwgd2FpdEZvciB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xyXG5pbXBvcnQgeyB1c2VTZWFyY2hFcnJvckhhbmRsZXIgfSBmcm9tICdAL2hvb2tzL3VzZVNlYXJjaEVycm9ySGFuZGxlcic7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBTRVRVUFxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgamVzdC51c2VGYWtlVGltZXJzKCk7XHJcbiAgLy8gTW9jayBjb25zb2xlIG1ldGhvZHMgdG8gcmVkdWNlIG5vaXNlXHJcbiAgamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XHJcbiAgamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xyXG59KTtcclxuXHJcbmFmdGVyRWFjaCgoKSA9PiB7XHJcbiAgamVzdC51c2VSZWFsVGltZXJzKCk7XHJcbiAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBCw4FTSUNPU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZVNlYXJjaEVycm9ySGFuZGxlciBIb29rJywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSB3aXRoIGRlZmF1bHQgc3RhdGUnLCAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTZWFyY2hFcnJvckhhbmRsZXIoKSk7XHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmN1cnJlbnRFcnJvcikudG9CZShudWxsKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5yZXRyeUNvdW50KS50b0JlKDApO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzUmV0cnlpbmcpLnRvQmUoZmFsc2UpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmhhc0Vycm9yKS50b0JlKGZhbHNlKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBhY2NlcHQgY3VzdG9tIHJldHJ5IGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiBcclxuICAgICAgdXNlU2VhcmNoRXJyb3JIYW5kbGVyKHtcclxuICAgICAgICByZXRyeUNvbmZpZzoge1xyXG4gICAgICAgICAgbWF4UmV0cmllczogNSxcclxuICAgICAgICAgIGJhc2VEZWxheTogNTAwLFxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnJldHJ5Q29uZmlnLm1heFJldHJpZXMpLnRvQmUoNSk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucmV0cnlDb25maWcuYmFzZURlbGF5KS50b0JlKDUwMCk7XHJcbiAgfSk7XHJcbn0pO1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy8gVEVTVFMgREUgQ0xBU0lGSUNBQ0nDk04gREUgRVJST1JFU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZVNlYXJjaEVycm9ySGFuZGxlciAtIEVycm9yIENsYXNzaWZpY2F0aW9uJywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgY2xhc3NpZnkgbmV0d29yayBlcnJvcnMgY29ycmVjdGx5JywgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU2VhcmNoRXJyb3JIYW5kbGVyKCkpO1xyXG5cclxuICAgIGNvbnN0IG5ldHdvcmtFcnJvciA9IG5ldyBUeXBlRXJyb3IoJ2ZldGNoIGZhaWxlZCcpO1xyXG4gICAgbmV0d29ya0Vycm9yLm5hbWUgPSAnVHlwZUVycm9yJztcclxuXHJcbiAgICBhY3QoKCkgPT4ge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHJlc3VsdC5jdXJyZW50LmhhbmRsZUVycm9yKG5ldHdvcmtFcnJvcik7XHJcbiAgICAgIGV4cGVjdChlcnJvci50eXBlKS50b0JlKCduZXR3b3JrJyk7XHJcbiAgICAgIGV4cGVjdChlcnJvci5yZXRyeWFibGUpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChlcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2NvbmV4acOzbicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgY2xhc3NpZnkgdGltZW91dCBlcnJvcnMgY29ycmVjdGx5JywgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU2VhcmNoRXJyb3JIYW5kbGVyKCkpO1xyXG5cclxuICAgIGNvbnN0IHRpbWVvdXRFcnJvciA9IG5ldyBFcnJvcigndGltZW91dCcpO1xyXG4gICAgdGltZW91dEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XHJcblxyXG4gICAgYWN0KCgpID0+IHtcclxuICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQuY3VycmVudC5oYW5kbGVFcnJvcih0aW1lb3V0RXJyb3IpO1xyXG4gICAgICBleHBlY3QoZXJyb3IudHlwZSkudG9CZSgndGltZW91dCcpO1xyXG4gICAgICBleHBlY3QoZXJyb3IucmV0cnlhYmxlKS50b0JlKHRydWUpO1xyXG4gICAgICBleHBlY3QoZXJyb3IubWVzc2FnZSkudG9Db250YWluKCd0YXJkw7MgZGVtYXNpYWRvJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBjbGFzc2lmeSBzZXJ2ZXIgZXJyb3JzIGNvcnJlY3RseScsICgpID0+IHtcclxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVNlYXJjaEVycm9ySGFuZGxlcigpKTtcclxuXHJcbiAgICBjb25zdCBzZXJ2ZXJFcnJvciA9IHsgc3RhdHVzOiA1MDAsIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InIH07XHJcblxyXG4gICAgYWN0KCgpID0+IHtcclxuICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQuY3VycmVudC5oYW5kbGVFcnJvcihzZXJ2ZXJFcnJvcik7XHJcbiAgICAgIGV4cGVjdChlcnJvci50eXBlKS50b0JlKCdzZXJ2ZXInKTtcclxuICAgICAgZXhwZWN0KGVycm9yLnJldHJ5YWJsZSkudG9CZSh0cnVlKTtcclxuICAgICAgZXhwZWN0KGVycm9yLmNvZGUpLnRvQmUoJzUwMCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgY2xhc3NpZnkgdmFsaWRhdGlvbiBlcnJvcnMgY29ycmVjdGx5JywgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU2VhcmNoRXJyb3JIYW5kbGVyKCkpO1xyXG5cclxuICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IHsgc3RhdHVzOiA0MDAsIG1lc3NhZ2U6ICdCYWQgUmVxdWVzdCcgfTtcclxuXHJcbiAgICBhY3QoKCkgPT4ge1xyXG4gICAgICBjb25zdCBlcnJvciA9IHJlc3VsdC5jdXJyZW50LmhhbmRsZUVycm9yKHZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgIGV4cGVjdChlcnJvci50eXBlKS50b0JlKCd2YWxpZGF0aW9uJyk7XHJcbiAgICAgIGV4cGVjdChlcnJvci5yZXRyeWFibGUpLnRvQmUoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoZXJyb3IuY29kZSkudG9CZSgnNDAwJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBSRVRSWSBBVVRPTcOBVElDT1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZVNlYXJjaEVycm9ySGFuZGxlciAtIFJldHJ5IExvZ2ljJywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgcmV0cnkgZmFpbGVkIG9wZXJhdGlvbnMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXHJcbiAgICAgIHVzZVNlYXJjaEVycm9ySGFuZGxlcih7XHJcbiAgICAgICAgcmV0cnlDb25maWc6IHtcclxuICAgICAgICAgIG1heFJldHJpZXM6IDMsXHJcbiAgICAgICAgICBiYXNlRGVsYXk6IDEwMCxcclxuICAgICAgICAgIGJhY2tvZmZGYWN0b3I6IDIsXHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgY2FsbENvdW50ID0gMDtcclxuICAgIGNvbnN0IGZhaWxpbmdPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcclxuICAgICAgY2FsbENvdW50Kys7XHJcbiAgICAgIGlmIChjYWxsQ291bnQgPCAzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnc3VjY2VzcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGV4ZWN1dGVQcm9taXNlOiBQcm9taXNlPGFueT47XHJcblxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgZXhlY3V0ZVByb21pc2UgPSByZXN1bHQuY3VycmVudC5leGVjdXRlV2l0aFJldHJ5KGZhaWxpbmdPcGVyYXRpb24sICd0ZXN0IG9wZXJhdGlvbicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXZhbnphciB0aW1lcnMgcGFyYSBsb3MgcmV0cmllc1xyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMCk7IC8vIFByaW1lciByZXRyeVxyXG4gICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDIwMCk7IC8vIFNlZ3VuZG8gcmV0cnlcclxuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXN1bHRfdmFsdWUgPSBhd2FpdCBleGVjdXRlUHJvbWlzZSE7XHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdF92YWx1ZSkudG9CZSgnc3VjY2VzcycpO1xyXG4gICAgZXhwZWN0KGZhaWxpbmdPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBub3QgcmV0cnkgbm9uLXJldHJ5YWJsZSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTZWFyY2hFcnJvckhhbmRsZXIoKSk7XHJcblxyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0JhZCBSZXF1ZXN0Jyk7XHJcbiAgICAoZXJyb3IgYXMgYW55KS5zdGF0dXMgPSA0MDA7XHJcbiAgICBjb25zdCBub25SZXRyeWFibGVPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUoZXJyb3IpO1xyXG5cclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGF3YWl0IGV4cGVjdChcclxuICAgICAgICByZXN1bHQuY3VycmVudC5leGVjdXRlV2l0aFJldHJ5KG5vblJldHJ5YWJsZU9wZXJhdGlvbiwgJ3ZhbGlkYXRpb24gdGVzdCcpXHJcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBlY3Qobm9uUmV0cnlhYmxlT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgc3RvcCByZXRyeWluZyBhZnRlciBtYXggYXR0ZW1wdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxyXG4gICAgICB1c2VTZWFyY2hFcnJvckhhbmRsZXIoe1xyXG4gICAgICAgIHJldHJ5Q29uZmlnOiB7IG1heFJldHJpZXM6IDIsIGJhc2VEZWxheTogMSB9IC8vIERlbGF5IG11eSBwZXF1ZcOxb1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBhbHdheXNGYWlsaW5nT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKFxyXG4gICAgICBuZXcgRXJyb3IoJ1BlcnNpc3RlbnQgZXJyb3InKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBVc2FyIHJlYWwgdGltZXJzIHBhcmEgZXN0ZSB0ZXN0XHJcbiAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtcclxuXHJcbiAgICBhd2FpdCBleHBlY3QoXHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LmV4ZWN1dGVXaXRoUmV0cnkoXHJcbiAgICAgICAgYWx3YXlzRmFpbGluZ09wZXJhdGlvbixcclxuICAgICAgICAncGVyc2lzdGVudCBmYWlsdXJlIHRlc3QnXHJcbiAgICAgIClcclxuICAgICkucmVqZWN0cy50b1Rocm93KCdQZXJzaXN0ZW50IGVycm9yJyk7XHJcblxyXG4gICAgZXhwZWN0KGFsd2F5c0ZhaWxpbmdPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTsgLy8gT3JpZ2luYWwgKyAyIHJldHJpZXNcclxuXHJcbiAgICAvLyBSZXN0YXVyYXIgZmFrZSB0aW1lcnNcclxuICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFRFU1RTIERFIENBTExCQUNLU1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuZGVzY3JpYmUoJ3VzZVNlYXJjaEVycm9ySGFuZGxlciAtIENhbGxiYWNrcycsICgpID0+IHtcclxuICBpdCgnc2hvdWxkIGNhbGwgb25FcnJvciBjYWxsYmFjayB3aGVuIGVycm9yIG9jY3VycycsICgpID0+IHtcclxuICAgIGNvbnN0IG9uRXJyb3IgPSBqZXN0LmZuKCk7XHJcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VTZWFyY2hFcnJvckhhbmRsZXIoeyBvbkVycm9yIH0pKTtcclxuXHJcbiAgICBjb25zdCB0ZXN0RXJyb3IgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcclxuXHJcbiAgICBhY3QoKCkgPT4ge1xyXG4gICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVFcnJvcih0ZXN0RXJyb3IpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZXhwZWN0KG9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxyXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XHJcbiAgICAgICAgdHlwZTogJ3Vua25vd24nLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdUZXN0IGVycm9yJyxcclxuICAgICAgICByZXRyeWFibGU6IHRydWUsXHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIGNhbGwgb25SZXRyeVN1Y2Nlc3MgY2FsbGJhY2sgb24gc3VjY2Vzc2Z1bCByZXRyeScsIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IG9uUmV0cnlTdWNjZXNzID0gamVzdC5mbigpO1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXHJcbiAgICAgIHVzZVNlYXJjaEVycm9ySGFuZGxlcih7IFxyXG4gICAgICAgIG9uUmV0cnlTdWNjZXNzLFxyXG4gICAgICAgIHJldHJ5Q29uZmlnOiB7IG1heFJldHJpZXM6IDIsIGJhc2VEZWxheTogNTAgfVxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgY2FsbENvdW50ID0gMDtcclxuICAgIGNvbnN0IHJldHJ5T3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XHJcbiAgICAgIGNhbGxDb3VudCsrO1xyXG4gICAgICBpZiAoY2FsbENvdW50ID09PSAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBmYWlsdXJlJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnc3VjY2VzcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGV4ZWN1dGVQcm9taXNlOiBQcm9taXNlPGFueT47XHJcblxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgZXhlY3V0ZVByb21pc2UgPSByZXN1bHQuY3VycmVudC5leGVjdXRlV2l0aFJldHJ5KHJldHJ5T3BlcmF0aW9uKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSg1MCk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgZXhlY3V0ZVByb21pc2UhO1xyXG5cclxuICAgIGV4cGVjdChvblJldHJ5U3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIGNhbGwgb25SZXRyeUZhaWxlZCBjYWxsYmFjayB3aGVuIGFsbCByZXRyaWVzIGZhaWwnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBvblJldHJ5RmFpbGVkID0gamVzdC5mbigpO1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cclxuICAgICAgdXNlU2VhcmNoRXJyb3JIYW5kbGVyKHtcclxuICAgICAgICBvblJldHJ5RmFpbGVkLFxyXG4gICAgICAgIHJldHJ5Q29uZmlnOiB7IG1heFJldHJpZXM6IDEsIGJhc2VEZWxheTogMSB9IC8vIERlbGF5IG11eSBwZXF1ZcOxb1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBmYWlsaW5nT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQWx3YXlzIGZhaWxzJykpO1xyXG5cclxuICAgIC8vIFVzYXIgcmVhbCB0aW1lcnMgcGFyYSBlc3RlIHRlc3RcclxuICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xyXG5cclxuICAgIGF3YWl0IGV4cGVjdChcclxuICAgICAgcmVzdWx0LmN1cnJlbnQuZXhlY3V0ZVdpdGhSZXRyeShmYWlsaW5nT3BlcmF0aW9uKVxyXG4gICAgKS5yZWplY3RzLnRvVGhyb3coKTtcclxuXHJcbiAgICBleHBlY3Qob25SZXRyeUZhaWxlZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXHJcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcclxuICAgICAgICB0eXBlOiAndW5rbm93bicsXHJcbiAgICAgICAgbWVzc2FnZTogJ0Fsd2F5cyBmYWlscycsXHJcbiAgICAgIH0pLFxyXG4gICAgICAxIC8vIG7Dum1lcm8gZGUgaW50ZW50b3NcclxuICAgICk7XHJcblxyXG4gICAgLy8gUmVzdGF1cmFyIGZha2UgdGltZXJzXHJcbiAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcclxuICB9KTtcclxufSk7XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUyBERSBFU1RBRE9cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmRlc2NyaWJlKCd1c2VTZWFyY2hFcnJvckhhbmRsZXIgLSBTdGF0ZSBNYW5hZ2VtZW50JywgKCkgPT4ge1xyXG4gIGl0KCdzaG91bGQgdXBkYXRlIHJldHJ5IHN0YXRlIGR1cmluZyByZXRyaWVzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gXHJcbiAgICAgIHVzZVNlYXJjaEVycm9ySGFuZGxlcih7XHJcbiAgICAgICAgcmV0cnlDb25maWc6IHsgbWF4UmV0cmllczogMiwgYmFzZURlbGF5OiA1MCB9XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG5cclxuICAgIGxldCBjYWxsQ291bnQgPSAwO1xyXG4gICAgY29uc3QgcmV0cnlPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcclxuICAgICAgY2FsbENvdW50Kys7XHJcbiAgICAgIGlmIChjYWxsQ291bnQgPCAzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXRyeSB0ZXN0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnc3VjY2VzcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGV4ZWN1dGVQcm9taXNlOiBQcm9taXNlPGFueT47XHJcblxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgZXhlY3V0ZVByb21pc2UgPSByZXN1bHQuY3VycmVudC5leGVjdXRlV2l0aFJldHJ5KHJldHJ5T3BlcmF0aW9uKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFZlcmlmaWNhciBlc3RhZG8gZHVyYW50ZSBwcmltZXIgcmV0cnlcclxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XHJcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSg1MCk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzUmV0cnlpbmcpLnRvQmUodHJ1ZSk7XHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucmV0cnlDb3VudCkudG9CZSgxKTtcclxuXHJcbiAgICAvLyBDb21wbGV0YXIgbGEgb3BlcmFjacOzblxyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcclxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDEwMCk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYXdhaXQgZXhlY3V0ZVByb21pc2UhO1xyXG5cclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc1JldHJ5aW5nKS50b0JlKGZhbHNlKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5yZXRyeUNvdW50KS50b0JlKDApO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIGNsZWFyIGVycm9yIHN0YXRlJywgKCkgPT4ge1xyXG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlU2VhcmNoRXJyb3JIYW5kbGVyKCkpO1xyXG5cclxuICAgIC8vIFNpbXVsYXIgZXJyb3JcclxuICAgIGFjdCgoKSA9PiB7XHJcbiAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZUVycm9yKG5ldyBFcnJvcignVGVzdCBlcnJvcicpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5oYXNFcnJvcikudG9CZSh0cnVlKTtcclxuXHJcbiAgICAvLyBMaW1waWFyIGVycm9yXHJcbiAgICBhY3QoKCkgPT4ge1xyXG4gICAgICByZXN1bHQuY3VycmVudC5jbGVhckVycm9yKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaGFzRXJyb3IpLnRvQmUoZmFsc2UpO1xyXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmN1cnJlbnRFcnJvcikudG9CZShudWxsKTtcclxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5yZXRyeUNvdW50KS50b0JlKDApO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIl0sIm5hbWVzIjpbImJlZm9yZUVhY2giLCJqZXN0IiwiY2xlYXJBbGxNb2NrcyIsInVzZUZha2VUaW1lcnMiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJhZnRlckVhY2giLCJ1c2VSZWFsVGltZXJzIiwicmVzdG9yZUFsbE1vY2tzIiwiZGVzY3JpYmUiLCJpdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VTZWFyY2hFcnJvckhhbmRsZXIiLCJleHBlY3QiLCJjdXJyZW50IiwiY3VycmVudEVycm9yIiwidG9CZSIsInJldHJ5Q291bnQiLCJpc1JldHJ5aW5nIiwiaGFzRXJyb3IiLCJyZXRyeUNvbmZpZyIsIm1heFJldHJpZXMiLCJiYXNlRGVsYXkiLCJuZXR3b3JrRXJyb3IiLCJUeXBlRXJyb3IiLCJuYW1lIiwiYWN0IiwiZXJyb3IiLCJoYW5kbGVFcnJvciIsInR5cGUiLCJyZXRyeWFibGUiLCJtZXNzYWdlIiwidG9Db250YWluIiwidGltZW91dEVycm9yIiwiRXJyb3IiLCJzZXJ2ZXJFcnJvciIsInN0YXR1cyIsImNvZGUiLCJ2YWxpZGF0aW9uRXJyb3IiLCJiYWNrb2ZmRmFjdG9yIiwiY2FsbENvdW50IiwiZmFpbGluZ09wZXJhdGlvbiIsImZuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJleGVjdXRlUHJvbWlzZSIsImV4ZWN1dGVXaXRoUmV0cnkiLCJhZHZhbmNlVGltZXJzQnlUaW1lIiwicmVzdWx0X3ZhbHVlIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwibm9uUmV0cnlhYmxlT3BlcmF0aW9uIiwibW9ja1JlamVjdGVkVmFsdWUiLCJyZWplY3RzIiwidG9UaHJvdyIsImFsd2F5c0ZhaWxpbmdPcGVyYXRpb24iLCJvbkVycm9yIiwidGVzdEVycm9yIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwib25SZXRyeVN1Y2Nlc3MiLCJyZXRyeU9wZXJhdGlvbiIsInRvSGF2ZUJlZW5DYWxsZWQiLCJvblJldHJ5RmFpbGVkIiwiY2xlYXJFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLGdFQUFnRTtBQUNoRSxzQ0FBc0M7Ozs7O3VCQUVHO3VDQUNIO0FBRXRDLHNDQUFzQztBQUN0QyxRQUFRO0FBQ1Isc0NBQXNDO0FBRXRDQSxXQUFXO0lBQ1RDLEtBQUtDLGFBQWE7SUFDbEJELEtBQUtFLGFBQWE7SUFDbEIsdUNBQXVDO0lBQ3ZDRixLQUFLRyxLQUFLLENBQUNDLFNBQVMsUUFBUUMsa0JBQWtCLENBQUMsS0FBTztJQUN0REwsS0FBS0csS0FBSyxDQUFDQyxTQUFTLFNBQVNDLGtCQUFrQixDQUFDLEtBQU87QUFDekQ7QUFFQUMsVUFBVTtJQUNSTixLQUFLTyxhQUFhO0lBQ2xCUCxLQUFLUSxlQUFlO0FBQ3RCO0FBRUEsc0NBQXNDO0FBQ3RDLGdCQUFnQjtBQUNoQixzQ0FBc0M7QUFFdENDLFNBQVMsOEJBQThCO0lBQ3JDQyxHQUFHLHdDQUF3QztRQUN6QyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxJQUFBQSxpQkFBVSxFQUFDLElBQU1DLElBQUFBLDRDQUFxQjtRQUV6REMsT0FB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