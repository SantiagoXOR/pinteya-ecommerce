a87fd21228c1e7581d42ec495739884a
// ===================================
// PINTEYA E-COMMERCE - TEST useProducts HOOK
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useProducts = require("../../hooks/useProducts");
// Mock data
const mockProductsResponse = {
    success: true,
    data: [
        {
            id: 1,
            name: 'Test Product 1',
            slug: 'test-product-1',
            description: 'Test description',
            price: 1000,
            discounted_price: 900,
            stock: 10,
            category_id: 1,
            images: {
                previews: [
                    '/test1.jpg'
                ]
            },
            category: {
                id: 1,
                name: 'Test Category',
                slug: 'test-category'
            }
        },
        {
            id: 2,
            name: 'Test Product 2',
            slug: 'test-product-2',
            description: 'Test description 2',
            price: 2000,
            discounted_price: null,
            stock: 5,
            category_id: 2,
            images: {
                previews: [
                    '/test2.jpg'
                ]
            },
            category: {
                id: 2,
                name: 'Test Category 2',
                slug: 'test-category-2'
            }
        }
    ],
    pagination: {
        page: 1,
        limit: 12,
        total: 2,
        totalPages: 1
    }
};
const mockCategoriesResponse = {
    success: true,
    data: [
        {
            id: 1,
            name: 'Test Category',
            slug: 'test-category'
        },
        {
            id: 2,
            name: 'Test Category 2',
            slug: 'test-category-2'
        }
    ]
};
// Mock fetch
const mockFetch = jest.fn();
global.fetch = mockFetch;
describe('useProducts Hook', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        mockFetch.mockResolvedValue({
            ok: true,
            json: async ()=>mockProductsResponse
        });
    });
    it('fetches products on mount', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        // Initially loading should be true
        expect(result.current.loading).toBe(true);
        expect(result.current.products).toEqual([]);
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Should have fetched products - the hook may not include default parameters
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/api/products'), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
        expect(result.current.products).toHaveLength(2);
        // Products are adapted, so we check the adapted structure
        expect(result.current.products[0]).toBeDefined();
    });
    it('fetches products successfully', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Should have fetched products
        expect(mockFetch).toHaveBeenCalled();
        expect(result.current.products).toHaveLength(2);
        expect(result.current.hasError).toBe(false);
    });
    it('handles search functionality', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock search response
        mockFetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    ...mockProductsResponse,
                    data: [
                        mockProductsResponse.data[0]
                    ]
                })
        });
        // Perform search
        await (0, _react.act)(async ()=>{
            await result.current.searchProducts('Test Product 1');
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/api/products'), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('handles category filtering', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock category filter response
        mockFetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    ...mockProductsResponse,
                    data: [
                        mockProductsResponse.data[0]
                    ]
                })
        });
        // Filter by category
        await (0, _react.act)(async ()=>{
            await result.current.filterByCategory('1');
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*category=1/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('handles pagination', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock page 2 response
        mockFetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>({
                    ...mockProductsResponse,
                    pagination: {
                        ...mockProductsResponse.pagination,
                        page: 2
                    }
                })
        });
        // Go to page 2
        await (0, _react.act)(async ()=>{
            await result.current.fetchProducts({
                page: 2
            });
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*page=2/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
        expect(result.current.pagination.page).toBe(2);
    });
    it('handles price range filtering', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock price filter response
        mockFetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>mockProductsResponse
        });
        // Filter by price range
        await (0, _react.act)(async ()=>{
            await result.current.fetchProducts({
                priceMin: 500,
                priceMax: 1500
            });
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*priceMin=500.*priceMax=1500/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('handles sorting', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock sort response
        mockFetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>mockProductsResponse
        });
        // Sort by price ascending
        await (0, _react.act)(async ()=>{
            await result.current.fetchProducts({
                sortBy: 'price',
                sortOrder: 'asc'
            });
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*sortBy=price.*sortOrder=asc/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('handles API errors gracefully', async ()=>{
        mockFetch.mockRejectedValueOnce(new Error('API Error'));
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        expect(result.current.error).toBe('API Error');
        expect(result.current.products).toEqual([]);
    });
    it('handles HTTP error responses', async ()=>{
        mockFetch.mockResolvedValueOnce({
            ok: false,
            status: 500,
            statusText: 'Internal Server Error',
            json: async ()=>({
                    error: 'Server Error'
                })
        });
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        expect(result.current.error).toContain('Error 500');
        expect(result.current.products).toEqual([]);
    });
    it('clears filters correctly', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Apply some filters first
        await (0, _react.act)(async ()=>{
            await result.current.searchProducts('test');
        });
        await (0, _react.act)(async ()=>{
            await result.current.filterByCategory('1');
        });
        // Clear previous calls
        mockFetch.mockClear();
        // Mock reset response
        mockFetch.mockResolvedValueOnce({
            ok: true,
            json: async ()=>mockProductsResponse
        });
        // Clear filters
        await (0, _react.act)(async ()=>{
            await result.current.clearFilters();
        });
        expect(mockFetch).toHaveBeenCalledWith(expect.stringMatching(/\/api\/products\?.*page=1/), expect.objectContaining({
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        }));
    });
    it('maintains loading state during requests', async ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProducts.useProducts)());
        // Initial loading
        expect(result.current.loading).toBe(true);
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
        // Mock slow response
        let resolvePromise;
        const slowPromise = new Promise((resolve)=>{
            resolvePromise = resolve;
        });
        mockFetch.mockReturnValueOnce(slowPromise);
        // Start new request
        (0, _react.act)(()=>{
            result.current.searchProducts('test');
        });
        // Should be loading again
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(true);
        });
        // Resolve the promise
        resolvePromise({
            ok: true,
            json: async ()=>mockProductsResponse
        });
        await (0, _react.waitFor)(()=>{
            expect(result.current.loading).toBe(false);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcX190ZXN0c19fXFxob29rc1xcdXNlUHJvZHVjdHMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUElOVEVZQSBFLUNPTU1FUkNFIC0gVEVTVCB1c2VQcm9kdWN0cyBIT09LXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbXBvcnQgeyByZW5kZXJIb29rLCB3YWl0Rm9yLCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0J1xuaW1wb3J0IHsgdXNlUHJvZHVjdHMgfSBmcm9tICdAL2hvb2tzL3VzZVByb2R1Y3RzJ1xuXG4vLyBNb2NrIGRhdGFcbmNvbnN0IG1vY2tQcm9kdWN0c1Jlc3BvbnNlID0ge1xuICBzdWNjZXNzOiB0cnVlLFxuICBkYXRhOiBbXG4gICAge1xuICAgICAgaWQ6IDEsXG4gICAgICBuYW1lOiAnVGVzdCBQcm9kdWN0IDEnLFxuICAgICAgc2x1ZzogJ3Rlc3QtcHJvZHVjdC0xJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBkZXNjcmlwdGlvbicsXG4gICAgICBwcmljZTogMTAwMCxcbiAgICAgIGRpc2NvdW50ZWRfcHJpY2U6IDkwMCxcbiAgICAgIHN0b2NrOiAxMCxcbiAgICAgIGNhdGVnb3J5X2lkOiAxLFxuICAgICAgaW1hZ2VzOiB7IHByZXZpZXdzOiBbJy90ZXN0MS5qcGcnXSB9LFxuICAgICAgY2F0ZWdvcnk6IHsgaWQ6IDEsIG5hbWU6ICdUZXN0IENhdGVnb3J5Jywgc2x1ZzogJ3Rlc3QtY2F0ZWdvcnknIH0sXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogMixcbiAgICAgIG5hbWU6ICdUZXN0IFByb2R1Y3QgMicsXG4gICAgICBzbHVnOiAndGVzdC1wcm9kdWN0LTInLFxuICAgICAgZGVzY3JpcHRpb246ICdUZXN0IGRlc2NyaXB0aW9uIDInLFxuICAgICAgcHJpY2U6IDIwMDAsXG4gICAgICBkaXNjb3VudGVkX3ByaWNlOiBudWxsLFxuICAgICAgc3RvY2s6IDUsXG4gICAgICBjYXRlZ29yeV9pZDogMixcbiAgICAgIGltYWdlczogeyBwcmV2aWV3czogWycvdGVzdDIuanBnJ10gfSxcbiAgICAgIGNhdGVnb3J5OiB7IGlkOiAyLCBuYW1lOiAnVGVzdCBDYXRlZ29yeSAyJywgc2x1ZzogJ3Rlc3QtY2F0ZWdvcnktMicgfSxcbiAgICB9LFxuICBdLFxuICBwYWdpbmF0aW9uOiB7XG4gICAgcGFnZTogMSxcbiAgICBsaW1pdDogMTIsXG4gICAgdG90YWw6IDIsXG4gICAgdG90YWxQYWdlczogMSxcbiAgfSxcbn1cblxuY29uc3QgbW9ja0NhdGVnb3JpZXNSZXNwb25zZSA9IHtcbiAgc3VjY2VzczogdHJ1ZSxcbiAgZGF0YTogW1xuICAgIHsgaWQ6IDEsIG5hbWU6ICdUZXN0IENhdGVnb3J5Jywgc2x1ZzogJ3Rlc3QtY2F0ZWdvcnknIH0sXG4gICAgeyBpZDogMiwgbmFtZTogJ1Rlc3QgQ2F0ZWdvcnkgMicsIHNsdWc6ICd0ZXN0LWNhdGVnb3J5LTInIH0sXG4gIF0sXG59XG5cbi8vIE1vY2sgZmV0Y2hcbmNvbnN0IG1vY2tGZXRjaCA9IGplc3QuZm4oKVxuZ2xvYmFsLmZldGNoID0gbW9ja0ZldGNoXG5cbmRlc2NyaWJlKCd1c2VQcm9kdWN0cyBIb29rJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tQcm9kdWN0c1Jlc3BvbnNlLFxuICAgIH0pXG4gIH0pXG5cbiAgaXQoJ2ZldGNoZXMgcHJvZHVjdHMgb24gbW91bnQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgIC8vIEluaXRpYWxseSBsb2FkaW5nIHNob3VsZCBiZSB0cnVlXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUodHJ1ZSlcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucHJvZHVjdHMpLnRvRXF1YWwoW10pXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBTaG91bGQgaGF2ZSBmZXRjaGVkIHByb2R1Y3RzIC0gdGhlIGhvb2sgbWF5IG5vdCBpbmNsdWRlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJy9hcGkvcHJvZHVjdHMnKSxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgIH0pXG4gICAgKVxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5wcm9kdWN0cykudG9IYXZlTGVuZ3RoKDIpXG4gICAgLy8gUHJvZHVjdHMgYXJlIGFkYXB0ZWQsIHNvIHdlIGNoZWNrIHRoZSBhZGFwdGVkIHN0cnVjdHVyZVxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5wcm9kdWN0c1swXSkudG9CZURlZmluZWQoKVxuICB9KVxuXG4gIGl0KCdmZXRjaGVzIHByb2R1Y3RzIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSlcbiAgICB9KVxuXG4gICAgLy8gU2hvdWxkIGhhdmUgZmV0Y2hlZCBwcm9kdWN0c1xuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5wcm9kdWN0cykudG9IYXZlTGVuZ3RoKDIpXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50Lmhhc0Vycm9yKS50b0JlKGZhbHNlKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIHNlYXJjaCBmdW5jdGlvbmFsaXR5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBDbGVhciBwcmV2aW91cyBjYWxsc1xuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxuXG4gICAgLy8gTW9jayBzZWFyY2ggcmVzcG9uc2VcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgLi4ubW9ja1Byb2R1Y3RzUmVzcG9uc2UsXG4gICAgICAgIGRhdGE6IFttb2NrUHJvZHVjdHNSZXNwb25zZS5kYXRhWzBdXSwgLy8gT25seSBmaXJzdCBwcm9kdWN0XG4gICAgICB9KSxcbiAgICB9KVxuXG4gICAgLy8gUGVyZm9ybSBzZWFyY2hcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuc2VhcmNoUHJvZHVjdHMoJ1Rlc3QgUHJvZHVjdCAxJylcbiAgICB9KVxuXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnL2FwaS9wcm9kdWN0cycpLFxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfVxuICAgICAgfSlcbiAgICApXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgY2F0ZWdvcnkgZmlsdGVyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBDbGVhciBwcmV2aW91cyBjYWxsc1xuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxuXG4gICAgLy8gTW9jayBjYXRlZ29yeSBmaWx0ZXIgcmVzcG9uc2VcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgLi4ubW9ja1Byb2R1Y3RzUmVzcG9uc2UsXG4gICAgICAgIGRhdGE6IFttb2NrUHJvZHVjdHNSZXNwb25zZS5kYXRhWzBdXSwgLy8gT25seSBmaXJzdCBwcm9kdWN0XG4gICAgICB9KSxcbiAgICB9KVxuXG4gICAgLy8gRmlsdGVyIGJ5IGNhdGVnb3J5XG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmZpbHRlckJ5Q2F0ZWdvcnkoJzEnKVxuICAgIH0pXG5cbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFwvYXBpXFwvcHJvZHVjdHNcXD8uKmNhdGVnb3J5PTEvKSxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgIH0pXG4gICAgKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIHBhZ2luYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIC8vIENsZWFyIHByZXZpb3VzIGNhbGxzXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpXG5cbiAgICAvLyBNb2NrIHBhZ2UgMiByZXNwb25zZVxuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAuLi5tb2NrUHJvZHVjdHNSZXNwb25zZSxcbiAgICAgICAgcGFnaW5hdGlvbjogeyAuLi5tb2NrUHJvZHVjdHNSZXNwb25zZS5wYWdpbmF0aW9uLCBwYWdlOiAyIH0sXG4gICAgICB9KSxcbiAgICB9KVxuXG4gICAgLy8gR28gdG8gcGFnZSAyXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmZldGNoUHJvZHVjdHMoeyBwYWdlOiAyIH0pXG4gICAgfSlcblxuICAgIGV4cGVjdChtb2NrRmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgZXhwZWN0LnN0cmluZ01hdGNoaW5nKC9cXC9hcGlcXC9wcm9kdWN0c1xcPy4qcGFnZT0yLyksXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9XG4gICAgICB9KVxuICAgIClcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucGFnaW5hdGlvbi5wYWdlKS50b0JlKDIpXG4gIH0pXG5cbiAgaXQoJ2hhbmRsZXMgcHJpY2UgcmFuZ2UgZmlsdGVyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICAvLyBDbGVhciBwcmV2aW91cyBjYWxsc1xuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxuXG4gICAgLy8gTW9jayBwcmljZSBmaWx0ZXIgcmVzcG9uc2VcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1Byb2R1Y3RzUmVzcG9uc2UsXG4gICAgfSlcblxuICAgIC8vIEZpbHRlciBieSBwcmljZSByYW5nZVxuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5mZXRjaFByb2R1Y3RzKHsgcHJpY2VNaW46IDUwMCwgcHJpY2VNYXg6IDE1MDAgfSlcbiAgICB9KVxuXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcL2FwaVxcL3Byb2R1Y3RzXFw/LipwcmljZU1pbj01MDAuKnByaWNlTWF4PTE1MDAvKSxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgIH0pXG4gICAgKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIHNvcnRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlUHJvZHVjdHMoKSlcblxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIC8vIENsZWFyIHByZXZpb3VzIGNhbGxzXG4gICAgbW9ja0ZldGNoLm1vY2tDbGVhcigpXG5cbiAgICAvLyBNb2NrIHNvcnQgcmVzcG9uc2VcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAganNvbjogYXN5bmMgKCkgPT4gbW9ja1Byb2R1Y3RzUmVzcG9uc2UsXG4gICAgfSlcblxuICAgIC8vIFNvcnQgYnkgcHJpY2UgYXNjZW5kaW5nXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmZldGNoUHJvZHVjdHMoeyBzb3J0Qnk6ICdwcmljZScsIHNvcnRPcmRlcjogJ2FzYycgfSlcbiAgICB9KVxuXG4gICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL1xcL2FwaVxcL3Byb2R1Y3RzXFw/Lipzb3J0Qnk9cHJpY2UuKnNvcnRPcmRlcj1hc2MvKSxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH1cbiAgICAgIH0pXG4gICAgKVxuICB9KVxuXG4gIGl0KCdoYW5kbGVzIEFQSSBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICBtb2NrRmV0Y2gubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcignQVBJIEVycm9yJykpXG5cbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSlcbiAgICB9KVxuXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlKCdBUEkgRXJyb3InKVxuICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5wcm9kdWN0cykudG9FcXVhbChbXSlcbiAgfSlcblxuICBpdCgnaGFuZGxlcyBIVFRQIGVycm9yIHJlc3BvbnNlcycsIGFzeW5jICgpID0+IHtcbiAgICBtb2NrRmV0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiBmYWxzZSxcbiAgICAgIHN0YXR1czogNTAwLFxuICAgICAgc3RhdHVzVGV4dDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiAoeyBlcnJvcjogJ1NlcnZlciBFcnJvcicgfSksXG4gICAgfSlcblxuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZVByb2R1Y3RzKCkpXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG5cbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQ29udGFpbignRXJyb3IgNTAwJylcbiAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQucHJvZHVjdHMpLnRvRXF1YWwoW10pXG4gIH0pXG5cbiAgaXQoJ2NsZWFycyBmaWx0ZXJzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQubG9hZGluZykudG9CZShmYWxzZSlcbiAgICB9KVxuXG4gICAgLy8gQXBwbHkgc29tZSBmaWx0ZXJzIGZpcnN0XG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LnNlYXJjaFByb2R1Y3RzKCd0ZXN0JylcbiAgICB9KVxuXG4gICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmZpbHRlckJ5Q2F0ZWdvcnkoJzEnKVxuICAgIH0pXG5cbiAgICAvLyBDbGVhciBwcmV2aW91cyBjYWxsc1xuICAgIG1vY2tGZXRjaC5tb2NrQ2xlYXIoKVxuXG4gICAgLy8gTW9jayByZXNldCByZXNwb25zZVxuICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgb2s6IHRydWUsXG4gICAgICBqc29uOiBhc3luYyAoKSA9PiBtb2NrUHJvZHVjdHNSZXNwb25zZSxcbiAgICB9KVxuXG4gICAgLy8gQ2xlYXIgZmlsdGVyc1xuICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZXN1bHQuY3VycmVudC5jbGVhckZpbHRlcnMoKVxuICAgIH0pXG5cbiAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXFwvYXBpXFwvcHJvZHVjdHNcXD8uKnBhZ2U9MS8pLFxuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfVxuICAgICAgfSlcbiAgICApXG4gIH0pXG5cbiAgaXQoJ21haW50YWlucyBsb2FkaW5nIHN0YXRlIGR1cmluZyByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VQcm9kdWN0cygpKVxuXG4gICAgLy8gSW5pdGlhbCBsb2FkaW5nXG4gICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUodHJ1ZSlcblxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIC8vIE1vY2sgc2xvdyByZXNwb25zZVxuICAgIGxldCByZXNvbHZlUHJvbWlzZTogKHZhbHVlOiBhbnkpID0+IHZvaWRcbiAgICBjb25zdCBzbG93UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlXG4gICAgfSlcblxuICAgIG1vY2tGZXRjaC5tb2NrUmV0dXJuVmFsdWVPbmNlKHNsb3dQcm9taXNlKVxuXG4gICAgLy8gU3RhcnQgbmV3IHJlcXVlc3RcbiAgICBhY3QoKCkgPT4ge1xuICAgICAgcmVzdWx0LmN1cnJlbnQuc2VhcmNoUHJvZHVjdHMoJ3Rlc3QnKVxuICAgIH0pXG5cbiAgICAvLyBTaG91bGQgYmUgbG9hZGluZyBhZ2FpblxuICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmxvYWRpbmcpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZVxuICAgIHJlc29sdmVQcm9taXNlISh7XG4gICAgICBvazogdHJ1ZSxcbiAgICAgIGpzb246IGFzeW5jICgpID0+IG1vY2tQcm9kdWN0c1Jlc3BvbnNlLFxuICAgIH0pXG5cbiAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5sb2FkaW5nKS50b0JlKGZhbHNlKVxuICAgIH0pXG4gIH0pXG59KVxuIl0sIm5hbWVzIjpbIm1vY2tQcm9kdWN0c1Jlc3BvbnNlIiwic3VjY2VzcyIsImRhdGEiLCJpZCIsIm5hbWUiLCJzbHVnIiwiZGVzY3JpcHRpb24iLCJwcmljZSIsImRpc2NvdW50ZWRfcHJpY2UiLCJzdG9jayIsImNhdGVnb3J5X2lkIiwiaW1hZ2VzIiwicHJldmlld3MiLCJjYXRlZ29yeSIsInBhZ2luYXRpb24iLCJwYWdlIiwibGltaXQiLCJ0b3RhbCIsInRvdGFsUGFnZXMiLCJtb2NrQ2F0ZWdvcmllc1Jlc3BvbnNlIiwibW9ja0ZldGNoIiwiamVzdCIsImZuIiwiZ2xvYmFsIiwiZmV0Y2giLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJvayIsImpzb24iLCJpdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VQcm9kdWN0cyIsImV4cGVjdCIsImN1cnJlbnQiLCJsb2FkaW5nIiwidG9CZSIsInByb2R1Y3RzIiwidG9FcXVhbCIsIndhaXRGb3IiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInN0cmluZ0NvbnRhaW5pbmciLCJvYmplY3RDb250YWluaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsInRvSGF2ZUxlbmd0aCIsInRvQmVEZWZpbmVkIiwidG9IYXZlQmVlbkNhbGxlZCIsImhhc0Vycm9yIiwibW9ja0NsZWFyIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwiYWN0Iiwic2VhcmNoUHJvZHVjdHMiLCJmaWx0ZXJCeUNhdGVnb3J5Iiwic3RyaW5nTWF0Y2hpbmciLCJmZXRjaFByb2R1Y3RzIiwicHJpY2VNaW4iLCJwcmljZU1heCIsInNvcnRCeSIsInNvcnRPcmRlciIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwiZXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwidG9Db250YWluIiwiY2xlYXJGaWx0ZXJzIiwicmVzb2x2ZVByb21pc2UiLCJzbG93UHJvbWlzZSIs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