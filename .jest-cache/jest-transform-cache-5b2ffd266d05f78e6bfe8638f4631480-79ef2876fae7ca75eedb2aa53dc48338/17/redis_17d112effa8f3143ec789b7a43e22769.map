{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\lib\\redis.ts"],"sourcesContent":["// ===================================\r\n// PINTEYA E-COMMERCE - REDIS CONFIGURATION\r\n// ===================================\r\n\r\nimport Redis from 'ioredis';\r\nimport { logger, LogLevel, LogCategory } from './logger';\r\n\r\n// Configuración de Redis\r\nconst REDIS_CONFIG = {\r\n  host: process.env.REDIS_HOST || 'localhost',\r\n  port: parseInt(process.env.REDIS_PORT || '6379'),\r\n  password: process.env.REDIS_PASSWORD,\r\n  db: parseInt(process.env.REDIS_DB || '0'),\r\n  retryDelayOnFailover: 100,\r\n  maxRetriesPerRequest: 3,\r\n  lazyConnect: true,\r\n  keepAlive: 30000,\r\n  connectTimeout: 10000,\r\n  commandTimeout: 5000,\r\n};\r\n\r\n// Cliente Redis singleton\r\nlet redisClient: Redis | null = null;\r\n\r\n/**\r\n * Obtiene o crea la instancia de Redis\r\n */\r\nexport function getRedisClient(): Redis {\r\n  if (!redisClient) {\r\n    redisClient = new Redis(REDIS_CONFIG);\r\n\r\n    // Event listeners para logging\r\n    redisClient.on('connect', () => {\r\n      logger.info(LogCategory.API, 'Redis connected successfully');\r\n    });\r\n\r\n    redisClient.on('error', (error) => {\r\n      logger.error(LogCategory.API, 'Redis connection error', error);\r\n    });\r\n\r\n    redisClient.on('close', () => {\r\n      logger.warn(LogCategory.API, 'Redis connection closed');\r\n    });\r\n\r\n    redisClient.on('reconnecting', () => {\r\n      logger.info(LogCategory.API, 'Redis reconnecting...');\r\n    });\r\n  }\r\n\r\n  return redisClient;\r\n}\r\n\r\n/**\r\n * Verifica si Redis está disponible\r\n */\r\nexport async function isRedisAvailable(): Promise<boolean> {\r\n  try {\r\n    const client = getRedisClient();\r\n    await client.ping();\r\n    return true;\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Redis health check failed', error as Error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Cierra la conexión de Redis\r\n */\r\nexport async function closeRedisConnection(): Promise<void> {\r\n  if (redisClient) {\r\n    await redisClient.quit();\r\n    redisClient = null;\r\n    logger.info(LogCategory.API, 'Redis connection closed gracefully');\r\n  }\r\n}\r\n\r\n/**\r\n * Operaciones de cache con manejo de errores\r\n */\r\nexport class RedisCache {\r\n  private client: Redis;\r\n\r\n  constructor() {\r\n    this.client = getRedisClient();\r\n  }\r\n\r\n  /**\r\n   * Obtiene un valor del cache\r\n   */\r\n  async get(key: string): Promise<string | null> {\r\n    try {\r\n      const value = await this.client.get(key);\r\n      logger.info(LogCategory.API, 'Cache get operation');\r\n      return value;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache get operation failed', error as Error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Establece un valor en el cache\r\n   */\r\n  async set(key: string, value: string, ttlSeconds?: number): Promise<boolean> {\r\n    try {\r\n      if (ttlSeconds) {\r\n        await this.client.setex(key, ttlSeconds, value);\r\n      } else {\r\n        await this.client.set(key, value);\r\n      }\r\n      \r\n      logger.info(LogCategory.API, 'Cache set operation');\r\n      return true;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache set operation failed', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Elimina un valor del cache\r\n   */\r\n  async del(key: string): Promise<boolean> {\r\n    try {\r\n      const result = await this.client.del(key);\r\n      logger.info(LogCategory.API, 'Cache delete operation');\r\n      return result > 0;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache delete operation failed', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Incrementa un contador atómicamente\r\n   */\r\n  async incr(key: string): Promise<number | null> {\r\n    try {\r\n      const result = await this.client.incr(key);\r\n      logger.info(LogCategory.API, 'Cache increment operation');\r\n      return result;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache increment operation failed', error as Error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Establece TTL para una clave existente\r\n   */\r\n  async expire(key: string, ttlSeconds: number): Promise<boolean> {\r\n    try {\r\n      const result = await this.client.expire(key, ttlSeconds);\r\n      logger.info(LogCategory.API, 'Cache expire operation');\r\n      return result === 1;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache expire operation failed', error as Error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obtiene TTL restante de una clave\r\n   */\r\n  async ttl(key: string): Promise<number | null> {\r\n    try {\r\n      const result = await this.client.ttl(key);\r\n      logger.info(LogCategory.API, 'Cache TTL check');\r\n      return result;\r\n    } catch (error) {\r\n      logger.error(LogCategory.API, 'Cache TTL check failed', error as Error);\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n// Instancia singleton del cache\r\nexport const redisCache = new RedisCache();\r\n\r\n// Funciones de utilidad para rate limiting\r\nexport async function getRateLimitInfo(key: string): Promise<{\r\n  count: number;\r\n  ttl: number;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const pipeline = client.pipeline();\r\n    pipeline.get(key);\r\n    pipeline.ttl(key);\r\n    \r\n    const results = await pipeline.exec();\r\n    \r\n    if (!results || results.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    const [countResult, ttlResult] = results;\r\n    const count = parseInt(countResult[1] as string) || 0;\r\n    const ttl = ttlResult[1] as number;\r\n\r\n    return { count, ttl };\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Rate limit info retrieval failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function incrementRateLimit(key: string, windowSeconds: number): Promise<{\r\n  count: number;\r\n  ttl: number;\r\n  isNewWindow: boolean;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const pipeline = client.pipeline();\r\n\r\n    // Incrementar contador\r\n    pipeline.incr(key);\r\n    // Establecer TTL solo si es la primera vez\r\n    pipeline.expire(key, windowSeconds);\r\n    // Obtener TTL actual\r\n    pipeline.ttl(key);\r\n\r\n    const results = await pipeline.exec();\r\n\r\n    if (!results || results.length !== 3) {\r\n      return null;\r\n    }\r\n\r\n    const count = results[0][1] as number;\r\n    const ttl = results[2][1] as number;\r\n    const isNewWindow = count === 1;\r\n\r\n    return { count, ttl, isNewWindow };\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Rate limit increment failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// =====================================================\r\n// FUNCIONES ENTERPRISE PARA RATE LIMITING\r\n// =====================================================\r\n\r\n/**\r\n * Rate limiting enterprise con sliding window\r\n */\r\nexport async function enterpriseRateLimit(\r\n  key: string,\r\n  windowMs: number,\r\n  maxRequests: number\r\n): Promise<{\r\n  allowed: boolean;\r\n  count: number;\r\n  remaining: number;\r\n  resetTime: number;\r\n  retryAfter?: number;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const now = Date.now();\r\n    const window = Math.floor(now / windowMs);\r\n    const redisKey = `rate_limit:${key}:${window}`;\r\n\r\n    // Usar pipeline para operaciones atómicas\r\n    const pipeline = client.pipeline();\r\n    pipeline.incr(redisKey);\r\n    pipeline.expire(redisKey, Math.ceil(windowMs / 1000));\r\n\r\n    const results = await pipeline.exec();\r\n\r\n    if (!results || results.length !== 2) {\r\n      return null;\r\n    }\r\n\r\n    const count = results[0][1] as number;\r\n    const remaining = Math.max(0, maxRequests - count);\r\n    const resetTime = (window + 1) * windowMs;\r\n    const allowed = count <= maxRequests;\r\n\r\n    const result = {\r\n      allowed,\r\n      count,\r\n      remaining,\r\n      resetTime,\r\n      retryAfter: allowed ? undefined : Math.ceil((resetTime - now) / 1000)\r\n    };\r\n\r\n    logger.debug(LogCategory.API, 'Enterprise rate limit check', {\r\n      key: redisKey,\r\n      count,\r\n      maxRequests,\r\n      allowed,\r\n      remaining\r\n    });\r\n\r\n    return result;\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Enterprise rate limit failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Rate limiting con múltiples ventanas (más preciso)\r\n */\r\nexport async function slidingWindowRateLimit(\r\n  key: string,\r\n  windowMs: number,\r\n  maxRequests: number,\r\n  precision: number = 10\r\n): Promise<{\r\n  allowed: boolean;\r\n  count: number;\r\n  remaining: number;\r\n  resetTime: number;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const now = Date.now();\r\n    const windowSize = Math.floor(windowMs / precision);\r\n    const currentWindow = Math.floor(now / windowSize);\r\n\r\n    // Limpiar ventanas antiguas y contar requests en ventana actual\r\n    const pipeline = client.pipeline();\r\n\r\n    // Eliminar ventanas más antiguas que el período de rate limiting\r\n    for (let i = 1; i <= precision; i++) {\r\n      const oldWindow = currentWindow - precision - i;\r\n      pipeline.del(`${key}:${oldWindow}`);\r\n    }\r\n\r\n    // Incrementar contador para ventana actual\r\n    const currentKey = `${key}:${currentWindow}`;\r\n    pipeline.incr(currentKey);\r\n    pipeline.expire(currentKey, Math.ceil(windowMs / 1000));\r\n\r\n    // Obtener contadores de todas las ventanas en el período\r\n    for (let i = 0; i < precision; i++) {\r\n      const windowKey = `${key}:${currentWindow - i}`;\r\n      pipeline.get(windowKey);\r\n    }\r\n\r\n    const results = await pipeline.exec();\r\n\r\n    if (!results) {\r\n      return null;\r\n    }\r\n\r\n    // Calcular total de requests en la ventana deslizante\r\n    let totalCount = 0;\r\n    const countResults = results.slice(precision + 2); // Saltar operaciones de limpieza e incremento\r\n\r\n    for (const result of countResults) {\r\n      if (result[1]) {\r\n        totalCount += parseInt(result[1] as string);\r\n      }\r\n    }\r\n\r\n    const remaining = Math.max(0, maxRequests - totalCount);\r\n    const allowed = totalCount <= maxRequests;\r\n    const resetTime = (currentWindow + 1) * windowSize;\r\n\r\n    return {\r\n      allowed,\r\n      count: totalCount,\r\n      remaining,\r\n      resetTime\r\n    };\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Sliding window rate limit failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Obtener estadísticas de rate limiting\r\n */\r\nexport async function getRateLimitStats(pattern: string = 'rate_limit:*'): Promise<{\r\n  totalKeys: number;\r\n  activeWindows: number;\r\n  topKeys: Array<{ key: string; count: number; ttl: number }>;\r\n} | null> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const keys = await client.keys(pattern);\r\n\r\n    if (keys.length === 0) {\r\n      return {\r\n        totalKeys: 0,\r\n        activeWindows: 0,\r\n        topKeys: []\r\n      };\r\n    }\r\n\r\n    // Obtener información de las claves más activas\r\n    const pipeline = client.pipeline();\r\n    keys.forEach(key => {\r\n      pipeline.get(key);\r\n      pipeline.ttl(key);\r\n    });\r\n\r\n    const results = await pipeline.exec();\r\n\r\n    if (!results) {\r\n      return null;\r\n    }\r\n\r\n    const keyStats: Array<{ key: string; count: number; ttl: number }> = [];\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n      const countResult = results[i * 2];\r\n      const ttlResult = results[i * 2 + 1];\r\n\r\n      if (countResult[1] && ttlResult[1]) {\r\n        keyStats.push({\r\n          key: keys[i],\r\n          count: parseInt(countResult[1] as string),\r\n          ttl: ttlResult[1] as number\r\n        });\r\n      }\r\n    }\r\n\r\n    // Ordenar por count descendente\r\n    keyStats.sort((a, b) => b.count - a.count);\r\n\r\n    return {\r\n      totalKeys: keys.length,\r\n      activeWindows: keyStats.filter(stat => stat.ttl > 0).length,\r\n      topKeys: keyStats.slice(0, 10) // Top 10\r\n    };\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Rate limit stats failed', error as Error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Limpiar claves de rate limiting expiradas\r\n */\r\nexport async function cleanupRateLimitKeys(pattern: string = 'rate_limit:*'): Promise<number> {\r\n  try {\r\n    const client = getRedisClient();\r\n    const keys = await client.keys(pattern);\r\n\r\n    if (keys.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    // Verificar TTL de cada clave y eliminar las expiradas\r\n    const pipeline = client.pipeline();\r\n    keys.forEach(key => {\r\n      pipeline.ttl(key);\r\n    });\r\n\r\n    const ttlResults = await pipeline.exec();\r\n\r\n    if (!ttlResults) {\r\n      return 0;\r\n    }\r\n\r\n    const expiredKeys: string[] = [];\r\n\r\n    for (let i = 0; i < keys.length; i++) {\r\n      const ttlResult = ttlResults[i];\r\n      if (ttlResult[1] === -2) { // Clave expirada\r\n        expiredKeys.push(keys[i]);\r\n      }\r\n    }\r\n\r\n    if (expiredKeys.length > 0) {\r\n      await client.del(...expiredKeys);\r\n      logger.info(LogCategory.API, `Cleaned up ${expiredKeys.length} expired rate limit keys`);\r\n    }\r\n\r\n    return expiredKeys.length;\r\n  } catch (error) {\r\n    logger.error(LogCategory.API, 'Rate limit cleanup failed', error as Error);\r\n    return 0;\r\n  }\r\n}\r\n\r\n// Exportar cliente Redis para uso directo\r\nexport const redis = getRedisClient();\r\n"],"names":["RedisCache","cleanupRateLimitKeys","closeRedisConnection","enterpriseRateLimit","getRateLimitInfo","getRateLimitStats","getRedisClient","incrementRateLimit","isRedisAvailable","redis","redisCache","slidingWindowRateLimit","REDIS_CONFIG","host","process","env","REDIS_HOST","port","parseInt","REDIS_PORT","password","REDIS_PASSWORD","db","REDIS_DB","retryDelayOnFailover","maxRetriesPerRequest","lazyConnect","keepAlive","connectTimeout","commandTimeout","redisClient","Redis","on","logger","info","LogCategory","API","error","warn","client","ping","quit","constructor","get","key","value","set","ttlSeconds","setex","del","result","incr","expire","ttl","pipeline","results","exec","length","countResult","ttlResult","count","windowSeconds","isNewWindow","windowMs","maxRequests","now","Date","window","Math","floor","redisKey","ceil","remaining","max","resetTime","allowed","retryAfter","undefined","debug","precision","windowSize","currentWindow","i","oldWindow","currentKey","windowKey","totalCount","countResults","slice","pattern","keys","totalKeys","activeWindows","topKeys","forEach","keyStats","push","sort","a","b","filter","stat","ttlResults","expiredKeys"],"mappings":"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"}