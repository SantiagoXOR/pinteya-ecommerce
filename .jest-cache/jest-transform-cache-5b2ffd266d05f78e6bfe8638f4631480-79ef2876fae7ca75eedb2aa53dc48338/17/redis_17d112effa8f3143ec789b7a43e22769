3e330eaa1e2b178b92d75912b23dd959
// ===================================
// PINTEYA E-COMMERCE - REDIS CONFIGURATION
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RedisCache: function() {
        return RedisCache;
    },
    cleanupRateLimitKeys: function() {
        return cleanupRateLimitKeys;
    },
    closeRedisConnection: function() {
        return closeRedisConnection;
    },
    enterpriseRateLimit: function() {
        return enterpriseRateLimit;
    },
    getRateLimitInfo: function() {
        return getRateLimitInfo;
    },
    getRateLimitStats: function() {
        return getRateLimitStats;
    },
    getRedisClient: function() {
        return getRedisClient;
    },
    incrementRateLimit: function() {
        return incrementRateLimit;
    },
    isRedisAvailable: function() {
        return isRedisAvailable;
    },
    redis: function() {
        return redis;
    },
    redisCache: function() {
        return redisCache;
    },
    slidingWindowRateLimit: function() {
        return slidingWindowRateLimit;
    }
});
const _ioredis = /*#__PURE__*/ _interop_require_default(require("ioredis"));
const _logger = require("./logger");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Configuración de Redis
const REDIS_CONFIG = {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD,
    db: parseInt(process.env.REDIS_DB || '0'),
    retryDelayOnFailover: 100,
    maxRetriesPerRequest: 3,
    lazyConnect: true,
    keepAlive: 30000,
    connectTimeout: 10000,
    commandTimeout: 5000
};
// Cliente Redis singleton
let redisClient = null;
function getRedisClient() {
    if (!redisClient) {
        redisClient = new _ioredis.default(REDIS_CONFIG);
        // Event listeners para logging
        redisClient.on('connect', ()=>{
            _logger.logger.info(_logger.LogCategory.API, 'Redis connected successfully');
        });
        redisClient.on('error', (error)=>{
            _logger.logger.error(_logger.LogCategory.API, 'Redis connection error', error);
        });
        redisClient.on('close', ()=>{
            _logger.logger.warn(_logger.LogCategory.API, 'Redis connection closed');
        });
        redisClient.on('reconnecting', ()=>{
            _logger.logger.info(_logger.LogCategory.API, 'Redis reconnecting...');
        });
    }
    return redisClient;
}
async function isRedisAvailable() {
    try {
        const client = getRedisClient();
        await client.ping();
        return true;
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Redis health check failed', error);
        return false;
    }
}
async function closeRedisConnection() {
    if (redisClient) {
        await redisClient.quit();
        redisClient = null;
        _logger.logger.info(_logger.LogCategory.API, 'Redis connection closed gracefully');
    }
}
class RedisCache {
    constructor(){
        this.client = getRedisClient();
    }
    /**
   * Obtiene un valor del cache
   */ async get(key) {
        try {
            const value = await this.client.get(key);
            _logger.logger.info(_logger.LogCategory.API, 'Cache get operation');
            return value;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache get operation failed', error);
            return null;
        }
    }
    /**
   * Establece un valor en el cache
   */ async set(key, value, ttlSeconds) {
        try {
            if (ttlSeconds) {
                await this.client.setex(key, ttlSeconds, value);
            } else {
                await this.client.set(key, value);
            }
            _logger.logger.info(_logger.LogCategory.API, 'Cache set operation');
            return true;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache set operation failed', error);
            return false;
        }
    }
    /**
   * Elimina un valor del cache
   */ async del(key) {
        try {
            const result = await this.client.del(key);
            _logger.logger.info(_logger.LogCategory.API, 'Cache delete operation');
            return result > 0;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache delete operation failed', error);
            return false;
        }
    }
    /**
   * Incrementa un contador atómicamente
   */ async incr(key) {
        try {
            const result = await this.client.incr(key);
            _logger.logger.info(_logger.LogCategory.API, 'Cache increment operation');
            return result;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache increment operation failed', error);
            return null;
        }
    }
    /**
   * Establece TTL para una clave existente
   */ async expire(key, ttlSeconds) {
        try {
            const result = await this.client.expire(key, ttlSeconds);
            _logger.logger.info(_logger.LogCategory.API, 'Cache expire operation');
            return result === 1;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache expire operation failed', error);
            return false;
        }
    }
    /**
   * Obtiene TTL restante de una clave
   */ async ttl(key) {
        try {
            const result = await this.client.ttl(key);
            _logger.logger.info(_logger.LogCategory.API, 'Cache TTL check');
            return result;
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Cache TTL check failed', error);
            return null;
        }
    }
}
const redisCache = new RedisCache();
async function getRateLimitInfo(key) {
    try {
        const client = getRedisClient();
        const pipeline = client.pipeline();
        pipeline.get(key);
        pipeline.ttl(key);
        const results = await pipeline.exec();
        if (!results || results.length !== 2) {
            return null;
        }
        const [countResult, ttlResult] = results;
        const count = parseInt(countResult[1]) || 0;
        const ttl = ttlResult[1];
        return {
            count,
            ttl
        };
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Rate limit info retrieval failed', error);
        return null;
    }
}
async function incrementRateLimit(key, windowSeconds) {
    try {
        const client = getRedisClient();
        const pipeline = client.pipeline();
        // Incrementar contador
        pipeline.incr(key);
        // Establecer TTL solo si es la primera vez
        pipeline.expire(key, windowSeconds);
        // Obtener TTL actual
        pipeline.ttl(key);
        const results = await pipeline.exec();
        if (!results || results.length !== 3) {
            return null;
        }
        const count = results[0][1];
        const ttl = results[2][1];
        const isNewWindow = count === 1;
        return {
            count,
            ttl,
            isNewWindow
        };
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Rate limit increment failed', error);
        return null;
    }
}
async function enterpriseRateLimit(key, windowMs, maxRequests) {
    try {
        const client = getRedisClient();
        const now = Date.now();
        const window = Math.floor(now / windowMs);
        const redisKey = `rate_limit:${key}:${window}`;
        // Usar pipeline para operaciones atómicas
        const pipeline = client.pipeline();
        pipeline.incr(redisKey);
        pipeline.expire(redisKey, Math.ceil(windowMs / 1000));
        const results = await pipeline.exec();
        if (!results || results.length !== 2) {
            return null;
        }
        const count = results[0][1];
        const remaining = Math.max(0, maxRequests - count);
        const resetTime = (window + 1) * windowMs;
        const allowed = count <= maxRequests;
        const result = {
            allowed,
            count,
            remaining,
            resetTime,
            retryAfter: allowed ? undefined : Math.ceil((resetTime - now) / 1000)
        };
        _logger.logger.debug(_logger.LogCategory.API, 'Enterprise rate limit check', {
            key: redisKey,
            count,
            maxRequests,
            allowed,
            remaining
        });
        return result;
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Enterprise rate limit failed', error);
        return null;
    }
}
async function slidingWindowRateLimit(key, windowMs, maxRequests, precision = 10) {
    try {
        const client = getRedisClient();
        const now = Date.now();
        const windowSize = Math.floor(windowMs / precision);
        const currentWindow = Math.floor(now / windowSize);
        // Limpiar ventanas antiguas y contar requests en ventana actual
        const pipeline = client.pipeline();
        // Eliminar ventanas más antiguas que el período de rate limiting
        for(let i = 1; i <= precision; i++){
            const oldWindow = currentWindow - precision - i;
            pipeline.del(`${key}:${oldWindow}`);
        }
        // Incrementar contador para ventana actual
        const currentKey = `${key}:${currentWindow}`;
        pipeline.incr(currentKey);
        pipeline.expire(currentKey, Math.ceil(windowMs / 1000));
        // Obtener contadores de todas las ventanas en el período
        for(let i = 0; i < precision; i++){
            const windowKey = `${key}:${currentWindow - i}`;
            pipeline.get(windowKey);
        }
        const results = await pipeline.exec();
        if (!results) {
            return null;
        }
        // Calcular total de requests en la ventana deslizante
        let totalCount = 0;
        const countResults = results.slice(precision + 2); // Saltar operaciones de limpieza e incremento
        for (const result of countResults){
            if (result[1]) {
                totalCount += parseInt(result[1]);
            }
        }
        const remaining = Math.max(0, maxRequests - totalCount);
        const allowed = totalCount <= maxRequests;
        const resetTime = (currentWindow + 1) * windowSize;
        return {
            allowed,
            count: totalCount,
            remaining,
            resetTime
        };
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Sliding window rate limit failed', error);
        return null;
    }
}
async function getRateLimitStats(pattern = 'rate_limit:*') {
    try {
        const client = getRedisClient();
        const keys = await client.keys(pattern);
        if (keys.length === 0) {
            return {
                totalKeys: 0,
                activeWindows: 0,
                topKeys: []
            };
        }
        // Obtener información de las claves más activas
        const pipeline = client.pipeline();
        keys.forEach((key)=>{
            pipeline.get(key);
            pipeline.ttl(key);
        });
        const results = await pipeline.exec();
        if (!results) {
            return null;
        }
        const keyStats = [];
        for(let i = 0; i < keys.length; i++){
            const countResult = results[i * 2];
            const ttlResult = results[i * 2 + 1];
            if (countResult[1] && ttlResult[1]) {
                keyStats.push({
                    key: keys[i],
                    count: parseInt(countResult[1]),
                    ttl: ttlResult[1]
                });
            }
        }
        // Ordenar por count descendente
        keyStats.sort((a, b)=>b.count - a.count);
        return {
            totalKeys: keys.length,
            activeWindows: keyStats.filter((stat)=>stat.ttl > 0).length,
            topKeys: keyStats.slice(0, 10) // Top 10
        };
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Rate limit stats failed', error);
        return null;
    }
}
async function cleanupRateLimitKeys(pattern = 'rate_limit:*') {
    try {
        const client = getRedisClient();
        const keys = await client.keys(pattern);
        if (keys.length === 0) {
            return 0;
        }
        // Verificar TTL de cada clave y eliminar las expiradas
        const pipeline = client.pipeline();
        keys.forEach((key)=>{
            pipeline.ttl(key);
        });
        const ttlResults = await pipeline.exec();
        if (!ttlResults) {
            return 0;
        }
        const expiredKeys = [];
        for(let i = 0; i < keys.length; i++){
            const ttlResult = ttlResults[i];
            if (ttlResult[1] === -2) {
                expiredKeys.push(keys[i]);
            }
        }
        if (expiredKeys.length > 0) {
            await client.del(...expiredKeys);
            _logger.logger.info(_logger.LogCategory.API, `Cleaned up ${expiredKeys.length} expired rate limit keys`);
        }
        return expiredKeys.length;
    } catch (error) {
        _logger.logger.error(_logger.LogCategory.API, 'Rate limit cleanup failed', error);
        return 0;
    }
}
const redis = getRedisClient();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcbGliXFxyZWRpcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBQSU5URVlBIEUtQ09NTUVSQ0UgLSBSRURJUyBDT05GSUdVUkFUSU9OXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbXBvcnQgUmVkaXMgZnJvbSAnaW9yZWRpcyc7XHJcbmltcG9ydCB7IGxvZ2dlciwgTG9nTGV2ZWwsIExvZ0NhdGVnb3J5IH0gZnJvbSAnLi9sb2dnZXInO1xyXG5cclxuLy8gQ29uZmlndXJhY2nDs24gZGUgUmVkaXNcclxuY29uc3QgUkVESVNfQ09ORklHID0ge1xyXG4gIGhvc3Q6IHByb2Nlc3MuZW52LlJFRElTX0hPU1QgfHwgJ2xvY2FsaG9zdCcsXHJcbiAgcG9ydDogcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVESVNfUE9SVCB8fCAnNjM3OScpLFxyXG4gIHBhc3N3b3JkOiBwcm9jZXNzLmVudi5SRURJU19QQVNTV09SRCxcclxuICBkYjogcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVESVNfREIgfHwgJzAnKSxcclxuICByZXRyeURlbGF5T25GYWlsb3ZlcjogMTAwLFxyXG4gIG1heFJldHJpZXNQZXJSZXF1ZXN0OiAzLFxyXG4gIGxhenlDb25uZWN0OiB0cnVlLFxyXG4gIGtlZXBBbGl2ZTogMzAwMDAsXHJcbiAgY29ubmVjdFRpbWVvdXQ6IDEwMDAwLFxyXG4gIGNvbW1hbmRUaW1lb3V0OiA1MDAwLFxyXG59O1xyXG5cclxuLy8gQ2xpZW50ZSBSZWRpcyBzaW5nbGV0b25cclxubGV0IHJlZGlzQ2xpZW50OiBSZWRpcyB8IG51bGwgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIE9idGllbmUgbyBjcmVhIGxhIGluc3RhbmNpYSBkZSBSZWRpc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZGlzQ2xpZW50KCk6IFJlZGlzIHtcclxuICBpZiAoIXJlZGlzQ2xpZW50KSB7XHJcbiAgICByZWRpc0NsaWVudCA9IG5ldyBSZWRpcyhSRURJU19DT05GSUcpO1xyXG5cclxuICAgIC8vIEV2ZW50IGxpc3RlbmVycyBwYXJhIGxvZ2dpbmdcclxuICAgIHJlZGlzQ2xpZW50Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xyXG4gICAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdSZWRpcyBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZWRpc0NsaWVudC5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ1JlZGlzIGNvbm5lY3Rpb24gZXJyb3InLCBlcnJvcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZWRpc0NsaWVudC5vbignY2xvc2UnLCAoKSA9PiB7XHJcbiAgICAgIGxvZ2dlci53YXJuKExvZ0NhdGVnb3J5LkFQSSwgJ1JlZGlzIGNvbm5lY3Rpb24gY2xvc2VkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZWRpc0NsaWVudC5vbigncmVjb25uZWN0aW5nJywgKCkgPT4ge1xyXG4gICAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdSZWRpcyByZWNvbm5lY3RpbmcuLi4nKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlZGlzQ2xpZW50O1xyXG59XHJcblxyXG4vKipcclxuICogVmVyaWZpY2Egc2kgUmVkaXMgZXN0w6EgZGlzcG9uaWJsZVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzUmVkaXNBdmFpbGFibGUoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNsaWVudCA9IGdldFJlZGlzQ2xpZW50KCk7XHJcbiAgICBhd2FpdCBjbGllbnQucGluZygpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdSZWRpcyBoZWFsdGggY2hlY2sgZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENpZXJyYSBsYSBjb25leGnDs24gZGUgUmVkaXNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbG9zZVJlZGlzQ29ubmVjdGlvbigpOiBQcm9taXNlPHZvaWQ+IHtcclxuICBpZiAocmVkaXNDbGllbnQpIHtcclxuICAgIGF3YWl0IHJlZGlzQ2xpZW50LnF1aXQoKTtcclxuICAgIHJlZGlzQ2xpZW50ID0gbnVsbDtcclxuICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgJ1JlZGlzIGNvbm5lY3Rpb24gY2xvc2VkIGdyYWNlZnVsbHknKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcGVyYWNpb25lcyBkZSBjYWNoZSBjb24gbWFuZWpvIGRlIGVycm9yZXNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZWRpc0NhY2hlIHtcclxuICBwcml2YXRlIGNsaWVudDogUmVkaXM7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5jbGllbnQgPSBnZXRSZWRpc0NsaWVudCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT2J0aWVuZSB1biB2YWxvciBkZWwgY2FjaGVcclxuICAgKi9cclxuICBhc3luYyBnZXQoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0KGtleSk7XHJcbiAgICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgJ0NhY2hlIGdldCBvcGVyYXRpb24nKTtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0NhY2hlIGdldCBvcGVyYXRpb24gZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVzdGFibGVjZSB1biB2YWxvciBlbiBlbCBjYWNoZVxyXG4gICAqL1xyXG4gIGFzeW5jIHNldChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgdHRsU2Vjb25kcz86IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHR0bFNlY29uZHMpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5zZXRleChrZXksIHR0bFNlY29uZHMsIHZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgJ0NhY2hlIHNldCBvcGVyYXRpb24nKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgc2V0IG9wZXJhdGlvbiBmYWlsZWQnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVsaW1pbmEgdW4gdmFsb3IgZGVsIGNhY2hlXHJcbiAgICovXHJcbiAgYXN5bmMgZGVsKGtleTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC5kZWwoa2V5KTtcclxuICAgICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgZGVsZXRlIG9wZXJhdGlvbicpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0ID4gMDtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdDYWNoZSBkZWxldGUgb3BlcmF0aW9uIGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5jcmVtZW50YSB1biBjb250YWRvciBhdMOzbWljYW1lbnRlXHJcbiAgICovXHJcbiAgYXN5bmMgaW5jcihrZXk6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQuaW5jcihrZXkpO1xyXG4gICAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksICdDYWNoZSBpbmNyZW1lbnQgb3BlcmF0aW9uJyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgaW5jcmVtZW50IG9wZXJhdGlvbiBmYWlsZWQnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXN0YWJsZWNlIFRUTCBwYXJhIHVuYSBjbGF2ZSBleGlzdGVudGVcclxuICAgKi9cclxuICBhc3luYyBleHBpcmUoa2V5OiBzdHJpbmcsIHR0bFNlY29uZHM6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQuZXhwaXJlKGtleSwgdHRsU2Vjb25kcyk7XHJcbiAgICAgIGxvZ2dlci5pbmZvKExvZ0NhdGVnb3J5LkFQSSwgJ0NhY2hlIGV4cGlyZSBvcGVyYXRpb24nKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gMTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdDYWNoZSBleHBpcmUgb3BlcmF0aW9uIGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogT2J0aWVuZSBUVEwgcmVzdGFudGUgZGUgdW5hIGNsYXZlXHJcbiAgICovXHJcbiAgYXN5bmMgdHRsKGtleTogc3RyaW5nKTogUHJvbWlzZTxudW1iZXIgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC50dGwoa2V5KTtcclxuICAgICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgVFRMIGNoZWNrJyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnQ2FjaGUgVFRMIGNoZWNrIGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBJbnN0YW5jaWEgc2luZ2xldG9uIGRlbCBjYWNoZVxyXG5leHBvcnQgY29uc3QgcmVkaXNDYWNoZSA9IG5ldyBSZWRpc0NhY2hlKCk7XHJcblxyXG4vLyBGdW5jaW9uZXMgZGUgdXRpbGlkYWQgcGFyYSByYXRlIGxpbWl0aW5nXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSYXRlTGltaXRJbmZvKGtleTogc3RyaW5nKTogUHJvbWlzZTx7XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICB0dGw6IG51bWJlcjtcclxufSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2xpZW50ID0gZ2V0UmVkaXNDbGllbnQoKTtcclxuICAgIGNvbnN0IHBpcGVsaW5lID0gY2xpZW50LnBpcGVsaW5lKCk7XHJcbiAgICBwaXBlbGluZS5nZXQoa2V5KTtcclxuICAgIHBpcGVsaW5lLnR0bChrZXkpO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcGlwZWxpbmUuZXhlYygpO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3VsdHMgfHwgcmVzdWx0cy5sZW5ndGggIT09IDIpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgW2NvdW50UmVzdWx0LCB0dGxSZXN1bHRdID0gcmVzdWx0cztcclxuICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQoY291bnRSZXN1bHRbMV0gYXMgc3RyaW5nKSB8fCAwO1xyXG4gICAgY29uc3QgdHRsID0gdHRsUmVzdWx0WzFdIGFzIG51bWJlcjtcclxuXHJcbiAgICByZXR1cm4geyBjb3VudCwgdHRsIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdSYXRlIGxpbWl0IGluZm8gcmV0cmlldmFsIGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluY3JlbWVudFJhdGVMaW1pdChrZXk6IHN0cmluZywgd2luZG93U2Vjb25kczogbnVtYmVyKTogUHJvbWlzZTx7XHJcbiAgY291bnQ6IG51bWJlcjtcclxuICB0dGw6IG51bWJlcjtcclxuICBpc05ld1dpbmRvdzogYm9vbGVhbjtcclxufSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2xpZW50ID0gZ2V0UmVkaXNDbGllbnQoKTtcclxuICAgIGNvbnN0IHBpcGVsaW5lID0gY2xpZW50LnBpcGVsaW5lKCk7XHJcblxyXG4gICAgLy8gSW5jcmVtZW50YXIgY29udGFkb3JcclxuICAgIHBpcGVsaW5lLmluY3Ioa2V5KTtcclxuICAgIC8vIEVzdGFibGVjZXIgVFRMIHNvbG8gc2kgZXMgbGEgcHJpbWVyYSB2ZXpcclxuICAgIHBpcGVsaW5lLmV4cGlyZShrZXksIHdpbmRvd1NlY29uZHMpO1xyXG4gICAgLy8gT2J0ZW5lciBUVEwgYWN0dWFsXHJcbiAgICBwaXBlbGluZS50dGwoa2V5KTtcclxuXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcGlwZWxpbmUuZXhlYygpO1xyXG5cclxuICAgIGlmICghcmVzdWx0cyB8fCByZXN1bHRzLmxlbmd0aCAhPT0gMykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb3VudCA9IHJlc3VsdHNbMF1bMV0gYXMgbnVtYmVyO1xyXG4gICAgY29uc3QgdHRsID0gcmVzdWx0c1syXVsxXSBhcyBudW1iZXI7XHJcbiAgICBjb25zdCBpc05ld1dpbmRvdyA9IGNvdW50ID09PSAxO1xyXG5cclxuICAgIHJldHVybiB7IGNvdW50LCB0dGwsIGlzTmV3V2luZG93IH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdSYXRlIGxpbWl0IGluY3JlbWVudCBmYWlsZWQnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIEZVTkNJT05FUyBFTlRFUlBSSVNFIFBBUkEgUkFURSBMSU1JVElOR1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuLyoqXHJcbiAqIFJhdGUgbGltaXRpbmcgZW50ZXJwcmlzZSBjb24gc2xpZGluZyB3aW5kb3dcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbnRlcnByaXNlUmF0ZUxpbWl0KFxyXG4gIGtleTogc3RyaW5nLFxyXG4gIHdpbmRvd01zOiBudW1iZXIsXHJcbiAgbWF4UmVxdWVzdHM6IG51bWJlclxyXG4pOiBQcm9taXNlPHtcclxuICBhbGxvd2VkOiBib29sZWFuO1xyXG4gIGNvdW50OiBudW1iZXI7XHJcbiAgcmVtYWluaW5nOiBudW1iZXI7XHJcbiAgcmVzZXRUaW1lOiBudW1iZXI7XHJcbiAgcmV0cnlBZnRlcj86IG51bWJlcjtcclxufSB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgY2xpZW50ID0gZ2V0UmVkaXNDbGllbnQoKTtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBjb25zdCB3aW5kb3cgPSBNYXRoLmZsb29yKG5vdyAvIHdpbmRvd01zKTtcclxuICAgIGNvbnN0IHJlZGlzS2V5ID0gYHJhdGVfbGltaXQ6JHtrZXl9OiR7d2luZG93fWA7XHJcblxyXG4gICAgLy8gVXNhciBwaXBlbGluZSBwYXJhIG9wZXJhY2lvbmVzIGF0w7NtaWNhc1xyXG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcclxuICAgIHBpcGVsaW5lLmluY3IocmVkaXNLZXkpO1xyXG4gICAgcGlwZWxpbmUuZXhwaXJlKHJlZGlzS2V5LCBNYXRoLmNlaWwod2luZG93TXMgLyAxMDAwKSk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHBpcGVsaW5lLmV4ZWMoKTtcclxuXHJcbiAgICBpZiAoIXJlc3VsdHMgfHwgcmVzdWx0cy5sZW5ndGggIT09IDIpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY291bnQgPSByZXN1bHRzWzBdWzFdIGFzIG51bWJlcjtcclxuICAgIGNvbnN0IHJlbWFpbmluZyA9IE1hdGgubWF4KDAsIG1heFJlcXVlc3RzIC0gY291bnQpO1xyXG4gICAgY29uc3QgcmVzZXRUaW1lID0gKHdpbmRvdyArIDEpICogd2luZG93TXM7XHJcbiAgICBjb25zdCBhbGxvd2VkID0gY291bnQgPD0gbWF4UmVxdWVzdHM7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICBhbGxvd2VkLFxyXG4gICAgICBjb3VudCxcclxuICAgICAgcmVtYWluaW5nLFxyXG4gICAgICByZXNldFRpbWUsXHJcbiAgICAgIHJldHJ5QWZ0ZXI6IGFsbG93ZWQgPyB1bmRlZmluZWQgOiBNYXRoLmNlaWwoKHJlc2V0VGltZSAtIG5vdykgLyAxMDAwKVxyXG4gICAgfTtcclxuXHJcbiAgICBsb2dnZXIuZGVidWcoTG9nQ2F0ZWdvcnkuQVBJLCAnRW50ZXJwcmlzZSByYXRlIGxpbWl0IGNoZWNrJywge1xyXG4gICAgICBrZXk6IHJlZGlzS2V5LFxyXG4gICAgICBjb3VudCxcclxuICAgICAgbWF4UmVxdWVzdHMsXHJcbiAgICAgIGFsbG93ZWQsXHJcbiAgICAgIHJlbWFpbmluZ1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0VudGVycHJpc2UgcmF0ZSBsaW1pdCBmYWlsZWQnLCBlcnJvciBhcyBFcnJvcik7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSYXRlIGxpbWl0aW5nIGNvbiBtw7psdGlwbGVzIHZlbnRhbmFzIChtw6FzIHByZWNpc28pXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2xpZGluZ1dpbmRvd1JhdGVMaW1pdChcclxuICBrZXk6IHN0cmluZyxcclxuICB3aW5kb3dNczogbnVtYmVyLFxyXG4gIG1heFJlcXVlc3RzOiBudW1iZXIsXHJcbiAgcHJlY2lzaW9uOiBudW1iZXIgPSAxMFxyXG4pOiBQcm9taXNlPHtcclxuICBhbGxvd2VkOiBib29sZWFuO1xyXG4gIGNvdW50OiBudW1iZXI7XHJcbiAgcmVtYWluaW5nOiBudW1iZXI7XHJcbiAgcmVzZXRUaW1lOiBudW1iZXI7XHJcbn0gfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNsaWVudCA9IGdldFJlZGlzQ2xpZW50KCk7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IE1hdGguZmxvb3Iod2luZG93TXMgLyBwcmVjaXNpb24pO1xyXG4gICAgY29uc3QgY3VycmVudFdpbmRvdyA9IE1hdGguZmxvb3Iobm93IC8gd2luZG93U2l6ZSk7XHJcblxyXG4gICAgLy8gTGltcGlhciB2ZW50YW5hcyBhbnRpZ3VhcyB5IGNvbnRhciByZXF1ZXN0cyBlbiB2ZW50YW5hIGFjdHVhbFxyXG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcclxuXHJcbiAgICAvLyBFbGltaW5hciB2ZW50YW5hcyBtw6FzIGFudGlndWFzIHF1ZSBlbCBwZXLDrW9kbyBkZSByYXRlIGxpbWl0aW5nXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBwcmVjaXNpb247IGkrKykge1xyXG4gICAgICBjb25zdCBvbGRXaW5kb3cgPSBjdXJyZW50V2luZG93IC0gcHJlY2lzaW9uIC0gaTtcclxuICAgICAgcGlwZWxpbmUuZGVsKGAke2tleX06JHtvbGRXaW5kb3d9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5jcmVtZW50YXIgY29udGFkb3IgcGFyYSB2ZW50YW5hIGFjdHVhbFxyXG4gICAgY29uc3QgY3VycmVudEtleSA9IGAke2tleX06JHtjdXJyZW50V2luZG93fWA7XHJcbiAgICBwaXBlbGluZS5pbmNyKGN1cnJlbnRLZXkpO1xyXG4gICAgcGlwZWxpbmUuZXhwaXJlKGN1cnJlbnRLZXksIE1hdGguY2VpbCh3aW5kb3dNcyAvIDEwMDApKTtcclxuXHJcbiAgICAvLyBPYnRlbmVyIGNvbnRhZG9yZXMgZGUgdG9kYXMgbGFzIHZlbnRhbmFzIGVuIGVsIHBlcsOtb2RvXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWNpc2lvbjsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHdpbmRvd0tleSA9IGAke2tleX06JHtjdXJyZW50V2luZG93IC0gaX1gO1xyXG4gICAgICBwaXBlbGluZS5nZXQod2luZG93S2V5KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcGlwZWxpbmUuZXhlYygpO1xyXG5cclxuICAgIGlmICghcmVzdWx0cykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhciB0b3RhbCBkZSByZXF1ZXN0cyBlbiBsYSB2ZW50YW5hIGRlc2xpemFudGVcclxuICAgIGxldCB0b3RhbENvdW50ID0gMDtcclxuICAgIGNvbnN0IGNvdW50UmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UocHJlY2lzaW9uICsgMik7IC8vIFNhbHRhciBvcGVyYWNpb25lcyBkZSBsaW1waWV6YSBlIGluY3JlbWVudG9cclxuXHJcbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBjb3VudFJlc3VsdHMpIHtcclxuICAgICAgaWYgKHJlc3VsdFsxXSkge1xyXG4gICAgICAgIHRvdGFsQ291bnQgKz0gcGFyc2VJbnQocmVzdWx0WzFdIGFzIHN0cmluZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZW1haW5pbmcgPSBNYXRoLm1heCgwLCBtYXhSZXF1ZXN0cyAtIHRvdGFsQ291bnQpO1xyXG4gICAgY29uc3QgYWxsb3dlZCA9IHRvdGFsQ291bnQgPD0gbWF4UmVxdWVzdHM7XHJcbiAgICBjb25zdCByZXNldFRpbWUgPSAoY3VycmVudFdpbmRvdyArIDEpICogd2luZG93U2l6ZTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBhbGxvd2VkLFxyXG4gICAgICBjb3VudDogdG90YWxDb3VudCxcclxuICAgICAgcmVtYWluaW5nLFxyXG4gICAgICByZXNldFRpbWVcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdTbGlkaW5nIHdpbmRvdyByYXRlIGxpbWl0IGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIE9idGVuZXIgZXN0YWTDrXN0aWNhcyBkZSByYXRlIGxpbWl0aW5nXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmF0ZUxpbWl0U3RhdHMocGF0dGVybjogc3RyaW5nID0gJ3JhdGVfbGltaXQ6KicpOiBQcm9taXNlPHtcclxuICB0b3RhbEtleXM6IG51bWJlcjtcclxuICBhY3RpdmVXaW5kb3dzOiBudW1iZXI7XHJcbiAgdG9wS2V5czogQXJyYXk8eyBrZXk6IHN0cmluZzsgY291bnQ6IG51bWJlcjsgdHRsOiBudW1iZXIgfT47XHJcbn0gfCBudWxsPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGNsaWVudCA9IGdldFJlZGlzQ2xpZW50KCk7XHJcbiAgICBjb25zdCBrZXlzID0gYXdhaXQgY2xpZW50LmtleXMocGF0dGVybik7XHJcblxyXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG90YWxLZXlzOiAwLFxyXG4gICAgICAgIGFjdGl2ZVdpbmRvd3M6IDAsXHJcbiAgICAgICAgdG9wS2V5czogW11cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPYnRlbmVyIGluZm9ybWFjacOzbiBkZSBsYXMgY2xhdmVzIG3DoXMgYWN0aXZhc1xyXG4gICAgY29uc3QgcGlwZWxpbmUgPSBjbGllbnQucGlwZWxpbmUoKTtcclxuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBwaXBlbGluZS5nZXQoa2V5KTtcclxuICAgICAgcGlwZWxpbmUudHRsKGtleSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcGlwZWxpbmUuZXhlYygpO1xyXG5cclxuICAgIGlmICghcmVzdWx0cykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBrZXlTdGF0czogQXJyYXk8eyBrZXk6IHN0cmluZzsgY291bnQ6IG51bWJlcjsgdHRsOiBudW1iZXIgfT4gPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgY291bnRSZXN1bHQgPSByZXN1bHRzW2kgKiAyXTtcclxuICAgICAgY29uc3QgdHRsUmVzdWx0ID0gcmVzdWx0c1tpICogMiArIDFdO1xyXG5cclxuICAgICAgaWYgKGNvdW50UmVzdWx0WzFdICYmIHR0bFJlc3VsdFsxXSkge1xyXG4gICAgICAgIGtleVN0YXRzLnB1c2goe1xyXG4gICAgICAgICAga2V5OiBrZXlzW2ldLFxyXG4gICAgICAgICAgY291bnQ6IHBhcnNlSW50KGNvdW50UmVzdWx0WzFdIGFzIHN0cmluZyksXHJcbiAgICAgICAgICB0dGw6IHR0bFJlc3VsdFsxXSBhcyBudW1iZXJcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE9yZGVuYXIgcG9yIGNvdW50IGRlc2NlbmRlbnRlXHJcbiAgICBrZXlTdGF0cy5zb3J0KChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxLZXlzOiBrZXlzLmxlbmd0aCxcclxuICAgICAgYWN0aXZlV2luZG93czoga2V5U3RhdHMuZmlsdGVyKHN0YXQgPT4gc3RhdC50dGwgPiAwKS5sZW5ndGgsXHJcbiAgICAgIHRvcEtleXM6IGtleVN0YXRzLnNsaWNlKDAsIDEwKSAvLyBUb3AgMTBcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdSYXRlIGxpbWl0IHN0YXRzIGZhaWxlZCcsIGVycm9yIGFzIEVycm9yKTtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExpbXBpYXIgY2xhdmVzIGRlIHJhdGUgbGltaXRpbmcgZXhwaXJhZGFzXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYW51cFJhdGVMaW1pdEtleXMocGF0dGVybjogc3RyaW5nID0gJ3JhdGVfbGltaXQ6KicpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBjbGllbnQgPSBnZXRSZWRpc0NsaWVudCgpO1xyXG4gICAgY29uc3Qga2V5cyA9IGF3YWl0IGNsaWVudC5rZXlzKHBhdHRlcm4pO1xyXG5cclxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBWZXJpZmljYXIgVFRMIGRlIGNhZGEgY2xhdmUgeSBlbGltaW5hciBsYXMgZXhwaXJhZGFzXHJcbiAgICBjb25zdCBwaXBlbGluZSA9IGNsaWVudC5waXBlbGluZSgpO1xyXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIHBpcGVsaW5lLnR0bChrZXkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdHRsUmVzdWx0cyA9IGF3YWl0IHBpcGVsaW5lLmV4ZWMoKTtcclxuXHJcbiAgICBpZiAoIXR0bFJlc3VsdHMpIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZXhwaXJlZEtleXM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHR0bFJlc3VsdCA9IHR0bFJlc3VsdHNbaV07XHJcbiAgICAgIGlmICh0dGxSZXN1bHRbMV0gPT09IC0yKSB7IC8vIENsYXZlIGV4cGlyYWRhXHJcbiAgICAgICAgZXhwaXJlZEtleXMucHVzaChrZXlzW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChleHBpcmVkS2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGF3YWl0IGNsaWVudC5kZWwoLi4uZXhwaXJlZEtleXMpO1xyXG4gICAgICBsb2dnZXIuaW5mbyhMb2dDYXRlZ29yeS5BUEksIGBDbGVhbmVkIHVwICR7ZXhwaXJlZEtleXMubGVuZ3RofSBleHBpcmVkIHJhdGUgbGltaXQga2V5c2ApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHBpcmVkS2V5cy5sZW5ndGg7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdSYXRlIGxpbWl0IGNsZWFudXAgZmFpbGVkJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvcnRhciBjbGllbnRlIFJlZGlzIHBhcmEgdXNvIGRpcmVjdG9cclxuZXhwb3J0IGNvbnN0IHJlZGlzID0gZ2V0UmVkaXNDbGllbnQoKTtcclxuIl0sIm5hbWVzIjpbIlJlZGlzQ2FjaGUiLCJjbGVhbnVwUmF0ZUxpbWl0S2V5cyIsImNsb3NlUmVkaXNDb25uZWN0aW9uIiwiZW50ZXJwcmlzZVJhdGVMaW1pdCIsImdldFJhdGVMaW1pdEluZm8iLCJnZXRSYXRlTGltaXRTdGF0cyIsImdldFJlZGlzQ2xpZW50IiwiaW5jcmVtZW50UmF0ZUxpbWl0IiwiaXNSZWRpc0F2YWlsYWJsZSIsInJlZGlzIiwicmVkaXNDYWNoZSIsInNsaWRpbmdXaW5kb3dSYXRlTGltaXQiLCJSRURJU19DT05GSUciLCJob3N0IiwicHJvY2VzcyIsImVudiIsIlJFRElTX0hPU1QiLCJwb3J0IiwicGFyc2VJbnQiLCJSRURJU19QT1JUIiwicGFzc3dvcmQiLCJSRURJU19QQVNTV09SRCIsImRiIiwiUkVESVNfREIiLCJyZXRyeURlbGF5T25GYWlsb3ZlciIsIm1heFJldHJpZXNQZXJSZXF1ZXN0IiwibGF6eUNvbm5lY3QiLCJrZWVwQWxpdmUiLCJjb25uZWN0VGltZW91dCIsImNvbW1hbmRUaW1lb3V0IiwicmVkaXNDbGllbnQiLCJSZWRpcyIsIm9uIiwibG9nZ2VyIiwiaW5mbyIsIkxvZ0NhdGVnb3J5IiwiQVBJIiwiZXJyb3IiLCJ3YXJuIiwiY2xpZW50IiwicGluZyIsInF1aXQiLCJjb25zdHJ1Y3RvciIsImdldCIsImtleSIsInZhbHVlIiwic2V0IiwidHRsU2Vjb25kcyIsInNldGV4IiwiZGVsIiwicmVzdWx0IiwiaW5jciIsImV4cGlyZSIsInR0bCIsInBpcGVsaW5lIiwicmVzdWx0cyIsImV4ZWMiLCJsZW5ndGgiLCJjb3VudFJlc3VsdCIsInR0bFJlc3VsdCIsImNvdW50Iiwid2luZG93U2Vjb25kcyIsImlzTmV3V2luZG93Iiwid2luZG93TXMiLCJtYXhSZXF1ZXN0cyIsIm5vdyIsIkRhdGUiLCJ3aW5kb3ciLCJNYXRoIiwiZmxvb3IiLCJyZWRpc0tleSIsImNlaWwiLCJyZW1haW5pbmciLCJtYXgiLCJyZXNldFRpbWUiLCJhbGxvd2VkIiwicmV0cnlBZnRlciIsInVuZGVmaW5lZCIsImRlYnVnIiwicHJlY2lzaW9uIiwid2luZG93U2l6ZSIsImN1cnJlbnRXaW5kb3ciLCJpIiwib2xkV2luZG93IiwiY3VycmVudEtleSIsIndpbmRvd0tleSIsInRvdGFsQ291bnQiLCJjb3VudFJlc3VsdHMiLCJzbGljZSIsInBhdHRlcm4iLCJrZXlzIiwidG90YWxLZXlzIiwiYWN0aXZlV2luZG93cyIsInRvcEtleXMiLCJmb3JFYWNoIiwia2V5U3RhdHMiLCJwdXNoIiwic29ydCIsImEiLCJiIiwiZmlsdGVyIiwic3RhdCIsInR0bFJlc3VsdHMiLCJleHBpcmVkS2V5cyJdLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDO0FBQ3RDLDJDQUEyQztBQUMzQyxzQ0FBc0M7Ozs7Ozs7Ozs7OztJQThFekJBLFVBQVU7ZUFBVkE7O0lBeVdTQyxvQkFBb0I7ZUFBcEJBOztJQXBYQUMsb0JBQW9C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