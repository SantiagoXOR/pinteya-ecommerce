9adc3b190ed9b9f37ae10285ca5852ac
// ===================================
// PINTEYA E-COMMERCE - METRICS SYSTEM
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    MetricsCollector: function() {
        return MetricsCollector;
    },
    metricsCollector: function() {
        return metricsCollector;
    }
});
const _redis = require("./redis");
const _logger = require("./logger");
// Configuración de métricas
const METRICS_CONFIG = {
    RETENTION_HOURS: 24,
    AGGREGATION_WINDOW_MINUTES: 5,
    ALERT_THRESHOLDS: {
        ERROR_RATE: 0.05,
        RESPONSE_TIME_P95: 5000,
        RATE_LIMIT_RATE: 0.1
    }
};
class MetricsCollector {
    constructor(){}
    static getInstance() {
        if (!MetricsCollector.instance) {
            MetricsCollector.instance = new MetricsCollector();
        }
        return MetricsCollector.instance;
    }
    /**
   * Registra una métrica de request
   */ async recordRequest(endpoint, method, statusCode, responseTime, labels = {}) {
        const timestamp = Date.now();
        const baseKey = `metrics:${endpoint}:${method}`;
        try {
            // Registrar request total
            await this.incrementCounter(`${baseKey}:requests:total`, timestamp);
            // Registrar por tipo de respuesta
            if (statusCode >= 200 && statusCode < 300) {
                await this.incrementCounter(`${baseKey}:requests:success`, timestamp);
            } else if (statusCode === 429) {
                await this.incrementCounter(`${baseKey}:requests:rate_limited`, timestamp);
            } else {
                await this.incrementCounter(`${baseKey}:requests:error`, timestamp);
                // Categorizar errores
                if (statusCode >= 400 && statusCode < 500) {
                    await this.incrementCounter(`${baseKey}:errors:4xx`, timestamp);
                } else if (statusCode >= 500) {
                    await this.incrementCounter(`${baseKey}:errors:5xx`, timestamp);
                }
            }
            // Registrar tiempo de respuesta
            await this.recordValue(`${baseKey}:response_time`, responseTime, timestamp);
            // Log para debugging
            _logger.logger.info(_logger.LogCategory.API, 'Metric recorded');
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to record metric', error);
        }
    }
    /**
   * Registra métricas de retry
   */ async recordRetry(operation, attempts, success, totalDuration) {
        const timestamp = Date.now();
        const baseKey = `metrics:retry:${operation}`;
        try {
            await this.incrementCounter(`${baseKey}:total`, timestamp);
            await this.recordValue(`${baseKey}:attempts`, attempts, timestamp);
            await this.recordValue(`${baseKey}:duration`, totalDuration, timestamp);
            if (success) {
                await this.incrementCounter(`${baseKey}:success`, timestamp);
            } else {
                await this.incrementCounter(`${baseKey}:failed`, timestamp);
            }
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to record retry metric', error);
        }
    }
    /**
   * Registra métricas de rate limiting
   */ async recordRateLimit(endpoint, blocked, remaining, limit) {
        const timestamp = Date.now();
        const baseKey = `metrics:rate_limit:${endpoint}`;
        try {
            await this.incrementCounter(`${baseKey}:checks`, timestamp);
            if (blocked) {
                await this.incrementCounter(`${baseKey}:blocked`, timestamp);
            }
            await this.recordValue(`${baseKey}:remaining`, remaining, timestamp);
            await this.recordValue(`${baseKey}:utilization`, (limit - remaining) / limit, timestamp);
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to record rate limit metric', error);
        }
    }
    /**
   * Incrementa un contador
   */ async incrementCounter(key, timestamp) {
        const windowKey = this.getWindowKey(key, timestamp);
        await _redis.redisCache.incr(windowKey);
        await _redis.redisCache.expire(windowKey, METRICS_CONFIG.RETENTION_HOURS * 3600);
    }
    /**
   * Registra un valor numérico
   */ async recordValue(key, value, timestamp) {
        const windowKey = this.getWindowKey(key, timestamp);
        const listKey = `${windowKey}:values`;
        // Agregar valor a la lista (usando Redis como cola circular)
        const client = _redis.redisCache['client'];
        await client.lpush(listKey, value.toString());
        await client.ltrim(listKey, 0, 999); // Mantener últimos 1000 valores
        await client.expire(listKey, METRICS_CONFIG.RETENTION_HOURS * 3600);
    }
    /**
   * Genera clave de ventana temporal
   */ getWindowKey(baseKey, timestamp) {
        const windowStart = Math.floor(timestamp / (METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000));
        return `${baseKey}:${windowStart}`;
    }
    /**
   * Obtiene métricas agregadas para un endpoint
   */ async getApiMetrics(endpoint, method, hoursBack = 1) {
        const baseKey = `metrics:${endpoint}:${method}`;
        const now = Date.now();
        const startTime = now - hoursBack * 60 * 60 * 1000;
        try {
            // Obtener contadores
            const requests = await this.getCounterSum(baseKey, 'requests', startTime, now);
            const errors = await this.getCounterSum(baseKey, 'errors', startTime, now);
            // Obtener tiempos de respuesta
            const responseTimes = await this.getValueStats(`${baseKey}:response_time`, startTime, now);
            // Obtener métricas de retry
            const retryStats = await this.getRetryStats(endpoint, startTime, now);
            return {
                requests: {
                    total: requests.total || 0,
                    success: requests.success || 0,
                    error: requests.error || 0,
                    rate_limited: requests.rate_limited || 0
                },
                response_times: responseTimes,
                error_rates: {
                    '4xx': errors['4xx'] || 0,
                    '5xx': errors['5xx'] || 0,
                    network: errors.network || 0,
                    timeout: errors.timeout || 0
                },
                retry_stats: retryStats
            };
        } catch (error) {
            _logger.logger.error(_logger.LogCategory.API, 'Failed to get API metrics', error);
            // Retornar métricas vacías en caso de error
            return this.getEmptyApiMetrics();
        }
    }
    /**
   * Obtiene suma de contadores en un rango de tiempo
   */ async getCounterSum(baseKey, category, startTime, endTime) {
        const result = {};
        const windowSize = METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000;
        for(let time = startTime; time <= endTime; time += windowSize){
            const windowStart = Math.floor(time / windowSize);
            // Obtener diferentes tipos de contadores
            const types = [
                'total',
                'success',
                'error',
                'rate_limited',
                '4xx',
                '5xx',
                'network',
                'timeout'
            ];
            for (const type of types){
                const key = `${baseKey}:${category}:${type}:${windowStart}`;
                const value = await _redis.redisCache.get(key);
                result[type] = (result[type] || 0) + parseInt(value || '0');
            }
        }
        return result;
    }
    /**
   * Obtiene estadísticas de valores numéricos
   */ async getValueStats(baseKey, startTime, endTime) {
        const values = [];
        const windowSize = METRICS_CONFIG.AGGREGATION_WINDOW_MINUTES * 60 * 1000;
        for(let time = startTime; time <= endTime; time += windowSize){
            const windowStart = Math.floor(time / windowSize);
            const key = `${baseKey}:${windowStart}:values`;
            try {
                const client = _redis.redisCache['client'];
                const windowValues = await client.lrange(key, 0, -1);
                values.push(...windowValues.map((v)=>parseFloat(v)).filter((v)=>!isNaN(v)));
            } catch (error) {
            // Continuar si no se puede obtener valores de una ventana
            }
        }
        if (values.length === 0) {
            return {
                count: 0,
                sum: 0,
                avg: 0,
                min: 0,
                max: 0,
                p95: 0,
                p99: 0
            };
        }
        values.sort((a, b)=>a - b);
        const sum = values.reduce((a, b)=>a + b, 0);
        return {
            count: values.length,
            sum,
            avg: sum / values.length,
            min: values[0],
            max: values[values.length - 1],
            p95: values[Math.floor(values.length * 0.95)] || 0,
            p99: values[Math.floor(values.length * 0.99)] || 0
        };
    }
    /**
   * Obtiene estadísticas de retry
   */ async getRetryStats(operation, startTime, endTime) {
        const baseKey = `metrics:retry:${operation}`;
        const counters = await this.getCounterSum(baseKey, '', startTime, endTime);
        const attempts = await this.getValueStats(`${baseKey}:attempts`, startTime, endTime);
        return {
            total_retries: counters.total || 0,
            successful_retries: counters.success || 0,
            failed_retries: counters.failed || 0,
            avg_attempts: attempts.avg || 0
        };
    }
    /**
   * Obtiene métricas específicas de MercadoPago
   */ async getMercadoPagoMetrics(hoursBack = 1) {
        try {
            const [paymentCreation, paymentQueries, webhookProcessing] = await Promise.all([
                this.getApiMetrics('/api/payments/create-preference', 'POST', hoursBack),
                this.getApiMetrics('/api/payments/query', 'GET', hoursBack),
                this.getApiMetrics('/api/webhooks/mercadopago', 'POST', hoursBack)
            ]);
            // Calcular métricas generales de salud
            const totalRequests = paymentCreation.requests.total + paymentQueries.requests.total + webhookProcessing.requests.total;
            const totalErrors = paymentCreation.requests.error + paymentQueries.requests.error + webhookProcessing.requests.error;
            const overallErrorRate = totalRequests > 0 ? totalErrors / totalRequests : 0;
            const avgResponseTime = totalRequests > 0 ? (paymentCreation.response_times.avg * paymentCreation.requests.total + paymentQueries.response_times.avg * paymentQueries.requests.total + webhookProcessing.response_times.avg * webhookProcessing.requests.total) / totalRequests : 0;
            return {
                payment_creation: paymentCreation,
                payment_queries: paymentQueries,
                webhook_processing: webhookProcessing,
                overall_health: {
                    uptime_percentage: overallErrorRate < 0.05 ? 99.9 : 95.0,
                    avg_response_time: avgResponseTime,
                    error_rate: overallErrorRate,
                    last_incident: overallErrorRate > 0.1 ? new Date().toISOString() : null
                }
            };
        } catch (error) {
            console.error('Error getting MercadoPago metrics:', error);
            // Retornar métricas vacías en caso de error
            const emptyMetrics = this.getEmptyApiMetrics();
            return {
                payment_creation: emptyMetrics,
                payment_queries: emptyMetrics,
                webhook_processing: emptyMetrics,
                overall_health: {
                    uptime_percentage: 0,
                    avg_response_time: 0,
                    error_rate: 1,
                    last_incident: new Date().toISOString()
                }
            };
        }
    }
    /**
   * Retorna métricas vacías por defecto
   */ getEmptyApiMetrics() {
        return {
            requests: {
                total: 0,
                success: 0,
                error: 0,
                rate_limited: 0
            },
            response_times: {
                count: 0,
                sum: 0,
                avg: 0,
                min: 0,
                max: 0,
                p95: 0,
                p99: 0
            },
            error_rates: {
                '4xx': 0,
                '5xx': 0,
                network: 0,
                timeout: 0
            },
            retry_stats: {
                total_retries: 0,
                successful_retries: 0,
                failed_retries: 0,
                avg_attempts: 0
            }
        };
    }
}
const metricsCollector = MetricsCollector.getInstance();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXHNyY1xcbGliXFxtZXRyaWNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vIFBJTlRFWUEgRS1DT01NRVJDRSAtIE1FVFJJQ1MgU1lTVEVNXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG5pbXBvcnQgeyByZWRpc0NhY2hlIH0gZnJvbSAnLi9yZWRpcyc7XHJcbmltcG9ydCB7IGxvZ2dlciwgTG9nTGV2ZWwsIExvZ0NhdGVnb3J5IH0gZnJvbSAnLi9sb2dnZXInO1xyXG5cclxuLy8gVGlwb3MgZGUgbcOpdHJpY2FzXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljRGF0YSB7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgdmFsdWU6IG51bWJlcjtcclxuICBsYWJlbHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFnZ3JlZ2F0ZWRNZXRyaWMge1xyXG4gIGNvdW50OiBudW1iZXI7XHJcbiAgc3VtOiBudW1iZXI7XHJcbiAgYXZnOiBudW1iZXI7XHJcbiAgbWluOiBudW1iZXI7XHJcbiAgbWF4OiBudW1iZXI7XHJcbiAgcDk1OiBudW1iZXI7XHJcbiAgcDk5OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXBpTWV0cmljcyB7XHJcbiAgcmVxdWVzdHM6IHtcclxuICAgIHRvdGFsOiBudW1iZXI7XHJcbiAgICBzdWNjZXNzOiBudW1iZXI7XHJcbiAgICBlcnJvcjogbnVtYmVyO1xyXG4gICAgcmF0ZV9saW1pdGVkOiBudW1iZXI7XHJcbiAgfTtcclxuICByZXNwb25zZV90aW1lczogQWdncmVnYXRlZE1ldHJpYztcclxuICBlcnJvcl9yYXRlczoge1xyXG4gICAgJzR4eCc6IG51bWJlcjtcclxuICAgICc1eHgnOiBudW1iZXI7XHJcbiAgICBuZXR3b3JrOiBudW1iZXI7XHJcbiAgICB0aW1lb3V0OiBudW1iZXI7XHJcbiAgfTtcclxuICByZXRyeV9zdGF0czoge1xyXG4gICAgdG90YWxfcmV0cmllczogbnVtYmVyO1xyXG4gICAgc3VjY2Vzc2Z1bF9yZXRyaWVzOiBudW1iZXI7XHJcbiAgICBmYWlsZWRfcmV0cmllczogbnVtYmVyO1xyXG4gICAgYXZnX2F0dGVtcHRzOiBudW1iZXI7XHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXJjYWRvUGFnb01ldHJpY3Mge1xyXG4gIHBheW1lbnRfY3JlYXRpb246IEFwaU1ldHJpY3M7XHJcbiAgcGF5bWVudF9xdWVyaWVzOiBBcGlNZXRyaWNzO1xyXG4gIHdlYmhvb2tfcHJvY2Vzc2luZzogQXBpTWV0cmljcztcclxuICBvdmVyYWxsX2hlYWx0aDoge1xyXG4gICAgdXB0aW1lX3BlcmNlbnRhZ2U6IG51bWJlcjtcclxuICAgIGF2Z19yZXNwb25zZV90aW1lOiBudW1iZXI7XHJcbiAgICBlcnJvcl9yYXRlOiBudW1iZXI7XHJcbiAgICBsYXN0X2luY2lkZW50OiBzdHJpbmcgfCBudWxsO1xyXG4gIH07XHJcbn1cclxuXHJcbi8vIENvbmZpZ3VyYWNpw7NuIGRlIG3DqXRyaWNhc1xyXG5jb25zdCBNRVRSSUNTX0NPTkZJRyA9IHtcclxuICBSRVRFTlRJT05fSE9VUlM6IDI0LFxyXG4gIEFHR1JFR0FUSU9OX1dJTkRPV19NSU5VVEVTOiA1LFxyXG4gIEFMRVJUX1RIUkVTSE9MRFM6IHtcclxuICAgIEVSUk9SX1JBVEU6IDAuMDUsIC8vIDUlXHJcbiAgICBSRVNQT05TRV9USU1FX1A5NTogNTAwMCwgLy8gNSBzZWd1bmRvc1xyXG4gICAgUkFURV9MSU1JVF9SQVRFOiAwLjEsIC8vIDEwJVxyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogQ2xhc2UgcHJpbmNpcGFsIHBhcmEgbWFuZWpvIGRlIG3DqXRyaWNhc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1ldHJpY3NDb2xsZWN0b3Ige1xyXG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBNZXRyaWNzQ29sbGVjdG9yO1xyXG5cclxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cclxuXHJcbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IE1ldHJpY3NDb2xsZWN0b3Ige1xyXG4gICAgaWYgKCFNZXRyaWNzQ29sbGVjdG9yLmluc3RhbmNlKSB7XHJcbiAgICAgIE1ldHJpY3NDb2xsZWN0b3IuaW5zdGFuY2UgPSBuZXcgTWV0cmljc0NvbGxlY3RvcigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1ldHJpY3NDb2xsZWN0b3IuaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RyYSB1bmEgbcOpdHJpY2EgZGUgcmVxdWVzdFxyXG4gICAqL1xyXG4gIGFzeW5jIHJlY29yZFJlcXVlc3QoXHJcbiAgICBlbmRwb2ludDogc3RyaW5nLFxyXG4gICAgbWV0aG9kOiBzdHJpbmcsXHJcbiAgICBzdGF0dXNDb2RlOiBudW1iZXIsXHJcbiAgICByZXNwb25zZVRpbWU6IG51bWJlcixcclxuICAgIGxhYmVsczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9XHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgYmFzZUtleSA9IGBtZXRyaWNzOiR7ZW5kcG9pbnR9OiR7bWV0aG9kfWA7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gUmVnaXN0cmFyIHJlcXVlc3QgdG90YWxcclxuICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnJlcXVlc3RzOnRvdGFsYCwgdGltZXN0YW1wKTtcclxuXHJcbiAgICAgIC8vIFJlZ2lzdHJhciBwb3IgdGlwbyBkZSByZXNwdWVzdGFcclxuICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPCAzMDApIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmluY3JlbWVudENvdW50ZXIoYCR7YmFzZUtleX06cmVxdWVzdHM6c3VjY2Vzc2AsIHRpbWVzdGFtcCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzQ29kZSA9PT0gNDI5KSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnJlcXVlc3RzOnJhdGVfbGltaXRlZGAsIHRpbWVzdGFtcCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnJlcXVlc3RzOmVycm9yYCwgdGltZXN0YW1wKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDYXRlZ29yaXphciBlcnJvcmVzXHJcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gNDAwICYmIHN0YXR1c0NvZGUgPCA1MDApIHtcclxuICAgICAgICAgIGF3YWl0IHRoaXMuaW5jcmVtZW50Q291bnRlcihgJHtiYXNlS2V5fTplcnJvcnM6NHh4YCwgdGltZXN0YW1wKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1c0NvZGUgPj0gNTAwKSB7XHJcbiAgICAgICAgICBhd2FpdCB0aGlzLmluY3JlbWVudENvdW50ZXIoYCR7YmFzZUtleX06ZXJyb3JzOjV4eGAsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZWdpc3RyYXIgdGllbXBvIGRlIHJlc3B1ZXN0YVxyXG4gICAgICBhd2FpdCB0aGlzLnJlY29yZFZhbHVlKGAke2Jhc2VLZXl9OnJlc3BvbnNlX3RpbWVgLCByZXNwb25zZVRpbWUsIHRpbWVzdGFtcCk7XHJcblxyXG4gICAgICAvLyBMb2cgcGFyYSBkZWJ1Z2dpbmdcclxuICAgICAgbG9nZ2VyLmluZm8oTG9nQ2F0ZWdvcnkuQVBJLCAnTWV0cmljIHJlY29yZGVkJyk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0ZhaWxlZCB0byByZWNvcmQgbWV0cmljJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0cmEgbcOpdHJpY2FzIGRlIHJldHJ5XHJcbiAgICovXHJcbiAgYXN5bmMgcmVjb3JkUmV0cnkoXHJcbiAgICBvcGVyYXRpb246IHN0cmluZyxcclxuICAgIGF0dGVtcHRzOiBudW1iZXIsXHJcbiAgICBzdWNjZXNzOiBib29sZWFuLFxyXG4gICAgdG90YWxEdXJhdGlvbjogbnVtYmVyXHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3QgYmFzZUtleSA9IGBtZXRyaWNzOnJldHJ5OiR7b3BlcmF0aW9ufWA7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnRvdGFsYCwgdGltZXN0YW1wKTtcclxuICAgICAgYXdhaXQgdGhpcy5yZWNvcmRWYWx1ZShgJHtiYXNlS2V5fTphdHRlbXB0c2AsIGF0dGVtcHRzLCB0aW1lc3RhbXApO1xyXG4gICAgICBhd2FpdCB0aGlzLnJlY29yZFZhbHVlKGAke2Jhc2VLZXl9OmR1cmF0aW9uYCwgdG90YWxEdXJhdGlvbiwgdGltZXN0YW1wKTtcclxuXHJcbiAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OnN1Y2Nlc3NgLCB0aW1lc3RhbXApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuaW5jcmVtZW50Q291bnRlcihgJHtiYXNlS2V5fTpmYWlsZWRgLCB0aW1lc3RhbXApO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKExvZ0NhdGVnb3J5LkFQSSwgJ0ZhaWxlZCB0byByZWNvcmQgcmV0cnkgbWV0cmljJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0cmEgbcOpdHJpY2FzIGRlIHJhdGUgbGltaXRpbmdcclxuICAgKi9cclxuICBhc3luYyByZWNvcmRSYXRlTGltaXQoXHJcbiAgICBlbmRwb2ludDogc3RyaW5nLFxyXG4gICAgYmxvY2tlZDogYm9vbGVhbixcclxuICAgIHJlbWFpbmluZzogbnVtYmVyLFxyXG4gICAgbGltaXQ6IG51bWJlclxyXG4gICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgIGNvbnN0IGJhc2VLZXkgPSBgbWV0cmljczpyYXRlX2xpbWl0OiR7ZW5kcG9pbnR9YDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLmluY3JlbWVudENvdW50ZXIoYCR7YmFzZUtleX06Y2hlY2tzYCwgdGltZXN0YW1wKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChibG9ja2VkKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRDb3VudGVyKGAke2Jhc2VLZXl9OmJsb2NrZWRgLCB0aW1lc3RhbXApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhd2FpdCB0aGlzLnJlY29yZFZhbHVlKGAke2Jhc2VLZXl9OnJlbWFpbmluZ2AsIHJlbWFpbmluZywgdGltZXN0YW1wKTtcclxuICAgICAgYXdhaXQgdGhpcy5yZWNvcmRWYWx1ZShgJHtiYXNlS2V5fTp1dGlsaXphdGlvbmAsIChsaW1pdCAtIHJlbWFpbmluZykgLyBsaW1pdCwgdGltZXN0YW1wKTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsb2dnZXIuZXJyb3IoTG9nQ2F0ZWdvcnkuQVBJLCAnRmFpbGVkIHRvIHJlY29yZCByYXRlIGxpbWl0IG1ldHJpYycsIGVycm9yIGFzIEVycm9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluY3JlbWVudGEgdW4gY29udGFkb3JcclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIGluY3JlbWVudENvdW50ZXIoa2V5OiBzdHJpbmcsIHRpbWVzdGFtcDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB3aW5kb3dLZXkgPSB0aGlzLmdldFdpbmRvd0tleShrZXksIHRpbWVzdGFtcCk7XHJcbiAgICBhd2FpdCByZWRpc0NhY2hlLmluY3Iod2luZG93S2V5KTtcclxuICAgIGF3YWl0IHJlZGlzQ2FjaGUuZXhwaXJlKHdpbmRvd0tleSwgTUVUUklDU19DT05GSUcuUkVURU5USU9OX0hPVVJTICogMzYwMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RyYSB1biB2YWxvciBudW3DqXJpY29cclxuICAgKi9cclxuICBwcml2YXRlIGFzeW5jIHJlY29yZFZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyLCB0aW1lc3RhbXA6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3Qgd2luZG93S2V5ID0gdGhpcy5nZXRXaW5kb3dLZXkoa2V5LCB0aW1lc3RhbXApO1xyXG4gICAgY29uc3QgbGlzdEtleSA9IGAke3dpbmRvd0tleX06dmFsdWVzYDtcclxuICAgIFxyXG4gICAgLy8gQWdyZWdhciB2YWxvciBhIGxhIGxpc3RhICh1c2FuZG8gUmVkaXMgY29tbyBjb2xhIGNpcmN1bGFyKVxyXG4gICAgY29uc3QgY2xpZW50ID0gcmVkaXNDYWNoZVsnY2xpZW50J107XHJcbiAgICBhd2FpdCBjbGllbnQubHB1c2gobGlzdEtleSwgdmFsdWUudG9TdHJpbmcoKSk7XHJcbiAgICBhd2FpdCBjbGllbnQubHRyaW0obGlzdEtleSwgMCwgOTk5KTsgLy8gTWFudGVuZXIgw7psdGltb3MgMTAwMCB2YWxvcmVzXHJcbiAgICBhd2FpdCBjbGllbnQuZXhwaXJlKGxpc3RLZXksIE1FVFJJQ1NfQ09ORklHLlJFVEVOVElPTl9IT1VSUyAqIDM2MDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2VuZXJhIGNsYXZlIGRlIHZlbnRhbmEgdGVtcG9yYWxcclxuICAgKi9cclxuICBwcml2YXRlIGdldFdpbmRvd0tleShiYXNlS2V5OiBzdHJpbmcsIHRpbWVzdGFtcDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHdpbmRvd1N0YXJ0ID0gTWF0aC5mbG9vcih0aW1lc3RhbXAgLyAoTUVUUklDU19DT05GSUcuQUdHUkVHQVRJT05fV0lORE9XX01JTlVURVMgKiA2MCAqIDEwMDApKTtcclxuICAgIHJldHVybiBgJHtiYXNlS2V5fToke3dpbmRvd1N0YXJ0fWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPYnRpZW5lIG3DqXRyaWNhcyBhZ3JlZ2FkYXMgcGFyYSB1biBlbmRwb2ludFxyXG4gICAqL1xyXG4gIGFzeW5jIGdldEFwaU1ldHJpY3MoZW5kcG9pbnQ6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGhvdXJzQmFjazogbnVtYmVyID0gMSk6IFByb21pc2U8QXBpTWV0cmljcz4ge1xyXG4gICAgY29uc3QgYmFzZUtleSA9IGBtZXRyaWNzOiR7ZW5kcG9pbnR9OiR7bWV0aG9kfWA7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbm93IC0gKGhvdXJzQmFjayAqIDYwICogNjAgKiAxMDAwKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBPYnRlbmVyIGNvbnRhZG9yZXNcclxuICAgICAgY29uc3QgcmVxdWVzdHMgPSBhd2FpdCB0aGlzLmdldENvdW50ZXJTdW0oYmFzZUtleSwgJ3JlcXVlc3RzJywgc3RhcnRUaW1lLCBub3cpO1xyXG4gICAgICBjb25zdCBlcnJvcnMgPSBhd2FpdCB0aGlzLmdldENvdW50ZXJTdW0oYmFzZUtleSwgJ2Vycm9ycycsIHN0YXJ0VGltZSwgbm93KTtcclxuICAgICAgXHJcbiAgICAgIC8vIE9idGVuZXIgdGllbXBvcyBkZSByZXNwdWVzdGFcclxuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lcyA9IGF3YWl0IHRoaXMuZ2V0VmFsdWVTdGF0cyhgJHtiYXNlS2V5fTpyZXNwb25zZV90aW1lYCwgc3RhcnRUaW1lLCBub3cpO1xyXG4gICAgICBcclxuICAgICAgLy8gT2J0ZW5lciBtw6l0cmljYXMgZGUgcmV0cnlcclxuICAgICAgY29uc3QgcmV0cnlTdGF0cyA9IGF3YWl0IHRoaXMuZ2V0UmV0cnlTdGF0cyhlbmRwb2ludCwgc3RhcnRUaW1lLCBub3cpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICByZXF1ZXN0czoge1xyXG4gICAgICAgICAgdG90YWw6IHJlcXVlc3RzLnRvdGFsIHx8IDAsXHJcbiAgICAgICAgICBzdWNjZXNzOiByZXF1ZXN0cy5zdWNjZXNzIHx8IDAsXHJcbiAgICAgICAgICBlcnJvcjogcmVxdWVzdHMuZXJyb3IgfHwgMCxcclxuICAgICAgICAgIHJhdGVfbGltaXRlZDogcmVxdWVzdHMucmF0ZV9saW1pdGVkIHx8IDAsXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXNwb25zZV90aW1lczogcmVzcG9uc2VUaW1lcyxcclxuICAgICAgICBlcnJvcl9yYXRlczoge1xyXG4gICAgICAgICAgJzR4eCc6IGVycm9yc1snNHh4J10gfHwgMCxcclxuICAgICAgICAgICc1eHgnOiBlcnJvcnNbJzV4eCddIHx8IDAsXHJcbiAgICAgICAgICBuZXR3b3JrOiBlcnJvcnMubmV0d29yayB8fCAwLFxyXG4gICAgICAgICAgdGltZW91dDogZXJyb3JzLnRpbWVvdXQgfHwgMCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJldHJ5X3N0YXRzOiByZXRyeVN0YXRzLFxyXG4gICAgICB9O1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihMb2dDYXRlZ29yeS5BUEksICdGYWlsZWQgdG8gZ2V0IEFQSSBtZXRyaWNzJywgZXJyb3IgYXMgRXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gUmV0b3JuYXIgbcOpdHJpY2FzIHZhY8OtYXMgZW4gY2FzbyBkZSBlcnJvclxyXG4gICAgICByZXR1cm4gdGhpcy5nZXRFbXB0eUFwaU1ldHJpY3MoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgc3VtYSBkZSBjb250YWRvcmVzIGVuIHVuIHJhbmdvIGRlIHRpZW1wb1xyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZ2V0Q291bnRlclN1bShcclxuICAgIGJhc2VLZXk6IHN0cmluZywgXHJcbiAgICBjYXRlZ29yeTogc3RyaW5nLCBcclxuICAgIHN0YXJ0VGltZTogbnVtYmVyLCBcclxuICAgIGVuZFRpbWU6IG51bWJlclxyXG4gICk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgbnVtYmVyPj4ge1xyXG4gICAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XHJcbiAgICBjb25zdCB3aW5kb3dTaXplID0gTUVUUklDU19DT05GSUcuQUdHUkVHQVRJT05fV0lORE9XX01JTlVURVMgKiA2MCAqIDEwMDA7XHJcbiAgICBcclxuICAgIGZvciAobGV0IHRpbWUgPSBzdGFydFRpbWU7IHRpbWUgPD0gZW5kVGltZTsgdGltZSArPSB3aW5kb3dTaXplKSB7XHJcbiAgICAgIGNvbnN0IHdpbmRvd1N0YXJ0ID0gTWF0aC5mbG9vcih0aW1lIC8gd2luZG93U2l6ZSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBPYnRlbmVyIGRpZmVyZW50ZXMgdGlwb3MgZGUgY29udGFkb3Jlc1xyXG4gICAgICBjb25zdCB0eXBlcyA9IFsndG90YWwnLCAnc3VjY2VzcycsICdlcnJvcicsICdyYXRlX2xpbWl0ZWQnLCAnNHh4JywgJzV4eCcsICduZXR3b3JrJywgJ3RpbWVvdXQnXTtcclxuICAgICAgXHJcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGAke2Jhc2VLZXl9OiR7Y2F0ZWdvcnl9OiR7dHlwZX06JHt3aW5kb3dTdGFydH1gO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcmVkaXNDYWNoZS5nZXQoa2V5KTtcclxuICAgICAgICByZXN1bHRbdHlwZV0gPSAocmVzdWx0W3R5cGVdIHx8IDApICsgKHBhcnNlSW50KHZhbHVlIHx8ICcwJykpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBPYnRpZW5lIGVzdGFkw61zdGljYXMgZGUgdmFsb3JlcyBudW3DqXJpY29zXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhc3luYyBnZXRWYWx1ZVN0YXRzKFxyXG4gICAgYmFzZUtleTogc3RyaW5nLCBcclxuICAgIHN0YXJ0VGltZTogbnVtYmVyLCBcclxuICAgIGVuZFRpbWU6IG51bWJlclxyXG4gICk6IFByb21pc2U8QWdncmVnYXRlZE1ldHJpYz4ge1xyXG4gICAgY29uc3QgdmFsdWVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IE1FVFJJQ1NfQ09ORklHLkFHR1JFR0FUSU9OX1dJTkRPV19NSU5VVEVTICogNjAgKiAxMDAwO1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCB0aW1lID0gc3RhcnRUaW1lOyB0aW1lIDw9IGVuZFRpbWU7IHRpbWUgKz0gd2luZG93U2l6ZSkge1xyXG4gICAgICBjb25zdCB3aW5kb3dTdGFydCA9IE1hdGguZmxvb3IodGltZSAvIHdpbmRvd1NpemUpO1xyXG4gICAgICBjb25zdCBrZXkgPSBgJHtiYXNlS2V5fToke3dpbmRvd1N0YXJ0fTp2YWx1ZXNgO1xyXG4gICAgICBcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjbGllbnQgPSByZWRpc0NhY2hlWydjbGllbnQnXTtcclxuICAgICAgICBjb25zdCB3aW5kb3dWYWx1ZXMgPSBhd2FpdCBjbGllbnQubHJhbmdlKGtleSwgMCwgLTEpO1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKC4uLndpbmRvd1ZhbHVlcy5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKS5maWx0ZXIodiA9PiAhaXNOYU4odikpKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAvLyBDb250aW51YXIgc2kgbm8gc2UgcHVlZGUgb2J0ZW5lciB2YWxvcmVzIGRlIHVuYSB2ZW50YW5hXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4geyBjb3VudDogMCwgc3VtOiAwLCBhdmc6IDAsIG1pbjogMCwgbWF4OiAwLCBwOTU6IDAsIHA5OTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcbiAgICBjb25zdCBzdW0gPSB2YWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvdW50OiB2YWx1ZXMubGVuZ3RoLFxyXG4gICAgICBzdW0sXHJcbiAgICAgIGF2Zzogc3VtIC8gdmFsdWVzLmxlbmd0aCxcclxuICAgICAgbWluOiB2YWx1ZXNbMF0sXHJcbiAgICAgIG1heDogdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSxcclxuICAgICAgcDk1OiB2YWx1ZXNbTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoICogMC45NSldIHx8IDAsXHJcbiAgICAgIHA5OTogdmFsdWVzW01hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAqIDAuOTkpXSB8fCAwLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgZXN0YWTDrXN0aWNhcyBkZSByZXRyeVxyXG4gICAqL1xyXG4gIHByaXZhdGUgYXN5bmMgZ2V0UmV0cnlTdGF0cyhcclxuICAgIG9wZXJhdGlvbjogc3RyaW5nLCBcclxuICAgIHN0YXJ0VGltZTogbnVtYmVyLCBcclxuICAgIGVuZFRpbWU6IG51bWJlclxyXG4gICk6IFByb21pc2U8QXBpTWV0cmljc1sncmV0cnlfc3RhdHMnXT4ge1xyXG4gICAgY29uc3QgYmFzZUtleSA9IGBtZXRyaWNzOnJldHJ5OiR7b3BlcmF0aW9ufWA7XHJcbiAgICBjb25zdCBjb3VudGVycyA9IGF3YWl0IHRoaXMuZ2V0Q291bnRlclN1bShiYXNlS2V5LCAnJywgc3RhcnRUaW1lLCBlbmRUaW1lKTtcclxuICAgIGNvbnN0IGF0dGVtcHRzID0gYXdhaXQgdGhpcy5nZXRWYWx1ZVN0YXRzKGAke2Jhc2VLZXl9OmF0dGVtcHRzYCwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3RhbF9yZXRyaWVzOiBjb3VudGVycy50b3RhbCB8fCAwLFxyXG4gICAgICBzdWNjZXNzZnVsX3JldHJpZXM6IGNvdW50ZXJzLnN1Y2Nlc3MgfHwgMCxcclxuICAgICAgZmFpbGVkX3JldHJpZXM6IGNvdW50ZXJzLmZhaWxlZCB8fCAwLFxyXG4gICAgICBhdmdfYXR0ZW1wdHM6IGF0dGVtcHRzLmF2ZyB8fCAwLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idGllbmUgbcOpdHJpY2FzIGVzcGVjw61maWNhcyBkZSBNZXJjYWRvUGFnb1xyXG4gICAqL1xyXG4gIGFzeW5jIGdldE1lcmNhZG9QYWdvTWV0cmljcyhob3Vyc0JhY2s6IG51bWJlciA9IDEpOiBQcm9taXNlPE1lcmNhZG9QYWdvTWV0cmljcz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgW3BheW1lbnRDcmVhdGlvbiwgcGF5bWVudFF1ZXJpZXMsIHdlYmhvb2tQcm9jZXNzaW5nXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICB0aGlzLmdldEFwaU1ldHJpY3MoJy9hcGkvcGF5bWVudHMvY3JlYXRlLXByZWZlcmVuY2UnLCAnUE9TVCcsIGhvdXJzQmFjayksXHJcbiAgICAgICAgdGhpcy5nZXRBcGlNZXRyaWNzKCcvYXBpL3BheW1lbnRzL3F1ZXJ5JywgJ0dFVCcsIGhvdXJzQmFjayksXHJcbiAgICAgICAgdGhpcy5nZXRBcGlNZXRyaWNzKCcvYXBpL3dlYmhvb2tzL21lcmNhZG9wYWdvJywgJ1BPU1QnLCBob3Vyc0JhY2spLFxyXG4gICAgICBdKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGFyIG3DqXRyaWNhcyBnZW5lcmFsZXMgZGUgc2FsdWRcclxuICAgICAgY29uc3QgdG90YWxSZXF1ZXN0cyA9IHBheW1lbnRDcmVhdGlvbi5yZXF1ZXN0cy50b3RhbCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRRdWVyaWVzLnJlcXVlc3RzLnRvdGFsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViaG9va1Byb2Nlc3NpbmcucmVxdWVzdHMudG90YWw7XHJcblxyXG4gICAgICBjb25zdCB0b3RhbEVycm9ycyA9IHBheW1lbnRDcmVhdGlvbi5yZXF1ZXN0cy5lcnJvciArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50UXVlcmllcy5yZXF1ZXN0cy5lcnJvciArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJob29rUHJvY2Vzc2luZy5yZXF1ZXN0cy5lcnJvcjtcclxuXHJcbiAgICAgIGNvbnN0IG92ZXJhbGxFcnJvclJhdGUgPSB0b3RhbFJlcXVlc3RzID4gMCA/IHRvdGFsRXJyb3JzIC8gdG90YWxSZXF1ZXN0cyA6IDA7XHJcblxyXG4gICAgICBjb25zdCBhdmdSZXNwb25zZVRpbWUgPSB0b3RhbFJlcXVlc3RzID4gMCA/XHJcbiAgICAgICAgKHBheW1lbnRDcmVhdGlvbi5yZXNwb25zZV90aW1lcy5hdmcgKiBwYXltZW50Q3JlYXRpb24ucmVxdWVzdHMudG90YWwgK1xyXG4gICAgICAgICBwYXltZW50UXVlcmllcy5yZXNwb25zZV90aW1lcy5hdmcgKiBwYXltZW50UXVlcmllcy5yZXF1ZXN0cy50b3RhbCArXHJcbiAgICAgICAgIHdlYmhvb2tQcm9jZXNzaW5nLnJlc3BvbnNlX3RpbWVzLmF2ZyAqIHdlYmhvb2tQcm9jZXNzaW5nLnJlcXVlc3RzLnRvdGFsKSAvIHRvdGFsUmVxdWVzdHMgOiAwO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwYXltZW50X2NyZWF0aW9uOiBwYXltZW50Q3JlYXRpb24sXHJcbiAgICAgICAgcGF5bWVudF9xdWVyaWVzOiBwYXltZW50UXVlcmllcyxcclxuICAgICAgICB3ZWJob29rX3Byb2Nlc3Npbmc6IHdlYmhvb2tQcm9jZXNzaW5nLFxyXG4gICAgICAgIG92ZXJhbGxfaGVhbHRoOiB7XHJcbiAgICAgICAgICB1cHRpbWVfcGVyY2VudGFnZTogb3ZlcmFsbEVycm9yUmF0ZSA8IDAuMDUgPyA5OS45IDogOTUuMCwgLy8gU2ltcGxpZmljYWRvXHJcbiAgICAgICAgICBhdmdfcmVzcG9uc2VfdGltZTogYXZnUmVzcG9uc2VUaW1lLFxyXG4gICAgICAgICAgZXJyb3JfcmF0ZTogb3ZlcmFsbEVycm9yUmF0ZSxcclxuICAgICAgICAgIGxhc3RfaW5jaWRlbnQ6IG92ZXJhbGxFcnJvclJhdGUgPiAwLjEgPyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgOiBudWxsLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIE1lcmNhZG9QYWdvIG1ldHJpY3M6JywgZXJyb3IpO1xyXG4gICAgICAvLyBSZXRvcm5hciBtw6l0cmljYXMgdmFjw61hcyBlbiBjYXNvIGRlIGVycm9yXHJcbiAgICAgIGNvbnN0IGVtcHR5TWV0cmljcyA9IHRoaXMuZ2V0RW1wdHlBcGlNZXRyaWNzKCk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcGF5bWVudF9jcmVhdGlvbjogZW1wdHlNZXRyaWNzLFxyXG4gICAgICAgIHBheW1lbnRfcXVlcmllczogZW1wdHlNZXRyaWNzLFxyXG4gICAgICAgIHdlYmhvb2tfcHJvY2Vzc2luZzogZW1wdHlNZXRyaWNzLFxyXG4gICAgICAgIG92ZXJhbGxfaGVhbHRoOiB7XHJcbiAgICAgICAgICB1cHRpbWVfcGVyY2VudGFnZTogMCxcclxuICAgICAgICAgIGF2Z19yZXNwb25zZV90aW1lOiAwLFxyXG4gICAgICAgICAgZXJyb3JfcmF0ZTogMSxcclxuICAgICAgICAgIGxhc3RfaW5jaWRlbnQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0b3JuYSBtw6l0cmljYXMgdmFjw61hcyBwb3IgZGVmZWN0b1xyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0RW1wdHlBcGlNZXRyaWNzKCk6IEFwaU1ldHJpY3Mge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmVxdWVzdHM6IHsgdG90YWw6IDAsIHN1Y2Nlc3M6IDAsIGVycm9yOiAwLCByYXRlX2xpbWl0ZWQ6IDAgfSxcclxuICAgICAgcmVzcG9uc2VfdGltZXM6IHsgY291bnQ6IDAsIHN1bTogMCwgYXZnOiAwLCBtaW46IDAsIG1heDogMCwgcDk1OiAwLCBwOTk6IDAgfSxcclxuICAgICAgZXJyb3JfcmF0ZXM6IHsgJzR4eCc6IDAsICc1eHgnOiAwLCBuZXR3b3JrOiAwLCB0aW1lb3V0OiAwIH0sXHJcbiAgICAgIHJldHJ5X3N0YXRzOiB7IHRvdGFsX3JldHJpZXM6IDAsIHN1Y2Nlc3NmdWxfcmV0cmllczogMCwgZmFpbGVkX3JldHJpZXM6IDAsIGF2Z19hdHRlbXB0czogMCB9LFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEluc3RhbmNpYSBzaW5nbGV0b25cclxuZXhwb3J0IGNvbnN0IG1ldHJpY3NDb2xsZWN0b3IgPSBNZXRyaWNzQ29sbGVjdG9yLmdldEluc3RhbmNlKCk7XHJcbiJdLCJuYW1lcyI6WyJNZXRyaWNzQ29sbGVjdG9yIiwibWV0cmljc0NvbGxlY3RvciIsIk1FVFJJQ1NfQ09ORklHIiwiUkVURU5USU9OX0hPVVJTIiwiQUdHUkVHQVRJT05fV0lORE9XX01JTlVURVMiLCJBTEVSVF9USFJFU0hPTERTIiwiRVJST1JfUkFURSIsIlJFU1BPTlNFX1RJTUVfUDk1IiwiUkFURV9MSU1JVF9SQVRFIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInJlY29yZFJlcXVlc3QiLCJlbmRwb2ludCIsIm1ldGhvZCIsInN0YXR1c0NvZGUiLCJyZXNwb25zZVRpbWUiLCJsYWJlbHMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwiYmFzZUtleSIsImluY3JlbWVudENvdW50ZXIiLCJyZWNvcmRWYWx1ZSIsImxvZ2dlciIsImluZm8iLCJMb2dDYXRlZ29yeSIsIkFQSSIsImVycm9yIiwicmVjb3JkUmV0cnkiLCJvcGVyYXRpb24iLCJhdHRlbXB0cyIsInN1Y2Nlc3MiLCJ0b3RhbER1cmF0aW9uIiwicmVjb3JkUmF0ZUxpbWl0IiwiYmxvY2tlZCIsInJlbWFpbmluZyIsImxpbWl0Iiwia2V5Iiwid2luZG93S2V5IiwiZ2V0V2luZG93S2V5IiwicmVkaXNDYWNoZSIsImluY3IiLCJleHBpcmUiLCJ2YWx1ZSIsImxpc3RLZXkiLCJjbGllbnQiLCJscHVzaCIsInRvU3RyaW5nIiwibHRyaW0iLCJ3aW5kb3dTdGFydCIsIk1hdGgiLCJmbG9vciIsImdldEFwaU1ldHJpY3MiLCJob3Vyc0JhY2siLCJzdGFydFRpbWUiLCJyZXF1ZXN0cyIsImdldENvdW50ZXJTdW0iLCJlcnJvcnMiLCJyZXNwb25zZVRpbWVzIiwiZ2V0VmFsdWVTdGF0cyIsInJldHJ5U3RhdHMiLCJnZXRSZXRyeVN0YXRzIiwidG90YWwiLCJyYXRlX2xpbWl0ZWQiLCJyZXNwb25zZV90aW1lcyIsImVycm9yX3JhdGVzIiwibmV0d29yayIsInRpbWVvdXQiLCJyZXRyeV9zdGF0cyIsImdldEVtcHR5QXBpTWV0cmljcyIsImNhdGVnb3J5IiwiZW5kVGltZSIsInJlc3VsdCIsIndpbmRvd1NpemUiLCJ0aW1lIiwidHlwZXMiLCJ0eXBlIiwiZ2V0IiwicGFyc2VJbnQiLCJ2YWx1ZXMiLCJ3aW5kb3dWYWx1ZXMiLCJscmFuZ2UiLCJwdXNoIiwibWFwIiwidiIsInBhcnNlRmxvYXQiLCJmaWx0ZXIiLCJpc05hTiIsImxlbmd0aCIsImNvdW50Iiwic3VtIiwiYXZnIiwibWluIiwibWF4IiwicDk1IiwicDk5Iiwic29ydCIsImEiLCJiIiwicmVkdWNlIiwiY291bnRlcnMiLCJ0b3RhbF9yZXRyaWVzIiwic3VjY2Vzc2Z1bF9yZXRyaWVzIiwiZmFpbGVkX3JldHJpZXMiLCJmYWlsZWQiLCJhdmdfYXR0ZW1wdHMiLCJnZXRNZXJjYWRvUGFnb01ldHJpY3MiLCJwYXltZW50Q3JlYXRpb24iLCJwYXltZW50UXVlcmllcyIsIndlYmhvb2tQcm9jZXNzaW5nIiwiUHJvbWlzZSIsImFsbCIsInRvdGFsUmVxdWVzdHMiLCJ0b3RhbEVycm9ycyIsIm92ZXJhbGxFcnJvclJhdGUiLCJhdmdSZXNwb25zZVRpbWUiLCJwYXltZW50X2NyZWF0aW9uIiwicGF5bWVudF9xdWVyaWVzIiwid2ViaG9va19wcm9jZXNzaW5nIiwib3ZlcmFsbF9oZWFsdGgiLCJ1cHRpbWVfcGVyY2VudGFnZSIsImF2Z19yZXNwb25zZV90aW1lIiwiZXJyb3JfcmF0ZSIsImxhc3RfaW5jaWRlbnQiLCJ0b0lTT1N0cmluZyIsImNvbnNvbGUiLCJlbXB0eU1ldHJpY3MiXSwibWFwcGluZ3MiOiJBQUFBLHNDQUFzQztBQUN0QyxzQ0FBc0M7QUFDdEMsc0NBQXNDOzs7Ozs7Ozs7Ozs7SUFzRXpCQSxnQkFBZ0I7ZUFBaEJBOztJQTBWQUMsZ0JBQWdCO2VBQWhCQTs7O3VCQTlaYzt3QkFDbUI7QUFxRDlDLDRCQUE0QjtBQUM1QixNQUFNQyxpQkFBaUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsNEJBQTRCO0lBQzVCQyxrQkFBa0I7UUFDaEJDLFlBQVk7UUFDWkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7SUFDbkI7QUFDRjtBQUtPLE1BQU1SO0lBR1gsYUFBc0IsQ0FBQztJQUV2QixPQUFP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