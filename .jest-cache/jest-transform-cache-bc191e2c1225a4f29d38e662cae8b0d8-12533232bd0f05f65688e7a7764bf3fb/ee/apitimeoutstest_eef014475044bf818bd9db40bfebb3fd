31eaaffe226d1672659b2fcc4d0e4e47
// ===================================
// TESTS: API Timeouts Configuration
// ===================================
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _apitimeouts = require("../../src/lib/config/api-timeouts");
// Mock fetch para tests
global.fetch = jest.fn();
const mockFetch = fetch;
// Mock environment variables
const originalEnv = process.env;
beforeEach(()=>{
    jest.clearAllMocks();
    process.env = {
        ...originalEnv
    };
});
afterAll(()=>{
    process.env = originalEnv;
});
describe('API Timeouts Configuration', ()=>{
    describe('Environment Variable Integration', ()=>{
        it('should use default values when env vars are not set', ()=>{
            // Clear environment variables
            delete process.env.API_TIMEOUT_DEFAULT;
            delete process.env.API_TIMEOUT_DATABASE;
            // Re-import to get fresh values
            jest.resetModules();
            const { API_TIMEOUTS } = require('@/lib/config/api-timeouts');
            expect(API_TIMEOUTS.default).toBe(30000);
            expect(API_TIMEOUTS.database).toBe(15000);
        });
        it('should use environment variables when provided', ()=>{
            process.env.API_TIMEOUT_DEFAULT = '45000';
            process.env.API_TIMEOUT_DATABASE = '20000';
            jest.resetModules();
            const { API_TIMEOUTS } = require('@/lib/config/api-timeouts');
            expect(API_TIMEOUTS.default).toBe(45000);
            expect(API_TIMEOUTS.database).toBe(20000);
        });
        it('should handle invalid environment variables gracefully', ()=>{
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            process.env.API_TIMEOUT_DEFAULT = 'invalid';
            process.env.API_TIMEOUT_DATABASE = '-1000';
            jest.resetModules();
            const { API_TIMEOUTS } = require('@/lib/config/api-timeouts');
            expect(API_TIMEOUTS.default).toBe(30000); // Should use default
            expect(API_TIMEOUTS.database).toBe(15000); // Should use default
            expect(consoleSpy).toHaveBeenCalledTimes(2);
            consoleSpy.mockRestore();
        });
    });
    describe('getTimeout', ()=>{
        it('should return correct timeout for each type', ()=>{
            expect((0, _apitimeouts.getTimeout)('default')).toBe(_apitimeouts.API_TIMEOUTS.default);
            expect((0, _apitimeouts.getTimeout)('database')).toBe(_apitimeouts.API_TIMEOUTS.database);
            expect((0, _apitimeouts.getTimeout)('external')).toBe(_apitimeouts.API_TIMEOUTS.external);
            expect((0, _apitimeouts.getTimeout)('upload')).toBe(_apitimeouts.API_TIMEOUTS.upload);
            expect((0, _apitimeouts.getTimeout)('payment')).toBe(_apitimeouts.API_TIMEOUTS.payment);
            expect((0, _apitimeouts.getTimeout)('auth')).toBe(_apitimeouts.API_TIMEOUTS.auth);
            expect((0, _apitimeouts.getTimeout)('admin')).toBe(_apitimeouts.API_TIMEOUTS.admin);
            expect((0, _apitimeouts.getTimeout)('webhook')).toBe(_apitimeouts.API_TIMEOUTS.webhook);
            expect((0, _apitimeouts.getTimeout)('email')).toBe(_apitimeouts.API_TIMEOUTS.email);
            expect((0, _apitimeouts.getTimeout)('image')).toBe(_apitimeouts.API_TIMEOUTS.image);
        });
    });
    describe('getEndpointTimeouts', ()=>{
        it('should return exact match for known endpoints', ()=>{
            const timeouts = (0, _apitimeouts.getEndpointTimeouts)('/api/products');
            expect(timeouts).toEqual(_apitimeouts.ENDPOINT_TIMEOUTS['/api/products']);
        });
        it('should return prefix match for nested endpoints', ()=>{
            const timeouts = (0, _apitimeouts.getEndpointTimeouts)('/api/products/123');
            expect(timeouts).toEqual(_apitimeouts.ENDPOINT_TIMEOUTS['/api/products']);
        });
        it('should return default timeouts for unknown endpoints', ()=>{
            const timeouts = (0, _apitimeouts.getEndpointTimeouts)('/api/unknown');
            expect(timeouts.connection).toBe(5000);
            expect(timeouts.request).toBe(_apitimeouts.API_TIMEOUTS.default);
            expect(timeouts.response).toBe(10000);
            expect(timeouts.total).toBe(_apitimeouts.API_TIMEOUTS.default);
        });
        it('should have valid timeout configurations for all endpoints', ()=>{
            Object.values(_apitimeouts.ENDPOINT_TIMEOUTS).forEach((config)=>{
                expect(config.connection).toBeGreaterThan(0);
                expect(config.request).toBeGreaterThan(0);
                expect(config.response).toBeGreaterThan(0);
                expect(config.total).toBeGreaterThan(0);
            });
        });
    });
    describe('createTimeoutController', ()=>{
        it('should create AbortController with timeout', ()=>{
            const { controller, timeoutId } = (0, _apitimeouts.createTimeoutController)(1000);
            expect(controller).toBeInstanceOf(AbortController);
            expect(controller.signal).toBeDefined();
            expect(typeof timeoutId).toBe('number');
            clearTimeout(timeoutId);
        });
        it('should abort signal after timeout', (done)=>{
            const { controller, timeoutId } = (0, _apitimeouts.createTimeoutController)(50);
            controller.signal.addEventListener('abort', ()=>{
                expect(controller.signal.aborted).toBe(true);
                clearTimeout(timeoutId);
                done();
            });
        });
    });
    describe('fetchWithTimeout', ()=>{
        it('should make successful request within timeout', async ()=>{
            const mockResponse = new Response('success', {
                status: 200
            });
            mockFetch.mockResolvedValueOnce(mockResponse);
            const response = await (0, _apitimeouts.fetchWithTimeout)('http://example.com', {
                timeout: 5000
            });
            expect(response).toBe(mockResponse);
            expect(mockFetch).toHaveBeenCalledWith('http://example.com', {
                timeout: 5000,
                signal: expect.any(AbortSignal)
            });
        });
        it('should timeout on slow requests', async ()=>{
            mockFetch.mockImplementation(()=>new Promise((resolve, reject)=>{
                    setTimeout(()=>{
                        const error = new Error('The operation was aborted');
                        error.name = 'AbortError';
                        reject(error);
                    }, 100);
                }));
            await expect((0, _apitimeouts.fetchWithTimeout)('http://example.com', {
                timeout: 50
            })).rejects.toThrow('Request timeout after 50ms');
        });
        it('should use default timeout when not specified', async ()=>{
            const mockResponse = new Response('success', {
                status: 200
            });
            mockFetch.mockResolvedValueOnce(mockResponse);
            await (0, _apitimeouts.fetchWithTimeout)('http://example.com');
            expect(mockFetch).toHaveBeenCalledWith('http://example.com', {
                signal: expect.any(AbortSignal)
            });
        });
        it('should handle fetch errors properly', async ()=>{
            const fetchError = new Error('Network error');
            mockFetch.mockRejectedValueOnce(fetchError);
            await expect((0, _apitimeouts.fetchWithTimeout)('http://example.com')).rejects.toThrow('Network error');
        });
        it('should handle abort errors as timeout', async ()=>{
            const abortError = new Error('The operation was aborted');
            abortError.name = 'AbortError';
            mockFetch.mockRejectedValueOnce(abortError);
            await expect((0, _apitimeouts.fetchWithTimeout)('http://example.com', {
                timeout: 1000
            })).rejects.toThrow('Request timeout after 1000ms');
        });
    });
    describe('withDatabaseTimeout', ()=>{
        it('should execute operation within timeout', async ()=>{
            const mockOperation = jest.fn().mockResolvedValue('database result');
            const result = await (0, _apitimeouts.withDatabaseTimeout)(mockOperation, 5000);
            expect(result).toBe('database result');
            expect(mockOperation).toHaveBeenCalledWith(expect.any(AbortSignal));
        });
        it('should use default database timeout when not specified', async ()=>{
            const mockOperation = jest.fn().mockResolvedValue('result');
            await (0, _apitimeouts.withDatabaseTimeout)(mockOperation);
            expect(mockOperation).toHaveBeenCalledWith(expect.any(AbortSignal));
        });
        it('should handle operation errors', async ()=>{
            const mockOperation = jest.fn().mockRejectedValue(new Error('DB error'));
            await expect((0, _apitimeouts.withDatabaseTimeout)(mockOperation)).rejects.toThrow('DB error');
        });
        it('should cleanup timeout on completion', async ()=>{
            const clearTimeoutSpy = jest.spyOn(global, 'clearTimeout');
            const mockOperation = jest.fn().mockResolvedValue('result');
            await (0, _apitimeouts.withDatabaseTimeout)(mockOperation, 1000);
            expect(clearTimeoutSpy).toHaveBeenCalled();
            clearTimeoutSpy.mockRestore();
        });
        it('should cleanup timeout on error', async ()=>{
            const clearTimeoutSpy = jest.spyOn(global, 'clearTimeout');
            const mockOperation = jest.fn().mockRejectedValue(new Error('error'));
            try {
                await (0, _apitimeouts.withDatabaseTimeout)(mockOperation, 1000);
            } catch (error) {
            // Expected error
            }
            expect(clearTimeoutSpy).toHaveBeenCalled();
            clearTimeoutSpy.mockRestore();
        });
    });
    describe('withExternalTimeout', ()=>{
        it('should execute operation within timeout', async ()=>{
            const mockOperation = jest.fn().mockResolvedValue('external result');
            const result = await (0, _apitimeouts.withExternalTimeout)(mockOperation, 5000);
            expect(result).toBe('external result');
            expect(mockOperation).toHaveBeenCalledWith(expect.any(AbortSignal));
        });
        it('should use default external timeout when not specified', async ()=>{
            const mockOperation = jest.fn().mockResolvedValue('result');
            await (0, _apitimeouts.withExternalTimeout)(mockOperation);
            expect(mockOperation).toHaveBeenCalledWith(expect.any(AbortSignal));
        });
    });
    describe('Timeout Values Validation', ()=>{
        it('should have reasonable timeout values', ()=>{
            // Database operations should be faster than external APIs
            expect(_apitimeouts.API_TIMEOUTS.database).toBeLessThan(_apitimeouts.API_TIMEOUTS.external);
            // Webhooks should be fastest
            expect(_apitimeouts.API_TIMEOUTS.webhook).toBeLessThan(_apitimeouts.API_TIMEOUTS.database);
            // Upload operations should have longest timeout
            expect(_apitimeouts.API_TIMEOUTS.upload).toBeGreaterThan(_apitimeouts.API_TIMEOUTS.default);
            // All timeouts should be positive
            Object.values(_apitimeouts.API_TIMEOUTS).forEach((timeout)=>{
                expect(timeout).toBeGreaterThan(0);
            });
        });
        it('should have consistent endpoint timeout hierarchies', ()=>{
            Object.values(_apitimeouts.ENDPOINT_TIMEOUTS).forEach((config)=>{
                // Connection timeout should be shortest
                expect(config.connection).toBeLessThanOrEqual(config.request);
                expect(config.connection).toBeLessThanOrEqual(config.response);
                // Total timeout should be longest
                expect(config.total).toBeGreaterThanOrEqual(config.request);
                expect(config.total).toBeGreaterThanOrEqual(config.response);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbWFydGlcXERlc2t0b3BcXERFU0FSUk9MTE9TV1xcQk9JTEVSUExBVFRFIEUtQ09NTUVSQ0VcXF9fdGVzdHNfX1xcbGliXFxhcGktdGltZW91dHMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vLyBURVNUUzogQVBJIFRpbWVvdXRzIENvbmZpZ3VyYXRpb25cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbmltcG9ydCB7XHJcbiAgQVBJX1RJTUVPVVRTLFxyXG4gIEVORFBPSU5UX1RJTUVPVVRTLFxyXG4gIGdldFRpbWVvdXQsXHJcbiAgZ2V0RW5kcG9pbnRUaW1lb3V0cyxcclxuICBjcmVhdGVUaW1lb3V0Q29udHJvbGxlcixcclxuICBmZXRjaFdpdGhUaW1lb3V0LFxyXG4gIHdpdGhEYXRhYmFzZVRpbWVvdXQsXHJcbiAgd2l0aEV4dGVybmFsVGltZW91dFxyXG59IGZyb20gJ0AvbGliL2NvbmZpZy9hcGktdGltZW91dHMnO1xyXG5cclxuLy8gTW9jayBmZXRjaCBwYXJhIHRlc3RzXHJcbmdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKTtcclxuY29uc3QgbW9ja0ZldGNoID0gZmV0Y2ggYXMgamVzdC5Nb2NrZWRGdW5jdGlvbjx0eXBlb2YgZmV0Y2g+O1xyXG5cclxuLy8gTW9jayBlbnZpcm9ubWVudCB2YXJpYWJsZXNcclxuY29uc3Qgb3JpZ2luYWxFbnYgPSBwcm9jZXNzLmVudjtcclxuXHJcbmJlZm9yZUVhY2goKCkgPT4ge1xyXG4gIGplc3QuY2xlYXJBbGxNb2NrcygpO1xyXG4gIHByb2Nlc3MuZW52ID0geyAuLi5vcmlnaW5hbEVudiB9O1xyXG59KTtcclxuXHJcbmFmdGVyQWxsKCgpID0+IHtcclxuICBwcm9jZXNzLmVudiA9IG9yaWdpbmFsRW52O1xyXG59KTtcclxuXHJcbmRlc2NyaWJlKCdBUEkgVGltZW91dHMgQ29uZmlndXJhdGlvbicsICgpID0+IHtcclxuICBkZXNjcmliZSgnRW52aXJvbm1lbnQgVmFyaWFibGUgSW50ZWdyYXRpb24nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IHZhbHVlcyB3aGVuIGVudiB2YXJzIGFyZSBub3Qgc2V0JywgKCkgPT4ge1xyXG4gICAgICAvLyBDbGVhciBlbnZpcm9ubWVudCB2YXJpYWJsZXNcclxuICAgICAgZGVsZXRlIHByb2Nlc3MuZW52LkFQSV9USU1FT1VUX0RFRkFVTFQ7XHJcbiAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5BUElfVElNRU9VVF9EQVRBQkFTRTtcclxuICAgICAgXHJcbiAgICAgIC8vIFJlLWltcG9ydCB0byBnZXQgZnJlc2ggdmFsdWVzXHJcbiAgICAgIGplc3QucmVzZXRNb2R1bGVzKCk7XHJcbiAgICAgIGNvbnN0IHsgQVBJX1RJTUVPVVRTIH0gPSByZXF1aXJlKCdAL2xpYi9jb25maWcvYXBpLXRpbWVvdXRzJyk7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoQVBJX1RJTUVPVVRTLmRlZmF1bHQpLnRvQmUoMzAwMDApO1xyXG4gICAgICBleHBlY3QoQVBJX1RJTUVPVVRTLmRhdGFiYXNlKS50b0JlKDE1MDAwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgdXNlIGVudmlyb25tZW50IHZhcmlhYmxlcyB3aGVuIHByb3ZpZGVkJywgKCkgPT4ge1xyXG4gICAgICBwcm9jZXNzLmVudi5BUElfVElNRU9VVF9ERUZBVUxUID0gJzQ1MDAwJztcclxuICAgICAgcHJvY2Vzcy5lbnYuQVBJX1RJTUVPVVRfREFUQUJBU0UgPSAnMjAwMDAnO1xyXG4gICAgICBcclxuICAgICAgamVzdC5yZXNldE1vZHVsZXMoKTtcclxuICAgICAgY29uc3QgeyBBUElfVElNRU9VVFMgfSA9IHJlcXVpcmUoJ0AvbGliL2NvbmZpZy9hcGktdGltZW91dHMnKTtcclxuICAgICAgXHJcbiAgICAgIGV4cGVjdChBUElfVElNRU9VVFMuZGVmYXVsdCkudG9CZSg0NTAwMCk7XHJcbiAgICAgIGV4cGVjdChBUElfVElNRU9VVFMuZGF0YWJhc2UpLnRvQmUoMjAwMDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZ3JhY2VmdWxseScsICgpID0+IHtcclxuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ3dhcm4nKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcclxuICAgICAgXHJcbiAgICAgIHByb2Nlc3MuZW52LkFQSV9USU1FT1VUX0RFRkFVTFQgPSAnaW52YWxpZCc7XHJcbiAgICAgIHByb2Nlc3MuZW52LkFQSV9USU1FT1VUX0RBVEFCQVNFID0gJy0xMDAwJztcclxuICAgICAgXHJcbiAgICAgIGplc3QucmVzZXRNb2R1bGVzKCk7XHJcbiAgICAgIGNvbnN0IHsgQVBJX1RJTUVPVVRTIH0gPSByZXF1aXJlKCdAL2xpYi9jb25maWcvYXBpLXRpbWVvdXRzJyk7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoQVBJX1RJTUVPVVRTLmRlZmF1bHQpLnRvQmUoMzAwMDApOyAvLyBTaG91bGQgdXNlIGRlZmF1bHRcclxuICAgICAgZXhwZWN0KEFQSV9USU1FT1VUUy5kYXRhYmFzZSkudG9CZSgxNTAwMCk7IC8vIFNob3VsZCB1c2UgZGVmYXVsdFxyXG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdnZXRUaW1lb3V0JywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gY29ycmVjdCB0aW1lb3V0IGZvciBlYWNoIHR5cGUnLCAoKSA9PiB7XHJcbiAgICAgIGV4cGVjdChnZXRUaW1lb3V0KCdkZWZhdWx0JykpLnRvQmUoQVBJX1RJTUVPVVRTLmRlZmF1bHQpO1xyXG4gICAgICBleHBlY3QoZ2V0VGltZW91dCgnZGF0YWJhc2UnKSkudG9CZShBUElfVElNRU9VVFMuZGF0YWJhc2UpO1xyXG4gICAgICBleHBlY3QoZ2V0VGltZW91dCgnZXh0ZXJuYWwnKSkudG9CZShBUElfVElNRU9VVFMuZXh0ZXJuYWwpO1xyXG4gICAgICBleHBlY3QoZ2V0VGltZW91dCgndXBsb2FkJykpLnRvQmUoQVBJX1RJTUVPVVRTLnVwbG9hZCk7XHJcbiAgICAgIGV4cGVjdChnZXRUaW1lb3V0KCdwYXltZW50JykpLnRvQmUoQVBJX1RJTUVPVVRTLnBheW1lbnQpO1xyXG4gICAgICBleHBlY3QoZ2V0VGltZW91dCgnYXV0aCcpKS50b0JlKEFQSV9USU1FT1VUUy5hdXRoKTtcclxuICAgICAgZXhwZWN0KGdldFRpbWVvdXQoJ2FkbWluJykpLnRvQmUoQVBJX1RJTUVPVVRTLmFkbWluKTtcclxuICAgICAgZXhwZWN0KGdldFRpbWVvdXQoJ3dlYmhvb2snKSkudG9CZShBUElfVElNRU9VVFMud2ViaG9vayk7XHJcbiAgICAgIGV4cGVjdChnZXRUaW1lb3V0KCdlbWFpbCcpKS50b0JlKEFQSV9USU1FT1VUUy5lbWFpbCk7XHJcbiAgICAgIGV4cGVjdChnZXRUaW1lb3V0KCdpbWFnZScpKS50b0JlKEFQSV9USU1FT1VUUy5pbWFnZSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2dldEVuZHBvaW50VGltZW91dHMnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiBleGFjdCBtYXRjaCBmb3Iga25vd24gZW5kcG9pbnRzJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0aW1lb3V0cyA9IGdldEVuZHBvaW50VGltZW91dHMoJy9hcGkvcHJvZHVjdHMnKTtcclxuICAgICAgZXhwZWN0KHRpbWVvdXRzKS50b0VxdWFsKEVORFBPSU5UX1RJTUVPVVRTWycvYXBpL3Byb2R1Y3RzJ10pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gcHJlZml4IG1hdGNoIGZvciBuZXN0ZWQgZW5kcG9pbnRzJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0aW1lb3V0cyA9IGdldEVuZHBvaW50VGltZW91dHMoJy9hcGkvcHJvZHVjdHMvMTIzJyk7XHJcbiAgICAgIGV4cGVjdCh0aW1lb3V0cykudG9FcXVhbChFTkRQT0lOVF9USU1FT1VUU1snL2FwaS9wcm9kdWN0cyddKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGRlZmF1bHQgdGltZW91dHMgZm9yIHVua25vd24gZW5kcG9pbnRzJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCB0aW1lb3V0cyA9IGdldEVuZHBvaW50VGltZW91dHMoJy9hcGkvdW5rbm93bicpO1xyXG4gICAgICBleHBlY3QodGltZW91dHMuY29ubmVjdGlvbikudG9CZSg1MDAwKTtcclxuICAgICAgZXhwZWN0KHRpbWVvdXRzLnJlcXVlc3QpLnRvQmUoQVBJX1RJTUVPVVRTLmRlZmF1bHQpO1xyXG4gICAgICBleHBlY3QodGltZW91dHMucmVzcG9uc2UpLnRvQmUoMTAwMDApO1xyXG4gICAgICBleHBlY3QodGltZW91dHMudG90YWwpLnRvQmUoQVBJX1RJTUVPVVRTLmRlZmF1bHQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYXZlIHZhbGlkIHRpbWVvdXQgY29uZmlndXJhdGlvbnMgZm9yIGFsbCBlbmRwb2ludHMnLCAoKSA9PiB7XHJcbiAgICAgIE9iamVjdC52YWx1ZXMoRU5EUE9JTlRfVElNRU9VVFMpLmZvckVhY2goY29uZmlnID0+IHtcclxuICAgICAgICBleHBlY3QoY29uZmlnLmNvbm5lY3Rpb24pLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICBleHBlY3QoY29uZmlnLnJlcXVlc3QpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICBleHBlY3QoY29uZmlnLnJlc3BvbnNlKS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgICAgZXhwZWN0KGNvbmZpZy50b3RhbCkudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnY3JlYXRlVGltZW91dENvbnRyb2xsZXInLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBBYm9ydENvbnRyb2xsZXIgd2l0aCB0aW1lb3V0JywgKCkgPT4ge1xyXG4gICAgICBjb25zdCB7IGNvbnRyb2xsZXIsIHRpbWVvdXRJZCB9ID0gY3JlYXRlVGltZW91dENvbnRyb2xsZXIoMTAwMCk7XHJcbiAgICAgIFxyXG4gICAgICBleHBlY3QoY29udHJvbGxlcikudG9CZUluc3RhbmNlT2YoQWJvcnRDb250cm9sbGVyKTtcclxuICAgICAgZXhwZWN0KGNvbnRyb2xsZXIuc2lnbmFsKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICBleHBlY3QodHlwZW9mIHRpbWVvdXRJZCkudG9CZSgnbnVtYmVyJyk7XHJcbiAgICAgIFxyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgYWJvcnQgc2lnbmFsIGFmdGVyIHRpbWVvdXQnLCAoZG9uZSkgPT4ge1xyXG4gICAgICBjb25zdCB7IGNvbnRyb2xsZXIsIHRpbWVvdXRJZCB9ID0gY3JlYXRlVGltZW91dENvbnRyb2xsZXIoNTApO1xyXG4gICAgICBcclxuICAgICAgY29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XHJcbiAgICAgICAgZXhwZWN0KGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpLnRvQmUodHJ1ZSk7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnZmV0Y2hXaXRoVGltZW91dCcsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgbWFrZSBzdWNjZXNzZnVsIHJlcXVlc3Qgd2l0aGluIHRpbWVvdXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tSZXNwb25zZSA9IG5ldyBSZXNwb25zZSgnc3VjY2VzcycsIHsgc3RhdHVzOiAyMDAgfSk7XHJcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UobW9ja1Jlc3BvbnNlKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dCgnaHR0cDovL2V4YW1wbGUuY29tJywge1xyXG4gICAgICAgIHRpbWVvdXQ6IDUwMDBcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzcG9uc2UpLnRvQmUobW9ja1Jlc3BvbnNlKTtcclxuICAgICAgZXhwZWN0KG1vY2tGZXRjaCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2h0dHA6Ly9leGFtcGxlLmNvbScsIHtcclxuICAgICAgICB0aW1lb3V0OiA1MDAwLFxyXG4gICAgICAgIHNpZ25hbDogZXhwZWN0LmFueShBYm9ydFNpZ25hbClcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHRpbWVvdXQgb24gc2xvdyByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja0ZldGNoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PlxyXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCcpO1xyXG4gICAgICAgICAgICBlcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICB9KVxyXG4gICAgICApO1xyXG5cclxuICAgICAgYXdhaXQgZXhwZWN0KGZldGNoV2l0aFRpbWVvdXQoJ2h0dHA6Ly9leGFtcGxlLmNvbScsIHtcclxuICAgICAgICB0aW1lb3V0OiA1MFxyXG4gICAgICB9KSkucmVqZWN0cy50b1Rocm93KCdSZXF1ZXN0IHRpbWVvdXQgYWZ0ZXIgNTBtcycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCB1c2UgZGVmYXVsdCB0aW1lb3V0IHdoZW4gbm90IHNwZWNpZmllZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbW9ja1Jlc3BvbnNlID0gbmV3IFJlc3BvbnNlKCdzdWNjZXNzJywgeyBzdGF0dXM6IDIwMCB9KTtcclxuICAgICAgbW9ja0ZldGNoLm1vY2tSZXNvbHZlZFZhbHVlT25jZShtb2NrUmVzcG9uc2UpO1xyXG5cclxuICAgICAgYXdhaXQgZmV0Y2hXaXRoVGltZW91dCgnaHR0cDovL2V4YW1wbGUuY29tJyk7XHJcblxyXG4gICAgICBleHBlY3QobW9ja0ZldGNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnaHR0cDovL2V4YW1wbGUuY29tJywge1xyXG4gICAgICAgIHNpZ25hbDogZXhwZWN0LmFueShBYm9ydFNpZ25hbClcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBmZXRjaCBlcnJvcnMgcHJvcGVybHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGZldGNoRXJyb3IgPSBuZXcgRXJyb3IoJ05ldHdvcmsgZXJyb3InKTtcclxuICAgICAgbW9ja0ZldGNoLm1vY2tSZWplY3RlZFZhbHVlT25jZShmZXRjaEVycm9yKTtcclxuXHJcbiAgICAgIGF3YWl0IGV4cGVjdChmZXRjaFdpdGhUaW1lb3V0KCdodHRwOi8vZXhhbXBsZS5jb20nKSkucmVqZWN0cy50b1Rocm93KCdOZXR3b3JrIGVycm9yJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBhYm9ydCBlcnJvcnMgYXMgdGltZW91dCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCcpO1xyXG4gICAgICBhYm9ydEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XHJcbiAgICAgIG1vY2tGZXRjaC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UoYWJvcnRFcnJvcik7XHJcblxyXG4gICAgICBhd2FpdCBleHBlY3QoZmV0Y2hXaXRoVGltZW91dCgnaHR0cDovL2V4YW1wbGUuY29tJywge1xyXG4gICAgICAgIHRpbWVvdXQ6IDEwMDBcclxuICAgICAgfSkpLnJlamVjdHMudG9UaHJvdygnUmVxdWVzdCB0aW1lb3V0IGFmdGVyIDEwMDBtcycpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCd3aXRoRGF0YWJhc2VUaW1lb3V0JywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBleGVjdXRlIG9wZXJhdGlvbiB3aXRoaW4gdGltZW91dCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSgnZGF0YWJhc2UgcmVzdWx0Jyk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aXRoRGF0YWJhc2VUaW1lb3V0KG1vY2tPcGVyYXRpb24sIDUwMDApO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgnZGF0YWJhc2UgcmVzdWx0Jyk7XHJcbiAgICAgIGV4cGVjdChtb2NrT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3QuYW55KEFib3J0U2lnbmFsKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IGRhdGFiYXNlIHRpbWVvdXQgd2hlbiBub3Qgc3BlY2lmaWVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdyZXN1bHQnKTtcclxuXHJcbiAgICAgIGF3YWl0IHdpdGhEYXRhYmFzZVRpbWVvdXQobW9ja09wZXJhdGlvbik7XHJcblxyXG4gICAgICBleHBlY3QobW9ja09wZXJhdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LmFueShBYm9ydFNpZ25hbCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgb3BlcmF0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0RCIGVycm9yJykpO1xyXG5cclxuICAgICAgYXdhaXQgZXhwZWN0KHdpdGhEYXRhYmFzZVRpbWVvdXQobW9ja09wZXJhdGlvbikpLnJlamVjdHMudG9UaHJvdygnREIgZXJyb3InKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgY2xlYW51cCB0aW1lb3V0IG9uIGNvbXBsZXRpb24nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNsZWFyVGltZW91dFNweSA9IGplc3Quc3B5T24oZ2xvYmFsLCAnY2xlYXJUaW1lb3V0Jyk7XHJcbiAgICAgIGNvbnN0IG1vY2tPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoJ3Jlc3VsdCcpO1xyXG5cclxuICAgICAgYXdhaXQgd2l0aERhdGFiYXNlVGltZW91dChtb2NrT3BlcmF0aW9uLCAxMDAwKTtcclxuXHJcbiAgICAgIGV4cGVjdChjbGVhclRpbWVvdXRTcHkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgICAgY2xlYXJUaW1lb3V0U3B5Lm1vY2tSZXN0b3JlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGNsZWFudXAgdGltZW91dCBvbiBlcnJvcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgY2xlYXJUaW1lb3V0U3B5ID0gamVzdC5zcHlPbihnbG9iYWwsICdjbGVhclRpbWVvdXQnKTtcclxuICAgICAgY29uc3QgbW9ja09wZXJhdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ2Vycm9yJykpO1xyXG5cclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB3aXRoRGF0YWJhc2VUaW1lb3V0KG1vY2tPcGVyYXRpb24sIDEwMDApO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIC8vIEV4cGVjdGVkIGVycm9yXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV4cGVjdChjbGVhclRpbWVvdXRTcHkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcclxuICAgICAgY2xlYXJUaW1lb3V0U3B5Lm1vY2tSZXN0b3JlKCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3dpdGhFeHRlcm5hbFRpbWVvdXQnLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgb3BlcmF0aW9uIHdpdGhpbiB0aW1lb3V0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrT3BlcmF0aW9uID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCdleHRlcm5hbCByZXN1bHQnKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpdGhFeHRlcm5hbFRpbWVvdXQobW9ja09wZXJhdGlvbiwgNTAwMCk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdleHRlcm5hbCByZXN1bHQnKTtcclxuICAgICAgZXhwZWN0KG1vY2tPcGVyYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5hbnkoQWJvcnRTaWduYWwpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgZXh0ZXJuYWwgdGltZW91dCB3aGVuIG5vdCBzcGVjaWZpZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tPcGVyYXRpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoJ3Jlc3VsdCcpO1xyXG5cclxuICAgICAgYXdhaXQgd2l0aEV4dGVybmFsVGltZW91dChtb2NrT3BlcmF0aW9uKTtcclxuXHJcbiAgICAgIGV4cGVjdChtb2NrT3BlcmF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3QuYW55KEFib3J0U2lnbmFsKSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ1RpbWVvdXQgVmFsdWVzIFZhbGlkYXRpb24nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIGhhdmUgcmVhc29uYWJsZSB0aW1lb3V0IHZhbHVlcycsICgpID0+IHtcclxuICAgICAgLy8gRGF0YWJhc2Ugb3BlcmF0aW9ucyBzaG91bGQgYmUgZmFzdGVyIHRoYW4gZXh0ZXJuYWwgQVBJc1xyXG4gICAgICBleHBlY3QoQVBJX1RJTUVPVVRTLmRhdGFiYXNlKS50b0JlTGVzc1RoYW4oQVBJX1RJTUVPVVRTLmV4dGVybmFsKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFdlYmhvb2tzIHNob3VsZCBiZSBmYXN0ZXN0XHJcbiAgICAgIGV4cGVjdChBUElfVElNRU9VVFMud2ViaG9vaykudG9CZUxlc3NUaGFuKEFQSV9USU1FT1VUUy5kYXRhYmFzZSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGxvYWQgb3BlcmF0aW9ucyBzaG91bGQgaGF2ZSBsb25nZXN0IHRpbWVvdXRcclxuICAgICAgZXhwZWN0KEFQSV9USU1FT1VUUy51cGxvYWQpLnRvQmVHcmVhdGVyVGhhbihBUElfVElNRU9VVFMuZGVmYXVsdCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBBbGwgdGltZW91dHMgc2hvdWxkIGJlIHBvc2l0aXZlXHJcbiAgICAgIE9iamVjdC52YWx1ZXMoQVBJX1RJTUVPVVRTKS5mb3JFYWNoKHRpbWVvdXQgPT4ge1xyXG4gICAgICAgIGV4cGVjdCh0aW1lb3V0KS50b0JlR3JlYXRlclRoYW4oMCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYXZlIGNvbnNpc3RlbnQgZW5kcG9pbnQgdGltZW91dCBoaWVyYXJjaGllcycsICgpID0+IHtcclxuICAgICAgT2JqZWN0LnZhbHVlcyhFTkRQT0lOVF9USU1FT1VUUykuZm9yRWFjaChjb25maWcgPT4ge1xyXG4gICAgICAgIC8vIENvbm5lY3Rpb24gdGltZW91dCBzaG91bGQgYmUgc2hvcnRlc3RcclxuICAgICAgICBleHBlY3QoY29uZmlnLmNvbm5lY3Rpb24pLnRvQmVMZXNzVGhhbk9yRXF1YWwoY29uZmlnLnJlcXVlc3QpO1xyXG4gICAgICAgIGV4cGVjdChjb25maWcuY29ubmVjdGlvbikudG9CZUxlc3NUaGFuT3JFcXVhbChjb25maWcucmVzcG9uc2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRvdGFsIHRpbWVvdXQgc2hvdWxkIGJlIGxvbmdlc3RcclxuICAgICAgICBleHBlY3QoY29uZmlnLnRvdGFsKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKGNvbmZpZy5yZXF1ZXN0KTtcclxuICAgICAgICBleHBlY3QoY29uZmlnLnRvdGFsKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKGNvbmZpZy5yZXNwb25zZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmV0Y2giLCJqZXN0IiwiZm4iLCJtb2NrRmV0Y2giLCJvcmlnaW5hbEVudiIsInByb2Nlc3MiLCJlbnYiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImFmdGVyQWxsIiwiZGVzY3JpYmUiLCJpdCIsIkFQSV9USU1FT1VUX0RFRkFVTFQiLCJBUElfVElNRU9VVF9EQVRBQkFTRSIsInJlc2V0TW9kdWxlcyIsIkFQSV9USU1FT1VUUyIsInJlcXVpcmUiLCJleHBlY3QiLCJkZWZhdWx0IiwidG9CZSIsImRhdGFiYXNlIiwiY29uc29sZVNweSIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsIm1vY2tSZXN0b3JlIiwiZ2V0VGltZW91dCIsImV4dGVybmFsIiwidXBsb2FkIiwicGF5bWVudCIsImF1dGgiLCJhZG1pbiIsIndlYmhvb2siLCJlbWFpbCIsImltYWdlIiwidGltZW91dHMiLCJnZXRFbmRwb2ludFRpbWVvdXRzIiwidG9FcXVhbCIsIkVORFBPSU5UX1RJTUVPVVRTIiwiY29ubmVjdGlvbiIsInJlcXVlc3QiLCJyZXNwb25zZSIsInRvdGFsIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsImNvbmZpZyIsInRvQmVHcmVhdGVyVGhhbiIsImNvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJjcmVhdGVUaW1lb3V0Q29udHJvbGxlciIsInRvQmVJbnN0YW5jZU9mIiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwidG9CZURlZmluZWQiLCJjbGVhclRpbWVvdXQiLCJkb25lIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0ZWQiLCJtb2NrUmVzcG9uc2UiLCJSZXNwb25zZSIsInN0YXR1cyIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsImZldGNoV2l0aFRpbWVvdXQiLCJ0aW1lb3V0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJhbnkiLCJBYm9ydFNpZ25hbCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic2V0VGltZW91dCIsImVycm9yIiwiRXJyb3IiLCJuYW1lIiwicmVqZWN0cyIsInRvVGhyb3ciLCJmZXRjaEVycm9yIiwibW9ja1JlamVjdGVkVmFsdWVPbmNlIiwiYWJvcnRFcnJvciIsIm1vY2tPcGVyYXRpb24iLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInJlc3VsdCIsIndpdGhEYXRhYmFzZVRpbWVvdXQiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsImNsZWFyVGltZW91dFNweSIsInRvSGF2ZUJlZW5DYWxsZWQiLCJ3aXRoRXh0ZXJuYWxUaW1lb3V0IiwidG9CZUxlc3NUaGFuIiwidG9CZUxlc3NUaGFuT3JF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