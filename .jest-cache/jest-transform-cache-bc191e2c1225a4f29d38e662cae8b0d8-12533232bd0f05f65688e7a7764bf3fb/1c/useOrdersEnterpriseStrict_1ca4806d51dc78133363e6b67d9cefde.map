{"version":3,"sources":["C:\\Users\\marti\\Desktop\\DESARROLLOSW\\BOILERPLATTE E-COMMERCE\\src\\hooks\\admin\\useOrdersEnterpriseStrict.ts"],"sourcesContent":["// ===================================\n// PINTEYA E-COMMERCE - STRICT ORDERS HOOK (REFACTORED)\n// Hook orquestador para gestión de órdenes con validación estricta\n// ===================================\n\nimport { useEffect, useCallback, useRef, useMemo } from 'react'\nimport { useToast } from '@/hooks/use-toast'\nimport {\n  StrictOrdersListResponse,\n  StrictApiError,\n  ApiResult,\n  createStrictApiError,\n  StrictOrderEnterprise,\n  StrictPagination,\n  isStrictApiError,\n  isStrictApiResponse,\n} from '@/types/api-strict'\nimport { OrderStatus, PaymentStatus, FulfillmentStatus } from '@/types/orders-enterprise'\nimport { useApiMonitoring } from '@/utils/api-monitoring'\nimport { useOrdersCache } from './useOrdersCache'\nimport { useOrdersApi } from './useOrdersApi'\nimport { useOrdersState, StrictOrdersState, StrictOrdersActions } from './useOrdersState'\nimport { useOrdersDevState } from './useOrdersDevPersistence'\n\n// Función de debounce para evitar peticiones múltiples\nfunction debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => func(...args), wait)\n  }\n}\n\n// ===================================\n// TIPOS DE FILTROS ESTRICTOS\n// ===================================\n\nexport interface StrictOrderFilters {\n  readonly search?: string\n  readonly status?: OrderStatus | 'all'\n  readonly payment_status?: PaymentStatus | 'all'\n  readonly fulfillment_status?: FulfillmentStatus | 'all'\n  readonly date_from?: string\n  readonly date_to?: string\n  readonly page?: number\n  readonly limit?: number\n  readonly sort_by?: 'created_at' | 'updated_at' | 'total' | 'order_number'\n  readonly sort_order?: 'asc' | 'desc'\n}\n\n// Tipos movidos a useOrdersState.ts\n\nexport interface UseOrdersEnterpriseStrictReturn extends StrictOrdersState, StrictOrdersActions {\n  readonly fetchOrders: (filters?: Partial<StrictOrderFilters>) => Promise<void>\n  readonly refreshOrders: () => Promise<void>\n  readonly retryLastRequest: () => Promise<void>\n}\n\n// ===================================\n// CONFIGURACIÓN DEL HOOK\n// ===================================\n\ninterface UseOrdersEnterpriseStrictOptions {\n  readonly autoFetch?: boolean\n  readonly refetchInterval?: number\n  readonly maxRetries?: number\n  readonly timeout?: number\n  readonly enableCache?: boolean\n  readonly cacheTimeout?: number\n}\n\nconst DEFAULT_OPTIONS: Required<UseOrdersEnterpriseStrictOptions> = {\n  autoFetch: true,\n  refetchInterval: 0, // 0 = disabled\n  maxRetries: 3,\n  timeout: 10000, // 10 seconds\n  enableCache: true,\n  cacheTimeout: 5 * 60 * 1000, // 5 minutes\n}\n\n// Constantes DEFAULT movidas a useOrdersState.ts\n\n// ===================================\n// CONFIGURACIÓN DEL HOOK ORQUESTADOR\n// ===================================\n\n// Funciones de cache movidas a useOrdersCache.ts\n\n// Funciones de cache movidas a useOrdersCache.ts\n\n// Todas las funciones de cache movidas a useOrdersCache.ts\n\n// ===================================\n// HOOK PRINCIPAL\n// ===================================\n\nexport function useOrdersEnterpriseStrict(\n  initialFilters: Partial<StrictOrderFilters> = {},\n  options: Partial<UseOrdersEnterpriseStrictOptions> = {}\n): UseOrdersEnterpriseStrictReturn {\n  const { toast } = useToast()\n  const apiMonitoring = useApiMonitoring()\n  const opts = useMemo(() => ({ ...DEFAULT_OPTIONS, ...options }), [options])\n\n  // Memoizar las funciones de monitoreo para evitar recreaciones\n  const recordDiscrepancy = useCallback(apiMonitoring.recordDiscrepancy, [])\n  const recordRenderingIssue = useCallback(apiMonitoring.recordRenderingIssue, [])\n\n  // ===================================\n  // HOOKS ESPECIALIZADOS\n  // ===================================\n\n  // Hook de cache\n  const cache = useOrdersCache({\n    enableCache: opts.enableCache,\n    cacheTimeout: opts.cacheTimeout,\n    maxSize: 50,\n    cleanupInterval: 10 * 60 * 1000,\n    minRequestInterval: 1000,\n  })\n\n  // Hook de persistencia para desarrollo (Fast Refresh)\n  const devPersistence = useOrdersDevState('orders-enterprise-dev')\n\n  // Hook de estado\n  const state = useOrdersState(initialFilters)\n\n  // Hook de API\n  const api = useOrdersApi({\n    timeout: opts.timeout,\n    maxRetries: opts.maxRetries,\n    enableCache: opts.enableCache,\n    cache,\n  })\n\n  // Referencias para control de requests (simplificadas)\n  const retryCountRef = useRef(0)\n  const refetchIntervalRef = useRef<NodeJS.Timeout | null>(null)\n  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n\n  // ===================================\n  // FUNCIONES DE FETCH SIMPLIFICADAS\n  // ===================================\n\n  // Usar el hook de API directamente\n  const fetchOrdersInternal = api.fetchOrdersInternal\n\n  // ===================================\n  // FUNCIONES DE FETCH PÚBLICAS\n  // ===================================\n\n  // Lógica de fetch movida a useOrdersApi.ts\n\n  // ===================================\n  // FUNCIÓN DE FETCH PÚBLICA CON RETRY\n  // ===================================\n\n  // Función interna sin debounce para uso directo\n  const fetchOrdersImmediate = useCallback(\n    async (newFilters: Partial<StrictOrderFilters> = {}): Promise<void> => {\n      console.log(\n        '[useOrdersEnterpriseStrict] fetchOrdersImmediate called with filters:',\n        newFilters\n      )\n      console.log('[useOrdersEnterpriseStrict] Current state filters:', state.filters)\n\n      // Generar clave única para esta petición\n      const requestKey = JSON.stringify({ ...state.filters, ...newFilters })\n      console.log('[useOrdersEnterpriseStrict] Request key:', requestKey)\n\n      // Evitar peticiones duplicadas\n      if (state.hasFiltersChanged({ ...state.filters, ...newFilters }) && state.isLoading) {\n        console.log('[useOrdersEnterpriseStrict] Skipping duplicate request')\n        return\n      }\n\n      // Actualizar filtros y estado de carga\n      console.log('[useOrdersEnterpriseStrict] Updating filters and setting loading to true')\n      state.updateFilters(newFilters)\n      state.setLoading(true)\n      retryCountRef.current = 0\n\n      const attemptFetch = async (attempt: number): Promise<void> => {\n        const currentFilters = state.getLastFilters()\n        console.log(\n          '[useOrdersEnterpriseStrict] attemptFetch - attempt:',\n          attempt,\n          'filters:',\n          currentFilters\n        )\n\n        const result = await fetchOrdersInternal(currentFilters, attempt > 0)\n        console.log('[useOrdersEnterpriseStrict] API result:', result)\n\n        if (isStrictApiResponse(result)) {\n          console.log('[useOrdersEnterpriseStrict] Valid API response received:', result.data)\n          // Monitoreo automático de discrepancias\n          const expectedCount = result.data.pagination.total\n          const actualCount = result.data.orders.length\n          const endpoint = `/api/admin/orders?${new URLSearchParams({\n            page: currentFilters.page?.toString() || '1',\n            limit: currentFilters.limit?.toString() || '20',\n            ...(currentFilters.status && { status: currentFilters.status }),\n            ...(currentFilters.payment_status && { payment_status: currentFilters.payment_status }),\n            ...(currentFilters.fulfillment_status && {\n              fulfillment_status: currentFilters.fulfillment_status,\n            }),\n            ...(currentFilters.sort_by && { sort_by: currentFilters.sort_by }),\n            ...(currentFilters.sort_order && { sort_order: currentFilters.sort_order }),\n          }).toString()}`\n\n          // Solo registrar discrepancia si hay una diferencia real (no por paginación)\n          const expectedPageCount = Math.min(\n            currentFilters.limit || 20,\n            expectedCount - ((currentFilters.page || 1) - 1) * (currentFilters.limit || 20)\n          )\n          if (actualCount < expectedPageCount && expectedPageCount > 0) {\n            recordDiscrepancy(endpoint, expectedPageCount, actualCount)\n          }\n\n          // Actualizar estado usando el hook especializado\n          state.setOrders(result.data.orders)\n          state.setPagination(result.data.pagination)\n          state.setAnalytics(result.data.analytics || null)\n          retryCountRef.current = 0\n\n          // ✅ PERSISTIR ESTADO PARA DESARROLLO (Fast Refresh)\n          if (process.env.NODE_ENV === 'development') {\n            devPersistence.persistState({\n              orders: result.data.orders,\n              pagination: result.data.pagination,\n              analytics: result.data.analytics || null,\n              filters: currentFilters,\n              hasData: true,\n              lastFetchTime: Date.now(),\n            })\n          }\n        } else {\n          // Es un error\n          if (attempt < opts.maxRetries && result.code !== 'REQUEST_CANCELLED') {\n            retryCountRef.current = attempt + 1\n            // Esperar antes del retry (exponential backoff)\n            const delay = Math.min(1000 * Math.pow(2, attempt), 10000)\n            await new Promise(resolve => setTimeout(resolve, delay))\n            return attemptFetch(attempt + 1)\n          }\n\n          // Máximo de reintentos alcanzado o error no recuperable\n          state.setError(result.error)\n\n          // Registrar problema de renderizado por error de API\n          recordRenderingIssue('useOrdersEnterpriseStrict', 0, 0, currentFilters, result.error)\n\n          // Mostrar toast de error\n          if (result.code !== 'REQUEST_CANCELLED') {\n            toast({\n              title: 'Error al cargar órdenes',\n              description: result.error,\n              variant: 'destructive',\n            })\n          }\n        }\n      }\n\n      await attemptFetch(0)\n    },\n    [fetchOrdersInternal, opts.maxRetries, toast, recordDiscrepancy, recordRenderingIssue, state]\n  )\n\n  // Función fetchOrders con debouncing para evitar peticiones múltiples\n  const fetchOrders = useCallback(\n    (newFilters: Partial<StrictOrderFilters> = {}): Promise<void> => {\n      return new Promise<void>(resolve => {\n        // Limpiar timeout anterior si existe\n        if (debounceTimeoutRef.current) {\n          clearTimeout(debounceTimeoutRef.current)\n        }\n\n        // Configurar nuevo timeout con debounce\n        const debounceMs = process.env.NODE_ENV === 'development' ? 300 : 150\n        debounceTimeoutRef.current = setTimeout(async () => {\n          try {\n            await fetchOrdersImmediate(newFilters)\n            resolve()\n          } catch (error) {\n            console.error('Error in debounced fetchOrders:', error)\n            resolve() // Resolver incluso en caso de error para evitar promesas colgadas\n          }\n        }, debounceMs)\n      })\n    },\n    [fetchOrdersImmediate]\n  )\n\n  // ===================================\n  // OTRAS ACCIONES\n  // ===================================\n\n  const refreshOrders = useCallback(async (): Promise<void> => {\n    // Limpiar cache para forzar refresh\n    if (opts.enableCache) {\n      cache.clearCache()\n    }\n    await fetchOrders()\n  }, [fetchOrders, opts.enableCache, cache])\n\n  // Usar las funciones del hook de estado directamente\n  const updateFilters = state.updateFilters\n  const clearError = state.clearError\n\n  const retryLastRequest = useCallback(async (): Promise<void> => {\n    const lastFilters = state.getLastFilters()\n    if (lastFilters) {\n      await fetchOrders(lastFilters)\n    }\n  }, [fetchOrders, state])\n\n  // ===================================\n  // EFECTOS\n  // ===================================\n\n  // ===================================\n  // RESTAURACIÓN DE ESTADO PERSISTIDO (DESARROLLO)\n  // ===================================\n\n  const hasRestoredRef = useRef(false)\n  useEffect(() => {\n    if (!hasRestoredRef.current && process.env.NODE_ENV === 'development') {\n      hasRestoredRef.current = true\n\n      // Intentar restaurar estado persistido\n      if (devPersistence.hasValidPersistedData()) {\n        const persistedState = devPersistence.getPersistedState()\n        if (persistedState) {\n          console.log('[useOrdersEnterpriseStrict] Restoring persisted state:', {\n            ordersCount: persistedState.orders.length,\n            hasData: persistedState.hasData,\n          })\n\n          // Restaurar estado\n          state.setOrders(persistedState.orders)\n          state.setPagination(persistedState.pagination)\n          state.setAnalytics(persistedState.analytics)\n          state.updateFilters(persistedState.filters)\n\n          return // No hacer auto-fetch si tenemos datos persistidos\n        }\n      }\n    }\n\n    // Auto-fetch inicial solo si no hay datos persistidos\n    if (opts.autoFetch && !hasRestoredRef.current) {\n      fetchOrders()\n    }\n  }, [opts.autoFetch]) // Solo ejecutar una vez al montar\n\n  // Escuchar cambios en filtros con debouncing optimizado\n  const filtersRef = useRef(state.filters)\n  const isInitialMount = useRef(true)\n\n  useEffect(() => {\n    // Evitar fetch en el primer render (ya se hace en auto-fetch)\n    if (isInitialMount.current) {\n      isInitialMount.current = false\n      filtersRef.current = state.filters\n      return\n    }\n\n    // Solo hacer fetch si los filtros han cambiado realmente\n    const hasChanged = JSON.stringify(filtersRef.current) !== JSON.stringify(state.filters)\n\n    if (hasChanged) {\n      filtersRef.current = state.filters\n      fetchOrders()\n    }\n  }, [state.filters, fetchOrders]) // Dependencias mínimas y estables\n\n  // Refetch interval - TEMPORALMENTE DESHABILITADO para evitar refresco infinito\n  useEffect(() => {\n    // NOTA: Refetch interval deshabilitado temporalmente para solucionar refresco infinito\n    // TODO: Reimplementar con useRef para fetchOrders o usar React Query\n    /*\n    if (opts.refetchInterval > 0) {\n      refetchIntervalRef.current = setInterval(() => {\n        if (!state.isLoading) {\n          fetchOrders();\n        }\n      }, opts.refetchInterval);\n\n      return () => {\n        if (refetchIntervalRef.current) {\n          clearInterval(refetchIntervalRef.current);\n        }\n      };\n    }\n    */\n  }, [opts.refetchInterval])\n\n  // Limpieza automática de cache movida a useOrdersCache.ts\n\n  // Cleanup al desmontar - OPTIMIZADO: Sin dependencias inestables\n  useEffect(() => {\n    return () => {\n      // Cancelar peticiones en progreso usando el hook de API\n      api.abortCurrentRequest()\n\n      // Limpiar intervalos y timeouts\n      if (refetchIntervalRef.current) {\n        clearInterval(refetchIntervalRef.current)\n      }\n      if (debounceTimeoutRef.current) {\n        clearTimeout(debounceTimeoutRef.current)\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        console.log('[useOrdersEnterpriseStrict] Hook cleanup completed')\n      }\n    }\n  }, []) // ✅ CORREGIDO: Sin dependencias para evitar remontajes por Fast Refresh\n\n  // ===================================\n  // RETORNO DEL HOOK\n  // ===================================\n\n  return {\n    // Estado\n    orders: state.orders,\n    pagination: state.pagination,\n    filters: state.filters,\n    analytics: state.analytics,\n    isLoading: state.isLoading,\n    error: state.error,\n    lastFetch: state.lastFetch,\n\n    // Acciones\n    fetchOrders,\n    refreshOrders,\n    updateFilters,\n    clearError,\n    retryLastRequest,\n  }\n}\n\n// ===================================\n// HOOK PARA ORDEN INDIVIDUAL\n// ===================================\n\nexport function useOrderDetailStrict(orderId: string | null) {\n  const { toast } = useToast()\n  const [order, setOrder] = useState<StrictOrderEnterprise | null>(null)\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n\n  const fetchOrder = useCallback(async () => {\n    if (!orderId) {\n      return\n    }\n\n    setIsLoading(true)\n    setError(null)\n\n    try {\n      const response = await fetch(`/api/admin/orders/${orderId}`, {\n        credentials: 'include', // ✅ AGREGADO: Incluir cookies de sesión NextAuth.js\n      })\n      const data = await response.json()\n\n      const validatedResponse = toStrictOrdersResponse(data)\n\n      if (isStrictApiError(validatedResponse)) {\n        setError(validatedResponse.error)\n        toast({\n          title: 'Error al cargar orden',\n          description: validatedResponse.error,\n          variant: 'destructive',\n        })\n      } else {\n        // Para orden individual, extraer la primera orden\n        const orderData = validatedResponse.data.orders[0] || null\n        setOrder(orderData)\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Error desconocido'\n      setError(errorMessage)\n      toast({\n        title: 'Error al cargar orden',\n        description: errorMessage,\n        variant: 'destructive',\n      })\n    } finally {\n      setIsLoading(false)\n    }\n  }, [orderId, toast])\n\n  useEffect(() => {\n    fetchOrder()\n  }, [fetchOrder])\n\n  return {\n    order,\n    isLoading,\n    error,\n    refetch: fetchOrder,\n  }\n}\n\n// ===================================\n// UTILIDADES EXPORTADAS\n// ===================================\n\n/**\n * Utilidades de cache movidas a useOrdersCache.ts\n * Estas funciones están disponibles a través del hook useOrdersCache\n */\n\n// Las utilidades de cache ahora están disponibles a través del hook useOrdersCache:\n// - cache.clearCache()\n// - cache.getCacheStats()\n// - cache.getPendingRequest()\n// - cache.setPendingRequest()\n"],"names":["useOrderDetailStrict","useOrdersEnterpriseStrict","debounce","func","wait","timeout","args","clearTimeout","setTimeout","DEFAULT_OPTIONS","autoFetch","refetchInterval","maxRetries","enableCache","cacheTimeout","initialFilters","options","toast","useToast","apiMonitoring","useApiMonitoring","opts","useMemo","recordDiscrepancy","useCallback","recordRenderingIssue","cache","useOrdersCache","maxSize","cleanupInterval","minRequestInterval","devPersistence","useOrdersDevState","state","useOrdersState","api","useOrdersApi","retryCountRef","useRef","refetchIntervalRef","debounceTimeoutRef","fetchOrdersInternal","fetchOrdersImmediate","newFilters","console","log","filters","requestKey","JSON","stringify","hasFiltersChanged","isLoading","updateFilters","setLoading","current","attemptFetch","attempt","currentFilters","getLastFilters","result","isStrictApiResponse","data","expectedCount","pagination","total","actualCount","orders","length","endpoint","URLSearchParams","page","toString","limit","status","payment_status","fulfillment_status","sort_by","sort_order","expectedPageCount","Math","min","setOrders","setPagination","setAnalytics","analytics","process","env","NODE_ENV","persistState","hasData","lastFetchTime","Date","now","code","delay","pow","Promise","resolve","setError","error","title","description","variant","fetchOrders","debounceMs","refreshOrders","clearCache","clearError","retryLastRequest","lastFilters","hasRestoredRef","useEffect","hasValidPersistedData","persistedState","getPersistedState","ordersCount","filtersRef","isInitialMount","hasChanged","abortCurrentRequest","clearInterval","lastFetch","orderId","order","setOrder","useState","setIsLoading","fetchOrder","response","fetch","credentials","json","validatedResponse","toStrictOrdersResponse","isStrictApiError","orderData","err","errorMessage","Error","message","refetch"],"mappings":"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"}