// ===================================
// HOOK: useTrendingSearches - B√∫squedas populares/trending
// ===================================

import { useQuery } from '@tanstack/react-query'
import { searchQueryKeys } from '@/lib/query-client'
import { TrendingSearch, TrendingSearchesResponse } from '@/app/api/search/trending/route'
import { ApiResponse } from '@/types/api'

export interface UseTrendingSearchesOptions {
  /** N√∫mero m√°ximo de b√∫squedas trending a obtener */
  limit?: number
  /** N√∫mero de d√≠as hacia atr√°s para calcular trending */
  days?: number
  /** Filtrar por categor√≠a espec√≠fica */
  category?: string
  /** Habilitar/deshabilitar la query */
  enabled?: boolean
  /** Intervalo de refetch en milisegundos */
  refetchInterval?: number
}

export interface UseTrendingSearchesReturn {
  /** B√∫squedas trending */
  trendingSearches: TrendingSearch[]
  /** Indica si est√° cargando */
  isLoading: boolean
  /** Indica si hay un error */
  error: Error | null
  /** Funci√≥n para refrescar los datos */
  refetch: () => void
  /** Indica si los datos est√°n obsoletos */
  isStale: boolean
  /** Timestamp de la √∫ltima actualizaci√≥n */
  lastUpdated: string | null
  /** Funci√≥n para registrar una b√∫squeda */
  trackSearch: (query: string, category?: string) => Promise<void>
}

/**
 * Hook para obtener b√∫squedas trending/populares
 *
 * Obtiene las b√∫squedas m√°s populares basadas en datos reales del sistema
 * de analytics, con fallback a datos por defecto.
 */
export function useTrendingSearches(
  options: UseTrendingSearchesOptions = {}
): UseTrendingSearchesReturn {
  const {
    limit = 6,
    days = 7,
    category,
    enabled = true,
    refetchInterval = 5 * 60 * 1000, // 5 minutos
  } = options

  // Query para obtener b√∫squedas trending
  const { data, isLoading, error, refetch, isStale } = useQuery({
    queryKey: [...searchQueryKeys.trending(), 'params', { limit, days, category }],
    queryFn: async (): Promise<TrendingSearchesResponse> => {
      console.log('üî• useTrendingSearches: Iniciando fetch de trending searches', {
        limit,
        days,
        category,
        enabled,
      })

      const params = new URLSearchParams()
      params.set('limit', limit.toString())
      params.set('days', days.toString())

      if (category) {
        params.set('category', category)
      }

      const url = `/api/search/trending?${params.toString()}`
      console.log('üî• useTrendingSearches: URL construida:', url)

      try {
        const response = await fetch(url)
        console.log('üî• useTrendingSearches: Response status:', response.status)

        if (!response.ok) {
          console.error(
            'üî• useTrendingSearches: Response not OK:',
            response.status,
            response.statusText
          )
          throw new Error(`Error fetching trending searches: ${response.status}`)
        }

        const result: ApiResponse<TrendingSearchesResponse> = await response.json()
        console.log('üî• useTrendingSearches: Raw API response:', result)

        if (!result.success || !result.data) {
          console.error('üî• useTrendingSearches: API response error:', result.error)
          throw new Error(result.error || 'Error obteniendo b√∫squedas trending')
        }

        console.log('‚úÖ useTrendingSearches: Trending searches fetched successfully', {
          count: result.data.trending.length,
          lastUpdated: result.data.lastUpdated,
          data: result.data.trending,
        })

        return result.data
      } catch (fetchError) {
        console.error('üî• useTrendingSearches: Fetch error:', fetchError)
        throw fetchError
      }
    },
    enabled,
    refetchInterval,
    staleTime: 2 * 60 * 1000, // 2 minutos
    gcTime: 10 * 60 * 1000, // 10 minutos
    retry: 2,
    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
  })

  // Funci√≥n para registrar una b√∫squeda en analytics
  const trackSearch = async (query: string, searchCategory?: string): Promise<void> => {
    try {
      const response = await fetch('/api/search/trending', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          query: query.trim(),
          category: searchCategory,
          userId: null, // Se puede obtener del contexto de auth si est√° disponible
          sessionId: `session-${Date.now()}`, // Generar session ID simple
        }),
      })

      if (!response.ok) {
        console.warn('‚ö†Ô∏è Error tracking search:', response.status)
      } else {
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Error tracking search:', error)
      // No lanzar error para no interrumpir la experiencia del usuario
    }
  }

  const result = {
    trendingSearches: data?.trending || [],
    isLoading,
    error: error as Error | null,
    refetch,
    isStale,
    lastUpdated: data?.lastUpdated || null,
    trackSearch,
  }

  console.log('üî• useTrendingSearches: Hook result:', {
    trendingSearchesCount: result.trendingSearches.length,
    isLoading: result.isLoading,
    error: result.error,
    data: data,
    rawTrending: data?.trending,
    enabled,
  })

  return result
}

/**
 * Hook simplificado para obtener solo las b√∫squedas trending
 */
export function useTrendingSearchesSimple(limit: number = 6): TrendingSearch[] {
  const { trendingSearches } = useTrendingSearches({ limit })
  return trendingSearches
}

/**
 * Hook para obtener b√∫squedas trending por categor√≠a
 */
export function useTrendingSearchesByCategory(
  category: string,
  limit: number = 4
): TrendingSearch[] {
  const { trendingSearches } = useTrendingSearches({
    category,
    limit,
    refetchInterval: 10 * 60 * 1000, // 10 minutos para categor√≠as espec√≠ficas
  })
  return trendingSearches
}

export default useTrendingSearches
